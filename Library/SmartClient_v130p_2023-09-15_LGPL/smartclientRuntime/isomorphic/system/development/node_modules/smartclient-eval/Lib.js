#!/usr/bin/env node

/*

  Isomorphic SmartClient Node.js Server
  Copyright 2021 and beyond Isomorphic Software, Inc. All rights reserved.
  "SmartClient" is a trademark of Isomorphic Software, Inc.

  LICENSE NOTICE
     INSTALLATION OR USE OF THIS SOFTWARE INDICATES YOUR ACCEPTANCE
     OF ISOMORPHIC SOFTWARE LICENSE TERMS. If you have received this file
     without an accompanying Isomorphic Software license file, please
     contact licensing@isomorphic.com for details. Unauthorized copying and
     use of this software is a violation of international copyright law.

  LGPL LICENSE
     This software may be used under the terms of the Lesser GNU Public License (LGPL),
     version 3.0 (see http://www.gnu.org/licenses/lgpl-3.0.html).  The LGPL is generally
     considered a commercial-friendly license, and is used by the Hibernate framework
     among others.  For any questions about the LGPL, please refer to a qualified attorney;
     Isomorphic does not provide legal advice.

  OTHER LICENSE OPTIONS
     Alternative licensing terms, including licenses with no requirement to make modifications
     publicly available, can be arranged by contacting Isomorphic Software by email
     (licensing@isomorphic.com) or web (www.isomorphic.com).

*/

"use strict";

const path = require("path");
const util = require("util");
const fs = require("fs-extra");
const readline = require("readline");
const { spawnSync } = require("child_process");


class CommonLib {

    /**
     * (Internal) Query user and asynchronously wait for reply.  For now, the only supported
     * option is hideEchoBack: true, which stops typing from being echoed back on the screen.
     *
     * @param (string) query   - specifies what info is needed
     * @param (object) options - query style options
     * @return (string) typed response
     */
    static async question(query, options) {
        const rl = readline.createInterface({
            input:  process.stdin,
            output: process.stdout
        });
        rl.on("SIGINT", function() {
            // Exit with error if Control-C pressed
            process.exit(0);
        });

        // if hideEchoBack is set, hide the user's typing
        if (options && options.hideEchoBack) {
            rl.input.on("keypress", function () {
                var output = rl.output,
                    length = rl.line.length;
                readline.moveCursor(output, -length, 0);
                readline.clearLine(output, 1);
                while (length-- > 0) output.write("*");
            });
        }

        const question = util.promisify(this._question);

        try {
            // asynchronously wait for the user's input
            var result = await question(rl, query);
        } finally {
            rl.close();
        }
        return result;
    }

    /**
     * (Internal) Wrapped version of readline's question() API that takes a standard callback
     * API, to allow the call to util.promisify() to succeed and wrap the callback properly.
     *
     * @param (object)   rl       - readline interface
     * @param (string)   query    - specifies what info is needed
     * @param (function) callback - standard callback; takes Error object (or null), and result
     * @return (string) typed response
     */
    static _question(rl, query, callback) {
        rl.question(query, function (result) {
            callback(null, result);
        });
    }

    /**
     * (Internal) Returns available version of npm.  Allows npm-version-dependent handling.
     *
     * @return (number)
     */
    static getNpmVersion() {
        let isWindows = process.platform == "win32",
            result
        ;
        try {
            result = spawnSync(isWindows ? "npm.cmd" : "npm", ["--version"]);
            if (result.status == 0) {
                return parseFloat(result.stdout.toString().trim());
            } else {
                console.warn("Unable to find npm version [status " + result.status + "]: " +
                             result.stderr);
            }
        } catch (e) {
            console.warn("Unable to find npm version: " + e);
        }
    }

    /**
     * (Internal) Returns whether interactive prompting is allowed.  It is not allowed in newer
     * versions of npm when commands are run via lifecycle hooks - install, uninstall, update.
     *
     * @return (number)
     */
    static supportsInteraction() {
        return this.getNpmVersion() < 7 || process.argv[2] == "true";
    }

    /**
     * (Internal) Prompt user and return answer.  Allow automatic "yes".
     *
     * @param (string) question - question text to show the user
     * @param {boolean) interactive - should this method wait for the user to type a response
     * @param {string) forcedAnswer - default if caller wants interactive but it isn't possible
     * @return (string) typed or automatic response
     */
    static async prompt(question, interactive, forcedAnswer) {
        let auto = "yes";

        // if interaction is possible, default to interactive mode
        if (this.supportsInteraction()) {
            if (interactive == null) interactive = true;

        // otherwise, default to no interaction, but use "safe" answers
        // if this explicitly overrides what has been passed via param
        } else {
            if (interactive == true) {
                auto = forcedAnswer;
            }
            interactive = false;
        }
        if (!interactive) {
            console.log(question + auto);
            return auto == "yes";
        }
        // interactive console session; parse what the user typed
        let answer = await CommonLib.question(question);
        return answer != null && (answer.trim() === "" || answer.match(/^y(es)?$/i));
    }

    /**
     * (Internal) Return all files under the specified directory as relative paths
     *
     * @param (string) dir - target directory
     * @param (string) dir - target directory relative to the first call
     * @param (array of string) fileList - files accumulated already by the caller
     * @return (array of string) accumulated files updated with files from target dir
     */
    static getAllFiles(dirPath, relPath = "", fileList = []) {
        const files = fs.readdirSync(dirPath);

        for (const file of files) {
            // ignore CVS directories and other temporary files
            if (file == "CVS" || file.match(/[~#]/)) continue;

            let fileRelPath = path.join(relPath, file),
                fileAbsPath = path.join(dirPath, file);
            if (fs.statSync(fileAbsPath).isDirectory()) {
                fileList = this.getAllFiles(fileAbsPath, fileRelPath, fileList);
            } else {
                fileList.push(fileRelPath);
            }
        }
        
        return fileList;
    }
    
}

module.exports = CommonLib;
