#!/usr/bin/env node

/*

  Isomorphic SmartClient Node.js Server
  Copyright 2018 and beyond Isomorphic Software, Inc. All rights reserved.
  "SmartClient" is a trademark of Isomorphic Software, Inc.

  LICENSE NOTICE
     INSTALLATION OR USE OF THIS SOFTWARE INDICATES YOUR ACCEPTANCE
     OF ISOMORPHIC SOFTWARE LICENSE TERMS. If you have received this file
     without an accompanying Isomorphic Software license file, please
     contact licensing@isomorphic.com for details. Unauthorized copying and
     use of this software is a violation of international copyright law.

  LGPL LICENSE
     This software may be used under the terms of the Lesser GNU Public License (LGPL),
     version 3.0 (see http://www.gnu.org/licenses/lgpl-3.0.html).  The LGPL is generally
     considered a commercial-friendly license, and is used by the Hibernate framework
     among others.  For any questions about the LGPL, please refer to a qualified attorney;
     Isomorphic does not provide legal advice.

  OTHER LICENSE OPTIONS
     Alternative licensing terms, including licenses with no requirement to make modifications
     publicly available, can be arranged by contacting Isomorphic Software by email
     (licensing@isomorphic.com) or web (www.isomorphic.com).

*/

/* global __dirname, Update */

const fs = require("fs-extra");
const util = require("util");
const path = require("path");
const https = require("https");
const npmurl = require("url");
const EOL = require('os').EOL;
const readline = require("readline");
const Zip = require("node-stream-zip");

const Const = require("./Const");
const CommonLib = require("./Lib");

let config = {};

/**
 * class for SmartClient runtime install/update
 */
class Update {

    /**
     * installs/updates SmartClient runtime
     */
    static async main() {
        // load persistent package configuration
        if (fs.existsSync(Const.SMARTCLIENT_CONF)) {
            config = fs.readJsonSync(Const.SMARTCLIENT_CONF);
        }

        // for update, show details of current installation
        if (config.date && this._hasIscDir(config.location)) {
            let isomorphicPath = this._getIscDir(config.location);
            console.log("SmartClient " + config.branch + ", build " + config.date +
                        ", runtime(s) are currently installed at " + isomorphicPath +
                        " according to configuration.");
        }

        let env = process.env, username, password;

        // show usage help documentation
        if (env.npm_config_showUsage) {
            this.usage(); return;
        }

        if (Const.REQUIRES_ACCOUNT) {
            console.log("SmartClient " + Const.SMARTCLIENT_NAME + 
                        " requires download credentials.  Checking.");

            // we need a username to download SmartClient SDK for this package
            username = env.npm_config_username || config.username;
            if (!username) {
                username = await CommonLib.question(
                    "Please provide your SmartClient username: ");
                if (!username) {
                    console.log("*** No username provided!");
                    process.exitCode = 4;
                    return;
                }
            }

            // we need a password to download SmartClient SDK for this package
            password = env.npm_config_password || config.password;
            if (!password) {
                password = await CommonLib.question(
                    "Please provide your SmartClient password: ", {hideEchoBack: true});
                if (password) {
                    console.log(
                        "\nFor security, the requested password will not be persisted.");
                    console.log(
                        "Please use command-line password option to store a password.\n");
                } else {
                    console.log("*** No password provided!");
                    process.exitCode = 5;
                    return;
                }
            }
        }

        // installation directory; default is directory of dependent module
        let location = env.npm_config_location || config.location || ".";

        // date
        let configDate = config.latest ? Const.LATEST_BUILD : config.date;
        let date = env.npm_config_date || configDate || Const.LATEST_BUILD;

        if (!date.match(/^2[0-9]{3}-[0-9]{2}-[0-9]{2}$/) && date != Const.LATEST_BUILD)
        {
            console.log("***Invalid date: " + date + "!\n");
            this.usage(); process.exitCode = 1; 
            return;
        }

        // branch
        let branch = env.npm_config_branch || config.branch || Const.DEFAULT_BRANCH;
        if (branch < Const.OLDEST_BRANCH || branch > Const.DEVELOP_BRANCH ||
            !branch.match(/^1[0-9]\.[0-1]$/))
        {
            console.log("*** Invalid branch: " + branch + "!\n");
            this.usage(); process.exitCode = 2;
            return;
        }

        // runtime
        let runtime = env.npm_config_runtime || config.runtime || Const.DEFAULT_RUNTIME;
        if (runtime != "debug" && runtime != "release" && runtime != "both") {
            console.log("*** Invalid runtime: " + runtime + "!\n");
            this.usage(); process.exitCode = 3;
            return;
        }

        // reference
        let reference = env.npm_config_reference != null ? env.npm_config_reference :
                                config.reference;

        // skins
        let skins = env.npm_config_skins || config.skins || Const.DEFAULT_SKIN;
        if (skins != Const.DEFAULT_SKIN && skins != "all" && skins != "none") {
            console.log("*** Invalid skins: " + skins + "!\n");
            this.usage(); process.exitCode = 6;
            return;
        }

        // prompt option allows interactive update
        let prompt = this.getPromptOption(config);

        let forcedAnswer = "yes",
            isomorphicPath = this._getIscDir(location),
            question = "Install SmartClient " + branch + " runtime, build date " + date +
                       ", at " + isomorphicPath
        ;
        if (fs.existsSync(isomorphicPath)) {
            if (!config.location || config.location != location) {
                question += " (removing the directory currently present at install path)"
            } else {
                question += " (replacing the existing SmartClient installation there)";
            }
            forcedAnswer = "no";
        }

        let query = Const.REQUIRES_ACCOUNT ? "?USERNAME=" + username +
                        "&PASSWORD=" + encodeURIComponent(password) : "";

        let answer = await CommonLib.prompt(question + "? [yes]: ", prompt, forcedAnswer);
        if (answer) {
            Update._getSmartClientLink(branch, date, query, Const.DOWNLOAD_DIR, 
                async function (link) {
                    await Update._updateRuntimeCore(location, link, query, branch, date,
                              runtime, skins, reference, username, prompt);
                }
            );
            return;
        }

        // user doesn't want to download a new SDK; see if we can reuse existing installation
        if (fs.existsSync(isomorphicPath) && config.location && config.location == location) {
            let isomorphicPath = this._getIscDir(config.location);
            console.log("Regenerating import scripts from installation at " + isomorphicPath);
            await Update._createImportScripts(location, query, branch, date, runtime, prompt);
        } else {
            console.log("No valid installation detected.  Skipping script generation.");
            console.log("To create scripts, run 'npm run update' in the module directory.");
        }            
    }

    /**
     * (Internal) Actual install/update of core runtime(s).
     * Creates directory tree.
     * Copies configuration file.
     *
     * @param {string} location - destination path
     * @param {string} link - download URL
     * @param {string} query - download credentials
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @param {string} runtime - "release", "debug", or "both"
     * @param {string} skins - which skins to install
     * @param {boolean} reference - install reference dir
     * @param {string} username - account username
     * @param {boolean} prompt - interactive update
     */
    static async _updateRuntimeCore(location, link, query, branch, date, runtime, skins,
                                    reference, username, prompt)
    {
        // if not present, create destination directory with user RWX access
        fs.ensureDirSync(location, {mode: 0o700});        

        // test if destination directory is accessible for reading and writing
        fs.access(location, fs.constants.R_OK | fs.constants.W_OK, async function(err) {
            if (err) {
                console.error("ERROR! Can not access destination directory: " + location);
                process.exit(-100);
            }

            let realDate = link.match(/2[0-9]{3}-[0-9]{2}-[0-9]{2}/)[0];

            // ask user to skip if there's no newer build and no configuration has changed
            if (Update._hasIscDir(location) &&
                location == config.location && 
                branch   == config.branch && 
                realDate == config.date &&
                runtime  == config.runtime &&
                skins    == config.skins &&
                !reference == !config.reference)
            {
                let skip = await CommonLib.prompt(
                    "It looks like we're about to re-download the same core runtime(s) " +
                    "already installed with no configuration change.  Skip? [yes]: ", prompt,
                    "yes");
                if (skip) {

                    // update "prompt" option even though new runtime core(s) won't be installed
                    if (prompt != config.prompt) {
                        if (prompt) config.prompt = true;
                        else delete config.prompt;
                        delete config.yes; 

                        fs.writeJsonSync(Const.SMARTCLIENT_CONF, config, {spaces: 4});
                        console.log("Configuration updated.");
                    }

                    console.log("Skipping re-installation.\n");

                    if (Const.SUPPORTS_MODULES) {
                        Update._startOptionalModulesUpdate(location, query, branch, date, 
                                                           runtime);
                    }
                    return;
                }
            }

            // downloading and installing SmartClient runtime
            const tmpDirName = path.join(__dirname, Const.TMP + "-framework");
            fs.ensureDirSync(tmpDirName);

            const zipFileName = path.join(tmpDirName, Const.SMARTCLIENT_ZIP);

            console.log("Looking for SmarClient runtime at " + link);
            const request = Update._httpsGet(link + query, async function(response) {
                if (response.statusCode !== 200) {
                    console.error("ERROR! Failed to download SmartClient runtime from: " +
                                  link);
                    process.exit(-101);
                }

                let currentLen = 0, 
                    totalLen = parseInt(response.headers['content-length'])
                ;

                process.stdout.write("Downloading: ");

                const headless = !process.stdout.cursorTo;
                if (!headless) process.stdout.write("...");

                let lastFraction = 0, lastSecond = 0;
                response.on("data", function (chunk) {
                    currentLen += chunk.length;
                    let hrtime = process.hrtime();
                    if (lastSecond != hrtime[0]) {
                        lastSecond = hrtime[0];

                        let fraction = Math.floor(currentLen * 100 / totalLen);
                        if (headless) {
                            if (fraction - lastFraction >= 5) {
                                lastFraction += 5;
                                process.stdout.write(lastFraction + "% ");
                            }
                        } else {
                            process.stdout.cursorTo(0);
                            process.stdout.write("Downloading " + fraction + "% complete.");
                        }
                    }
                });

                response.pipe(fs.createWriteStream(zipFileName));
                response.on("end", async function() {
                    if (headless) process.stdout.write("\n");
                    else          process.stdout.cursorTo(0);
                    process.stdout.write("Downloading 100% complete (" + totalLen + 
                                         " bytes transferred).\n");

                    console.log("Unzipping SmartClient runtime file " + zipFileName +
                                " to " + tmpDirName);

                    {
                        fs.ensureDirSync(tmpDirName);
                        const zipFile = new Zip.async({file: zipFileName});
                        const count = await zipFile.extract(null, tmpDirName);
                        console.log("Extracted " + count + " entries");
                        await zipFile.close();
                        
                        if (config.location) { // remove existing installation, if any
                            let oldPath = Update._getIscDir(config.location);
                            console.log("Removing old SmartClient runtime(s) at " + oldPath);
                            fs.removeSync(oldPath);
                        }                            

                        let isomorphicPath = Update._getIscDir(location);
                        console.log("Copying SmartClient runtime(s) to " + isomorphicPath);

                        fs.removeSync(isomorphicPath);

                        let packageDir = fs.readdirSync(tmpDirName).filter(function (f) {
                            return f.startsWith("SmartClient_");
                        })[0];

                        fs.copySync(path.join(tmpDirName, packageDir, Const.SMARTCLIENT_DIR,
                                              Const.ISOMORPHIC_DIR), isomorphicPath, {
                            filter: function (src, dest) {
                                // exclude unwanted runtimes 
                                if (runtime == "release" && 
                                    dest.endsWith(Const.DEBUG_MODULES) ||
                                    runtime == "debug" &&
                                    dest.endsWith(Const.RELEASE_MODULES))
                                {
                                    return false;
                                }

                                dest = Update._canonicalizePath(dest);

                                // exclude reference dir unless configured to keep it
                                if (!reference && dest.match(/system\/reference$/)) {
                                    return false;
                                }

                                // exclude unwanted skins
                                if (skins != "all" && dest.match(/skins\/[a-z]+$/i) &&
                                    (skins == "none" || 
                                     !dest.endsWith("skins/" + Const.DEFAULT_SKIN)))
                                {
                                    return false;
                                }
                                // exclude content never wanted for npm
                                if (dest.match(/skins\/.*\/template/)) {
                                    return false;
                                }
                                return true;
                            }
                        });

                        if (runtime == "both") {
                            console.log("Installed debug and release runtimes.");
                        } else {
                            console.log("Installed " + runtime + " runtime.");
                        }

                        if (reference) {
                            console.log("Installing the reference directory.");
                        } else {
                            console.log("Not installing the reference directory.");
                        }

                        if (skins == Const.DEFAULT_SKIN) {
                            console.log("Installed " + Const.DEFAULT_SKIN + " skin.");
                        } else {
                            let whichSkins = skins == "none" ? "no" : skins;
                            console.log("Installed " + whichSkins + " skins.");
                        }
                        
                        console.log("See command-line documentation for alternatives.");

                        let env = process.env;

                        // persist configuration
                        config.location = location;
                        config.runtime  = runtime;
                        config.branch   = branch;
                        config.date     = realDate;
                        config.skins    = skins;

                        if (date == Const.LATEST_BUILD) config.latest = true;
                        else                            delete config.latest;

                        if (reference) config.reference = true;
                        else delete config.reference;

                        if (prompt) config.prompt = true;
                        else delete config.prompt;
                        delete config.yes;

                        // persist credentials (only persist password if on the command line)
                        if (Const.REQUIRES_ACCOUNT) {
                            config.username = username;
                            if (env.npm_config_password) {
                                config.password = env.npm_config_password;
                            }
                        }

                        fs.writeJsonSync(Const.SMARTCLIENT_CONF, config, {spaces: 4});

                        console.log("Configuration updated.");

                        console.log("Deleting temporary files from " + tmpDirName);
                        fs.removeSync(tmpDirName);

                        await Update._createImportScripts(location, query, branch, date,
                                                          runtime, prompt);
                    }
                });
            });
        });
    }

    /**
     * (Internal) return the isomorphic dir from the location
     *
     * @param {string} location - isomorphic dir location
     * @return (string) absolute path to the isomorphid dir
     */
    static _getIscDir(location) {
        return path.resolve("..", "..", location, Const.ISOMORPHIC_DIR);
    }

    /**
     * (Internal) whether the location specifies a valid isomorphic dir
     *
     * @param {string} location - isomorphic dir location
     * @return (string) whether location specifies a valid isomorphic dir
     */
    static _hasIscDir(location) {
        return fs.existsSync(this._getIscDir(location));
    }

    /**
     * (Internal) generate import scripts for framework, skins, and optional modules
     *
     * @param {string} location - destination path
     * @param {string} query - download credentials
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @param {string} runtime - "release", "debug", or "both"
     * @param {boolean} prompt - interactive update
     */
    static async _createImportScripts(location, query, branch, date, runtime, prompt) {
        let isomorphicPath = this._getIscDir(location);

        console.log("Setting up import scripts...");
        Update.__createImportScripts(isomorphicPath, branch);
        await Update._injectTypeScript(isomorphicPath, prompt);

        if (Const.SUPPORTS_MODULES) {
            console.log("Installation of runtime core complete.\n");
            Update._startOptionalModulesUpdate(location, query, branch, date, runtime);
        } else {
            console.log("Installation complete.");
        }
    }

    /**
     * (Internal) Start install/update of optional modules.
     * Updates configuration file.
     *
     * @param {string} location - destination path
     * @param {string} query - download credentials
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @param {string} runtime - "release", "debug", or "both"
     */
    static _startOptionalModulesUpdate(location, query, branch, date, runtime) {
        console.log("Updating optional modules.");
        Update._updateAnalyticsModule(location, query, branch, date, runtime);
    }

    /**
     * (Internal) Complete install/update of optional modules.
     * Updates configuration file.
     *
     * @param {string} location - destination path
     * @param (boolean) updated - whether module config got updated
     */
    static _completeOptionalModulesUpdate(location, updated) {
        let status = "Done updating optional modules.";

        if (updated) {
            status += "  Configuration updated.";
            fs.writeJsonSync(Const.SMARTCLIENT_CONF, config, {spaces: 4});

            console.log("Setting up optional module import scripts...");
            const isomorphicPath = this._getIscDir(location);
            Update._createOptionalModuleScripts(isomorphicPath, "analytics", "Analytics");
            Update._createOptionalModuleScripts(isomorphicPath, "rtm", "RealtimeMessaging");
        }

        console.log(status);
    }

    /**
     * (Internal) Install/update analytics module.
     * Updates configuration file.
     *
     * @param {string} location - destination path
     * @param {string} query - download credentials
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @param {string} runtime - "release", "debug", or "both"
     */
    static _updateAnalyticsModule(location, query, branch, date, runtime) {
        let updated, config_analytics = process.env.npm_config_analytics;

        let analytics = config_analytics != null ? config_analytics : config.analytics;
        if (analytics) {
            Update._getSmartClientLink(branch, date, query, Const.ANALYTICS_NAME + "Module",
                function (link) {
                    Update._updateModule(location, link, query, branch, date, runtime, 
                        Const.ANALYTICS_NAME,
                        function () {
                            if (!config.analytics) {
                                config.analytics = true;
                                updated = true;
                            }
                            Update._updateMessagingModule(location, query, branch, date, 
                                                          runtime, updated);
                        }
                    );
                }
            );
            return;
        }
        if (config.analytics) {
            Update._removeModule(location, Const.ANALYTICS_NAME, Const.ANALYTICS_FILE);
            updated = true;
        } else {
            console.log("Not installing the " + Const.ANALYTICS_NAME + " module")
        }
        delete config.analytics;

        Update._updateMessagingModule(location, query, branch, date, runtime, updated);
    }

    /**
     * (Internal) Install/update messaging module.
     * Updates configuration file.
     *
     * @param {string} location - destination path
     * @param {string} query - download credentials
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @param {string} runtime - "release", "debug", or "both"
     * @param (boolean) updated - whether module config got updated
     */
    static _updateMessagingModule(location, query, branch, date, runtime, updated) {
        let config_rtm = process.env.npm_config_rtm;

        let rtm = config_rtm != null ? config_rtm : config.rtm;
        if (rtm) {
            Update._getSmartClientLink(branch, date, query, Const.MESSAGING_NAME + "Module",
                function (link) {
                    Update._updateModule(location, link, query, branch, date, runtime,
                        Const.MESSAGING_NAME,
                        function () {
                            if (!config.rtm) {
                                config.rtm = true;
                                updated = true;
                            }
                            Update._completeOptionalModulesUpdate(location, updated);
                        }
                    );
                }
            );
            return;
        }
        if (config.rtm) {
            Update._removeModule(location, Const.MESSAGING_NAME, Const.MESSAGING_FILE);
            updated = true;
        } else {
            console.log("Not installing the " + Const.MESSAGING_NAME + " module")
        }
        delete config.rtm;

        Update._completeOptionalModulesUpdate(location, updated);
    }

    /**
     * (Internal) Actual install/update optional module.
     * Creates directory tree.
     * Copies configuration file.
     *
     * @param {string} location - destination path
     * @param {string} link - download URL
     * @param {string} query - download credentials
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @param {string} runtime - "release", "debug", or "both"
     * @param {string} moduleName - human-meaningful name of module
     * @param {function} callback
     */
    static _updateModule(location, link, query, branch, date, runtime, moduleName, callback) {

        // downloading and installing optional module
        const tmpDirName = path.join(__dirname, Const.TMP + "-modules");
        fs.ensureDirSync(tmpDirName);

        const zipFileName = path.join(tmpDirName, Const.MODULE_ZIP);

        console.log("Looking for " + moduleName + " module at " + link);
        const request = Update._httpsGet(link + query, function(response) {
            if (response.statusCode !== 200) {
                console.error("ERROR! Failed to download " + moduleName + " module from: " +
                              link);
                process.exit(-101);
            }

            let totalLen = parseInt(response.headers['content-length']);

            response.pipe(fs.createWriteStream(zipFileName));
            response.on("end", function() {
                console.log("Downloading 100% complete (" + totalLen + 
                            " bytes transferred).");
                console.log("Unzipping " + moduleName + " module file " + zipFileName + " to " + 
                            tmpDirName);

                const zipFile = fs.createReadStream(zipFileName);
                zipFile.pipe(unzipper.Extract({
                    path: tmpDirName
                })).on("close", function() {

                    let isomorphicPath = Update._getIscDir(location);
                    console.log("Installing " + moduleName + " module to " + isomorphicPath);

                    if (runtime == "release" || runtime == "both") {
                        fs.copySync(tmpDirName, path.join(isomorphicPath, Const.RELEASE_MODULES), {
                            overwrite: true,
                            filter: function (src, dest) {
                                return src == tmpDirName || src.match(/\.js(\.gz)?$/);
                            }
                        });
                    }
                    if (runtime == "debug" || runtime == "both") {
                        fs.copySync(path.join(tmpDirName, "modules-debug"), 
                                    path.join(isomorphicPath, Const.DEBUG_MODULES), {
                            overwrite: true
                        });
                    }

                    console.log("Deleting temporary files from " + tmpDirName);
                    fs.removeSync(tmpDirName);
                    console.log("Installation of module " + moduleName + " complete.");

                    callback.call();
                });
            });
        });
    }

    /**
     * (Internal) Remove optional modules.
     *
     * @param {string} location - runtime install location
     * @param {string} moduleName - human-meaningful name of module
     * @param {string} moduleFile - file name (JS implementation) of module 
     */
    static _removeModule(location, moduleName, moduleFile) {
        let isomorphicPath = this._getIscDir(location);
        fs.removeSync(path.join(isomorphicPath, Const.RELEASE_MODULES, moduleFile))
        fs.removeSync(path.join(isomorphicPath, Const.RELEASE_MODULES, moduleFile + ".gz"))
        fs.removeSync(path.join(isomorphicPath, Const.DEBUG_MODULES,   moduleFile));
        console.log("Removed " + moduleName + " module.");
    }

    /**
     * (Internal) Get download url.
     *
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @param {string} query - download credentials
     * @param {string} moduleName - Const.DOWNLOAD_DIR for core runtime(s), 
     *                              or optional module name
     * @param {function} callback
     */
    static _getSmartClientLink(branch, date, query, moduleName, callback) {
        let release = branch <= Const.DEFAULT_BRANCH;

        let baseUrl = Const.SMARTCLIENT_LINK,
            linkDir = branch + (release ? "p" : "d") + "/" + moduleName + "/" + date,
            linkUrl = baseUrl + "/" + linkDir
        ;

        if (date == Const.LATEST_BUILD) {
            const request = Update._httpsGet(linkUrl + query, function(response) {
                if (response.statusCode !== 200) {
                    console.error("ERROR! Failed to get SmartClient directory listing from: " +
                                  linkUrl);
                    process.exit(-102);
                }
                response.on('data', function (data) {
                    if (data == null) {
                        console.error("ERROR! Got empty SmartClient directory listing from: " +
                                      linkUrl);
                        process.exit(-103);
                    }
                    let matches = data.toString().match(/[A-Za-z0-9_-]+\.zip/);
                    if (!matches) {
                        console.error("ERROR! No SmartClient runtimes available from: " +
                                      linkUrl);
                        process.exit(-104);
                    }                        
                    callback.call(null, linkUrl + "/" + matches[0]);
                });
            });

        } else {
            callback.call(null, linkUrl + "/" + Update._getSmartClientZipName(branch, date));
        }
    }

    /**
     * (Internal) generate import scripts for importing framework and skins
     *
     * @param {string} isomorphicPath - path to isomorphic directory
     * @param {number} branch - SmartClient branch
     */
    static __createImportScripts(isomorphicPath, branch) {
        var dirname = path.resolve(__dirname);

        // remove or regenerate the release import script for SmartClient release
        let releaseLoaderPath = path.join(dirname, "release", "index.js"),
            releaseModulesPath = path.join(isomorphicPath, "system/modules");
        if (fs.existsSync(releaseModulesPath)) {
            Update._createRuntimeLoader(branch, releaseLoaderPath, dirname,
                                        releaseModulesPath);
        } else fs.removeSync(releaseLoaderPath);

        // remove or regenerate the debug import script for SmartClient debug
        let debugLoaderPath = path.join(dirname, "debug", "index.js"),
            debugModulesPath = path.join(isomorphicPath, "system/modules-debug");
        if (fs.existsSync(debugModulesPath)) {
            Update._createRuntimeLoader(branch, debugLoaderPath, dirname,
                                        debugModulesPath);
        } else fs.removeSync(debugLoaderPath);

        // remove or regenerate the React SmartClient wrapper import script
        let reactLoaderPath  = path.join(dirname, "react", "index.js"),
            reactWrapperPath = path.join(isomorphicPath, "react");
        if (!Update.hasReact()) {
            fs.removeSync(reactLoaderPath.replace("index.js", ""));
            console.log("SmartClient React support is not needed.");
        } else if (!fs.existsSync(reactWrapperPath)) {
            fs.removeSync(reactLoaderPath.replace("index.js", ""));
            console.log("SmartClient React support is not available.");
        } else {
            fs.outputFileSync(reactLoaderPath.replace(".js", ".d.ts"),
                               "declare module '" + Const.MODULE_NAME + "/react'");
            Update._createReactLoader(branch, reactLoaderPath, reactWrapperPath);
            console.log("Installed SmartClient React support and import script.");
        }

        // clear out any existing scripts to import skins
        const skinLoaderPath = path.join(dirname, "skins");
        fs.removeSync(skinLoaderPath);

        // generate scripts to import all skins present undder isomorphicPath
        let skinDirs = fs.readdirSync(path.join(isomorphicPath, "skins"));
        for (let i = 0; i < skinDirs.length; i++) {
            if (skinDirs[i] == "CVS" || skinDirs[i].match(/[#~_]/)) continue;
            let skinDir = path.join(isomorphicPath, "skins", skinDirs[i]);
            if (fs.existsSync(skinDir) && fs.lstatSync(skinDir).isDirectory()) {
                Update._createSkinLoader(path.join(skinLoaderPath, skinDirs[i], "index.js"),
                                         dirname, skinDir, skinDirs[i]);
            }
        }
    }

    /**
     * (Internal) generate script to load framework runtime (modules), either release or debug
     *
     * @param {number} branch - SmartClient branch
     * @param {string} loaderPath - path where loader script should be generated
     * @param {string} dirname - current directory where this script is running
     * @param {string} modulesDir - path where framework modules are located
     */
    static _createRuntimeLoader(branch, loaderPath, dirname, modulesDir) {
        const modules = Const.SMARTCLIENT_MODULES,
              dependentPath = path.resolve("..", "..")
        ;
        if (modulesDir.startsWith(dependentPath)) {
            modulesDir = "../../.." + Update._canonicalizePath(
                modulesDir.substring(dependentPath.length));
        } else {
            modulesDir = Update._canonicalizePath(modulesDir);
        }

        let contents =
            "if (!(window && window.isc && window.isc.module_Core) &&\n" +
            "    (!window ||  !window.Window ||  !(window instanceof window.Window)    ||\n" +
            "     !window.Navigator || !(window.navigator instanceof window.Navigator) ||\n" +
            "     !window.Document  || !(window.document  instanceof window.Document)))\n" +
            "{\n" +
            "    throw new Error('" + Const.ILLEGAL_USAGE_TEXT + "');\n" +
            "}\n\n" +
            "if (!window.isc) window.isc = {};\n\n"
        ;

        // compute the maximum module name length for formatting output
        let maxNameLen = 0;
        for (let i = 0; i < modules.length; i++) {
            if (branch >= "13.0" && modules[i] == "Workflow") continue;
            if (maxNameLen < modules[i].length) {
                maxNameLen = modules[i].length;
            }
        }

        // add code to load each ISC module if the module is not already loaded
        for (let i = 0; i < modules.length; i++) {
            if (branch >= "13.0" && modules[i] == "Workflow") continue;
            const moduleFile = "ISC_" + modules[i] + ".js";
            contents += "if (!window.isc.module_" + modules[i] + ") " +
                " ".repeat(Math.max(0, maxNameLen - modules[i].length)) +
                "require('" + modulesDir + "/" + moduleFile + "');\n";
        }

        // add window hook to allow code to be injected after the framework loads
        contents += "\nif (window.isc_afterFrameworkLoadCustomJS) {\n" +
                      "    isc.eval(window.isc_afterFrameworkLoadCustomJS);\n" +
                      "}\n";

        fs.outputFileSync(loaderPath, contents);
    }

    /**
     * (Internal) generate script to load the React runtime wrappers
     *
     * @param {number} branch - SmartClient branch
     * @param {string} loaderPath - path where loader script should be generated
     * @param {string} wrapperDir - path where the React wrappers are located
     */
    static _createReactLoader(branch, loaderPath, wrappersDir) {
        // if not an internal project, install wrapper files under React app source dir
        if (!path.resolve(wrappersDir).match(/isomorphic\/react\/[^\/]+\/isomorphic/)) {
            const wrappersInstallDir = path.resolve("..", "..", Const.REACT_APP_SRC_DIR,
                                                    "isomorphic", "react");
            fs.removeSync(wrappersInstallDir), fs.ensureDirSync(wrappersInstallDir);
            fs.copySync(wrappersDir, wrappersInstallDir, {dereference: true});
            wrappersDir = wrappersInstallDir;
        }

        const dependentPath = path.resolve("..", ".."),
              files = CommonLib.getAllFiles(path.resolve(wrappersDir));
        ;
        if (wrappersDir.startsWith(dependentPath)) {
            wrappersDir = "../../.." + Update._canonicalizePath(
                wrappersDir.substring(dependentPath.length));
        } else {
            wrappersDir = Update._canonicalizePath(wrappersDir);
        }

        let exportStatements = [
            "if (window.isc) window.isc.react = true;\n"
        ];
        files.forEach( filePath => {
            if (filePath.match(Const.REACT_SOURCE_PATTERN)) {
                filePath = Update._canonicalizePath(filePath);
                exportStatements.push(`export * from "${wrappersDir}/${filePath}";`);
            }
        });

        fs.outputFileSync(loaderPath, exportStatements.join( EOL ));
    }

    /**
     * (Internal) generate script to load one of the installed skins
     *
     * @param {string} loaderPath - path where loader script should be generated
     * @param {string} dirname - current directory where this script is running
     * @param {string} skinDir - path to skin folder (inside isomorphic directory)
     * @param {string} skinName - name of skin (e.g. "Tahoe")
     */
    static _createSkinLoader(loaderPath, dirname, skinDir, skinName) {
        const skinExts = ["css", "svg", "png", "jpg", "gif", 
                          "woff", "woff2", "ttf", "TTF", "otf"]
        ;
        
        const dependentPath = path.resolve("..", "..");
        if (!skinDir.startsWith(dependentPath)) {
            console.error("ERROR! Can't generate a skin loader for path " + skinDir +
                          " not under the dependent module");
            return;
        }

        const isomorphicRegExp = this._getPathSegmentRegExp(Const.ISOMORPHIC_DIR);
        let contextPath = skinDir.substring(dependentPath.length + 1)
                                 .match(isomorphicRegExp)[0];

        skinDir = "../../../.." + Update._canonicalizePath(
            skinDir.substring(dependentPath.length));
        contextPath = Update._canonicalizePath(contextPath);

        let contents = "require.context(\n" +
            "    '!!file-loader?context=" + contextPath +
            "&name=[path][name].[ext]!" + skinDir + "',\n" +
            "    true, /\\.(" + skinExts.join("|") + ")$/\n" +
            ");\n"
        ;

        contents += 
            "isc.Page.manualStyleSheets = true;\n" +
            "window.isc_currentScriptSrc = '/isomorphic/skins/" + skinName + "/';\n" +
            "require('" + skinDir + "/skin_styles.css');\n" +
            "require('" + skinDir + "/load_skin.js');\n"
        ;

        // for Showcase, skip attempts to load skin after initial skin load
        contents = "if (!isc.loadSkin) {\n\n" + contents + "\n}\n";

        fs.outputFileSync(loaderPath, contents);        
    }

    /**
     * (Internal) inject include dependency for SmartClient's typescript file
     *
     * @param {string} isomorphicPath - path to isomorphic directory
     * @param {boolean} prompt - interactive update
     */
    static async _injectTypeScript(isomorphicPath, prompt) {
        const tsConfigName = Const.TYPESCRIPT_CONF,
              dependentPath = path.resolve("..", ".."),
              tsFilePath = path.join(isomorphicPath, "system", "development")
        ;
        if (isomorphicPath.startsWith(dependentPath)) {
            isomorphicPath = isomorphicPath.substring(dependentPath.length + 1);
        }
        const tsIncludePath = path.join(isomorphicPath, "**", "*.d.ts"),
              failureMessage = "Assuming your typescript file is in the top-level directory " +
                  "of your module with isc-config.json, you can manually add the path '" +
                  tsIncludePath + "' to the list of include paths in your typescript file " +
                  "with a block like this:\n" +
                  "    \"include\": [\n" +
                  "        // other, existing paths...\n" +
                  "        \"" + tsIncludePath + "\"\n" +
                  "    ]\n" +
                  "(If your typescript is elsewhere, the path may need adjustment.)  " +
                  "Or you can copy smartclient.d.ts from '" + tsFilePath + "' to your app's " +
                  "source directory and manually import it from your app.\n"
        ;
        // if we can find the dependent module's tsconfig.json, offer/try to update it
        if (dependentPath) {
            const tsPath = path.join(dependentPath, tsConfigName);
            if (fs.existsSync(tsPath)) {
                let tsConfig;
                try {
                    tsConfig = fs.readJsonSync(tsPath);
                } catch (e) {
                    console.warn("WARNING! Unable to parse the file " + tsPath +
                        " for your app.  (Bad syntax? JS-style comments?)  " +
                        failureMessage);
                    return;
                }
                let includedDirs = tsConfig.include;
                if (includedDirs && includedDirs.indexOf(tsIncludePath) >= 0) {
                    console.log("Your app already has the right typescript include path in " +
                                "its " + tsConfigName + " for SmartClient.");
                } else {
                    const question = "Your app lacks an include path in its " + tsConfigName +
                                     " for SmartClient.  Add";
                    let answer = await CommonLib.prompt(question + "? [yes]: ", prompt, "no");
                    if (answer)
                    {
                        console.log("Adding SmartClient's typescript include path to the " +
                                    tsConfigName + " of your app...");
                        if (!includedDirs) includedDirs = tsConfig.include = [];
                        includedDirs.push(tsIncludePath);
                        fs.writeJsonSync(tsPath, tsConfig, {spaces: 4});
                    } else {
                        console.log("To import SmartClient's typescript file, add the path '" +
                                    tsIncludePath + " to the include paths in your app's" +
                                    tsConfigName + " file");
                    }
                }
                return;
            }
        }
        console.warn("WARNING! Unable to find " + tsConfigName + " for your app.  " +
                     failureMessage);
    }

    /**
     * (Internal) generate import scripts for importing an optional module
     *
     * @param {string} isomorphicPath - path to isomorphic directory
     * @param {string} scriptFolder - folder to contain module loader
     * @param {string} moduleName - name of the optional module
     */
    static _createOptionalModuleScripts(isomorphicPath, scriptFolder, moduleName) {
        var dirname = path.resolve(__dirname),
            moduleFile = "ISC_" + moduleName + ".js"
        ;
        // remove or regenerate the release import script for the optional module
        let releaseLoaderPath = path.join(dirname, "release", scriptFolder, "index.js"),
            releaseModulePath = path.join(isomorphicPath, "system", "modules", moduleFile);
        if (fs.existsSync(releaseModulePath)) {
            Update._createModuleLoader(releaseLoaderPath, dirname, releaseModulePath);
        } else fs.removeSync(releaseLoaderPath);

        // remove or regenerate the debug import script for the optional module
        let debugLoaderPath = path.join(dirname, "debug", scriptFolder, "index.js"),
            debugModulePath = path.join(isomorphicPath, "system", "modules-debug", moduleFile);
        if (fs.existsSync(debugModulePath)) {
            Update._createModuleLoader(debugLoaderPath, dirname, debugModulePath);
        } else fs.removeSync(debugLoaderPath);
    }

    /**
     * (Internal) generate script to load an optional module (e.g. analytics)
     *
     * @param {string} loaderPath - path where loader script should be generated
     * @param {string} dirname - current directory where this script is running
     * @param {string} modulesPath - full path, including filename, of optional module
     */
    static _createModuleLoader(loaderPath, dirname, modulesPath) {
        const dependentPath = path.resolve("..", "..");

        if (modulesPath.startsWith(dependentPath)) {
            modulesPath = "../../.." + Update._canonicalizePath(
                modulesPath.substring(dependentPath.length));
        } else {
            modulesPath = Update._canonicalizePath(modulesPath);
        }

        const contents = "require('" + modulesPath + "');\n";
        fs.outputFileSync(loaderPath, contents);
    }

    /**
     * (Internal) Get download file name.
     *
     * @param {number} branch - SmartClient branch
     * @param {string} date - build date
     * @return (string)
     */
    static _getSmartClientZipName(branch, date) {
        let release = branch <= Const.DEFAULT_BRANCH;

        return "SmartClient_" + (release ? "" : "SNAPSHOT_") + "v" + (branch * 10) +
            (release ? "p" : "d") + "_" + date + "_" + Const.SMARTCLIENT_NAME + ".zip";
    }

    /**
     * (Internal) Send GET with userAgent.
     *
     * @param {url} target url for GET
     * @param {callback}
     */
    static _httpsGet(url, callback) {
        let request = npmurl.parse(url);
        request.headers = {
            "User-Agent": "npmjs / " + process.env.npm_package_name
        };
        https.get(request, res => {
            let status = res.statusCode;
            switch (status) {
            case 301: case 302:
            case 307: case 308:
                // handle an HTTP 3XX redirect by calling this method with new URL
                let location = res.headers["location"] || rs.headers["Location"];
                console.log("Rediected to " + location);
                return this._httpsGet(location, callback);
            }
            callback(res);
        });
    }

    /**
     * (Internal) Canonicalize filesystem path to have Linux/MacOS separators.
     *
     * @param {string) filepath - raw filesystem path to convert
     * @return (string)
     */
    static _canonicalizePath(filepath) {
        if (!filepath || path.sep == "/") return filepath;
        return filepath.replace(new RegExp("\\" + path.sep, "g"), "/");
    }

    /**
     * (Internal) Return a RegExp that looks for "node_modules" in a path.
     *
     * @param (string) segment - path segment to convert to RegExp
     * @return (string)
     */
    static _getPathSegmentRegExp(segment) {
        return new RegExp("(?:^|.*\\" + path.sep + ")(?=" + segment + "\\" + path.sep + ")");
    }

    /**
     * (Internal) Returns whether to consider "prompt" option true
     *
     * @param (Object) config - current module configuration
     * @return (Boolean) whether to consider "prompt" option true
     */
    static getPromptOption(config) {
        // command line config has the highest priority
        if (process.env.npm_config_prompt != null) {
            return process.env.npm_config_prompt;
        }
        // if stored config is present, respect it
        if (config) {
            // current config uses "prompt"
            if (config.prompt != null) {
                return config.prompt;
            }
            // legacy config used "yes" (inverted)
            if (config.yes != null) {
                return !config.yes;
            }
        }
    }

    /**
     * (Internal) Check whether depedendent module is a React app.
     *
     * @return (Boolean) whether depedendent module is a React app.
     */
    static hasReact() {
        let result;

        const parentPackageFile = path.resolve("..", "..", "package.json");
        if (fs.existsSync(parentPackageFile)) {
            const dependencies = fs.readJsonSync(parentPackageFile).dependencies;
            if (dependencies) result = dependencies.react;
        }

        if (result) console.log("Dependent module appears to be a React app.");
        else console.log("Dependent module doesn't appear to use React.");

        return !!result;
    }

    /**
     * (Internal) Show update usage information.
     */
    static usage() {

        let package_name = process.env.npm_package_name,
            default_branch = Const.DEFAULT_BRANCH,
            default_skin = Const.DEFAULT_SKIN
        ;
        let usage =
            "Install package and SmartClient runtime(s):\n\n" +
            "     npm install " + package_name + " [flags]\n\n" +
            "Update/reconfigure SmartClient runtime(s) (must be run from package directory):\n\n" +
            "     npm run update [flags]\n\n" +
            "where the supported flags are:\n\n" +
            "     --location=<directory>  where to install the SmartClient runtime(s);\n" +
            "                             default is to place runtime root (" + Const.ISOMORPHIC_DIR + ")\n" +
            "                             in the dependent module directory\n\n" +
            "     --branch=<number>       desired branch (e.g. 11.1); default is " + default_branch + "\n\n" +
            "     --date=<date>|latest    desired build date, in format YYYY-MM-DD,\n" +
            "                             or 'latest'; default is 'latest'\n\n" +
            "     --runtime=release|debug|both\n" +
            "                             which runtime(s) to install; default is 'both'\n\n" +
            "     --reference[=<boolean>] whether to keep the framework reference directory;\n" +
            "                             default is to not install it to save disk space\n\n" +
            "     --skins=" + default_skin + "|all|none  which skins (if any) to install;\n" +
            "                             default is to only install " + default_skin + "\n\n" +
            "     --prompt[=<boolean>]    wait for input instead of assuming the default\n" +
            "                             response to all queries during install; default\n" +
            "                             is to not prompt to support newer npm releases\n\n" +

            (Const.REQUIRES_ACCOUNT ? (
            "     --username=<string>     username for account on www.smartclient.com\n\n" +
            "     --password=<string>     password for account on www.smartclient.com\n\n") : "") +

            (Const.SUPPORTS_MODULES ? (
            "     --analytics[=<boolean>] install the optional Analytics module\n\n" +
            "     --rtm[=<boolean>]       install the optional RealtimeMessaging module\n\n") : "") +

            "After installation, command-line configuration is persisted, so command-line arguments only\n" +
            "need to be supplied when updating if the desired configuration has changed.  " + 
            
            (Const.REQUIRES_ACCOUNT ? ("If a username\n" +
            "and password aren't supplied via the above options, you will be prompted to enter them by\n" +
            "the update script.  A password typed in response to the script won't be persisted to your\n" +
            "configuration, so you may choose to always enter it interactively for security.") : "") + 
            "\n\n" +

            "Note that since 'npm update' no longer runs a package's update script, you must use the\n" +
            "syntax above to update the runtime(s) if the package has already been installed.\n\n" +
            "Examples:\n\n" +
            "New install, selecting a specific branch and date:\n\n" +
            "     npm install " + package_name + " --branch=11.1 --date=2018-12-30\n\n" +
            "Update to latest nighlty build (run from package directory):\n\n" +
            "     npm run update --date=latest\n\n" +
            "Update to SmartClient 12.0 branch, installing all skins:\n\n" +
            "     npm run update --branch=12.0 --skins=all\n";

        console.log(usage);
    }

}

// Start install/update process
(async function () {
    Update.main();
})();
