/*

  SmartClient Ajax RIA system
  Version v13.0p_2023-09-15/LGPL Deployment (2023-09-15)

  Copyright 2000 and beyond Isomorphic Software, Inc. All rights reserved.
  "SmartClient" is a trademark of Isomorphic Software, Inc.

  LICENSE NOTICE
     INSTALLATION OR USE OF THIS SOFTWARE INDICATES YOUR ACCEPTANCE OF
     ISOMORPHIC SOFTWARE LICENSE TERMS. If you have received this file
     without an accompanying Isomorphic Software license file, please
     contact licensing@isomorphic.com for details. Unauthorized copying and
     use of this software is a violation of international copyright law.

  DEVELOPMENT ONLY - DO NOT DEPLOY
     This software is provided for evaluation, training, and development
     purposes only. It may include supplementary components that are not
     licensed for deployment. The separate DEPLOY package for this release
     contains SmartClient components that are licensed for deployment.

  PROPRIETARY & PROTECTED MATERIAL
     This software contains proprietary materials that are protected by
     contract and intellectual property law. You are expressly prohibited
     from attempting to reverse engineer this software or modify this
     software for human readability.

  CONTACT ISOMORPHIC
     For more information regarding license rights and restrictions, or to
     report possible license violations, please contact Isomorphic Software
     by email (licensing@isomorphic.com) or web (www.isomorphic.com).

*/
// SelectionOrRollOverCanvas: Canvas subclass with special undocumented 
// cssPointerEvents setting to allow events to be natively routed through to the 
// target canvas underneath (the body)
isc.defineClass("SelectionOrRollOverCanvas", "Canvas").addProperties({
    cssPointerEvents: "none"
});

//> @class  ListGrid
// A ListGrid is a +link{DataBoundComponent} that displays a list of objects in a grid, where
// each row represents one object and each cell in the row represents one property.
//
//  @inheritsFrom VLayout
//  @implements DataBoundComponent
//  @treeLocation Client Reference/Grids
//  @visibility external
//<
// Make ListGrid a subclass of VLayout. This allows us to change the order of the sub-components
// - show summary row between header and body, etc.

isc.ClassFactory.defineClass("ListGrid", "VLayout", "DataBoundComponent");

isc.defer("isc.ListGrid.addProperties({ showRollOver: !isc.Browser.isTouch });" +
"if (isc.Browser.hasDualInput) isc.ListGrid.addProperties({ handleMouseMove : " + 
"function (event, eventInfo) {return this._handleDualInputMouseMove(event, eventInfo);}});");

// Synonym for backCompat.  NOTE: define an alias rather than make a subclass, otherwise, attempts
// to skin the class using the old name would only affect the subclass!
isc.addGlobal("ListViewer", isc.ListGrid);
// define groups for documentation purposes

    //> @groupDef data
    //<

    //> @groupDef databinding
    // DataBinding means the automatic, highly customizable process of 'binding' a UI component
    // to a DataSource, so that a UI component displays, edits and saves DataSource records
    // using appropriate formatters, editors, validation rules, and persistence logic.
    //
    // @see interface:DataBoundComponent
    // @title DataBinding
    //<

    //> @groupDef sorting
    //<

    //> @groupDef editing
    // Data being displayed by a grid may be edited within the grid, by showing editing
    // interfaces embedded inside the cells of the grid.
    // <P>
    // <b>Enabling editing</b>
    // <P>
    // Editing is enabled when +link{listGrid.canEdit,canEdit} is <code>true</code>.  When enabled,
    // the user can begin editing via the
    // +link{listGrid.editEvent,editEvent}, typically click or double-click.  Editing can also be triggered
    // programmatically by a call to +link{listGrid.startEditing,startEditing()} or
    // +link{listGrid.startEditingNew,startEditingNew()}.
    // <P>
    // <b>New record creation</b>
    // <P>
    // By default, editing is restricted to existing records.  Setting +link{listGrid.listEndEditAction} to
    // "next" allows the user to create new records by simply navigating off the end of the dataset
    // with the keyboard.  Editing of new records can also be initiated with
    // +link{listGrid.startEditingNew()}, for example, from a button outside the grid.  See the
    // +link{group:unsavedRecords,Unsaved Records Overview} for special concerns when dealing
    // with unsaved records.
    // <P>
    // <b>Saving changes</b>
    // <P>
    // Saving of changes is triggered automatically when the user navigates out of the row or cell
    // being edited (based on +link{listGrid.saveByCell}) or when the user ends editing.   For
    // a "mass update" interface, automatic saving of changes can be disabled entirely via
    // +link{listGrid.autoSaveEdits,autoSaveEdits:false}, in which case a manual call to
    // +link{listGrid.saveEdits,saveEdits()} or +link{listGrid.saveAllEdits,saveAllEdits()} is required
    // to trigger saving.
    // <P>
    // If a grid has no DataSource, saving means that the properties of the +link{ListGridRecord}s
    // in +link{listGrid.data,grid.data} are directly changed.
    // <P>
    // For a grid with a DataSource, saving will be accomplished by using DataSource "update"
    // operations for existing records, and DataSource "add" operations for new records.  If multiple
    // records have been edited and +link{listGrid.saveAllEdits,saveAllEdits()} is called,
    // +link{rpcManager.startQueue,request queuing} will be automatically used to enable all
    // edits to be saved in one HTTP turnaround (if using the SmartClient Server).
    // <P>
    // By default, a grid will send only updated fields and primaryKey fields as part of
    // +link{dsRequest.data} so that the server can discern which fields the user actually changed.
    // However, the grid always includes the original field values in the
    // dsRequest as +link{dsRequest.oldValues}.
    // <P>
    // Note that although it is possible to load DataSource data without actually declaring a
    // +link{dataSourceField.primaryKey,primaryKey field}, a primaryKey must be declared for
    // editing and saving.  The values of primaryKey fields is how SmartClient identifies the
    // changed record to the server.
    // <P>
    // <b>Saving edits in a sorted data set:</b> When a user updates or adds a record in a sorted 
    // listGrid, the data set may be automatically +link{listGrid.unsort(),unsorted}.
    // When this happens, the sort indicator will be removed from sort
    // field headers, and all rows will stay in their current positions, including edited records
    // where the sort field value has been changed.<br>
    // Note that for a databound grid with a partial data set, a "true unsort" isn't possible 
    // without droppping the cache, as both client and server need to agree on the positions
    // of rows. In this case the grid is marked as unsorted, and all visible rows stay in place
    // until the next fetch occurs, at which point the cache is dropped and a truly unsorted
    // data set retrieved from the server. Typically the next fetch would be caused by the
    // user scrolling to a new position in the grid. Once that fetch occurs the positions
    // of rows within the grid will be updated to match the positions of rows in the unsorted
    // server-side data set, meaning if the user scrolled back to their previous position
    // they may see a different set of records. (See also +link{ResultSet.updatePartialCache}).
    // <P>
    // <b>Validation</b>
    // <P>
    // Any time saving is attempted, validation is automatically triggered.  Values entered by the
    // user will be checked against the +link{listGridField.validators} and the
    // +link{dataSourceField.validators}. Any invalid values abort an attempted save.
    // <P>
    // Similar to editing and saving, validation can be done on row transitions or on cell
    // transitions by setting +link{listGrid.validateByCell,validateByCell}, or can be disabled entirely
    // via +link{listGrid.neverValidate,neverValidate:true}.
    // <P>
    // <b>Editability of cells</b>
    // <P>
    // Editors will either be shown for the complete row or for a single cell based on
    // +link{listGrid,editByCell,editByCell}.  Whether a cell can be edited can be controlled on a
    // per field basis by setting +link{listGridField.canEdit,field.canEdit}, or on a per-record basis
    // by setting +link{listGrid.recordEditProperty,recordEditProperty} on a
    // +link{ListGridRecord,record}, or can be controlled on an arbitrary, programmatic basis via
    // an override of +link{listGrid.canEditCell()}.
    // <P>
    // Cells which are not editable just display the cell's current value.
    // <P>
    // <b>Keyboard Navigation</b>
    // <P>
    // Full keyboard navigation is supported by default, including Tab and Shift-Tab to navigate
    // between cells in a row, and Up Arrow and Down Arrow to traverse rows.  Several properties
    // on both grids and fields, all named *EditAction, control navigation behavior of certain keys
    // (eg Enter).
    // <P>
    // You can use +link{listGrid.startEditing,startEditing(<i>rowNum</i>, <i>colNum</i>)} to
    // programmatically move editing to a particular cell, for example, during a
    // +link{listGridField.changed,field.changed()} event.
    // <P>
    // <b>editValues (unsaved changes)</b>
    // <P>
    // The term "editValues" means changes that the user has made to the dataset which have not
    // been saved.  The grid manages and stores editValues separately from the data itself in order
    // to allow the user to revert to original values, and in order to enable to grid to send only
    // updated fields to the server.
    // <P>
    // Because editValues are stored separately, if you directly access the dataset (eg via
    // <code>grid.getData().get()</code>) you will see the records without the user's unsaved changes.
    // Many APIs exist for retrieving and managing editValues (search for editValue).
    // For the common case of needing to access the record-as-edited, you can call
    // +link{listGrid.getEditedRecord,grid.getEditedRecord(rowNum)}.
    // <P>
    // When accessing and manipulating edited data, you should think carefully about whether
    // you want to be working with the original data or with the edited version.  Values entered
    // by the user may not have been validated yet, or may have failed validation, hence you may
    // find a String value in a field of type "date" or "int", which could cause naive formatters or
    // totaling functions to crash.
    // <P>
    // Setting editValues via APIs such as +link{listGrid.setEditValue()} is fully equivalent
    // to the user making changes to data via the editing UI.  If you <i>also</i> allow editing
    // external to the grid, setting editValues is one way to combine changes from external
    // editors into the grid's edits, so that you can do a single save.
    // <P>
    // <b>Customizing Cell Editors</b>
    // <P>
    // When a cell is being edited, the editor displayed in the cell will be a +link{class:FormItem}.
    // The editor type for the cell will be determined by +link{listGrid.getEditorType()} based on the
    // specified +link{ListGridField.editorType} or +link{ListGridField.type, data type} for the field in
    // question.
    // <P>
    // You can customize the editor by setting +link{listGridField.editorProperties} to a set of
    // properties that is valid for that FormItem type.  Custom FormItem classes are also allowed,
    // for example, you may use +link{formItem.icons} to create an icon that launches a separate
    // +link{Dialog} in order to provide an arbitrary interface that allows the user to select the
    // value for a field.
    // <P>
    // <b>Events</b>
    // <P>
    // Editing triggers several events which you can provide handlers for in order to customize
    // editing behavior.  Some of the most popular are +link{listGridField.change,field.change()},
    // +link{listGridField.changed,field.changed()} for detecting changes made by the user,
    // +link{listGrid.cellChanged()} for detecting changes that have been successfully saved,
    // and +link{listGrid.editorEnter,editorEnter} and +link{listGrid.editorExit,editorExit()}
    // for detecting user navigation during editing.
    // <P>
    // <smartclient>
    // You can also install event handlers directly on the FormItem-based editors used in the grid
    // via +link{listGridField.editorProperties,editorProperties} as mentioned above.  When handling
    // events on items, or which involve items, be aware that in addition to standard
    // +link{FormItem} APIs, editors have the following properties:
    // <P>
    // - <code>rowNum</code>: The rowNum of the record being edited.<br>
    // - <code>colNum</code>: The colNum of the cell being edited.<br>
    // - <code>grid</code>: A pointer back to the listGrid containing the record.
    // </smartclient>
    // <smartgwt>
    // <code>ListGridField.setEditorType()</code> can be used to customize the editors shown
    // for each field, including providing FormItem-specific event handlers.  However,
    // ListGrid-provided event APIs should be used wherever possible (for example, use
    // <code>EditorEnterEvent</code> rather than <code>FocusEvent</code>).  If, in a FormItem
    // event handler, you need access to the ListGrid, you can either declare the event handler
    // as a Java "inner class" in a scope where the ListGrid is available as a final variable,
    // or you can use <code>event.getItem().getContainerWidget()</code>.  Note the ListGrid APIs
    // +link{listGrid.getEditRow,getEditRow()} and +link{listGrid.getEditCol,getEditCol()}
    // indicate what cell is being edited.
    // <P>
    // For more dynamic editor customization, include changing the type of editor used on a
    // per-row basis, use +sgwtLink{listGrid.setEditorCustomizer()}.
    // <P>
    // <b>NOTE:</b> with both APIs, in effect several FormItems are generated from the
    // customized FormItem you provide - see the docs for
    // +link{DataSourceField.editorType()} for special coding patterns that apply in this
    // case.
    // </smartgwt>
    // <P>
    // <b>Binary Fields</b>
    // <P>
    // The ListGrid will automatically show "view" and "download" icon buttons for binary field
    // types (see +link{type:ListGridFieldType}).  However, you cannot use an upload control
    // embedded within a ListGrid row to upload files (regardless of whether you use FileItem or
    // UploadItem).  This is because, in the browser's security model, native HTML upload
    // controls cannot be re-created and populated with a chosen file, and the ListGrid needs
    // to be able to re-create editors at any time in order to handle loading data on scroll,
    // scrolling editors in and out of view, adding new rows, changing sort direction, and
    // other use cases.
    // <P>
    // However you <i>can</i> create an editor with a +link{formItem.icons,FormItem icon} that
    // pops up a separate Window containing a FileItem in a DynamicForm, so long as the form in
    // the Window saves the uploaded file immediately rather than trying to have the grid
    // perform the save.
    //
    // @title Grid Editing
    // @treeLocation Client Reference/Grids/ListGrid
    // @visibility external
    //<
    


    //> @groupDef unsavedRecords
    // APIs such as +link{listGrid.startEditingNew(),startEditingNew()} or
    // +link{listGrid.listEndEditAction,listEndEditAction:"next"} allow editing records that have not
    // been saved to the server.  These unsaved records are special in several ways:
    // <ul>
    // <li> there is no actual Record object in the dataset for them: <code>getRecord(rowNum)</code>
    // will return null, instead, <code>getEditValues(rowNum)</code> allows access to field values for
    // the unsaved record
    // <li> rows for editing these records always appear at the end of the grid and do not sort with
    // other rows
    // <li> because unsaved records lack an actual Record object and lack a
    // +link{dataSourceField.primaryKey} value, they have limited functionality: they cannot be
    // selected, and do not support +link{listGrid.showRecordComponents} and certain other features.
    // </ul>
    // <P>
    // If you need to work with unsaved records and have all ListGrid features apply to them, this is
    // usually a sign that you should re-think your UI for adding new records.  Consider the following
    // approaches - which works best will depend on the application:
    // <ul>
    // <li> actually save a new record to persistent storage, then start editing it.  This has the
    // advantage that the user will never lose data by exiting the application with unsaved
    // records, which can be important if there is a lot of data entry before the record is ready to
    // save (for example, a new issue report in an issue-tracking applications, or a new blog entry).
    // This is also a good approach if the user may want to get a unique ID for the new record
    // right away (again useful for a new issue report or blog entry).
    // <P>
    // If values for several fields are required before the record should be visible on other screens
    // or to other users, you can add a field to the record to flag it as incomplete so that it is not
    // shown on other screens.  Alternatively, require certain fields to be entered via an external
    // form or dialog before the record is added to the grid.
    // <P>
    // Saving a new record and editing it can be done via +link{DataSource.addData()} followed by a call to
    // +link{listGrid.startEditing()} once the record has been saved.
    // <li> edit new records via a separate +link{DynamicForm,form} instead, possibly in a modal
    // +link{Window} - then unsaved records never need to be shown in the grid.  Similar to the
    // approach above, this modal form might have only certain minimum fields to make a valid
    // new record, then further editing could continue in the grid.
    // <li> use a +link{dataSource.clientOnly,clientOnly DataSource} so that records can be saved
    // immediately without contacting the server.  This is a good approach if several unsaved records
    // need to be manipulated by multiple components before they are finally saved.
    // <li> use +link{DataSource.updateCaches()} with an "add" DSResponse to cause a new record to be
    // added to the grid due to +link{ResultSet,automatic cache synchronization}.  At this point the
    // grid will believe the record exists on the server and it will be treated like any other saved
    // record.  This means your server code will need to handle the fact that the ListGrid will submit
    // "update" DSRequests for any subsequent edits.
    // </ul>
    // <b>NOTE about validation:</b> by design, SmartClient assumes that any record that has been
    // saved is valid and does not validate field values that appear in records loaded from the
    // server.  This includes records added to a clientOnly DataSource via
    // +link{DataSource.setCacheData()} as well as records added due to a call to
    // +link{DataSource.updateCaches()}.
    // <P>
    // Usually the best approach is to avoid this situation by editing such records in a form or other
    // control until they are valid rather than showing invalid records in a grid.  However, if such
    // records need to be considered invalid, one approach is to take field values and add them as
    // editValues via +link{listGrid.setEditValues()}.  At this point the ListGrid will consider the
    // values as user edits and will validate them.
    //
    // @title Handling Unsaved Records
    // @visibility external
    //<

    //> @groupDef imageColumns
    // Columns that show images either as their only appearance or in addition to text.
    //<

    //> @groupDef formulaFields
    // Fields with values calculated from other fields in the grid.
    //<

isc.defineClass("GridBody", isc.GridRenderer).addProperties({
    // suppress adjustOverflow while pending a redraw so we can resize smaller without seeing
    // a scrollbar flash in and out of existence
    adjustOverflowWhileDirty:false,

    
    _redrawToFixIEFocusScrollArtifacts:isc.Browser.isIE && isc.Browser.version > 9,

    initWidget : function () {
        this.Super("initWidget", arguments);

        
        if (isc.screenReader) this._redrawToFixIEFocusScrollArtifacts = false;

        this._cacheVariableHeightFieldNums();
    },

    fireSelectionUpdated : function () {
        this.grid.fireSelectionUpdated();
    },

    canSelectRecord : function(record) {
        return this.grid.canSelectRecord(record);
    },    


    // Override showSelectedStyle() to avoid showing inappropriate selected styling on group header nodes
    
    _showSelectedStyle : function (record, rowNum, colNum) {
        var lg= this.grid;        
        if (record && lg.isGrouped && !(lg.canSelectGroups && lg.selectionAppearance == "checkbox") 
            && record._isGroup) 
        {
            return false;
        }
        if (record && record._isGroup) {
            this.logWarn("Calling super");
        }
        return this.Super("_showSelectedStyle", arguments);
    },
    
    redrawForSelectionChanged : function () {
        this.grid._markBodyForRedraw("selection changed");
    },

    // adjustOverflow() - overridden to support 'autoFitData' behavior
    adjustOverflow : function (reason, a,b,c,d) {
        // If we get naively called while undrawn just call Super which will bail.
        // Ditto if we're hidden using display:none - in that case we can't reliably get
        // sizing information from the DOM
        
        var isVisibleInDom = this.isDrawn() && !this._handleDisplayIsNone();
        if (!isVisibleInDom) return this.Super("adjustOverflow", arguments);
   
        // we call 'getDelta' from this method which can fall back through to 'adjustOverflow'
        // Avoid infinite looping if we hit this case.
        if (this._calculatingDelta) return;
        
        if (this.grid._updatingRecordComponents) {
            return this.Super("adjustOverflow", arguments);
        }

        
        var grid = this.grid;

        
        if (grid == null) return this.Super("adjustOverflow", arguments);

        // Invalidate cached scrollHeight / scrollWidth so any calls to getScrollWidth/Height will
        // pick up values reflecting the current rendered HTML
        if (this._scrollWidth != null) delete this._scrollWidth;
        if (this._scrollHeight != null) delete this._scrollHeight;

        
        var data = grid.data, isLoading = false;;

        if (isc.isA.ResultSet(data) && !data.lengthIsKnown()) {
            if (grid.emptyMessageHeight == null) {
                return this.invokeSuper(isc.GridBody, "adjustOverflow", reason,a,b,c,d);
            }
            isLoading = true;
        }

        var initialWidth = this.getWidth(), initialHeight = this.getHeight();
        var fitVertical = (this.autoFitData == "both"),
            fitHorizontal = fitVertical,
            frozen = grid && grid.frozenFields != null,
            isFrozenBody = frozen && grid && (grid.frozenBody == this);

        if (!fitVertical) fitVertical = (this.autoFitData == "vertical");
        if (!fitHorizontal) fitHorizontal = (this.autoFitData == "horizontal");
        // If we have frozen fields, the frozen body never shows scrollbars and always
        // gets sized to match the widths of the fields it contains (done as part of
        // setBodyFieldWidths). Don't worry about trying to run special auto-fit logic
        // on the frozen body.
        // - We do run auto-fit logic on the unfrozen body and take the size of the frozen
        //   body into account when doing so.
        // - We do still need to ensure the header layout is sized correctly when the frozen
        //   body is resized
        
        if (fitHorizontal || fitVertical) {
            var height, width, rowHeights, hscrollOn, vscrollOn, dX, dY;

            if (fitVertical) {
                var minHeight = this.grid.getAutoFitMinBodyHeight();
                height = minHeight;
                var totalRows = isLoading ? 0 : this.getTotalRows(),
                    rows = totalRows;

                rowHeights = 0;
                // ignore autoFitMaxRecords if set to zero - this means fit to all records!
                if (this.autoFitMaxRecords) {
                    rows = Math.min(rows, this.autoFitMaxRecords);
                }
                if (rows > 0) {
                    // We need to handle variable rowHeights so we're going to have to look at
                    // the table element to determine the heights - we already have a method to
                    // do that
                    var drawnRowHeights = this._getDrawnRowHeights();
                    // If we have any undrawn rows assume calculated sizes
                    
                    var firstDrawnRow = this._firstDrawnRow,
                        lastDrawnRow = this._lastDrawnRow;

                    

                    // fdr / ldr unset implies no drawn rows - set such that we calculate
                    // theoretical heights only
                    if (this._firstDrawnRow == null) {
                        firstDrawnRow = rows;
                        lastDrawnRow = rows;
                    }
                    // _isFrozenBody defined in GridRenderer
                    var isFrozenBody = this._isFrozenBody();

                    if (firstDrawnRow > 0) {
                        firstDrawnRow = Math.min(firstDrawnRow, rows);
                        for (var i = 0; i < firstDrawnRow; i++) {
                            rowHeights += this.getRowHeight ?
                                            this.getRowHeight(this.grid.getRecord(i), i, isFrozenBody)
                                            : this.cellHeight;
                        }
                    }
                    var lastLogicalRow = rows-1;
                    if (lastDrawnRow < lastLogicalRow) {
                        for (var i = lastDrawnRow+1; i < lastLogicalRow+1; i++) {
                            rowHeights += this.getRowHeight ?
                                            this.getRowHeight(this.grid.getRecord(i), i, isFrozenBody)
                                            : this.cellHeight;
                        }
                    }
                    // Measure the rendered rows and add up the heights.
                    // Note that getDrawnRowHeights() just returns an array of the heights of
                    // rendered rows so the first drawn row is the first entry in the array, not
                    // the _firstDrawnRow'th entry
                    lastDrawnRow = Math.min(lastDrawnRow, lastLogicalRow);
                    for (var i = 0; i <= lastDrawnRow-firstDrawnRow; i++) {
                        rowHeights += drawnRowHeights[i];
                    }
                    // If we are clipping off any rows we know we have a v-scrollbar
                    vscrollOn = totalRows > rows;

                    // Treat autoFitMaxHeight:0 as unspecified - resize as large as necessary
                    var autoFitMaxHeight = this.getAutoFitMaxHeight();
                    if (autoFitMaxHeight && rowHeights > autoFitMaxHeight) {
                        rowHeights = autoFitMaxHeight;
                        vscrollOn = true;
                    }
//                     this.logWarn("total rows to show:"+ rows +
//                      ", rendered:" + [this._firstDrawnRow,this._lastDrawnRow] +
//                      ", rowHeights total up to:"+ rowHeights +
//                      ", current height:" + this.getHeight() +
//                      ", body height based on ListGrid specified height:" + height);

                } else {
                    // The emptyMessage renders in the available space. If emptyMessageHeight
                    // is explicitly set, leave that much space for it.
                    
                    if (this.grid.emptyMessageHeight != null) {
                        rowHeights = this.grid.emptyMessageHeight;
                    }
                }
                

                // add some extra height if autoFitExtraRecords is set
                
                if (this.autoFitExtraRecords && this.autoFitExtraRecords > 0) {
                    var extraHeight = Math.round(this.autoFitExtraRecords * this.cellHeight);
                    rowHeights += extraHeight;
                }

            } else {
                vscrollOn = this.getScrollHeight() > this.getHeight();
            }

            if (fitHorizontal && !isFrozenBody) {
                var width = this.grid.getInnerWidth(),
                    frozenBodyWidth;
                if (frozen) {
                    var frozenWidths = this.grid.getFrozenSlots(this.grid._fieldWidths);
                    frozenBodyWidth = frozenWidths.sum();
                    width -= frozenBodyWidth;

                    // if the frozenWidths exceed the specified width for the grid as a whole,
                    // apply an arbitrary small positive min width for the unfrozen body
                }


                // Note that we're calling getColumnSizes on the GridRenderer
                // So if we the LG is frozen body this gives us the cols within the
                // appropriate body, not the total set of cols in the grid.
                var colSizes = this.getColumnSizes(),
                    contentWidth = colSizes.sum();
                if (this.autoFitMaxColumns) {
                    var maxCols = this.autoFitMaxColumns;
                    // bit of a hack - how to deal with maxCols specified as a number <= the
                    // number of frozen fields.
                    // For now we just enforce at least one unfrozen field
                    if (frozen) {
                        maxCols = Math.max(1, maxCols-this.grid.frozenFields.length);
                    }

                    if (maxCols < colSizes.length) {
                        colSizes = colSizes.slice(0, maxCols);
                    }
                }

                var colWidths = colSizes.sum();
                if (this.autoFitMaxWidth) {
                    var maxWidth = this.grid.getAutoFitMaxWidth();
                    if (frozen) maxWidth = Math.max(20, maxWidth - frozenBodyWidth);
                    colWidths = Math.min(maxWidth, colWidths);
                }
                hscrollOn = (this.overflow == isc.Canvas.SCROLL) ? true :
                            (this.overflow == isc.Canvas.AUTO) ? (contentWidth > Math.max(width, colWidths)) :
                            false;

            } else {
                hscrollOn = this.overflow == isc.Canvas.SCROLL ? true :
                            this.overflow == isc.Canvas.AUTO  ? this.getScrollWidth() > this.getWidth() :
                            false;
            }

            

            // Now we know if we have an h-scrollbar, adjust height and width for scrollbars /
            // borders / margin if appropriate
            if (fitVertical && rowHeights != null) {
                rowHeights += this.getVBorderPad() + this.getVMarginSize();
                if (hscrollOn) {
                    rowHeights += this.getScrollbarSize();
                    var autoFitMaxHeight = this.getAutoFitMaxHeight()
                    if (autoFitMaxHeight && rowHeights > autoFitMaxHeight) {
                        rowHeights = autoFitMaxHeight;
                    }
                }
                // Resize vertically if rowHeights (+ border etc) > the auto fit min height
                // (which is derived from the ListGrid's specified height)
                if (rowHeights > height) {
                    height = rowHeights;
                    this._vAutoFit = true;
                } else {
                    if (this._vAutoFit) delete this._vAutoFit;
                }
            }
            if (fitHorizontal && !isFrozenBody && colWidths != null) {

                colWidths += this.getHBorderPad() + this.getHMarginSize();
                // If we're showing a vertical scrollbar
                // or we're leaving a scrollbar gap, ensure we autoFit wide enough to
                // accommodate that scrollbar/gap
                if (vscrollOn || this.alwaysShowVScrollbar || this.grid._shouldLeaveScrollbarGap(!!vscrollOn)) {
                    colWidths += this.getScrollbarSize();
                    if (this.autoFitMaxWidth) {
                        var maxWidth = this.grid.getAutoFitMaxWidth();
                        if (frozen) maxWidth = Math.max(20, maxWidth - frozenBodyWidth);
                        colWidths = Math.min(maxWidth, colWidths);
                    }
                }
                // Resize horizontally if colWidths > width
                if (colWidths > width) {
                    width = colWidths;
                    this._hAutoFit = true;
                } else {
                    if (this._hAutoFit) delete this._hAutoFit;
                }
            }

            // Calculate the delta with our current size.
            this._calculatingDelta = true;            
            dY = this.getDelta(this._$height, height, this.getHeight());

            dX = this.getDelta(this._$width, width, this.getWidth());
            delete this._calculatingDelta;
            // If necessary resize to accommodate content!
            if (dY != null || dX != null) {
                this.resizeBy(dX, dY, null, null, this._$autoFitSize);
            } 

            // if width change != null, resize header to match body
            // Note that if isFrozenBody is true we skipped the dX calculation so
            // always resize the headerLayout to match
            
            if (dX != null || (isFrozenBody && fitHorizontal)) {
                var lg = this.grid,
                    scrollbarSize = lg._shouldLeaveScrollbarGap() ? lg.body.getScrollbarSize() : 0,
                    headerWidth = width - scrollbarSize,
                    totalHeaderWidth = headerWidth;
                if (frozen && lg.headerLayout) {

                    if (isFrozenBody) {
                        totalHeaderWidth = this.getWidth() + lg.body.getWidth();
                        // If we go past the autoFitMaxWidth limit, run adjustOverflow on the body
                        // to force it to shrink/start scrolling
                        if (lg.autoFitMaxWidth != null &&
                            (totalHeaderWidth + lg.getHBorderPad() +
                                lg.getHMarginSize() > lg.getAutoFitMaxWidth()))
                        {
                            // don't bother to go on and resize the header - we'll do that
                            // when the body adjust overflow method runs
                            return lg.body.adjustOverflow();
                        }
                        totalHeaderWidth -= scrollbarSize;

                    } else {
                        totalHeaderWidth = headerWidth + lg.frozenBody.getWidth();
                    }
                    lg.headerLayout.setWidth(totalHeaderWidth);
                }

                // We can skip resizing the frozen header - this is handled in setBodyFieldWidths
                if (!isFrozenBody) {
                    var header = lg.header;

                    if (header && header.isDrawn()) {
                        header.setWidth(headerWidth);
                    }
                }
            }

        // if autoFitData is null but we don't match our 'specified size', assume the property
        // has been modified and reset to specified size
        }
        if (isFrozenBody) {
            var frozenWidths = this.grid.getFrozenSlots(this.grid._fieldWidths),
                frozenContentWidth = frozenWidths.sum();
            var mustHScroll = this.getViewportWidth() < frozenContentWidth;
            if (this.grid.bodyOverflow == isc.Canvas.AUTO) {
                this.setCustomHScrollbar(mustHScroll);
            }
        }
        

        // catch the case where autoFitData has been cleared in either direction and
        // reset to specified size.
        var verticalChanged = (!fitVertical && this._vAutoFit),
            horizontalChanged = (!fitHorizontal && this._hAutoFit);
        if (verticalChanged || horizontalChanged) {
            delete this._vAutoFit;
            delete this._hAutoFit;

            var standardHeight = verticalChanged ? this.grid.getAutoFitMinBodyHeight() : null,
                standardWidth = horizontalChanged ?
                                (!frozen ? this.grid.getInnerWidth() :
                                    (this.grid.getInnerWidth() - this.grid.frozenBody.getWidth()) )
                                                  : null;
            this.resizeTo(standardWidth,standardHeight);
            // reset userHeight / userWidth to 100%, so future resizes to the LG cause the
            // body to also resize.
            if (!fitHorizontal) this.updateUserSize("100%", this._$width);
            if (!fitVertical)   this.updateUserSize("100%", this._$height);
            // reset field widths on the grid to resize the header to match the body
            this.grid._updateFieldWidths("autoFitData mode changed");
        }
        var returnVal = this.invokeSuper(isc.GridBody, "adjustOverflow", reason, a,b,c,d);
        // if size changed, refresh recordComponents to account for new draw area
        if ((fitVertical || fitHorizontal) &&
            (this.getWidth() != initialWidth || this.getHeight() != initialHeight))
        {
            this.grid.updateRecordComponents(true);
        }

        // Fire the "bodyOverflowed" observation. This updates frozen body end space and
        // summary row body right space to so these can keep in sync with body scrolling
        // even though the viewport sizes are different.
        if (!isFrozenBody) this.grid.bodyOverflowed();
        return returnVal;
    },
    
    // When determining auto-fit-field-widths, avoid adding a pixel to account for
    // rounding errors due to sub-pixel sized rendering coupled with pixel-resolution
    // reported sizes for cells whose content is actually sized to fill the available
    // space
    
    adjustForSubPixelSizing : function (colNum) {
        var grid = this.grid;
        if (grid._editorShowing || grid.alwaysShowEditors) {
            var fieldNum = grid.getFieldNumFromLocal(colNum, this),
                field = grid.getField(fieldNum),
                nonEditableField = (!field || field.disabled || field.canEdit == false ||
                                    field.type == "summary" ||
                                    (field.canEdit == null && 
                                        (field.userFormula || field.userSummary)));
            if (!nonEditableField && (!grid.editByCell || grid.getEditCol() == fieldNum)) {
                return false;
            }
        }
        return true;
    },
    
    setCustomHScrollbar : function (show) {
        var scrollbar = this.customHscrollbar;
        
        if (!scrollbar) {
            if (!show) return;
        
            scrollbar = this.customHscrollbar = isc.ClassFactory.newInstance(
                this.scrollbarConstructor,
            {
                ID:this.getID()+"_custom_hscroll",
                autoDraw:false,
                _generated:true,
                zIndex:this.getZIndex() +1,
                showThumbTriggerArea: isc.Browser.isTouch || isc.Browser.supportsDualInput,
                vertical:false,
                scrollTarget:this,
                visibility:this.visibility,
                _redrawWithMaster:false,
                _resizeWithMaster:false,
                _redrawWithParent:false,

                // rely on snapTo for auto-positioning!                
                snapTo:"B",
                width:"100%",
                btnSize:this.getCustomScrollbarSize()
            });
            
            this.addPeer(scrollbar);
        }
        
        scrollbar.setVisibility(show);
        
    },
    

    // Override 'getSizeMayChangeOnRedraw' to return true when autoFitData is set.
    getSizeMayChangeOnRedraw : function () {
		var fitVertical = (this.autoFitData == "both"),
        	fitHorizontal = fitVertical;
		
	    if (!fitVertical) fitVertical = (this.autoFitData == "vertical");
	    if (!fitHorizontal) fitHorizontal = (this.autoFitData == "horizontal");
	    if (fitHorizontal || fitVertical) return true;
	    return this.Super("getSizeMayChangeOnRedraw", arguments);	    
    },

    getAutoFitMaxHeight : function () {
        return this.grid ? this.grid.getAutoFitMaxBodyHeight() : null;
    },
    
    // When determining auto-fit-field-widths (drawn size of columns) we render out an
    // offscreen tester containing tableHTML and look at the various cells' widths in a row.
    // If the grid is grouped, we need to choose a row which isn't the group header
    // since that contains col-spanning cells
    _getValidAutoFitRowNum : function () {
        var grid = this.grid;
        if (this.grid && this.grid.isGrouped) {
            var rowNum = 0;
            while (rowNum < this.grid.getTotalRows()) {
                var record = this.grid.getRecord(rowNum);
                if (record == null || !this.grid.isGroupNode(record)) {
                    return rowNum;
                }
                rowNum++;
            }
        }
        return 0;
    },

    _$autoFitSize: "autoFitSize",

    resizeBy : function (deltaX, deltaY, animating, suppressHandleUpdate, reason) {
        var autoFitSize = reason == this._$autoFitSize;

        // autoFitSize parameter: When autoFitData is true for this grid, we resize the
        // body to fit the data, and pass in the autoFitSize parameter to this method.
        // In the case of an explicit resize outside the autoFitData system, hang onto the
        // specified size so we can reset to it if the data shrinks, etc
        if (!autoFitSize) {
            this._specifiedWidth = this.getWidth() + (deltaX != null ? deltaX : 0);
        }

        // Note that return value of resizeBy indicates whether the size actually changed
        var returnVal = this.invokeSuper(isc.GridBody, "resizeBy", deltaX, deltaY, animating,
                                         suppressHandleUpdate, reason);
        // we usually update _userWidth/_userHeight as part of layout.childResized to
        // store the explicit width, which then stops the member reacting to the layout's
        // subsequent resizes.
        // However, if we're autoFitting the (unfrozen) body to content, we want a
        // subsequent resize of the grid as a whole to still cause the body to expand
        // further.
        // Therefore yank out this _userSize flag in this case.
        if (autoFitSize && deltaX != null && !this.frozen) {
            delete this._userWidth;
        }
        return returnVal;
    },

    // context menus (NOTE: ListGrid-level handling is identical for cell vs row context click)
    cellContextClick : function (record, rowNum, colNum) {
        var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
        return this.grid._cellContextClick(record, rowNum, gridColNum);
    },

    // Override _rowClick: If a record is marked as disabled this suppresses all events, but
    // if the user clicks in the "remove" field of an already removed record we actually want
    // to react to this and unmarkAsRemoved()
    _rowClick : function (rowNum, colNum) {
        if (!this.grid) return;
        var returnVal;
        var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
        
        var rec = rowNum >= 0 ? this.grid.getRecord(rowNum) : null,
            field = gridColNum >= 0 ? this.grid.getField(gridColNum) : null,
            isRemoveClick = false
        ;
        
        if (!isc.isA.RecordEditor(this.grid) && field && field.isRemoveField) {
            // If the user clicks inside the remove field on a group or summary row, don't fire
            // the remove-click!
            isRemoveClick = !rec || !(rec._isGroup || rec.isGroupSummary || rec.isGridSummary);
        }
        
        if (isRemoveClick) {
            if (rowNum >= 0) {
                this.grid.removeRecordClick(rowNum,colNum);
                returnVal = false;
            }
        } else {
            returnVal = this.Super("_rowClick", arguments);
        }
        
        // if selectCellTextOnClick is true, select the cell text now
        if (returnVal != false && this.grid.shouldSelectCellTextOnClick(rowNum, gridColNum)) {
            this.grid.selectCellText(rowNum, gridColNum);
        }
        
        return returnVal;
    },

    
    _fixRowClickRow : function (record, rowNum, colNum) {
        var grid = this.grid
        if (grid && grid.data && grid.isGrouped && grid.isGroupNode(record) && 
            record != this.getCellRecord(rowNum, colNum))
        {
            // return the current rowNum of the groupNode
            
            var groupNodeIndex = grid.data.indexOf(record);
            if (groupNodeIndex >= 0) return groupNodeIndex;
        }
        return rowNum;
    },

    getCellHoverDelay : function (rowNum, colNum) {
        if (!this.grid) return;
        var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
        return this.grid.getCellHoverDelay(this.grid.getCellRecord(rowNum, gridColNum), rowNum,
                                           gridColNum);
    },


    _getCellHoverComponent : function (record, rowNum, colNum) {
        if (this.grid && isc.isA.ListGrid(this.grid)) {
            var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
            return this.grid._getCellHoverComponent(record, rowNum, gridColNum);
        }
    },

    
    _cacheVariableHeightFieldNums : function (skipOtherBody) {
        this._variableRecordHeightFieldNums = null;
        
        var grid = this.grid;

        if (grid && grid.variableRecordHeightFields != null) {
            var fieldNums = []
            ;
            for (var i = 0; i < grid.variableRecordHeightFields.length; i++) {
                var fieldName = grid.variableRecordHeightFields[i],
                    colNum = this.getFieldNum(fieldName)
                ;
                if (colNum >= 0) {
                    fieldNums.push(colNum);
                }
            }
            if (fieldNums.length > 0) {
                this._variableRecordHeightFieldNums = fieldNums;
            }

            
            if (!skipOtherBody) {
                var otherBody = this.frozen ? grid.body : grid.frozenBody;
                if (otherBody != null) {
                    otherBody._cacheVariableHeightFieldNums(true);
                }
            }
        }
    },

    // this ensures that if we're not showing any records we can still scroll the header fields
    // into view.
    expandEmptyMessageToMatchFields:true,
    applyHSpaceToEmptyMessage:true,

    getInnerHTML : function () {
        // call bodyDrawing on the LG if we are the primary body
        this.grid.bodyDrawing(this);
        return this.Super("getInnerHTML", arguments);
    },
    
    // Override _canFocus to check for whether we have any data.
    _canFocus : function () {
        var canFocus = this.Super("_canFocus", arguments);
        if (canFocus && this.grid && !this.grid.canFocusInEmptyGrid && this.isEmpty()) {
            return false;
        }
        return canFocus;
    },

    // alwaysManageFocusNavigation is true for ListGrids - this means any tab-navigation within
    // the grid will ultimately rely on 'syntheticShiftFocus' rather than native tab-index
    // handling
    
    syntheticShiftFocus : function () {
        var grid = this.grid;
        if (grid && grid.frozenFields != null) {
            var focusCol = grid._getKeyboardClickNum(),
                fcBody = focusCol == -1 ? grid.body : grid.getFieldBody(focusCol);
            if (fcBody != this) return false;
        }
        return this.Super("syntheticShiftFocus", arguments);
    },

    // ------------------------------------------------------
    //
    // PrintHTML
    // This needs some tweaking to handle the following:
    // - printHTML can be generated asynchronously in 2 ways:
    //  - if number of rows exceeds printMaxRows we use timers to break up the HTML generation
    //  - if we have embeddedComponents fetching their printHTML may also be asynchronous
    //
    // In either case, 'getTableHTML()' will be fired more than once, asynchronously.
    // In the case of async embedded component printHTML generation, this is the standard
    // mechanism - see 'gotComponentPrintHTML' in GridRenderer.
    // In the case of splitting the printing into chunks, the _printingChunk
    // flag will be set and startRow/endRow will be shifted, then getTableHTML will be called
    // on a timer, repeatedly until all the rows' HTML is generated.
    //
    // We need to fire the 'prepareBodyForPrinting' and 'bodyDonePrinting' methods on the ListGrid
    // around each of these blocks - this is required as the ListGrid relies on the body to
    // handle generating header HTML and if there are frozen fields, HTML from the frozen
    // body, and does so by setting various flags on the GR body which'll be read by
    // getTableHTML()
    //
    
    
    getTablePrintHTML : function (context) {
        // context contains startRow, endRow, callback, printProperties, printWidths
        var startRow = context.startRow,
            endRow = context.endRow,
            totalRows = endRow != null ? (endRow - startRow) : this.getTotalRows(),
            maxRows = this.printMaxRows,
            printWidths = context.printWidths,
            printProps = context.printProps;

        var asyncPrintCallback = {
            target:this,
            methodName:"gotTablePrintHTML",
            printContext:context,
            printCallback:context.callback
        };

        context.callback = asyncPrintCallback;

        if (maxRows < totalRows) {
            this.logDebug("get table print html - breaking HTML into chunks", "printing");
            if (startRow == null) startRow = context.startRow = 0;
            if (endRow == null) endRow = context.endRow = this.getTotalRows();
            this.getPrintHTMLChunk(context);

            return null;
        }

        // No chunks - can only be asynchronous due to getTableHTML directly going async
        // to get embeddedComponentHTML
        var suspendPrintingContext = this.grid._prepareBodyForPrinting(printWidths, printProps);
        var printHTML = this.getTableHTML(null, startRow, endRow, null, asyncPrintCallback);

        // restore settings
        this.grid._bodyDonePrinting(suspendPrintingContext);
        return printHTML;
    },

    gotTablePrintHTML : function (HTML, asyncCallback) {
        var callback = asyncCallback.printCallback;
        if (callback) {
            this.fireCallback(callback, "HTML,callback", [HTML,callback]);
        }
    },

    // This is called repeatedly, asynchronously for each "chunk"
    // The first chunk may include fetches for component tableHTML so can also be asynchronous
    // itself.
    
    getPrintHTMLChunk : function (context, returnSynchronous) {

        var suspendPrintingContext = this.grid._prepareBodyForPrinting(context.printWidths);
        // printing chunk flag - used by the GR to avoid writing out the outer table tags for each
        // chunk.
        this._printingChunk = true;

        // Second flag to indicate we are printing chunks. This is used only by
        // gotComponentPrintHTML() to reset the _printingChunk flag before calling
        // getTableHTML
        this._gettingPrintChunkHTML = true;

        var startRow = context.startRow,
            endRow = context.endRow,
            maxRows = this.printMaxRows,
            callback = context.callback;

        this.currentPrintProperties = context.printProps;

        if (!context.html) context.html = [];

        var chunkEndRow = context.chunkEndRow = Math.min(endRow, (startRow + maxRows)),
            chunkHTML = this.getTableHTML(null, startRow, chunkEndRow, null,
                {target:this, methodName:"gotPrintChunkHTML",
                    printContext:context, printCallback:context.callback
                });

        // restore settings
        this.grid._bodyDonePrinting(suspendPrintingContext);
        this._printingChunk = false;

        // chunkHTML will only be null if getTableHTML went asynchronous - can happen on the
        // first chunk while retrieving embedded componentHTML
        if (chunkHTML != null) {
            delete this._gettingPrintChunkHTML;
            this.gotPrintChunkHTML(chunkHTML, {printContext:context});
            if (returnSynchronous) {
                return chunkHTML;
            }
        }
    },
    gotPrintChunkHTML : function (HTML, callback) {
        var context = callback.printContext,
            startRow = context.startRow,
            endRow = context.endRow,
            chunkEndRow = context.chunkEndRow,
            maxRows = this.printMaxRows,
            gotHTMLCallback = context.callback;

        context.html.add(HTML);

        if (chunkEndRow < endRow) {
            context.startRow = chunkEndRow;
            return this.delayCall("getPrintHTMLChunk", [context], 0);
        }

        if (gotHTMLCallback != null) {
            var html = context.html.join(isc.emptyString);
            this.fireCallback(gotHTMLCallback, "HTML,callback", [html,gotHTMLCallback]);
        }
    },

    // In GridRenderer.getTableHTML(), when printing, we generate all embedded components'
    // print HTML up front, then slot it into the actual HTML for the table.
    // component printHTML may be asynchronously generated in which case this callback is
    // fired when we have the component HTML - default implementation re-runs getTableHTML
    // which now recognizes it's got component HTML and continues to get the actual table
    // HTML then fire the async callback.
    // Overridden to call 'prepareBodyForPrinting()' on the grid and reset the '_printingChunk'
    // flag if necessary
    gotComponentPrintHTML : function (HTML, callback) {

        var asyncCallback = callback.context.asyncCallback,
            context = asyncCallback.printContext;

        var printWidths = context.printWidths;

        var suspendPrintingContext = this.grid._prepareBodyForPrinting(printWidths);
        if (this._gettingPrintChunkHTML) {
            this._printingChunk = true;
        }

        var HTML = this.Super("gotComponentPrintHTML", arguments);
        if (this._printingChunk) delete this._printingChunk;

        if (HTML != null) {
            delete this._gettingPrintChunkHTML;
        } else {
            this.grid._bodyDonePrinting(suspendPrintingContext);
        }

    },

    // override getPrintHeaders / getPrintFooters to return the
    // already calculated HTML set up by the calling grid.
    
    getPrintHeaders : function (startCol, endCol) {
        var HTML = this._printHeadersHTML;
        // Lazily clean up this attribute.
        
        delete this._printHeadersHTML;
        return HTML == null ? "" : HTML;
    },

    getPrintFooters : function (startCol, endCol) {
        var HTML = this._printFootersHTML;
        delete this._printFootersHTML;
        return HTML == null ? "" : HTML;
    },

    // Row Spanning Cells
    // ----------------------------

    


    
    refreshCellValue : function (rowNum, colNum, refreshingRow, allowEditCellRefresh) {
        var lg = this.grid;
        // Sanity check only - we shouldn't see a drawn, orphaned body
        if (lg == null) {
            return this.Super("refreshCellValue", arguments);
        }
 
        // If we need to delay the refresh, fire again after a delay
        if (!this._readyToRefreshCell(rowNum, colNum)) {
            this.delayCall("refreshCellValue", [rowNum, colNum, refreshingRow, allowEditCellRefresh]);
            return;
        }

        var lgColNum = lg.getFieldNumFromLocal(colNum, this);

        // Handle the case of showing an edit form field for this cell.
        
        var editFieldName = lg.getEditorName(rowNum, lgColNum),
            fieldName = lg.getFieldName(lgColNum),
            form = lg._editRowForm,
            editItem, cellHasFocus = false,
            cellShowingEditor, cellWillShowEditor;
        
        if (form) {
                var editItem = form.getItem(editFieldName),
                    rowHasEditor = (lg._editorShowing && rowNum == lg.getEditRow());
                // sanity check if the colNum on the edit item doesn't match the colNum of the
                // cell we're refreshing, it doesn't relate to this cell.
                // This occurs in CubeGrids where we have one record per cell
                if (editItem && editItem.colNum != lgColNum) editItem = null;

            if (rowHasEditor) {
                // whether there is currently an editor in the cell
                cellShowingEditor = (editItem && editItem.isDrawn());
                // whether there will be an editor in the cell after refresh
                cellWillShowEditor = lg._shouldShowEditCell(rowNum,lgColNum);

                if (editItem != null && form.hasFocus) {
                    var formFocusItem = form.getFocusSubItem();
                    cellHasFocus = (formFocusItem == editItem ||
                                (editItem.items && editItem.items.contains(formFocusItem)));
                }
            // catch the case where we're clearing out a drawn item
            
            } else if (editItem && editItem.rowNum == rowNum) {
                cellWillShowEditor = false;
                cellShowingEditor = editItem.isDrawn();
            }
        }

        
        if (!allowEditCellRefresh && (cellHasFocus && cellShowingEditor && cellWillShowEditor))
        {
            return false;
        }

        // In some cases redraw can write out innerHTML, and then refresh a row
        // immediately from within that same redraw flow [from modifyContent], before
        // the editItemsDrawingNotification has fired.
        // In this case, rather than firing the drawing notification here, simply 
        // remove the item from the _drawnEditItems array. getEditCellValue() will re-add it 
        // if appropriate (called when we get the cell content), and we can wait for upstream 
        // code in redraw to complete and actually fire the drawn() notification
        
        var suppressItemNotifications = this._innerHTMLUpdatedForRedraw;
        if (suppressItemNotifications && this._drawnEditItems != null && 
            editItem != null && editItem.rowNum == rowNum) 
        {
            this._drawnEditItems.remove(editItem);
        }

        // If there is a visible editor in this cell, update it's value and blur before redrawing
        if (cellShowingEditor) {
            
            lg.getUpdatedEditorValue();

            if (editItem != null) {
                if (cellHasFocus) {
                    // Note - if the item will be visible after this method, silently blur and
                    // refocus. Otherwise allow the blur handler to fire, since we won't be
                    // restoring focus.
                    if (cellWillShowEditor) {
                        // Explicitly store focus for redraw, so we can refocus after
                        // redraw using the standard DF redraw mechanism
                        
                        editItem._storeFocusForRedraw();
                        form._blurFocusItemWithoutHandler();
                        
                        editItem._skipStoreFocusForRedraw = true;
                    }
                    else editItem.blurItem();
                }
                // If this method will clear a form item, notify it now
                // (drawing() / redrawing() notifications are handled separately when we
                // generate the item HTML)
                if (!cellWillShowEditor) editItem.clearing(true);
            }
        }
        
        if (this._drawnEditItems && this._drawnEditItems.length == 0) {
            delete this._drawnEditItems;
        }
    
        // Remember the native text selection for resetting if appropriate
        if (!cellShowingEditor && !cellWillShowEditor && lg.selectCellTextOnClick) {
            lg._selectedCellTextConfig = lg._getSelectedCellTextConfig(rowNum, lgColNum);
        }

        var correctedRowNum = rowNum
        if (rowNum >= 0 && colNum >= 0 && lg && lg.allowRowSpanning && lg.useRowSpanStyling)
        {
            // If we're asked to refresh a logical cell that's not rendered
            // (actually spanned by another cell) we could either refuse or refresh the
            // spanning cell. Refresh the spanning cell in case its value is calculated
            // from the cell in question.
            var startRow = this.getCellStartRow(rowNum, colNum);
            if (startRow != rowNum) {
                correctedRowNum = startRow;
            }
        }

        // Refresh the actual cell HTML
        isc.GridRenderer._instancePrototype.refreshCellValue.call(this, correctedRowNum, colNum);

        if (editItem && editItem._skipStoreFocusForRedraw) delete editItem._skipStoreFocusForRedraw;
        if (editItem && (cellShowingEditor || cellWillShowEditor)) {
            // Call our method to fire the appropriate 'drawn()' / 'redrawn()' / 'cleared()'
            // notification on the edit item.

            
            if (cellWillShowEditor) lg._drawingItem = editItem;

            if (!suppressItemNotifications) lg._editItemsDrawingNotification(editItem, null, this);
            if (cellWillShowEditor) {
                delete lg._drawingItem;
                // restore focus if it had focus
                
                if (cellHasFocus) {
                    editItem._suppressGridTextSelection = true;
                    editItem._refocusAfterRedraw();
                    editItem._suppressGridTextSelection = false;
                }
            }
        } else {
            // If we had native text selection of cellContent and selectCellTextOnClick is
            // true, reset selection.
            if (lg.selectCellTextOnClick && lg._selectedCellTextConfig) {
        
                var config = lg._selectedCellTextConfig;
                delete lg._selectedCellTextConfig;
                
                var cell = this.getTableElement(config.rowNum, colNum);
                
                if (cell != null && window.getSelection != null) {
                    var range = window.document.createRange();
                    range.selectNodeContents(cell);
                
                    if (range.toString() == config.text) {
                        var sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);    
                    }
                }
            }
            
            // If we have variable row heights and frozen fields, also refresh the
            // special "rowHeightSpacer" cells
            if (!refreshingRow && lg.frozenFields &&
                !lg.fixedRecordHeights &&
                lg.matchFrozenRowHeightsApproach == "rowHeightSpacerHTML" &&
                (lg.variableRecordHeightFields == null || lg.variableRecordHeightFields.contains(fieldName))) 
            {
                var frozenRow = lg.frozenBody.getTableElement(rowNum),
                    frozenSpacerCell = frozenRow 
                        ? frozenRow.cells[lg.frozenFields.length] : null,
                    unfrozenRow = lg.body.getTableElement(rowNum),
                    unfrozenSpacerCell = unfrozenRow 
                        ? unfrozenRow.cells[lg.fields.length - lg.frozenFields.length]
                        : null,
                    record = this.getCellRecord(rowNum, lgColNum);
                
                if (frozenSpacerCell) frozenSpacerCell.innerHTML = 
                    lg.frozenBody._getRowHeightSpacerCellValue(record, rowNum);
                if (unfrozenSpacerCell) unfrozenSpacerCell.innerHTML = 
                    lg.body._getRowHeightSpacerCellValue(record, rowNum);
            }
        }

    },


    // Cell Alignment
    // ---------------------------------------------------------------------------------------

    // cellAlignment - override to account for the fact that with frozen fields, body
    // colNum may be offset from ListGrid colNum
    getCellVAlign : function (record, field, rowNum, colNum) {
        if (this.grid && this.grid.getCellVAlign) {
            var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
            return this.grid.getCellVAlign(record, rowNum, gridColNum);
        }
    },
    getCellAlign : function (record, field, rowNum, colNum) {

        if (this.grid && this.grid.getCellAlign != null) {
            var gridColNum = this.grid.getFieldNumFromLocal(colNum, this);
            return this.grid.getCellAlign(record, rowNum, gridColNum);

        } else return field.cellAlign || field.align;
    },

    // Single Cell rows
    // ---------------------------------------------------------------------------------------

    // if this is removed, DONTCOMBINE directive no longer needed in GridRenderer.js
    _drawRecordAsSingleCell : function (rowNum, record,c) {
        var lg = this.grid;
        if (lg._isNewRecordRow(rowNum)) return true;
        
        return isc.GridRenderer._instancePrototype.
            _drawRecordAsSingleCell.call(this, rowNum,record,c);
        //return this.Super("_drawRecordAsSingleCell", arguments);
    },

    // showSingleCellCheckboxField()
    // If this record is showing a single cell value, should a checkbox field also show up next
    // to the record?
    showSingleCellCheckboxField : function (record) {
        var lg = this.grid;
        return lg && lg.showSingleCellCheckboxField(record);
    },

    // This method is called on records where _drawRecordAsSingleCell is true
    // returns the start/end col the single cell value should span.
    // Typically just spans all the cells we render out but if we're showing the
    // checkbox field we may want to NOT span over that field
    _getSingleCellSpan : function (record, rowNum, startCol, endCol) {
        // Span all columns if we're not showing a checkbox field
        
        if (rowNum == this._animatedShowStartRow ||
            !this.showSingleCellCheckboxField(record) ||
            (this.grid && this.grid.frozenBody != null && this.grid.frozenBody != this))
        {
            return [startCol,endCol];
        }

        
        var checkboxFieldPos = this.grid.getCheckboxFieldPosition()+1;
        return [Math.max(startCol, checkboxFieldPos), endCol];
    },

    // Cell ClipDiv overflow
    // ----------------------
    // Should we write "text-overflow:ellipsis" into our clip-div? Return false
    // for boolean fields / fields which show valueIconOnly
    _clipDiv_writeTextOverflowEllipsis:function (field) {
        if (this.grid.showEllipsisWhenClipped == false) return false;
        if (field != null && field.showEllipsisWhenClipped != null) return field.showEllipsisWhenClipped;
        if (field != null && this.grid.showValueIconOnly(field)) return false;
        return true;
    },    
    
    // If we have frozen fields and variable row heights, we can use the row-height-spacer
    // feature to synchronize row-heights across frozen and unfrozen bodies
    _writeRowHeightSpacerHTML : function (drawRect) {
        var grid = this.grid;
        
        if (!grid || grid.matchFrozenRowHeightsApproach != "rowHeightSpacerHTML") {
            return false;
        }
        
        // If we have variable row heights we may need to force a min-height for rows
        // (in either frozen or unfrozen body)
        if (!this.fixedRowHeights && grid) {
            // If we're incremental rendering overflowing columns, we do
            // need the row-height spacer unless we're rendering the specific col
            if (this._variableRecordHeightFieldNums) {
                var startCol = drawRect[2], endCol = drawRect[3];
                for (var i = 0; i < this._variableRecordHeightFieldNums; i++) {
                    var varHeightFieldNum = this._variableRecordHeightFieldNums[i]
                    if (varHeightFieldNum < startCol || varHeightFieldNum > endCol) {
                        return true;
                    }
                }
            }
            // If we have frozen fields which can overflow, we also need the row-height spacer
            if (grid.frozenFields && grid.frozenFields.length > 0) {
        
                var otherBody = this.frozen ? grid.body : grid.frozenBody;
                if (otherBody != null && 
                    // No explicit variable fields - any field can overflow so we need
                    // the spacer
                    (!grid.variableRecordHeightFields  ||
                    // Explicit variable fields are in the other body - again we need
                    // the spacer
                     otherBody._variableRecordHeightFieldNums) )
                {
                    return true;
                }
            }
        }
        // By default we don't want to write out the spacer!
        return false;
    },

    
    _getRowHeightSpacerCellValue : function (record, rowNum, drawRect) {
        var grid = this.grid;
        if (grid) {
            var rowHTML;
            var otherBody = this.frozen ? grid.body : grid.frozenBody;
            if (otherBody != null) {
                otherBody._suppressRowVPaddingBorder = true;
                otherBody._suppressMinHeightCSSText = true;
                
                // We want to pick up inactive cell values
                // for edit fields or any field with custom 'inactive' formatters
                otherBody._gettingRowHeightSpacerHTML = true;
                rowHTML = otherBody.getTableHTML(otherBody._variableRecordHeightFieldNums, 
                                                rowNum, rowNum+1, true);

                otherBody._gettingRowHeightSpacerHTML = false;
                otherBody._suppressRowVPaddingBorder = false;
                otherBody._suppressMinHeightCSSText = false;
                
            }
            if (this._variableRecordHeightFieldNums) {
                var drawnStartCol = drawRect[2],
                    drawnEndCol = drawRect[3],
                    cols = [];
                for (var i = 0; i < this._variableRecordHeightFieldNums.length; i++) {
                    var colNum = this._variableRecordHeightFieldNums[i];
                    if (colNum < drawnStartCol || colNum > drawnEndCol) {
                        cols.add(colNum);
                    }
                }
                
                if (cols.length > 0) {
                   
                    this._suppressRowVPaddingBorder = true;
                    this._suppressMinHeightCSSText = true;
                
                    // We want to pick up inactive cell values
                    // for edit fields or any field with custom 'inactive' formatters
                    this._gettingRowHeightSpacerHTML = true;
                    if (rowHTML == null) {
                        rowHTML = this.getTableHTML(cols, 
                                                rowNum, rowNum+1, true);
                    } else {
                        rowHTML = "<table cellspacing=0 cellpadding=0><tr><td>" +
                                    rowHTML + "</td><td>" + 
                                    this.getTableHTML(cols, rowNum, rowNum+1, true) + 
                                    "</td></tr></table>";
                    }

                    this._gettingRowHeightSpacerHTML = false;
                    this._suppressRowVPaddingBorder = false;
                    this._suppressMinHeightCSSText = false;
                }
            }
            if (rowHTML != null) return rowHTML;
        }
        return "&nbsp;";
    },

    // Scrolling / Scroll Sync
    // ---------------------------------------------------------------------------------------

    // Have v-scrolling occur on the frozen body on mouseWheel
    // This essentially duplicates the mouseWheel handler at the Canvas level for
    // widgets with visible scrollbars.
    mouseWheel : function () {
        if (this.frozen && this.grid != null) {
            
            
            var wheelTarget = this.ns.EH.lastEvent.wheelTarget;
            var wheelDeltaY = this.ns.EH.lastEvent.wheelDeltaY,
                wheelDeltaX = this.ns.EH.lastEvent.wheelDeltaX;
            // Can we scroll in the direction the user requested?
            var noScrollV = (wheelTarget != null && wheelTarget != this) || 
                            (wheelDeltaY == 0) ||
                             (wheelDeltaY < 0 && this.scrollTop == 0) ||
                             (wheelDeltaY > 0 && this.scrollTop == this.getScrollBottom()),

                noScrollH =  (this.customHscrollbar == null ||
                                !this.customHscrollbar.isVisible()) ||
                            (wheelTarget != null && wheelTarget != this) || 
                            (wheelDeltaX == 0) ||
                             (wheelDeltaX < 0 && this.scrollLeft == 0) ||
                             (wheelDeltaX > 0 && this.scrollLeft == this.getScrollRight());
            if (!noScrollH) {
                wheelTarget = this;
                var scrollLeft;
        
                // For each increment the user scrolled the mouse wheel, we want to move about 50px
                // This seems to approximately match native scrolling speed.
                scrollLeft = 
                    this.scrollLeft + Math.round(wheelDeltaX * isc.Canvas.scrollWheelDelta);
                // Note that scrollTo already catches scrolling past beginning or end
                this.scrollTo(scrollLeft, null, "mouseWheel");
            }
            
            if (!noScrollV) {
                var scrollTop = this.scrollTop + Math.round(wheelDeltaY * isc.Canvas.scrollWheelDelta);
                // Scroll the main body (we'll scroll in response to that) rather than
                // scrolling the frozen body directly.
                this.grid.body.scrollTo(null, scrollTop, "frozenMouseWheel");
            }
            
            if (!noScrollH || !noScrollV) return false;
        }
        return this.Super("mouseWheel", arguments);
    },

    // Override _getDrawRows()
    // Have the frozen body rely on the unfrozen body to handle drawAhead / quickDrawAhead
    // etc and keep set of drawn rows in sync
    
    _getDrawRows : function (a, b, c) {
        if (this.frozen && this.grid) {
            var grid = this.grid,
                body = grid.body;
            
            if (body._initialDrawRows != null) {
                return body._initialDrawRows;
            }
            return grid.body._getDrawRows(a, b, c);
        }
        return this.Super("_getDrawRows", arguments);
    },
    
    // Override getDrawAllMaxCells()
    // We need to keep frozen and unfrozen body draw rows in synch (absolutely required
    // for virtual scrolling to work).
    // This is handled by _getDrawRows() but that method isn't consulted if the
    // drawAllMaxCells threshold isn't hit.
    getDrawAllMaxCells : function () {
        var grid = this.grid;
        if (grid && grid.frozenFields != null && grid.virtualScrolling) {
            return 0
        }
        return this.drawAllMaxCells;
    },

    // Helper to determine whether the data currently has a known length
    // used by GR.getVisibleRows() / getDrawArea().
    lengthIsKnown : function () {
        var grid = this.grid,
            data = grid && grid.data;
        return ((data && data.lengthIsKnown) ? data.lengthIsKnown() : true);
    },

    // helper to check whether event is in a drag handle field
    _shouldAllowRecordDrag : function () {
        if (!isc.Browser.isTouch) return true;

        var grid = this.grid;
        if (!grid || !grid._shouldUseDragHandles()) return true;

        var fieldNum = this.getEventColumn(),
            field = this.getField(fieldNum)
        ;
        return field && field.isDragHandle;
    },

    // override to select on mouseDown (rather than mouseUp) for clicks in the drag handle field
    _shouldSelectOnMouseUp : function (colNum) {
        var field;
        if (isc.Browser.isTouch) { // drag handle check will only impact touch targets
            field = this.grid.getField(this.grid.getFieldNumFromLocal(colNum, this));
        }
        return this.invokeSuper(isc.GridBody, "_shouldSelectOnMouseUp", colNum,
                                field && field.isDragHandle);
    },

    // doneFastScrolling: ensure *both* bodies redraw without draw-ahead direction
    doneFastScrolling : function () {
        // we only expect to see this fire on the unfrozen body - the frozen body doesn't
        // show a scrollbar so won't get the thumb drag which initializes this method
        if (!this.frozen && this.grid != null && this.grid.frozenBody != null) {

            var redrawFrozenBody = this._appliedQuickDrawAhead;
            this.Super("doneFastScrolling", arguments);
            if (redrawFrozenBody) {
                this.grid.frozenBody._suppressDrawAheadDirection = true;
                this.grid.frozenBody.markForRedraw("Done fast scrolling on unfrozen body");
            }
        }
    },

    // observe the scroll routine of the body so we can sync up
    scrollTo : function (left, top, reason, animating) {
        if (isc._traceMarkers) arguments.__this = this;
        
        // Clamp the positions passed in to the edges of the viewport
        // (avoids the header from getting out of sync with the body.)
        
        if (left != null) {
            
            var maxScrollLeft = this.getScrollWidth() - this.getViewportWidth();
            left = Math.max(0, Math.min(maxScrollLeft, left));
        }
        if (top != null) {
            
            var maxScrollTop = this.getScrollHeight() - this.getViewportHeight();
            top = Math.max(0, Math.min(maxScrollTop, top));
        }
        var lg = this.grid;

        
        this.invokeSuper(isc.GridBody, "scrollTo", left,top,reason,animating);
        
        //this.logWarn("body.scrollTo: " + this.getStackTrace());
        // dontReport when we're being called in response to bodyScrolled
        // observation!
        var dontReport = this._noScrollObservation;

        
        if (!dontReport) lg.bodyScrolled(this.getScrollLeft(), this.getScrollTop(), this.frozen);

        // If the body scrolled without forcing a redraw, ensure any visible edit form
        // items are notified that they have moved.
        
        if (!this.isDirty() && lg._editorShowing) {
            var form = lg._editRowForm,
                allItems = form.getItems(),
                items = [];
            for (var i = 0; i < allItems.length; i++) {
                if (allItems[i].isDrawn()) items.add(allItems[i]);
            }
            form.itemsMoved(items);
        }

    },

    // helper to scroll to top without redrawing
    _resetScrollTopBeforeFetch : function () {
        var delayedRedraw = this._delayedRedraw;
        this._delayedRedraw = true;
        this.scrollTo(null, 0);
        this._delayedRedraw = delayedRedraw;
    },

    
    _fixIEFocusScrollArtifacts : function () {
        var mustRedraw = this._redrawToFixIEFocusScrollArtifacts;
        if (mustRedraw && this.grid && this.grid.frozenBody != null 
            && this.virtualScrolling) 
        {
            this.logWarn("Disabling redraw");
            mustRedraw = false;
        }
        
        if (mustRedraw) {
            // use fireOnPause to minimize redraws (Even though this means the lines sit there for
            // a few ms)
            this.fireOnPause("redrawToFixIEFocusScrollArtifacts", 
                {target:this, methodName:"markForRedraw", args:["fixIEScrollArtifacts"]}, 
                100);
        } else {
            var style = this.getStyleHandle();
            // trivial touch is sufficient to clear the odd focus-outline scroll artifacts
            if (style) style.backgroundColor = style.backgroundColor;
        }
    },

    // Embedded Components
    // ---------------------------------------------------------------------------------------

    // embedded components can be per row or per cell.
    // When per-cell the GR APIs act by colNum only, not by field name.
    // However for us to handle field reorder, show/hide, etc it's useful to hang fieldName
    // onto the embeddedComponents as well
    addEmbeddedComponent : function (component, record, rowNum, colNum, position, suppressRedraw) {
        var comp = this.invokeSuper(isc.GridBody, "addEmbeddedComponent", component, record,
                                    rowNum, colNum, position, suppressRedraw);
        if (component._currentColNum != null && component._currentColNum != -1 && this.grid) {
            var grid = this.grid,
                colNum = component._currentColNum,
                gridColNum = grid.getFieldNumFromLocal(colNum, this),
                fieldName = grid.getFieldName(gridColNum);

            component._currentFieldName = fieldName;

            // set up a map of embedded components per column (fieldName)
            // This will make lookup quicker.
            if (grid._columnComponentsMap == null) {
                grid._columnComponentsMap = {};
            }
            if (grid._columnComponentsMap[fieldName] == null) {
                grid._columnComponentsMap[fieldName] = {};
            }
            grid._columnComponentsMap[fieldName][component.getID()] = true;
            // skip "%" sized components since they should never expand a field.
            if (component._percent_width == null) {
                grid._fieldComponentWidthsChanged(fieldName);
            }
        }

        return component;
    },
    removeEmbeddedComponent : function (record, component, suppressRedraw) {
        var grid = this.grid;
        if (grid) {
            var fieldName = component._currentFieldName;
            if (fieldName != null) {
                if (grid._columnComponentsMap && grid._columnComponentsMap[fieldName]) {
                    delete grid._columnComponentsMap[fieldName][component.getID()];
                }
                if (component._percent_width == null) {
                    grid._fieldComponentWidthsChanged(fieldName);
                }
            }
            // Clear out the stored field name which is basically stale at this point.
            component._currentFieldName = null;
        }
        this.invokeSuper(isc.GridBody, "removeEmbeddedComponent", record, component, suppressRedraw);
    },


    // Override getMaxEmbeddedComponentHeight() / upateHeightForEmbeddedComponents to
    // respect listGrid.recordComponentHeight if specified, even if there are no
    // embedded components for this record.
    
    updateHeightForEmbeddedComponents : function (record, rowNum, height) {

        if (record && !this.grid._hasEmbeddedComponents(record) && this.grid.showRecordComponents
            && this.grid.recordComponentHeight != null)
        {
            // Reimplementing the superClass version, except that this logic is running even
            // when there are no embeddedComponents on the row.
            var details = this.getMaxEmbeddedComponentHeight(record, rowNum);
            if (details.allWithin) {
                height = Math.max(height,details.requiredHeight);
                //this.logWarn("in updateHeightForEmbeddedComponents ("+this.grid+"): details are "+isc.echoAll(details)+"\nheight is "+height);
            } else {
                height += details.requiredHeight;
                //this.logWarn("in updateHeightForEmbeddedComponents ("+this.grid+"): details are "+isc.echoAll(details)+"\nheight is "+height);
            }

            return height;
        }

        return this.invokeSuper(isc.GridBody, "updateHeightForEmbeddedComponents", record, rowNum, height);
    },

    getMaxEmbeddedComponentHeight : function (record, rowNum) {
        var heightConfig = this.invokeSuper(isc.GridBody, "getMaxEmbeddedComponentHeight",
                                        record, rowNum);
        if (this.grid.showRecordComponents && this.grid.recordComponentHeight != null) {
            heightConfig.requiredHeight = Math.max(heightConfig.requiredHeight,
                                            this.grid.recordComponentHeight);
        }
        return heightConfig;
    },
    _writeEmbeddedComponentSpacer : function (record) {
        if (record && this.grid && this.grid.showRecordComponents
            && this.grid.recordComponentHeight != null)
        {
            return true;
        }
        return this.invokeSuper(isc.GridBody, "_writeEmbeddedComponentSpacer", record);
    },

    _placeEmbeddedComponents : function () {
        
        if (this.grid && this.grid._autoFittingFields) {
            return;
        }
        return this.Super("_placeEmbeddedComponents", arguments);
    },

    getAvgRowHeight : function () {
        if (this.grid) return this.grid.getAvgRowHeight(this);
        return this.Super("getAvgRowHeight", arguments);
    },

    // override shouldShowAllColumns() - we can avoid showing all columns if row height
    // is variable *only* because of an expansion component expanding the entire row since
    // the heights won't vary per-cell.
    shouldShowAllColumns : function () {
        if (this.showAllColumns) {
            return true;
        }
        if (!this.fixedRowHeights) {
            if (this.grid.canExpandRecords && this.grid._specifiedFixedRecordHeights) {
                return false;
            }
            
            // If we have specific columns marked as overflowers we can support incremental
            // column rendering by ensuring the row height matches the rendered size for
            // those columns.
            // This will reduce the total amount of HTML we have to generate as we can
            // render only the out-of-view overflowing cells for measurement purposes 
            // rather than the whole row.
            if (this.grid.variableRecordHeightFields != null) {
                return false;
            }
            return true;
        }
        if (this.overflow == isc.Canvas.VISIBLE) {
            return true;
        }
        return false;

    },

    // Editing
    // ---------------------------------------------------------------------------------------

    //> @method listGrid.markForRedraw()
    // @include canvas.markForRedraw
    // @visibility external
    //<

    // Redraw overridden:
    // - Update the editRow form items (we don't create more items than we need when
    //   rendering incrementally)
    // - Update the values in the edit row form.
    redraw : function (reason,b,c,d) {
        // since we're doing a full redraw, cancel pending refreshCell() calls
        if (this._pendingCellRefreshTimer) this.cancelPendingCellRefresh();

        // check if a string grid.searchForm needs to be resolved
        if (this.grid) this.grid.checkForSearchForm();

        // flag to note we're redrawing - this is used by getDrawnFields()
        this._redrawing = true;
        // Ensure we pick up and size to a fresh value
        // and set the flag so clearCellValueCacheOnRedraw() doesn't 
        // clear the cache again.
        // This flag cleared below after Super() call.
        this._clearCellValueCacheForRedraw();
        this._clearedCellValueCacheInRedrawThread = true;
        
        this._cacheVariableHeightFieldNums();

        // If alwaysShowEditors is marked as true, but editorShowing is false it implies our
        // attempt to start editing on draw() failed - presumably there were no
        // editable cells in view.
        // See if we can start editing now in this case
        var lg = this.grid;

        if (lg.alwaysShowEditors && !lg._editorShowing) {
            // pull stashed value for target edit cell if provided
            // by scrollCellIntoView
            var rowNum, colNum;
            if (lg._editCellAfterRedraw) {
                rowNum = lg._editCellAfterRedraw[0];
                colNum = lg._editCellAfterRedraw[1];
                delete lg._editCellAfterRedraw;
            }
            lg.startEditing(rowNum,colNum,true,null,true);
        }
        if (lg._editorShowing && !lg._inShowEditForm) {
            lg._cacheCurrentEditCells();
        }

        
        var editForm = lg._editRowForm,
            editing = lg._editorShowing,
            editColNum, editRowNum, editRecord,
            completeWidths,
            fieldsToRemove;

        // If the grid is showing inactive Editor HTML for any cells, we'll clear it
        // (and potentially regenerate it) as part of redraw(). Notify the grid so it can clear
        // up inactive contexts stored on the edit form items
        
        lg._clearingInactiveEditorHTML();

        // if body redraw came from data change, folder opening, or resizing of content,
        // it's likely to introduce a v-scrollbar.
        // If leaveScrollbarGap is false, call '_updateFieldWidths()' before the redraw occurs so
        // we leave a gap for the v-scrollbar, rather than redrawing with both V and H scrollbar,
        // then resizing the fields and redrawing without an H-scrollbar.
        if (!lg.leaveScrollbarGap && lg.predictScrollbarGap && (this.overflow == isc.Canvas.AUTO)) {
            var vScrollOn = this.vscrollOn,
                
                vScrollWillBeOn = !lg.isEmpty() &&
                                  (lg.getTotalRows() * lg.cellHeight)  > this.getInnerHeight();

            if (vScrollOn != vScrollWillBeOn) {
                // ensure we don't try to recalculate field widths a second time by clearing
                // the _fieldWidthsDirty flag
                delete this._fieldWidthsDirty;
                lg._updateFieldWidths("body redrawing with changed vertical scroll-state");

            }
        }

        var editFieldName, suppressRowElementFocus = false;

        if (editing) {
            this.logInfo("redraw with editors showing, editForm.hasFocus: " +
                         editForm.hasFocus, "gridEdit");
            editColNum = lg.getEditCol();

            
            if (isc.Browser.isEdge) {
                editFieldName = lg.getFieldName(editColNum);
                lg._parkFocus(editForm ? editForm.getItem(editFieldName) : null, editColNum);
            }

            // See comments near _storeFocusForRedraw() for how edit form item focus is handled
            // on redraw
            this._storeFocusForRedraw();

            // This will add the new edit items corresponding to the newly displayed fields
            // and return the items that need to be removed (after the body is actually redrawn,
            // which will hide them)
            // It also fires the "clearing()" pre-clear notification if a drawn item is
            // removed. cleared() will be fired after the redraw completes.
            fieldsToRemove = this._updateEditItems();
            
        // If we're not editing, but we have an editForm with drawn items, fire the 'clearing()' notification.
        // We fire the cleared notification below (after the DOM has been updated)
        } else if (editForm != null) {
            var items = editForm.getItems();
            for (var i = 0; i < items.length; i++) {
                if (items[i].isDrawn()) items[i].clearing(true);
            }
            
        } else if (isc.screenReader) {
            var focusCanvas = this.ns.EH.getFocusCanvas();
            // Suppress focusing the row element if some other widget is focused.
            suppressRowElementFocus = focusCanvas !== this;
        } else {
            // Redraw when not editing / in screenReader mode: remember the native
            // text selection within a cell if there is one so we can reset it post draw
            
            if (lg.selectCellTextOnClick) {
                this._textSelectionConfig = lg._getSelectedCellTextConfig();
            }
        }
        // refresh field widths if necessary
        if (this._fieldWidthsDirty != null) {
            
            var fwReason = this._fieldWidthsDirty;
            delete this._fieldWidthsDirty;
            
            lg._updateFieldWidths(fwReason);
        }
        // store the new drawArea
        var newDrawArea = this.getDrawArea();
        

        var grid = this.grid,
            drawArea = this._oldDrawArea;

        if (!drawArea) drawArea = this._oldDrawArea = [0,0,0,0];

        var grid = this.grid,
            firstRecord = grid._getCachedCellRecord(newDrawArea[0]),
            lastRecord = grid._getCachedCellRecord(newDrawArea[1]),
            dataPresent = (firstRecord != null && lastRecord != null);

        if (dataPresent && !drawArea.equals(newDrawArea)) {
            // the old and new drawAreas differ and the extents of the new data are present -
            // fire the notification method and update the stored _oldDrawArea
            
            if (!this.frozen) {
                grid._drawAreaChanged(drawArea[0], drawArea[1], drawArea[2], drawArea[3], this);
                this._oldDrawArea = newDrawArea;
            }
        }

        
        delete this._drawnEditItems;

        this.invokeSuper(isc.GridBody, "redraw", reason,b,c,d);

        // clear the "redrawing" flag since the HTML is now up to date
        delete this._redrawing;
        // clear the flag indicating we already dropped our body cell-value-cache
        // so we drop cache again (as we should) on future redraws
        delete this._clearedCellValueCacheInRedrawThread;

        if (grid._clearRemoveAnimation) {
            // flag set from grid._removeDataAnimationComplete() - indicates the row-animation 
            // settings from an animated record remove need to be cleared
            delete grid._clearRemoveAnimation;
            this._clearLastRowAnimation()
        }

        // Always update all recordComponents on redraw().
        // don't rely on the draw area changing since we may be showing the same set of
        // rowNum/colNums but having underlying data or field meaning changes.
        // Note: updateRecordComponents() updates components in frozen and unfrozen bodies.
        // If this is a redraw of the frozen body, don't call updateRecordComponents() if
        // the redraw was tripped by scrolling or data change as in this case we'll also
        // get a redraw of the unfrozen body which can handle updating the RC's.
        // (DO still call the method in other cases as it may imply the fields in the frozen
        // body have changed, etc).
        // NOTE 2014: do this *after* calling Super() so that the drawn rows match the 
        // data        
        if (!(this.frozen && this._suppressRecordComponentsUpdate)) {
            grid.updateRecordComponents();
        }
        this._suppressRecordComponentsUpdate = false;

        if (editing) {
            // Remove the items that correspond to fields that are no longer rendered in the DOM
            if (fieldsToRemove != null && fieldsToRemove.length > 0) {
                editForm.removeItems(fieldsToRemove);
            }

            // Fire the method to notify form items that they have been drawn() / redrawn()
            // or cleared()
            
            lg._editItemsDrawingNotification(null, true, this);

            /*
            var itemColArray = [],
                items = lg._editRowForm.getItems();
            for (var i =0; i < items.length; i++) {
                itemColArray.add(items[i].colNum + " - " + items[i].name);
            }
            this.logWarn("After redraw - edit form covers these cols:" + itemColArray);
            */

            
            lg.updateEditRow(lg.getEditRow());

            
            var focusParkForm = isc.ListGrid._focusParkForm;
            if (isc.Browser.isEdge && editFieldName && focusParkForm &&
                (focusParkForm.hasFocus || focusParkForm.itemHasFocus()))
            {
                var focusItem = editForm.getItem(editFieldName);
                if (focusItem) this._delayedFocusEvent = focusItem.delayCall("focusAtEnd");

            } else if (editForm.hasFocus ||
                (this._editorSelection && isc.EH.getFocusCanvas() == null))
            {
                this._restoreFocusAfterRedraw(editColNum);
            } else {
                delete this._editorSelection;
            }

        } else {
            if (editForm != null) {
                // notify the form that it's items have been cleared() (will no-op if they're
                // not currently drawn)
                lg._editItemsDrawingNotification(null, null, this);
            }

            // _nativeFocusRow was remembered last time putNativeFocusInRow was called
            
            if (isc.screenReader) {
                this._putNativeFocusInRow(this.getNativeFocusRow(), this.getNativeFocusColumn(), suppressRowElementFocus);
            
            // Reset native text selection if appropriate
            } else if (lg.selectCellTextOnClick && this._textSelectionConfig != null) {
                var config = this._textSelectionConfig;
                delete this._textSelectionConfig;
            
                var colNum = lg.getLocalFieldNum(config.colNum);
                var cell = this.getTableElement(config.rowNum, colNum);
                
                if (cell != null && window.getSelection != null) {
                    var range = window.document.createRange();
                    range.selectNodeContents(cell);
                
                    if (range.toString() == config.text) {
                        var sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }

                }            
            }
        }



        
        if (lg._scrollCell != null) lg._delayedScrollToCell();


    },
    
    _clearCellValueCacheForDraw : function () {
        
        if (this._clearedCellValueCacheInDrawThread) return;
        
        return this.Super("_clearCellValueCacheForDraw", arguments);
    },
    
    
    _clearCellValueCacheForRedraw : function () {
        // If we already cleared the cellValueCache in this thread due to our override
        // return
        
        if (this._clearedCellValueCacheInRedrawThread) return;
        
        // Also bail if we're doing a redraw thanks to explicit auto-fit rather than
        // data changed
        var grid = this.grid;
        if (grid && (grid._autoFittingField || grid._autoFittingFields)) {
            return;
        }
        return this.Super("_clearCellValueCacheForRedraw", arguments);
    },
    
    // Override bypassCellValueCache - avoid caching edit item cell values
    // This is appropriate for the case where we are writing out inactive 
    // element HTML - for example to measure the width of an auto-fit column.
    // Ditto for group-nodes, where we suppress the HTML altogether when getting
    // auto-fit measurement HTML
    
    bypassCellValueCache : function (record,rowNum,colNum) {
    
        if (this.grid) {
            var grid = this.grid;
            if (this.grid.isGrouped && record && record._isGroup) {
                return true;
                
            } else if (this.grid._editorShowing) {
                        
                var editRowNum = grid._editRowNum,
                    editStartRow = editRowNum;
                if (editStartRow != null && grid.allowRowSpanning) {
                    editStartRow = grid.getCellStartRow(editStartRow, fieldNum);
                }
            
                var isEditRow = editStartRow == rowNum;
                if (isEditRow) {
                    var fieldNum = grid.getFieldNumFromLocal(colNum, this);
                    var isEditCell = (!grid.editByCell || grid._editColNum == fieldNum) &&
                                  
                                  (grid._shouldShowEditCell(editRowNum,fieldNum));

                    if (isEditCell) return true;
                }
            }
            // We almost always want inactive 'measure' HTML for cells to be cached
            // so we don't have to render out grid content twice, but if there's
            // a separate inactive HTML formatter we'll need to call it, so can't
            // use the cache in this case.
            if (grid._gettingInactiveCellHTML(rowNum, 
                    grid.getFieldNumFromLocal(colNum, this))) 
            {
                if (grid.formatInactiveCellValue != null) return true;
                var field = grid.getField(colNum);
                if (field && field.formatInactiveCellValue != null) return true;
            }
        }
        // Default from GridRenderer simply avoids caching the print version
        return this.isPrinting;
    },
    
    redrawOnScroll : function (immediate) {
        if (this.frozen) this._suppressRecordComponentsUpdate = true;
        return this.Super("redrawOnScroll", arguments);
    },

    
    _lockVirtualScrolling : function () {
        this.grid._virtualScrollingLocked = true;
    },
    _canStopVirtualScrolling : function () {
        return !this.grid._virtualScrollingLocked;
    },    

    // force redraw on setDisabled() if we're showing an edit form to ensure we
    // redraw the items in enabled/disabled state
    setHandleDisabled : function (disabled) {
        var lg = this.grid;
        // need to force redraw generally, so that cell-styles get updated
        if (this.isDrawn()) { 
            this.markForRedraw("Grid body disabled");
        }
        return this.Super("setHandleDisabled", arguments);
    },

    // Add edit items corresponding to newly displayed fields (displayed due to incremental
    // rendering)
    // If any fields are to be hidden, do not remove these here, but return them in an array so
    // they can be removed from the form after the redraw completes
    // Note that the order of items in the form will not match the order of fields necessarily -
    // acceptable since developers will be interacting with the items' colNum attribute rather than
    // index in the edit form fields array.
    
    _updateEditItems : function () {
        // We keep the set of items in the editForm in sync with the set of
        // visible columns for performance.
        // Determine which items need to be created or removed here.
        var lg = this.grid, editForm = lg.getEditForm(),
            fieldsToRemove = [],
            editItems = editForm.getItems();
        if (!lg.editByCell) {

            // set up the vars used in creating form items
            var editRowNum = lg.getEditRow(),
                editRecord = lg.getRecord(editRowNum),
                
                completeWidths = lg.getEditFormItemFieldWidths(editRecord);

            // Determine what fields are rendered into the body
            // If we have frozen columns, we will always be showing them, in addition to whatever
            // fields are visible
            var editItems = editForm.getItems(),
                itemNames = editItems.getProperty(this.fieldIdProperty),
                fields = lg.getDrawnFields(),
                fieldNames = fields.getProperty(this.fieldIdProperty);

            // minor optimization - if possible, avoid iterating through both arrays
            var lengthsMatch = editItems.length == fields.length,
                changed = false;
            
            // fields that are no longer drawn should be removed
            for (var i = 0; i < editItems.length; i++) {
                
                // don't actually remove the items until they have been removed from the DOM via
                // redraw
                var index = fieldNames.indexOf(itemNames[i]),
                    itemDrawn = editItems[i].isDrawn();

                if (index == -1) {
                    changed = true;
                    fieldsToRemove.add(editItems[i]);
                    if (itemDrawn){
                        editItems[i].clearing(true);
                    }
                } else {
                    var fieldName = itemNames[i],
                        // Check canEdit for each field - if it's canEdit:false we don't want to fire
                        // drawing notifications!
                        
                        canEdit = lg._shouldShowEditCell(editRowNum, index);
                    if (canEdit) {
                        
                        editItems[i].width = completeWidths[editItems[i].colNum];
                        editItems[i]._size = null;
                    } else {
                        // Fire the 'clearing()' pre-clear notification on items being removed
                        // from the DOM
                        if (itemDrawn) editItems[i].clearing(true);
                    }
                }
            }

            // newly rendered fields should be added
            if (!lengthsMatch || changed) {
                var editedVals = lg.getEditedRecord(editRowNum, 0);
                for (var i = 0; i < fields.length; i++) {
                    if (!itemNames.contains(fieldNames[i])) {
                        var colNum = lg.fields.indexOf(fields[i]);
                        var item = lg.getEditItem(
                                        fields[i],
                                        editRecord, editedVals, editRowNum,
                                        colNum, completeWidths[colNum]
                                   );
                        editForm.addItem(item);
                        if (editForm._fieldCriteriaCache) {
                            
                            delete editForm._fieldCriteriaCache[fieldNames[i]];
                        }
                    }
                }
                // Keep the edit form items in the same order in the items array as
                // they are in the ListGrid.
                
                editForm.items.sortByProperty("colNum", Array.ASCENDING);
            }
        }
        // if editByCell is true this is not necessary - we consistently have the editForm contain
        // only the necessary cell
        return fieldsToRemove;
    },

    // _storeFocusForRedraw()
    // called when the edit form is showing and the body is being redrawn.
    // remember the current focus state / selection of the edit form so we can reset it after
    // redrawing the item in the DOM
    // blur the item (suppressing the handler if the item will be refocused after redraw)


    

    
    _storeFocusForRedraw : function () {
        var lg = this.grid,
            editForm = lg.getEditForm(),
            editColNum = lg.getEditCol();

        if (editForm.hasFocus) {
            var focusItem = editForm.getFocusSubItem();
            if (focusItem) {
                focusItem.updateValue(true);
                var origFocusItem = focusItem;

                // We may be focused in a sub item, in which case we need to use the
                // parentItem to get the field name wrt our fields array
                while (focusItem.parentItem != null) {
                    focusItem = focusItem.parentItem;
                }

                // blur the focus item before removing it from the DOM.
                // If canEditCell for the current focus item returns false, we will
                // not redisplay it at the end of this method, so allow it to fire the
                // standard blur-handler
                
                
                if (!lg._shouldShowEditCell(focusItem.rowNum, focusItem.colNum) ||
                    editColNum != focusItem.colNum) {
                    
                    editForm.blur();
                } else {
                    
                    if (focusItem.hasFocus) {
                        // remember the current selection, so we can reset it after the redraw
                        // and refocus. [will have no effect if the item is not a text-item]
                        focusItem.rememberSelection();
                        this._editorSelection =
                            [focusItem._lastSelectionStart, focusItem._lastSelectionEnd];
                    }
                    editForm._blurFocusItemWithoutHandler();

                }
                
            }
        }
        
        editForm._setValuesPending = true;
    },

    // If the editForm is visible during a body redraw() this method ensures that after the
    // redraw completes, and the form items are present in the DOM, focus / selection is restored
    // to whatever it was before the redraw
    _restoreFocusAfterRedraw : function (editColNum) {
        var lg = this.grid,
            editForm = lg.getEditForm(),
            editItem = editForm.getItem(lg.getEditorName(lg.getEditRow(), editColNum));
        if (editItem != null && editItem.isDrawn()) {
            var scrollLeft = lg.body.getScrollLeft(),
                scrollTop = lg.body.getScrollTop(),
                viewportWidth = lg.body.getViewportWidth(),
                viewportHeight = lg.body.getViewportHeight(),
                rect = editItem.getRect(),
                // If we are partially out of the viewport, don't put focus into item -
                // forces a native scroll which can interfere with user scrolling.
                // Note: partially out of viewport actually could be ok for text items
                // where focus will only cause a scroll if the actual text is offscreen.
                
                // if the field is frozen, it won't be scrolled out of view
                frozen = this.grid.fieldIsFrozen(editColNum),
                outOfViewport = !frozen && 
                                (rect[0] < scrollLeft ||
                                rect[1] < scrollTop ||
                                rect[0] + rect[2] > (scrollLeft + viewportWidth) ||
                                rect[1] + rect[3] > (scrollTop + viewportHeight));
            if (!outOfViewport) {
                // Avoid selecting the focused value - we don't want rapid keypresses
                // to kill what was previously entered
                editForm._focusInItemWithoutHandler(editItem);
                // Reset the selection / text insertion point to whatever was
                // remembered before the redraw.
                
                if (this._editorSelection && this._editorSelection[0] != null) {
                    editItem.setSelectionRange(this._editorSelection[0], this._editorSelection[1]);
                }
                // clear up the _editorSelection flag so we don't try to restore focus again on
                // scroll
                delete this._editorSelection;
            }
        }
    },
    
    _suppressEventHandling : function (lastMouseEvent) {
        if (this.Super("_suppressEventHandling", arguments)) return true;
        // If an event occurred over an expansion component, don't react to it at the GridRenderer level
        
        if (lastMouseEvent) {
            var target = lastMouseEvent.target;
            while (target && target != this) {
                if (target.isExpansionComponent) return true;
                target = target.parentElement;
            }
        }
        return false;
    },
    
    // Override mouseOut to avoid clearing rollover styling when the user interacts with a
    // child of a CanvasItem editor
    
    mouseOut : function (a,b,c,d,e) {
        var grid = this.grid;
        if (grid.getEditRow() != null) {
            var editForm = grid.getEditForm();
            var target = isc.EH.getTarget();
            while (target && target.parentElement) {
                if (target.canvasItem != null && editForm.items.contains(target.canvasItem)) {
                    return;
                }
                if (target == this) break;
                target = target.parentElement;
            }
        }
        return this.invokeSuper(isc.GridBody, "mouseOut", a,b,c,d,e);
    },
    

    // Override cellMove: We need to be able to show validation error HTML
    cellMove : function (record,rowNum,colNum) {
        // If the event is bubbled from an embedded child widget no need to check for
        // icons
        if (isc.EH.lastEvent.target == this) {

            var nativeTarget = isc.EH.lastEvent ? isc.EH.lastEvent.nativeTarget : null;
            if (nativeTarget && nativeTarget.getAttribute != null &&
                (nativeTarget.getAttribute("isErrorIcon") == "true"))
            {
                // adjust for frozen fields
                colNum = this.grid.getFieldNumFromLocal(colNum, this);
                if (this.grid._overErrorIcon != null) {
                    var lastRow = this.grid._overErrorIcon[0],
                        lastCol = this.grid._overErrorIcon[1];
                    if (lastRow != rowNum || lastCol != colNum) {
                        this.grid._handleErrorIconOut(rowNum, colNum);
                    }
                }

                if (this.grid._overErrorIcon == null) {
                    this.grid._handleErrorIconOver(rowNum,colNum);
                }
            } else {
                if (this.grid._overErrorIcon != null) {
                    this.grid._handleErrorIconOut(rowNum, colNum);
                }
            }
        }
    },

    cellOut : function (record, rowNum, colNum) {
        if (this.grid._overErrorIcon != null) {
            this.grid._handleErrorIconOut(rowNum, colNum);
        }
    },

    // Override shouldShowRollOver to avoid styling the current edit cell with the over
    // style.
    // This avoids the issue where if you roll over the edit form items, the rollover style
    // would flash off as the body receives a mouseout (looks very weird).
    // Also - support showing the rollOver styling for the current focus row even if 
    // showRollOver is false.
    // We'll still use the rollOver style name in this case, but it improves keyboard accessibility
    // without requiring the normal rollOver effects.
    shouldShowRollOver : function (rowNum, colNum,a,b) {
    
    
        //if (!this.invokeSuper(isc.GridBody, "shouldShowRollOver", rowNum,colNum,a,b)) return false;
        
        var hiliteOnFocus = this.grid.hiliteRowOnFocus;
        if (hiliteOnFocus == null) {
            hiliteOnFocus = this.grid.showRollOver;
        }

        var lg = this.grid;
        if ((!lg.showRollOver &&
             (!hiliteOnFocus || (this._lastHiliteRow != rowNum)))
            || this._rowAnimationInfo) 
        {
            return false;
        }

        var record = lg.getRecord(rowNum);

        // Don't show roll over if the record in question doesn't want it.
        if (record && record[lg.recordShowRollOverProperty] === false) {
            return false;
        }

        // don't show rollover for the edit row
        
        if (lg._editorShowing && rowNum == lg._editRowNum) {
            return false;
        }
        return true;
    },

    updateRollOver : function (rowNum, colNum, movingToNewCell) {
        var lg = this.grid;

        if (lg.showRollOverCanvas || lg.showRollUnderCanvas || 
            lg.showSelectedRollOverCanvas || lg.showSelectedRollUnderCanvas) 
        {
            // movingToNewCell param passed when the user rolled off one cell and over another
            // and this method is being called to clear the first cell hilight.
            // we can no-op in this case since we'll update the rollOverCanvas on the subsequent
            // call to this method, and that will avoid a clear/draw cycle (and flash)
            
            if (!movingToNewCell) {
                var leaving = !(this.lastOverRow == rowNum && this.lastOverCol == colNum);
                var gridColNum = lg.getFieldNumFromLocal(colNum, this);
                lg.updateRollOverCanvas(rowNum, gridColNum, leaving);
            }
            // no support for frozen body / rollOverCanvas yet

        }

        this.setRowStyle(rowNum, null, this.canSelectCells || this.useCellRollOvers ?
                         colNum : null);

        // frozen fields: if there is another body, force its rollover row to match and
        // update it
        var otherBody = (this == lg.body ? lg.frozenBody : lg.body);
        if (otherBody && !this.useCellRollOvers) {
            otherBody.lastOverRow = this.lastOverRow;
            otherBody.lastOverCol = this.lastOverCol;
            otherBody.setRowStyle(rowNum, null, (this.useCellRollOvers ? colNum : null));
        }
    },

    _selectCellOnMouseDown : function (record, rowNum, colNum) {
        
        this.grid.clearLastHilite();

        // remember the last cell clicked (used for keyboard navigation)
        // (Note: we use the same cell used for selection rather than the actual position
        // of the event as that's where the user will see the visual indication)
        this._lastSelectedRow = rowNum;
        this._lastSelectedCol = colNum;

        this.grid._lastSelectedBody = this;

        //this.logWarn("mouseDown at: " + [rowNum, colNum]);

        if (this.useRowSpanStyling) {
            // rowSpan-sensitive selection
            var gridSelection = this.grid.selectionManager;

            // selected cells are designed by the coordinates where spanning starts.
            // NOTE: this means that calling isSelected() with return false for any cell
            // coordinates where no cell exists in the DOM (because it was spanned over by a
            // rowSpanning cell in a previous row).  This is true even when the spanning cell
            // that eliminated that DOM cell is in facet selected.
            var startRow = this.getCellStartRow(rowNum, colNum);

            // for ctrl-click just select/deselect the clicked cell
            if (isc.EH.modifierKeyDown()) {
                var gridColumn = this.grid.getFieldNumFromLocal(colNum, this);
                gridSelection.selectOnMouseDown(this, startRow, gridColumn);
                return;
            }

            // deselect everything - shift modifiers, dragging or other cases not supported in
            // this mode
            gridSelection.deselectAll();

            // select all cells to the right that are partially or wholly spanned by the
            // clicked cell

            var gridBody, startCol, span,
                mode = this.rowSpanSelectionMode;

            if (mode == "forward" || mode == null) {
                // field num where the click landed, in terms of listGrid.fields
                startCol = this.grid.getFieldNumFromLocal(colNum, this);
                // cells spanned by the clicked cell
                span = this.getCellRowSpan(startRow, colNum);
            } else if (mode == "outerSpan") {
                // optionally, start the selection from the span of the first column, which
                // creates a selection behavior similar to the default row-level selection
                // behavior, based on the concept of the span in the first column defining the
                // "row"
                startCol = 0;
                gridBody = this.grid.getFieldBody(0);
                startRow = gridBody.getCellStartRow(rowNum, 0);
                span = gridBody.getCellRowSpan(startRow, 0);
            } else if (mode == "both") {
                // use the span of the clicked cell
                span = this.getCellRowSpan(startRow, colNum);
                // but go through all columns
                startCol = 0;
            } else {
                this.logWarn("unrecognized rowSpanSelectionMode: '" + mode + "'");
                return;
            }

            //this.logWarn("start cell: " + [startRow, startCol] +
            //             " spans: " + span);
            // for each column to the right of the starting column
            for (var column = startCol; column < this.grid.fields.length; column++) {
                // get the body that contains the field and the field's index within that body
                var bodyToSelect = this.grid.getFieldBody(column),
                    localFieldNum = this.grid.getLocalFieldNum(column);

                // for each row spanned by the starting cell
                for (var i = startRow; i < startRow+span; i++) {
                    // when selecting, select the coordinates of the beginning of the span
                    var cellStartRow = bodyToSelect.getCellStartRow(i, localFieldNum);
                    gridSelection.selectCell(cellStartRow, column);
                    // and skip past cells that were spanned over
                    i += (bodyToSelect.getCellRowSpan(cellStartRow, localFieldNum) - 1);
                }
            }
            return;
        }

        // if we're in the body, select rows or cells
        this.selectionManager.selectOnMouseDown(this, rowNum, colNum);
    },
    
    // override selectOnMouseDown/Up to disable selection when a row is clicked anywhere
    // besides the checkbox when selectionAppearance is checkbox.
    selectOnMouseDown : function (record, rowNum, colNum, d,e,f) {
        var shouldSelect = true,
            selApp = this.grid.selectionAppearance,
            cbSel = (selApp == "checkbox");
        if (cbSel) {
            // if frozen fields are showing, the cb field will show up in the frozen body!
            if ((this.grid.frozenFields != null && this.grid.frozenBody != this) || (
                // it's not the checkbox field and canSelectCells is false
                (this.grid.getCheckboxFieldPosition() != colNum && !this.canSelectCells) &&
                // it's not the expansion field, or it is but selectOnExpandRecord is false
                (this.grid.getExpansionFieldPosition() != colNum || !this.grid.selectOnExpandRecord)))
            {
                shouldSelect = false;
            }
        }
        
        if (shouldSelect) {
            if (this.canSelectCells) this._selectCellOnMouseDown(record, rowNum, colNum);
            else this.invokeSuper(isc.GridBody, "selectOnMouseDown", record, rowNum, colNum, d,e,f);
        }

        if (isc.screenReader) {
            // In screen reader mode, if canSelectCells is enabled, we want to hilite the cell;
            // otherwise, we will want to hilite the entire row.
            // _putNativeFocusInRow() calls _hiliteRecord(), so we will need to clear this hilite.
            this._putNativeFocusInRow(rowNum, colNum);
            if (this.canSelectCells) {
                var lastRow = this.lastOverRow,
                    lastCol = this.lastOverCol;
                this.lastOverRow = null;
                this.lastOverCol = null;
                this.updateRollOver(lastRow, lastCol);
                this.grid._lastKeyboardHiliteBody = this;
                this.grid._hiliteCell(rowNum, colNum);
            }
        } else {
            // If showRollOver is false and hiliteRowOnFocus is true we may be
            // showing a rollOver from keyboard navigation on another cell
            // Clear this now to avoid confusing styling.
            if (this._lastHiliteRow != null && this._lastHiliteRow != rowNum) {
                if (this.lastOverRow  == this._lastHiliteRow) {
                    var lastRow = this.lastOverRow,
                        lastCol = this.lastOverCol;
                    this.lastOverRow = null;
                    this.lastOverCol = null;
                    this.updateRollOver(lastRow, lastCol);
                }
            }
        }
        this._lastHiliteRow = rowNum;
        this._lastHiliteCol = colNum;
    },

    // If a user keyboard-navigated-to or clicked an unselectable row, should we deselect other rows?
    // Overridden to deselect others during keyboard navigation over group-nodes
    
    _deselectAllOnDisallowedSelectionEvent : function (record, rowNum, colNum, keyboardGenerated) {
        if (keyboardGenerated && this.grid.selectionType != "simple" && 
            !isc.EH.shiftKeyDown() && this.grid.isGroupNode(record)) 
        {
            return true;
        }
        return false;
    },

    
    // When showing the edit clickMask, a mouseDown will clear the mask and end editing
    // before normal mouse-down processing.
    // Override _getMouseDownCell to ensure, even if this caused the row-height to change, 
    // we return the cell coords before the change of row-height.
    _getMouseDownCell : function () {
        if (this._maskedMouseDownCell != null) {
            var cell = this._maskedMouseDownCell;
            // clear the property so it doesn't impact future mouseDowns
            this._maskedMouseDownCell = null;
            return cell;
        }
        return this.Super("_getMouseDownCell", arguments);
    },

    // Override mouseUp.
    // If the mouseUp occurred over a CanvasItem, ignore it.
    
    mouseUp : function () {
        var target = isc.EH.getTarget();
        
        if (this.grid && target != null && target != this && this.grid._editorShowing) {
            var editForm = this.grid.getEditForm();
            while (target != this && target != null && target != editForm) {
                if (target.canvasItem && editForm.items.contains(target.canvasItem)) {
                    return;
                }
                target = isc.isA.FormItem(target) ? target.containerWidget : target.parentElement;
            }
        }
        return this.Super("mouseUp", arguments);
    },

    selectOnMouseUp : function (record, rowNum, colNum, d,e,f) {
        var cbColNum = this.grid.getCheckboxFieldPosition(),
            selApp = this.grid.selectionAppearance;
        if (selApp != "checkbox" || (selApp == "checkbox" && cbColNum == colNum)) {
            this.invokeSuper(isc.GridBody, "selectOnMouseUp", record, rowNum, colNum, d,e,f);
        }
    },

    // Override handleSelectionChanged() to fire our viewStateChanged method
    handleSelectionChanged : function (record,state) {
        if (this.grid.suppressSelectionChanged) return;
        var returnVal = this.Super("handleSelectionChanged", arguments);
        // ignore the events that comes from the frozen body
        if (this._isFrozenBody() == 0) this.grid.handleViewStateChanged();
        return returnVal;
    },

    setSelection : function (selection) {
        this.clearSelection();
        this.Super("setSelection", arguments);
    },

    clearSelection : function () {
        var selection = this.selectionManager;
        this.Super("clearSelection", arguments);
        // if selection not inherited from ListGrid, destroy it
        if (selection && selection.isA("DependentCellSelection")) {
            selection.destroy();
        }
    },

    _setSeparateCellSelection : function (selection, firstCol) {
        this.clearSelection();
        if (selection) {
            this.selectionManager = this.selection = 
                selection.getDependentCellSelection(this.fields.length);
            this.selectionManager._updateDependency(firstCol);
            this.observe(this.selectionManager, "selectionChanged", function () {
                this._cellSelectionChanged(this.selectionManager.changedCells);
            });
        }
    },

    // When refreshing cellStyle, notify our edit items that the underlying cell style changed
    // so they can update if necessary
    _updateCellStyle : function (record, rowNum, colNum, cell, className, a,b,c) {
        this.invokeSuper(isc.GridBody, "_updateCellStyle", record, rowNum,colNum,cell,className,a,b,c);
        var lg = this.grid;
        if (lg && lg.getEditRow() == rowNum) {
            var fieldName = lg.getFieldName(lg.getFieldNumFromLocal(colNum, this)),
                form = lg.getEditForm(),
                item = form ? form.getItem(fieldName) : null;
            if (item && item.gridCellStyleChanged) {
                if (className == null) className = this.getCellStyle(record,rowNum,colNum);
                item.gridCellStyleChanged(record, rowNum, colNum, className);
            }
        }

    },

    // hovers: override getHoverTarget to return a pointer to our grid - this allows
    // the developer to call 'updateHover' directly on the grid.
    getHoverTarget : function () {
        return this.grid;
    },

    // direct keyPresses to the ListGrid as a whole to implement arrow navigation,
    // selection, etc
    
    keyPress : function (event, eventInfo) {
        return this.grid.bodyKeyPress(event, eventInfo);
    },

    // getters for the current keyboard focus row for key-events.
    
    getFocusRow : function () {
        return this.grid.getFocusRow();
    },
    getFocusCol : function () {
        var colNum = this.grid._getKeyboardClickNum();
        return this.grid.getLocalFieldNum(colNum);
    },

    
    _restoreFocusForClickMaskHide : function () {
        this._suppressKeyboardNavHiliting = true;
        this.focus();
        delete this._suppressKeyboardNavHiliting;
    },

    // Override _focusChanged to implement 'editOnFocus' - start editing the first
    // editable cell if appropriate.
    // See comments in 'editOnFocus' jsdoc comment for details of how this should work.
    _focusChanged : function (hasFocus) {
        // use the Super implementation to set up this.hasFocus BEFORE we further
        // manipulate focus due to editing.
        var returnVal = this.Super("_focusChanged", arguments);

        var lastEvent = isc.EH.lastEvent;

        // if we're acquiring focus because we're in the middle of a click sequence on the body,
        // the mouse handlers will correctly start editing or place focus on whatever row was hit, and we
        // should do nothing
        if (lastEvent.target == this &&
              (lastEvent.eventType == isc.EH.MOUSE_DOWN ||
               lastEvent.eventType == isc.EH.MOUSE_UP ||
               lastEvent.eventType == isc.EH.CLICK ||
               lastEvent.eventType == isc.EH.DOUBLE_CLICK)) 
        {
            // We still need to kill the suppressEditOnFocus flag, otherwise a modal-editing
            // grid with edit-on-focus enabled will get stuck with the flag if the user clicks
            // over the empty area
            if (this.grid._suppressEditOnFocus) {
                delete this.grid._suppressEditOnFocus;
            }            
            return returnVal;
        }

        // otherwise, entering focus due to a key event (tab, shift-tab) or something else (programmatic
        // including re-focus due to clickMask blur).
        var editCell,
            parent = this.grid;
        if (hasFocus && parent.canEdit != false) {
            // editOnFocus enabled, but not currently editing
            if (parent.editOnFocus && parent.canEdit != false &&
                parent.getEditRow() == null)
            {
                if (this.logIsInfoEnabled("gridEdit")) {
                    this.logInfo("Editing on focus: eventType: " + lastEvent.eventType +
                                 ", lastTarget " + lastEvent.target, "gridEdit");
                }

                // If we're explicitly suppressing edit on focus, don't start editing.
                if (parent._suppressEditOnFocus) {
                    delete parent._suppressEditOnFocus;
                } else {
                    // this'll run through every cell in every record until it finds one that's
                    // editable
                    var editCell = parent.getFocusCell();

                    
                    var editCellValid = isc.isAn.Array(editCell) && editCell[0] != null &&
                            editCell[0] >= 0 && editCell[1] != null && editCell[1] >= 0;
                    // If we can't edit the default focus/keyboard cell, check whether the
                    // row itself is editable - we don't want to jump to the first row if we
                    // can help it
                    if (editCellValid && !parent.canEditCell(editCell[0], editCell[1])) {
                        editCell = parent.findNextEditCell(editCell[0], editCell[1],
                                     true, true, // direction, stepThroughFields
                                     false, false, true, // checkStartingCell, checkPastListEnd, dontCheckPastRowEnd,
                                     false); // ignoreFocus
                        // If there are no editable cells in this row - just find the first editable cell
                        // in the grid
                        if (editCell == null) editCellValid = false;
                    }
                    if (!editCellValid) {
                        editCell = parent.findNextEditCell(0,0,true,true);
                    }

                    if (editCell != null) {
                        parent.handleEditCellEvent(editCell[0], editCell[1], isc.ListGrid.FOCUS);
                    }
                }
            }
        }

        // In screenReader mode, if focus is moving into the grid but we're not going into editing mode,
        // put focus onto the row element rather than onto the GR body.
        
        var hiliteOnFocus = parent.hiliteRowOnFocus;
        if (hiliteOnFocus == null) hiliteOnFocus = parent.showRollOver;
        if (isc.screenReader) {
            if (hasFocus) {
                if (editCell == null) {
                    // find the last hilited row if there is one
                    var rowNum = this.getNativeFocusRow();

                    //this.logWarn("focus entering body - focusing in native row: " + rowNum +
                    //             ", focus row was: " + parent.getFocusRow());
                    this._putNativeFocusInRow(rowNum, this.getNativeFocusColumn());
                }
            } else {
                parent.clearLastHilite();
            }
        // Even if we don't have screenReader mode enabled, hilite the current keyboard
        // target row on focus (but don't trigger a click or select it).
        // Also call clearLastHilite() on blur, so we don't show orphaned "over"
        // styling when the user takes focus from the grid
        } else if (hiliteOnFocus) {
            if (hasFocus) {
                // keyboard nav hiliting will be suppressed for focus due to hideClickMask()
                if (editCell == null && !this._suppressKeyboardNavHiliting) {
                    if (parent.canSelectCells) {
                        parent._navigateToNextCell(0, 1, true, true, "focus");
                    } else {
                        parent._navigateToNextRecord(1, true, "focus", true);
                    }
                }
            } else {
                // If the user mouseDowned on an embedded widget, such as a rollOverCanvas,
                // don't clear the hilight or we'll lose the roll-over canvas altogether.
                var mouseDownTarget = isc.EH.mouseDownTarget(),
                    eventType = isc.EH.lastEvent.eventType;
                if (eventType != isc.EH.MOUSE_DOWN || !this.contains(mouseDownTarget)) {
                    parent.clearLastHilite();
                }
            }

        }
        return returnVal;
    },

    // override putNativeFocusInRow to ensure we hilight the focus row
    _putNativeFocusInRow : function (rowNum, colNum, suppressFocus) {
        var parent = this.grid;
        if (parent) {
            var gridColNum = colNum == null ? null : parent.getFieldNumFromLocal(colNum, this);


            // if suppressFocus is passed, we're not actually focusing into the row so don't
            // hilite the row.
            if (parent.hiliteOnNativeRowFocus && !suppressFocus) {
                parent._hiliteRecord(rowNum, gridColNum);
            }
            // Let the grid know which body last had native cell focus applied to
            // it.
            if (!suppressFocus) {
                parent._lastNativeFocusBody = this;
                parent.keyboardClickField = gridColNum;
            }
        }

        return this.Super("_putNativeFocusInRow", arguments);
    },

    // override updateRowSelection to update selectionCanvas if necessary
    updateRowSelection : function (rowNum) {

        var lg = this.grid;
        if (!lg) return;

        

        if (lg.showSelectionCanvas || lg.showSelectionUnderCanvas) {
            lg.updateSelectionCanvas();
        }
            
        if (lg.showSelectedRollOverCanvas || lg.showSelectedRollUnderCanvas) {
            lg.updateRollOverCanvas(this.lastOverRow, this.lastOverCol);
        }
        if (lg._dontRefreshSelection) {
            return;
        }
        this.invokeSuper(isc.GridBody, "updateRowSelection", rowNum);

        if (isc.Canvas.ariaEnabled() && lg.selectionManager) {
            this.setRowAriaState(rowNum, "selected", lg.selectionManager.
                                 isSelected(lg.getRecord(rowNum), rowNum, true));
        }
        
        var cellsToRefresh = lg.getCellsToRefreshOnSelectionChange(rowNum);
        if (cellsToRefresh && cellsToRefresh.length > 0) {
            for (var i = 0; i < cellsToRefresh.length; i++) {
                lg.refreshCell(cellsToRefresh[i][0], cellsToRefresh[i][1]);
            }
        }
        // with selectionAppearance:"checkbox", also update checkbox in header
        if (lg.getCurrentCheckboxField() != null) {
            lg.updateCheckboxHeaderState();
        }
    },

    // Fired when selecting a list of entries (for every row)
    // Default implementation marks for redraw
    // Also set up to update SelectionCanvas when the thread completes.
    
    markForRowSelectionRefresh : function () {
        var lg = this.grid;
        if (!lg) return;
        if (lg.showSelectionCanvas || lg.showSelectionUnderCanvas) {
            lg.fireOnPause("updateSelectionCanvasFromRowRefresh", "updateSelectionCanvas");
        }
        if (lg.getCurrentCheckboxField() != null) {
            lg.fireOnPause("updateCheckboxHeaderFromRowRefresh", "updateCheckboxHeaderState");
        }
        if (lg.showSelectedRollOverCanvas || lg.showSelectedRollUnderCanvas) {
            lg.fireOnPause("updateSelectionRollOverCanvasFromRowRefresh",
                        {target:lg, methodName:"updateRollOverCanvas",
                         args:[this.lastOverRow, this.lastOverCol]});
        }

        if (lg._dontRefreshSelection) {
            return;
        }
        // This will mark the body for redraw (refreshing the actual styling / checkboxes)
        this.invokeSuper(isc.GridBody, "markForRowSelectionRefresh");
    },

    // ditto with _cellSelectionChanged
    _cellSelectionChanged : function (cellList,b,c,d) {
        var lg = this.grid;
        if (lg != null &&
            (lg.showSelectionCanvas || lg.showSelectionUnderCanvas))
        {
            lg.updateSelectionCanvas();
        }
        return this.invokeSuper(isc.GridBody, "_cellSelectionChanged", cellList, b,c,d);
    },

    // remove any dynamic references that point to us if we're being destroyed
    destroy : function () {
        var grid = this.grid;
        if (this == grid._lastSelectedBody)       grid._lastSelectedBody       = null;
        if (this == grid._lastKeyboardHiliteBody) grid._lastKeyboardHiliteBody = null;
        this.Super("destroy", arguments);
    },

    // Embedded components
    // -----------------------

    // animateShow selectionCanvas / rollOverCanvas if appropriate
    shouldAnimateEmbeddedComponent : function (component) {
        var grid = this.grid;
        if (component == grid.selectionCanvas) return grid.animateSelection;
        if (component == grid.selectionUnderCanvas) return grid.animateSelectionUnder;
        if (component == grid.rollOverCanvas) return grid.animateRollOver;
        if (component == grid.rollUnderCanvas) return grid.animateRollUnder;

        return false;
    },


    _handleEmbeddedComponentResize : function (component, deltaX, deltaY) {
        this.Super("_handleEmbeddedComponentResize", arguments);

        // Notify the grid - allows us to update the other body if we're showing
        // both a frozen and an unfrozen body
        this.grid._handleEmbeddedComponentResize(this, component, deltaX, deltaY);
    },

    // Override draw() to scroll to the appropriate cell if 'scrollCellIntoView' was called
    // before the body was drawn/created
    // Also update the edit form item rows if we're already editing.
    draw : function (a,b,c,d) {
        var lg = this.grid;
        if (lg.getEditRow() != null) {
            
            var rowNum = lg.getEditRow(),
                record = lg.getRecord(rowNum),
                fieldNum = lg.getEditCol(),
                form = lg._editRowForm,
                items = lg.getEditRowItems(record, rowNum, fieldNum, lg.editByCell),
                liveItems = form.getItems();

            var setItems = liveItems == null || items.length != liveItems.length;
            if (!setItems) {
                var liveItemNames = liveItems.getProperty("name");
                for (var i = 0; i < items.length; i++) {
                    if (!liveItemNames.contains(items[i].name)) {
                        setItems = true;
                        break;
                    }
                }
            }
            if (setItems) {
                this.logDebug("calling setItems on form from body draw","gridEdit");
                form.setItems(items);
            } else {
                this.logDebug("Skipping setItems() on form from body draw", "gridEdit");
            }

            
            form._setValuesPending = true;

        }

        
        delete this._drawnEditItems;

        
        if (lg._editorShowing && lg._currentEditCells == null) {
            lg._cacheCurrentEditCells();
        }
        this.invokeSuper(isc.GridBody, "draw", a,b,c,d);

        // If we are showing any edit form items, notify them that they have been written
        // into the DOM.
        
        if (lg._editRowForm) {
            lg._editItemsDrawingNotification(null, null, this);
        }
        // Tell the form to update its values (setItemValues())
        // (do this after the items have been notified that they're drawn to ensure items'
        // element values are set)
        lg.updateEditRow(lg.getEditRow());

        if (lg._scrollCell != null) lg._delayedScrollToCell();

        // Call 'updateRecordComponents()' on initial draw to set up recordComponents
        // If this is a ResultSet rather than an array, the updateRecordComponents method
        // will be able to skip all records and we'll render out the components on redraw.
        this.grid.updateRecordComponents();

        if (!this._updatingExpansionComponents) this.grid.updateExpansionComponents();

        
        if (isc.screenReader) {
            this._putNativeFocusInRow(this.getNativeFocusRow(), this.getNativeFocusColumn(), true);
        }            

    },

    // rerun ListGrid-level layout if the body's scrolling state changes, to allow sizing
    // the header appropriately
    layoutChildren : function (reason,a,b,c) {
        this.invokeSuper(isc.GridBody, "layoutChildren", reason,a,b,c);
        // This method may be called with "scrolling state change" when a bodyLayout is
        // currently undrawn but drawing out its children - we've seen this in FF 3
        // In this case bail now since if _updateFieldWidths() is fired on an undrawn body it
        // bails, leaving the body mis sized
        
        if (!this.isDrawn() || (this.grid.frozenFields && !this.grid.bodyLayout.isDrawn())) {
            return;
        }
        var isScrollStateChanged = isc.startsWith(reason, "scrolling state changed"),
            isNewScrollbars      = isc.startsWith(reason, "introducing scrolling");
        if (isScrollStateChanged || isNewScrollbars) {
            
            if (this.isRTL() && !this._animatedShowStartRow) {
                this._placeEmbeddedComponents();
            }

            
            if (this._rowHeightAnimation == null) {
                this.grid.layoutChildren("body scroll changed");
                delete this._scrollbarChangeDuringAnimation;
            } else {
                this._scrollbarChangeDuringAnimation = true;
            }
        }
    },

    // Override rowAnimationComplete to call layoutChildren on the ListGrid if
    // scrollbars were introduced or cleared during animation.
    _rowAnimationComplete : function () {
        this.Super("_rowAnimationComplete", arguments);
        if (this._scrollbarChangeDuringAnimation) {
            this.grid.layoutChildren("body scroll changed during animation");
            delete this._scrollbarChangeDuringAnimation;
        }
    },


    // Override moved to notify any edit form items that they have moved.
    handleMoved : function (a,b,c,d) {
        this.invokeSuper(isc.GridBody, "handleMoved", a,b,c,d);
        this._notifyEditItemsOnMoved();
    },

    handleParentMoved : function (a,b,c,d) {
        this.invokeSuper(isc.GridBody, "handleParentMoved", a,b,c,d);
        this._notifyEditItemsOnMoved();
    },
    _notifyEditItemsOnMoved : function () {
        
        var lg = this.grid;
        if (lg._editorShowing) {
            var form = lg._editRowForm,
                allItems = form.getItems(),
                items = [];
            for (var i = 0; i < allItems.length; i++) {
                if (allItems[i].isDrawn()) items.add(allItems[i]);
            }
            form.itemsMoved(items);
        }
    },

    // Override show() / hide() / parentVisibilityChanged() / clear() to notify the Edit
    // form items that they have been shown / hidden.
    setVisibility : function (newVisibility,b,c,d) {
        this.invokeSuper(isc.GridBody, "setVisibility", newVisibility,b,c,d);
        var lg = this.grid;
        if (lg._editorShowing) lg._editRowForm.itemsVisibilityChanged();
        if (lg.fieldPickerWindow && newVisibility == "hidden") lg.fieldPickerWindow.hide();
    },

    parentVisibilityChanged : function (newVisibility,b,c,d) {
        this.invokeSuper(isc.GridBody, "parentVisibilityChanged", newVisibility,b,c,d);
        var lg = this.grid;
        if (lg._editorShowing) lg._editRowForm.itemsVisibilityChanged();
    },

    clear : function () {
        var lg = this.grid;
        lg._clearingInactiveEditorHTML();
        // Fire 'clearing' notifications on any drawn items. 
        var editForm = lg.getEditForm();
        if (editForm != null) {
            var items = editForm.getItems();
            for (var i = 0; i < items.length; i++) {
                if (items[i] && items[i].isDrawn()) {
                    items[i].clearing(false);
                }
            }
        }

        
        delete this._drawnEditItems;
        this.Super("clear", arguments);
        if (lg._editorShowing) {
            // If we're showing the editRow form, notify the items that they have
            // been removed from the DOM.
            lg._editItemsDrawingNotification(null, null, this);

            // Separate mechanism to notify the form that items are no longer visible.
            
            lg._editRowForm.itemsVisibilityChanged();
        }
    },

    // also notify the edit form items of z index change
    zIndexChanged : function () {
        this.Super("zIndexChanged", arguments);
        var lg = this.grid;
        // Note: setZIndex can be called at init time to convert "auto" to a numeric
        // zIndex - we therefore can't assume that we've been added to the ListGrid as
        // a child yet.
        if (lg && lg._editorShowing) lg._editRowForm.itemsZIndexChanged();

    },
    parentZIndexChanged : function (a,b,c,d) {
        this.invokeSuper(isc.GridBody, "zIndexChanged", a,b,c,d);
        var lg = this.grid;
        if (lg._editorShowing) lg._editRowForm.itemsZIndexChanged();
    },

    // Implement 'redrawFormItem()' - if one of the edit form items asks to redraw
    // we can simply refresh the cell rather than having the entire body redraw
    redrawFormItem : function (item, reason) {
        var lg = this.grid;
        if (lg && (item.form == lg._editRowForm)) {
            // determine which cell
            var row = lg.getEditRow(), col = lg.getColNum(item.getFieldName());

            // If the user has edited the cell, or setValue() has been called on the item
            // we don't want a call to redraw() on the item to drop that value
            if (lg.getEditCol() == col) {
                lg.storeUpdatedEditorValue();
            }

            if (row >= 0 && col >= 0) lg.refreshCell(row, col, false, true);

        } else
            return this.markForRedraw("Form Item Redraw " + (reason ? reason : isc.emptyString));
    },

    
    sizeFormItem : function (item) {
        var lg = this.grid;
        var width = item.width,
            finalWidth;

        if (isc.isA.String(width)) {
            var fieldWidths = lg.getEditFormItemFieldWidths(item.record),
                fieldWidth = fieldWidths[lg.getFieldNum(item.getFieldName())];
             if (width == "*") {
                finalWidth = fieldWidth;
             } else if (width.charAt(width.length - 1) == "%") {
                var percentWidth = parseInt(width);
                if (isc.isA.Number(percentWidth)) {
                    finalWidth = Math.floor(fieldWidth * (percentWidth / 100));
                }
            }
        }

        var height = item.height,
            finalHeight;
        if (isc.isA.String(height)) {
            var cellHeight = lg.cellHeight;
            if (width == "*") {
                finalHeight = cellHeight;
            } else if (height.charAt(height.length - 1) == "%") {
               var percentHeight = parseInt(height);
               if (isc.isA.Number(percentHeight)) {
                   finalHeight = Math.floor(cellHeight * (percentHeight / 100));
               }
            }
        }
        // Hang the calculated values on the _size attribute as we do when running
        // normal stretch-resize policy in form items.
        
        if (finalHeight != null || finalWidth != null) {
            item._size = [finalWidth == null ? item.width : finalWidth,
                          finalHeight == null ? item.height : finalHeight];
        }

    },
   
    // Cell Styling: modify the 'alternate' column offset to account for
    // frozen columns if necessary
    getAlternateColumnOffset : function (record, rowNum, colNum) {
        var grid = this.grid;
        if (grid != null && (this == grid.body) && grid.frozenFields != null) {
            return grid.frozenFields.length;
        }
        return 0;
    },

    //>Animation
    // Override startRowAnimation - if doing a delayed redraw to kick off a row animation
    // to close an open folder, we need to temporarily open the folder again to get the
    // appropriate HTML for the animation rows.
    startRowAnimation : function (show, startRow, endRow, callback, speed, duration,
                                  effect, slideIn, delayed)
    {
        this.finishRowAnimation();

        var shouldOpenFolder = (delayed && (this._openFolder != null)),
            tg = this.grid;

        if (shouldOpenFolder) {
            var wasSuppressed = tg._suppressFolderToggleRedraw;
            tg._suppressFolderToggleRedraw = true;
            tg.data.openFolder(this._openFolder);
            tg._suppressFolderToggleRedraw = wasSuppressed;
        }
        this.Super("startRowAnimation", arguments);
        if (shouldOpenFolder) {
            var wasSuppressed = tg._suppressFolderToggleRedraw;
            tg._suppressFolderToggleRedraw = true;
            tg.data.closeFolder(this._openFolder);
            tg._suppressFolderToggleRedraw = wasSuppressed;
        }
        delete this._openFolder;
    }
    //<Animation
});


isc.ListGrid.addClassProperties({
    

    //> @type SortArrow
    //          Do we display an arrow for the sorted field ?
    //          @group  sorting, appearance
    //  @value  "none"   Don't show a sort arrow at all.
    //  @value  "corner" Display sort arrow in the upper-right corner (above the scrollbar) only.
    CORNER:"corner",
    //  @value  "field"  Display sort arrow above each field header only.
    FIELD:"field",
    //  @value  "both"   Display sort arrow above each field header AND in corner above scrollbar.
    //BOTH:"both", // NOTE: Canvas establishes this constant
    // @visibility external
    //<
    // NOTE: Canvas established the constant NONE ( == "none")

    //> @type ReorderPosition
    //  Controls where a drag-item should be dropped in relation to the target row
    // @value  isc.ListGrid.BEFORE  Drop the drag-item before the target-row
    // @value  isc.ListGrid.AFTER   Drop the drag-item after the target-row
    // @value  isc.ListGrid.OVER    Drop the drag-item over (onto) the target-row
    // @visibility external
    // @group dragdrop
    //<

    //> @classAttr ListGrid.BEFORE (Constant : "before" : [R])
    // A declared value of the enum types 
    // +link{type:RecordDropPosition,RecordDropPosition} and
    // +link{type:ReorderPosition,ReorderPosition}.
    // @visibility external
    // @constant
    //<
    BEFORE:"before",

    //> @classAttr ListGrid.AFTER (Constant : "after" : [R])
    // A declared value of the enum types 
    // +link{type:RecordDropPosition,RecordDropPosition} and
    // +link{type:ReorderPosition,ReorderPosition}.
    // @visibility external
    // @constant
    //<
    AFTER:"after",

    //> @classAttr ListGrid.OVER (Constant : "over" : [R])
    // A declared value of the enum types 
    // +link{type:RecordDropPosition,RecordDropPosition},
    // +link{type:ReorderPosition,ReorderPosition} and
    // +link{type:RecordDropAppearance,RecordDropAppearance}.
    // @visibility external
    // @constant
    //<
    OVER:"over",

    //> @type RecordDropAppearance
    // Controls how ListGrid record drop events report their
    // +link{listGrid.getRecordDropPosition(),dropPosition}, and where the drop indicator will be displayed
    // if appropriate.
    //
    // @value isc.ListGrid.OVER When the user drops onto a record, dropPosition will always be "over"
    // @value isc.ListGrid.BETWEEN When the user drops onto a record, dropPosition will be either
    //   "before" or "after" depending on whether the mouse was over the top or bottom of
    //   the target record
    // @value isc.ListGrid.BOTH When the user drops onto a record, if the drop occurs centered over the
    //   record, the dropPosition will be reported as "over", otherwise it will be
    //   "before" or "after" depending on whether the mouse was over the top or bottom of the
    //   target record.
    // @value isc.ListGrid.BODY No dropPosition will be reported
    //
    // @visibility external
    //<

    //> @classAttr ListGrid.BETWEEN (Constant : "between" : [R])
    // A declared value of the enum type  
    // +link{type:RecordDropAppearance,RecordDropAppearance}.
    // @visibility external
    // @constant
    //<
    BETWEEN: "between",

    //> @classAttr ListGrid.BOTH (Constant : "both" : [R])
    // A declared value of the enum type  
    // +link{type:RecordDropAppearance,RecordDropAppearance}.
    // @visibility external
    // @constant
    //<
    //BOTH:"both", // NOTE: Canvas establishes this constant

    //> @classAttr ListGrid.BODY (Constant : "body" : [R])
    // A declared value of the enum type  
    // +link{type:RecordDropAppearance,RecordDropAppearance}.
    // @visibility external
    // @constant
    //<
    BODY:"body",

    //> @type RecordDropPosition
    // Position of a +link{listGrid.recordDrop} operation with respect to the target record.
    // @value isc.ListGrid.OVER User dropped directly onto the record
    // @value isc.ListGrid.BEFORE User dropped before the record
    // @value isc.ListGrid.AFTER User dropped after the record
    // @value isc.ListGrid.NONE Drop position is not over a record
    //
    // @visibility external
    //<

    //> @classAttr ListGrid.NONE (Constant : "none" : [R])
    // A declared value of the enum type  
    // +link{type:RecordDropPosition,RecordDropPosition}.
    // @visibility external
    // @constant
    //<
    //NONE:"none", // NOTE: Canvas establishes this constant

    //> @type RowEndEditAction
    //  While editing a ListGrid, what cell should we edit when the user attempts to navigate
    //  into a cell past the end of an editable row, via a Tab keypress, or a programmatic
    //  saveAndEditNextCell() call?
    //
    // @value   "same"   navigate to the first editable cell in the same record
    // @value   "next"   navigate to the first editable cell in the next record
    // @value   "done"   complete the edit.
    // @value   "stop"   Leave focus in the cell being edited (take no action)
    // @value   "none"   take no action
    //
    // @visibility external
    // @group editing
    // @see ListGrid.rowEndEditAction
    //
    //<

    //> @type EnterKeyEditAction
    // What to do when a user hits enter while editing a cell
    // @value "done" end editing (will save edit values if +link{listGrid.autoSaveEdits}
    //  is true).
    // @value "nextCell" edit the next editable cell in the record
    // @value "nextRow" edit the same field in the next editable record
    // @value "nextRowStart" edit the first editable cell in next editable record
    //
    // @group editing
    // @visibility external
    //<

    //> @type EscapeKeyEditAction
    // What to do if the user hits escape while editing a cell.
    // @value "cancel" cancels the current edit and discards edit values
    // @value "done" end editing (will save edit values if +link{listGrid.autoSaveEdits}
    //  is true).
    // @value "exit" exit the editor (edit values will be left intact but not saved).
    // @value "ignore" do nothing special when the Escape key is pressed (ie, just ignore it)
    //
    // @group editing
    // @visibility external
    //<
    
    //> @type ArrowKeyEditAction
    // What to do if the user hits Up or Down arrow key while editing a cell.
    // @value "none" The grid will take no special action when the user presses up or down
    //   arrow keys within an editor
    // @value "editNext" The grid will intercept up and down arrow keypresses and navigate
    //   to the next or previous edit row by generating an appropriate +link{EditCompletionEvent}
    //
    // @group editing
    // @visibility external
    //<
    
    
    //> @type EditCompletionEvent
    //          What event / user interaction type caused cell editing to complete.
    //          @visibility external
    //          @group  editing
    //
    //          @value  isc.ListGrid.CLICK_OUTSIDE  User clicked outside editor during edit.
    //          @value  isc.ListGrid.CLICK  User started editing another row by clicking on it
    //          @value  isc.ListGrid.DOUBLE_CLICK  User started editing another row by double
    //                               clicking
    //          @value  isc.ListGrid.ENTER_KEYPRESS Enter pressed.
    //          @value  isc.ListGrid.ESCAPE_KEYPRESS    User pressed Escape.
    //          @value  isc.ListGrid.UP_ARROW_KEYPRESS  Up arrow key pressed.
    //          @value  isc.ListGrid.DOWN_ARROW_KEYPRESS    down arrow key.
    //          @value  isc.ListGrid.TAB_KEYPRESS   User pressed Tab.
    //          @value  isc.ListGrid.SHIFT_TAB_KEYPRESS   User pressed Shift+Tab.
    //          @value  isc.ListGrid.EDIT_FIELD_CHANGE      Edit moved to a different field (same row)
    //          @value  isc.ListGrid.PROGRAMMATIC   Edit completed via explicit function call
    // @visibility external
    //<

    //> @classAttr ListGrid.CLICK_OUTSIDE (Constant : "click_outside" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    CLICK_OUTSIDE:"click_outside",

    //> @classAttr ListGrid.CLICK (Constant : "click" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    CLICK:"click",

    //> @classAttr ListGrid.DOUBLE_CLICK (Constant : "doubleClick" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    DOUBLE_CLICK:"doubleClick",

    //> @classAttr ListGrid.ENTER_KEYPRESS (Constant : "enter" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    ENTER_KEYPRESS:"enter",

    //> @classAttr ListGrid.ESCAPE_KEYPRESS (Constant : "escape" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    ESCAPE_KEYPRESS:"escape",

    //> @classAttr ListGrid.UP_ARROW_KEYPRESS (Constant : "arrow_up" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    UP_ARROW_KEYPRESS:"arrow_up",

    //> @classAttr ListGrid.DOWN_ARROW_KEYPRESS (Constant : "arrow_down" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    DOWN_ARROW_KEYPRESS:"arrow_down",

    // left/right only used in conjunction with moveEditorOnArrow
    LEFT_ARROW_KEYPRESS:"arrow_left",
    RIGHT_ARROW_KEYPRESS:"arrow_right",

    //> @classAttr ListGrid.TAB_KEYPRESS (Constant : "tab" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    TAB_KEYPRESS:"tab",

    //> @classAttr ListGrid.SHIFT_TAB_KEYPRESS (Constant : "shift_tab" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    SHIFT_TAB_KEYPRESS:"shift_tab",

    //> @classAttr ListGrid.EDIT_FIELD_CHANGE (Constant : "field_change" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    EDIT_FIELD_CHANGE:"field_change",
    EDIT_ROW_CHANGE:"row_change",

    //> @classAttr ListGrid.PROGRAMMATIC (Constant : "programmatic" : [R])
    // A declared value of the enum type  
    // +link{type:EditCompletionEvent,EditCompletionEvent}.
    // @visibility external
    // @constant
    //<
    PROGRAMMATIC:"programmatic",

    // Focus is not a valid edit completion event - focusing in the grid can start an edit
    // if editOnFocus is true but this should not kill an existing edit.
    FOCUS:"focus",


    //> @classAttr ListGrid.GROUP_BY (Constant : "groupBy" : [R])
    // A declared value of the enum type 
    // +link{type:GroupTreeChangeType}
    // @visibility external
    // @constant
    //<
    GROUP_BY:"groupBy",

    //> @classAttr ListGrid.REGROUP (Constant : "regroup" : [R])
    // A declared value of the enum type 
    // +link{type:GroupTreeChangeType}
    // @visibility external
    // @constant
    //<
    REGROUP:"regroup",

    //> @classAttr ListGrid.INCREMENTAL (Constant : "incremental" : [R])
    // A declared value of the enum type 
    // +link{type:GroupTreeChangeType}
    // @visibility external
    // @constant
    //<
    INCREMENTAL:"incremental",


    // GridRenderer passthrough
    // --------------------------------------------------------------------------------------------

    // the following properties, when set on the ListGrid, are applied to the GridBody
    _gridPassthroughProperties : [
        // pass it a selection object (this enables selection behaviors)
        "selection",
        "selectionType",
        "canSelectCells",
        "canDragSelect",
        "selectionManager",
        "canSelectOnRightMouse",
        "recordCanSelectProperty",
        "useNativeTouchScrolling",

        "screenReaderNavigateByCell",

        // D&D
        "canDrag",
        "canAcceptDrop",
        "canDrop",

        // table geometry
        "autoFit",
        "wrapCells",
        "preserveWhitespace",
        "cellSpacing",
        "cellPadding",
        "cellHeight",
        "enforceVClipping",
        // autoFitData behavior implemented on GridBody class, not GR class
        "autoFitData",
        "autoFitMaxRecords",
        "autoFitMaxWidth",
        "autoFitMaxColumns",
        "autoFitMaxHeight",
        "autoFitExtraRecords",

        "allowRowSpanning",

        // incremental rendering
        // "showAllRecords" -> showAllRows done elsewhere
        "showAllColumns",
        "drawAllMaxCells",
        "drawAheadRatio",
        "quickDrawAheadRatio",
        "instantScrollTrackRedraw",
        "scrollRedrawDelay",
        "dragScrollRedrawDelay",
        "scrollWheelRedrawDelay",
        "touchScrollRedrawDelay",

        // printing
        "printMaxRows",

        //>Animation
        // If we're doing a speed rather than duration based row animation allow the cap to
        // be specified on the ListGrid / TreeGrid
        // (Note that this is documented in the TreeGrid class).
        "animateRowsMaxTime",
        //<Animation

        // documented by default setting
        "fastCellUpdates",

        // rollover
        "showRollOver",
        "useCellRollOvers",

        // hover
        "canHover",
        "showHover",
        "showHoverOnDisabledCells",
        "showClippedValuesOnHover",
        "hoverDelay",
        "hoverWidth",
        "hoverHeight",
        "hoverAlign",
        "hoverVAlign",
        "hoverStyle",
        "hoverOpacity",
        "hoverMoveWithMouse",
        "hoverAutoFitWidth",
        "hoverAutoFitMaxWidth",

        "hoverByCell",
        "keepHoverActive",
        "cellHoverOutset",

        // empty message
        "showEmptyMessage",
        "emptyMessageStyle",
        "emptyMessageTableStyle",

        // offline message
        "showOfflineMessage",
        "offlineMessageStyle",

        // special presentation of records
        "useCellRecords",
        "singleCellValueProperty",
        "isSeparatorProperty",

        // Focus things -- note no need to pass tabIndex through - layouts should auto-manage
        // their members' tab-orders correctly
        "accessKey",
        "canFocus",
        "_useNativeTabIndex",
        "tableStyle",
        "baseStyle",
        "recordCustomStyleProperty",
        "showSelectedStyle",
        "preserveFocusStylingOnMouseOut",
        
        // whether to use rowSpan-oriented cell styling behaviors
        "useRowSpanStyling",
        // selection mode when rowSpanning is active
        "rowSpanSelectionMode",

        "showFocusOutline"
    ],

    // the following methods, when called on the LV, will call the same-named method on the
    // GridRenderer (this.body).
    _lv2GridMethods : [
        // this makes it easier to override getCellStyle at the LV level, since you can call
        // these helpers as this.getCellStyleName()
        "getCellStyleName",
        "getCellStyleIndex",

        "_getShowClippedValuesOnHover",

        // setFastCellUpdates explicitly handled
        // in a method which keeps lg.fcu in sync with the
        // body property value
        //"setFastCellUpdates",

        // checking table geometry
        "getRowTop",
        "getRowPageTop",
        "getRowSize",
        "getDrawnRowHeight",

        // row span information
        "getCellStartRow",
        "getCellRowSpan",

        //> @method listGrid.getVisibleRows
        // @include gridRenderer.getVisibleRows()
        // @return (Array of Integer)
        // @visibility external
        //<
        "getVisibleRows",

        //> @method listGrid.getDrawnRows
        // @include gridRenderer.getDrawnRows()
        // @visibility external
        //<
        "getDrawnRows"
    ],

    // styling

    //> @method listGrid.getCellStyle()
    // @include gridRenderer.getCellStyle()
    // @see listGrid.getBaseStyle()
    //<

    // refresh
    //> @method listGrid.refreshCellStyle()
    //  @include    gridRenderer.refreshCellStyle()
    //<

    // events
    //> @method listGrid.cellOver()
    // @include gridRenderer.cellOver()
    //<
    //> @method listGrid.rowOver()
    // @include gridRenderer.rowOver()
    //<

    //> @method listGrid.cellOut()
    // @include gridRenderer.cellOut()
    //<
    //> @method listGrid.rowOut()
    // @include gridRenderer.rowOut()
    //<

    //> @method listGrid.cellHover()
    // @include gridRenderer.cellHover()
    //<
    //> @method listGrid.cellValueHover() ([A])
    // @include gridRenderer.cellValueHover()
    //<
    //> @method listGrid.rowHover()
    // @include gridRenderer.rowHover()
    //<
    //> @method listGrid.cellHoverHTML()
    // @include gridRenderer.cellHoverHTML()
    //<
    //> @method listGrid.cellValueHoverHTML()
    // @include gridRenderer.cellValueHoverHTML()
    //<

    //> @attr listGrid.showHoverOnDisabledCells (boolean : false : IRW)
    // @include gridRenderer.showHoverOnDisabledCells
    //<


    //> @method listGrid.cellContextClick()
    // @include gridRenderer.cellContextClick()
    // @example cellClicks
    //<
    //> @method listGrid.rowContextClick()
    // @include gridRenderer.rowContextClick()
    // @example recordClicks
    //<

    //> @method listGrid.cellMouseDown()
    // @include gridRenderer.cellMouseDown()
    //<
    //> @method listGrid.rowMouseDown()
    // @include gridRenderer.rowMouseDown()
    //<

    //> @method listGrid.cellMouseUp()
    // @include gridRenderer.cellMouseUp()
    //<
    //> @method listGrid.rowMouseUp()
    // @include gridRenderer.rowMouseUp()
    //<

    //> @method listGrid.cellClick()
    // Called when a cell receives a click event.
    // <P>
    // Note that returning false from this method will not prevent any
    // specified +link{listGrid.rowClick} handler from firing.
    //
    // @group   events
    // @param   record  (ListGridRecord)    Record object returned from getCellRecord()
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number of the cell
    // @return  (boolean)   whether to cancel the event
    // @visibility external
    // @example cellClicks
    //<

    //> @method listGrid.cellDoubleClick()
    // @include gridRenderer.cellDoubleClick()
    // @example cellClicks
    //<

    // Geometry
    //> @method listGrid.getRowTop()
    // @include gridRenderer.getRowTop()
    // @visibility external
    //<

    //> @method listGrid.getRowPageTop()
    // @include gridRenderer.getRowPageTop()
    // @visibility external
    //<

    // ListGrid / GridBody passthroughs
    // ---------------------------------------------------------------------------------------

    // the following methods, when called on the GridRenderer used as LV.body, call the same-named
    // method on the ListGrid instance itself
    _grid2LVMethods : [

        "getTotalRows",
        "isEmpty",
        "cellIsEnabled",
        "willAcceptDrop",

        // passed scroll change notification through
        "scrolled",

        // native element naming
        "getTableElementId",
        "getRowElementId",
        "getCellElementId",

        // shouldFixRowHeight - enables us to override the ListGrid level 'fixedRecordHeights'
        // for individual rows
        "shouldFixRowHeight",

        "getEmptyMessage",
        "getCanHover",
        // bubble stopHover on the GR up to stopHover here.
        "stopHover",

        "updateEmbeddedComponentZIndex"

        // NOTE: These methods pick up their parameters from the stringMethodRegistry on the
        // GridRenderer class. If expanding this list ensure that any methods that take parameters
        // are registered as stringMethods on that class
    ],

    // used by _invokeKeyboardCopyPasteShortcut for copy/paste between ListGrids
    _cellClipboard : null
});

isc.ListGrid.addClassMethods({
    makeBodyMethods : function (methodNames) {
        var funcTemplate = this._funcTemplate;
        if (funcTemplate == null) {
            funcTemplate = this._funcTemplate = [
                ,
                
                
                "this.grid._passthroughBody = this;" +
                "var returnVal = this.grid.",,"(",,");" +
                "this.grid._passthroughBody=null;" +
                "return returnVal;"];
        }

        var methods = {};

        for (var i = 0; i < methodNames.length; i++) {
            var methodName = methodNames[i],
                argString = isc.GridRenderer.getArgString(methodName),

                
                isCellIsEnabled = (methodName == "cellIsEnabled");

            funcTemplate[0] = "var methodName = '" + methodName + "';\n";
                
            if (isc.contains(argString, "colNum")) {
                // if there's a colNum argument, map it to the field index in the master
                funcTemplate[0] += "if (this.fields[colNum]) colNum = this.fields[colNum].masterIndex;"

            } else if (isc.isAn.emptyString(argString)) {
                // if there are no arguments, pass the body itself as a means of identifying
                // the calling body
                argString = "body";
                funcTemplate[0] += "body = this;";
            }
            if (isCellIsEnabled) {
                var checkRecord = "if (record === undefined) record = this.grid.getCellRecord(" + argString + ");";
                funcTemplate[0] += checkRecord;
            }

            // create a function that routes a function call to the target object
            funcTemplate[2] = methodName;
            funcTemplate[4] = (isCellIsEnabled ? "record," + argString : argString);
            var functionText = funcTemplate.join(isc.emptyString);

            //this.logWarn("for method: " + methodName + " with argString :"  + argString +
            //             " function text is: " + functionText);

            var method = methods[methodName] = isc._makeFunction(
                (isCellIsEnabled ? argString + ",record" : argString), functionText);
            method._isPassthroughMethod = true;
        }

        return methods;
    },
    

    classInit : function () {
        // create functions to have methods on the ListGrid's body call methods on the ListGrid
        // itself.  This is partly legacy support: the way to customize body rendering used to
        // be to install functions that controlled body rendering directly on the ListGrid
        // itself.

        // make certain grid methods appear on the LV for convenience, so you don't have to go
        // this.body.someGridMethod()
        

        this.addMethods(isc.ClassFactory.makePassthroughMethods(
            this._lv2GridMethods, "body"));

        // ----------------------------------------------------------------------------------------
        // create methods that can be installed on the body to call methods on the LV itself, for:
        var passthroughMethods = {};

        // - handlers (like cellOver) and overrides (like getCellCSSText) that we allow to be
        //   defined on the LV but are really grid APIs
        var gridAPIs = isc.getKeys(isc.GridRenderer._gridAPIs),
            passthroughMethods = isc.ListGrid.makeBodyMethods(gridAPIs);

        // - methods the grid needs to fulfill as the drag/drop target, which are really implemented
        //   on the LV
        isc.addProperties(passthroughMethods,
                          isc.ListGrid.makeBodyMethods(this._grid2LVMethods));

        this._passthroughMethods = passthroughMethods;

        

        // create methods on the ListGrid to act as Super implementations for per-instance
        // overrides of methods where we want to call the original GridRenderer implementation
        // as Super.
        var passBackMethods = {},
            funcTemplate = [
                ,
                // _passthroughBody is set up by the body function that called back up the
                // the grid method - if present, we use it to ensure we call the original
                // implementation on the correct body.
                "var _passthroughBody = this._passthroughBody || this.body;" +
                " if (_passthroughBody == null) {" +
                    "return;" +
                "}" +
                "if(_passthroughBody.__orig_",,")return _passthroughBody.__orig_",,"(",,")"],
            origPrefix  = "__orig_",
            gridProto = isc.GridRenderer.getPrototype();
        for (var i = 0; i < gridAPIs.length; i++) {
            var methodName = gridAPIs[i],
                argString = isc.GridRenderer.getArgString(methodName);
            if (isc.ListGrid.getInstanceProperty(methodName) == null) {

                if (isc.contains(argString, "colNum")) {
                    // if there's a colNum argument, map it to the field index in the body
                    
                    funcTemplate[0] = "if (colNum != null && colNum >= 0) colNum = this.getLocalFieldNum(colNum);"
                } else {
                    funcTemplate[0] = null;
                }
                funcTemplate[2] = funcTemplate[4] = methodName;
                funcTemplate[6] = argString

                passBackMethods[methodName] = isc._makeFunction(argString,
                    funcTemplate.join(isc.emptyString));
                // XXX this would also work, but imposes another Super call penalty, and is
                // odd (call to Super from outside of the object)
                //"return this.body.Super('" + methodName + "', arguments);");
            }
            
            gridProto[origPrefix + methodName] = gridProto[methodName];
        }
        this._passBackMethods = passBackMethods;
        this.addMethods(passBackMethods);

    },

    // retrieve possibly sorted list of coordinates from a coordinate record
    _getCoordinateList : function (coordinateRecord, sortByCoordinate) {
        var list = [];
        for (var coordinate in coordinateRecord) {
            if (coordinateRecord.hasOwnProperty(coordinate)){
                list.add(parseInt(coordinate));
            }
        }
        if (sortByCoordinate) {
            list.sort(function (a, b) { return a - b; });
        }
        return list;
    }
});

// add default properties to the class
isc.ListGrid.addProperties( {

    //> @attr listGrid.styleName (CSSStyleName : "listGrid" : IRW)
    // Default CSS class for the ListGrid as a whole.
    // @group appearance
    // @visibility external
    //<
    styleName:"listGrid",

    //> @attr listGrid.data (List of ListGridRecord : null : IRW)
    // A list of ListGridRecord objects, specifying the data to be used to populate the
    // ListGrid.  In ListGrids, the data array specifies rows.
    // <p>
    // When using a +link{DataSource}, rather than directly providing <code>data</code>, you will
    // typically call +link{fetchData()} instead, which will automatically establish
    // <code>data</code> as a +link{class:ResultSet,ResultSet} (see the +link{fetchData()} docs for details).
    // <p>
    // If you call <code>fetchData</code>, any previously supplied <code>data</code> is
    // discarded.  Also, it is not necessary to call <code>setData()</code> after calling
    // +link{ListGrid.fetchData()}.
    // <p>
    // When calling <code>setData()</code><smartgwt>,
    // if <code>data</code> is provided as a RecordList or ResultSet</smartgwt>, direct changes
    // to the list using Framework APIs such as <smartclient>+link{list.add()} or 
    // +link{list.remove()}</smartclient><smartgwt>+link{RecordList.add()} or 
    // +link{RecordList.remove()}</smartgwt> will be automatically <smartclient>observed</smartclient>
    // <smartgwt>detected</smartgwt> and the
    // ListGrid will redraw in response. However, direct changes to individual Records will not
    // be automatically <smartclient>observed</smartclient><smartgwt>detected</smartgwt>
    // and require calls to +link{refreshCell()} or 
    // +link{refreshRow()} to cause the ListGrid to visually update.  Calling methods such as
    // +link{ListGrid.updateData()}, +link{removeData()} or +link{addData()} always causes
    // automatic visual refresh.
    // <smartclient><p>
    // Note that direct manipulation of the data object without using the +link{List} APIs (for
    // example by directly assigning a new Record object to some index or calling non-Framework
    // APIs such as pop(), shift(), etc.) will not be reflected in the grid automatically, but 
    // developers can call +link{list.dataChanged()} directly to notify the grid of changes.
    // </smartclient>
    //
    // @group data
    // @see ListGridRecord
    // @setter setData()
    // @visibility external
    // @example inlineData
    // @example localData
    //<

    // useCellRecords - Is our data model going to be one record per cell or one record per row?
    useCellRecords:false,

    //> @object ListGridRecord
    // <smartclient>A ListGridRecord is a JavaScript Object whose properties contain values for each
    // +link{ListGridField}.</smartclient>
    // <smartgwt>ListGridRecord represents a JavaScript Object whose properties contain values 
    // for each +link{ListGridField}.</smartgwt> A ListGridRecord may have additional properties 
    // which affect the record's appearance or behavior, or which hold data for use by custom logic 
    // or other, related components.
    // <p>
    // <smartclient>
    // For example a ListGrid that defines the following fields:
    // <pre>
    // fields : [
    //     {name: "field1"},
    //     {name: "field2"}
    // ],
    // </pre>
    // </smartclient>
    // <smartgwt>
    // For example, if a ListGrid is getting its ListGridFields from the following DataSource definition:
    // <pre>
    // &lt;DataSource ... &gt;
    //      &lt;fields&gt;
    //          &lt;field name="field1" ... /&gt;
    //          &lt;field name="field2" ... /&gt;
    //      &lt;/fields&gt;
    // &lt;/DataSource&gt;
    // </pre>
    // </smartgwt>
    // <smartgwt>It might</smartgwt><smartclient>Might</smartclient> have the following data:
    // <P>
    // <pre>
    // data : [
    //     {field1: "foo", field2: "bar", customProperty:5},
    //     {field1: "field1 value", field2: "field2 value", enabled:false}
    // ]
    // </pre>
    // <smartclient>
    // Each line of code in the <code>data</code> array above creates one JavaScript Object via
    // JavaScript +link{type:ObjectLiteral,object literal} notation.  These JavaScript Objects are
    // used as ListGridRecords.
    // </smartclient>
    // <smartgwt>
    // The sample data shown above is in JSON format, and might be how data is returned from a REST 
    // web service.
    // </smartgwt>
    // <P>
    // Both records shown above have properties whose names match the name property of a
    // ListGridField, as well as additional properties. The second record will be disabled due to
    // <code>enabled:false</code>; the first record has a property "customProperty" which will
    // have no effect by default but which may be accessed by custom logic.
    // <P>
    // <smartgwt>
    // The same records could be constructed in Java like so:
    // <P>
    // <pre>
    // ListGridRecord records[] = new ListGridRecord[2];
    // records[0] = new ListGridRecord();
    // records[0].setAttribute("field1", "foo");
    // records[0].setAttribute("field2", "bar");
    // records[0].setAttribute("customProperty", 5);
    //
    // records[1] = new ListGridRecord();
    // records[1].setAttribute("field1", "field1 value");
    // records[1].setAttribute("field2", "field2 value");
    // records[1].setAttribute("enabled", false);
    // 
    // RecordList recordList = new RecordList();
    // recordList.addList(records);
    // </pre>
    // </smartgwt>
    // <P>
    // After a ListGrid is created and has loaded data, records may be accessed via
    // <smartgwt>
    // {@link com.smartgwt.client.widgets.grid.ListGrid#getDataAsRecordList()},
    // which will return a +link{ResultSet} (a subclass of
    // {@link com.smartgwt.client.data.RecordList}) if the listGrid is bound to a DataSource.
    // </smartgwt>
    // <smartclient>
    // +link{listGrid.data, listGrid.getData()}, for example, listGrid.getData().get(0) retrieves the first record.
    // +link{ListGrid.data} may be a +link{ResultSet} if the listGrid is bound to a DataSource.
    // </smartclient>
    // ListGridRecords are also passed to many events, such as
    // +link{ListGrid.cellClick,cellClick()}.
    // <P>
    // A ListGridRecord is <smartgwt>a wrapper around</smartgwt><smartclient>always</smartclient>
    // an ordinary JavaScript Object regardless of how the grid's
    // dataset is loaded (static data, java server, XML web service, etc), 
    // <smartclient>
    // and so supports the normal behaviors of JavaScript Objects, including accessing and 
    // assigning to properties via dot notation:
    // <pre>
    //     var fieldValue = record.<i>fieldName</i>;
    //     record.<i>fieldName</i> = newValue;
    // </pre>
    // </smartclient>
    // <smartgwt>
    // where you have access to its properties via setAttribute() and getAttribute() methods:
    // <pre>
    // record.setAttribute("field1", "foo");
    // String value1 = record.getAttribute("field1");
    // </pre>
    // </smartgwt>
    // <P>
    // Note however that simply assigning a value to a record won't cause the display to be
    // automatically refreshed - +link{listGrid.refreshCell()} needs to be called.  Also,
    // consider +link{group:editing,editValues vs saved values} when directly modifying
    // ListGridRecords.
    // <P>
    // See the attributes in the API tab for the full list of special properties on
    // ListGridRecords that will affect the grid's behavior.
    //
    // @treeLocation Client Reference/Grids/ListGrid
    // @inheritsFrom Record
    // @visibility external
    //<
    


    //> @attr listGrid.recordEnabledProperty (String : "enabled" : IR)
    // Property name on a record that will be checked to determine whether a record is enabled.
    // <P>
    // Setting this property on a record will effect the visual style and interactivity of
    // the record.  If set to <code>false</code> the record (row in a +link{ListGrid} or
    // +link{TreeGrid}) will not highlight when the mouse moves over it, nor will it respond to
    // mouse clicks.
    //
    // @see listGridRecord.enabled
    // @example disabledRows
    // @visibility external
    //<
    
    recordEnabledProperty: "enabled",

    //> @attr listGridRecord.enabled (boolean : null : IR)
    //
    // Default property name denoting whether this record is enabled. Property name may be
    // modified for some grid via +link{listGrid.recordEnabledProperty}.
    //
    // @visibility external
    // @example disabledRows
    //<

    //> @attr listGrid.canExpandRecordProperty (String : "canExpand" : IR)
    // Property name on a record that will be checked to determine whether a record can be
    // expanded.
    //
    // @see listGridRecord.canExpand
    // @group expansionField
    // @visibility external
    //<
    canExpandRecordProperty: "canExpand",

    //> @attr listGridRecord.canExpand (boolean : null : IR)
    //
    // Default property name denoting whether this record can be expanded. Property name may be
    // modified for the grid via +link{listGrid.canExpandRecordProperty}.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.recordCanRemoveProperty (String : "_canRemove" : IRA)
    // If set to false on a record and +link{ListGrid.canRemoveRecords,canRemoveRecords} is
    // true, removal of that record is disallowed in the UI. The icon in the remove field
    // is not shown.
    // @group  editing
    // @visibility external
    //<
    recordCanRemoveProperty:"_canRemove",

    //> @attr listGridRecord._canRemove (boolean : null : IRW)
    //
    // Default property name denoting whether this record can be removed. Property name may be
    // modified for the grid via +link{listGrid.recordCanRemoveProperty}.
    //
    // @group  editing
    // @visibility external
    //<

    //> @attr listGridRecord.isSeparator (boolean : null : IR)
    //
    // Default property name denoting a separator row.<br>
    // When set to <code>true</code>, defines a horizontal separator in the listGrid
    // object. Typically this is specified as the only property of a record object, since a
    // record with <code>isSeparator:true</code> will not display any values.<br>
    // Note: this attribute name is governed by +link{ListGrid.isSeparatorProperty}.
    // @visibility external
    //<

    //> @attr listGridRecord.customStyle (CSSStyleName : null : IRW)
    // Name of a CSS style to use for all cells for this particular record.
    // <P>
    // Note that using this property assigns a single, fixed style to the record, so rollover
    // and selection styling are disabled.  To provide a series of stateful styles for a record
    // use +link{listGridRecord._baseStyle} instead.
    // <P>
    // See +link{listGrid.getCellStyle()} for an overview of various ways to customize styling,
    // both declarative and programmatic.
    // <P>
    // If this property is changed after draw(), to refresh the grid call
    // +link{listGrid.refreshRow()} (or +link{listGrid.markForRedraw()} if several rows are
    // being refreshed).
    // <P>
    // If your application's data uses the "customStyle" attribute for something else, the
    // property name can be changed via +link{listGrid.recordCustomStyleProperty}.
    //
    // @visibility external
    //<

    //> @attr listGridRecord._baseStyle (CSSStyleName : null : IRW)
    // Name of a CSS style to use as the +link{listGrid.baseStyle} for all cells for this
    // particular record.
    // <P>
    // The styleName specified with have suffixes appended to it as the record changes state
    // ("Over", "Selected" and so forth) as described by +link{listGrid.getCellStyle()}.  For a
    // single, fixed style for a record, use +link{listGridRecord.customStyle} instead.
    // <P>
    // See +link{listGrid.getCellStyle()} for an overview of various ways to customize styling,
    // both declarative and programmatic.
    // <P>
    // If this property is changed after draw(), to refresh the grid call
    // +link{listGrid.refreshRow()} (or +link{listGrid.markForRedraw()} if several rows are
    // being refreshed).
    // <P>
    // If your application's data uses the "_baseStyle" attribute for something else, the
    // property name can be changed via +link{listGrid.recordBaseStyleProperty}.
    //
    // @visibility external
    //<

    //> @attr listGridRecord.singleCellValue (HTMLString : null : IRW)
    // Default property name denoting the single value to display for all fields of this row.
    // If this property is set for some record, the record will be displayed as a single
    // cell spanning every column in the grid, with contents set to the value of this
    // property.<br>
    // Note: this attribute name is governed by +link{ListGrid.singleCellValueProperty}.
    // @visibility external
    //<


    //> @attr listGridRecord.canDrag (boolean : null : IR)
    //
    // When set to <code>false</code>, this record cannot be dragged. If canDrag is false for
    // any record in the current selection, none of the records will be draggable.
    //
    // @visibility external
    //<

    //> @attr listGridRecord.canAcceptDrop (boolean : null : IR)
    //
    // When set to <code>false</code>, other records cannot be dropped on (i.e., inserted
    // via drag and drop) immediately before this record.
    //
    // @visibility external
    //<

    //> @attr listGridRecord.linkText (String : null : IRW)
    //
    //  The HTML to display in this row for fields with fieldType set to link. This overrides
    //  +link{attr:listGridField.linkText}.
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @see attr:listGridField.linkText
    //  @see attr:listGrid.linkTextProperty
    //  @group  display_values
    //  @visibility external
    //<

    // Animation
    // ---------------------------------------------------------------------------------------
    // These apply to ListGrid grouping, which basically makes the data model into a Tree where animation
    // is applied for folder open/close.

    //> @attr listGrid.animateFolders (Boolean : true : IRW)
    // If true, when folders are opened / closed children will be animated into view.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    //<
    animateFolders:true,

    //> @attr listGrid.animateFolderMaxRows (Integer : null : IRW)
    // If +link{animateFolders} is true for this grid, this number can be set to designate
    // the maximum number of rows to animate at a time when opening / closing a folder.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @see treeGrid.getAnimateFolderMaxRows()
    // @group animation
    // @visibility external
    //<

    //> @attr listGrid.animateFolderTime (number : 100 : IRW)
    // When animating folder opening / closing, if +link{treeGrid.animateFolderSpeed} is not
    // set, this property designates the duration of the animation in ms.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    // @see listGrid.animateFolderSpeed
    //<
    animateFolderTime:100,

    //> @attr listGrid.animateFolderSpeed (number : 3000 : IRW)
    // When animating folder opening / closing, this property designates the speed of the
    // animation in pixels shown (or hidden) per second. Takes precedence over the
    // +link{treeGrid.animateFolderTime} property, which allows the developer to specify a
    // duration for the animation rather than a speed.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    // @see listGrid.animateFolderTime
    //<
    animateFolderSpeed:3000,

    //> @attr listGrid.animateFolderEffect (AnimationAcceleration : null : IRW)
    // When animating folder opening / closing, this property can be set to apply an
    // animated acceleration effect. This allows the animation speed to be "weighted", for
    // example expanding or collapsing at a faster rate toward the beginning of the animation
    // than at the end.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation
    //<

    //> @attr listGrid.animateRowsMaxTime (number : 1000 : IRW)
    // If animateFolderSpeed is specified as a pixels / second value, this property will cap
    // the duration of the animation.
    // <P>
    // For a ListGrid, this property applies when +link{ListGrid.canGroupBy,grouping} is enabled.
    // @group animation
    // @visibility animation_advanced
    //<
    animateRowsMaxTime:1000,

    // external: doc'd on TreeGrid
    shouldAnimateFolder : function (folder) {
        if (!this.animateFolders || !this.isDrawn()) return false;
        
        if (this.autoFitData == "vertical" || this.autoFitData== "both") return false;

        var nodeLocator;
        if (this.data.isANodeLocator(folder)) {
            nodeLocator = folder;
            folder = folder.node;
        }

        var children;
        if (this.data.isFolder(folder)) {
            // Since we are only checking whether there are opened children, don't apply sorting
            // (the dontUseNormalizer parameter is true).
            children = this.data.getOpenList(nodeLocator || folder, null, null, null, null, null, null, true);
        }

        // No children - bit arbitrary whether we "animate" or not!
        
        if (children == null || children.length <= 1) return false;
        return (children.length <= this.getAnimateFolderMaxRows());
    },

    // external: doc'd on TreeGrid
    // returns the min of (3x the viewport row-count) or 75, meaning a given node may
    // or may not animate on open/close depending on the current grid height
    getAnimateFolderMaxRows : function () {
        var maxRows = this.animateFolderMaxRows;
        if (maxRows == null) {
            var vfRs = this.body ? this.body._getViewportFillRows() : [0,0];
            maxRows = Math.min(75, (vfRs[1]-vfRs[0]) * 3);
        }
        return maxRows
    },


    // DataBinding
    // ----------------------------------------------------------------------------------------

    //> @attr listGrid.fields (Array of ListGridField : null : [IRW])
    // An array of field objects, specifying the order, layout, formatting, and
    // sorting behavior of each field in the listGrid object.  In ListGrids, the fields
    // array specifies columns.  Each field in the fields array is a ListGridField object.
    // Any listGrid that will display data should have at least one visible field.
    // <p>
    // If +link{ListGrid.dataSource} is also set, this value acts as a set of overrides as
    // explained in +link{attr:DataBoundComponent.fields}.
    //
    // @see    ListGridField
    // @see    setFields()
    // @group databinding
    // @visibility external
    // @example listGridFields
    // @example mergedFields
    //<

    //> @attr listGrid.defaultFields (Array of ListGridField Properties : null : IRA)
    // An array of listGrid field configuration objects.  When a listGrid is initialized, if this
    // property is set and there is no value for the <code>fields</code> attribute, this.fields will
    // be defaulted to a generated array of field objects duplicated from this array.
    // <P>
    // This property is useful for cases where a standard set of fields will be displayed
    // in multiple listGrids - for example a subclass of ListGrid intended to display a particular
    // type of data:<br>
    // In this example we would not assign a single +link{listGrid.fields} array directly to the
    // class via <code>addProperties()</code> as every generated instance of this class would
    // then point to the same fields array object. This would cause unexpected behavior such as
    // changes to the field order in one grid effecting other grids on the page.<br>
    // Instead we could use <code>addProperties()</code> on our new subclass to set
    // <code>defaultFields</code> to a standard array of fields to display. Each generated instance
    // of the subclass would then show up with default fields duplicated from this array.
    // @visibility external
    //<

    //> @attr   listGrid.dataSource     (DataSource | ID : null : IRW)
    // @include dataBoundComponent.dataSource
    //<

    //> @attr listGrid.dataArity (String : "multiple" : IRWA)
    // A ListGrid is a +link{dataBoundComponent.dataArity,dataArity}:multiple component.
    // @group databinding
    // @visibility external
    //<

    //> @attr listGrid.autoFetchDisplayMap (Boolean : true : [IRW])
    // If true, for fields where +link{listGridField.optionDataSource} is specified,
    // a valueMap will be automatically created by making a +link{dataSource.fetchData()} call
    // against the specified dataSource and extracting a valueMap from the returned records
    // based on the displayField and valueField.
    // <P>
    // If set to false, valueMaps will not be automatically fetched.  In this case, setting
    // field.optionDataSource is effectively a shortcut for setting optionDataSource on
    // the editor via +link{listGridField.editorProperties}.
    // <P>
    // Can also be disabled on a per-field basis with +link{listGridField.autoFetchDisplayMap}.
    //
    // @group display_values
    // @see listGridField.autoFetchDisplayMap
    // @see listGridField.optionDataSource
    // @visibility external
    //<
    autoFetchDisplayMap:true,

    //> @attr listGrid.warnOnUnmappedValueFieldChange (Boolean : true : IRWA)
    // If a field has +link{listGridField.displayField} specified and has no
    // +link{listGridField.optionDataSource}, this field will display the value from the
    // <code>displayField</code> of each record by default (for more on this behavior
    // see +link{listGridField.optionDataSource}).
    // <P>
    // If such a field is editable, changing the edit value for the field on some record,
    // without updating the edit value for the associated display field on the same record
    // would mean the user would continue to see the unchanged display field value.
    // Developers can resolve this situation by programmatically setting an edit value for
    // the display field as well as the data field, or avoid it by specifying an optionDataSource
    // and ensuring +link{listGrid.autoFetchDisplayMap} is true, or setting an explicit valueMap
    // for the field.
    // <P>
    // By default, when the edit value on a field with a specified displayField and
    // no optionDataSource is set, we log a warning to notify the developer. This warning may
    // be disabled by setting <code>warnOnUnmappedValueFieldChange</code> to <code>false</code>.
    // <P>
    // Note: There are actually a couple of cases in which the system will automatically
    // derive a new display-field value and apply it to the record:
    // <ol><li>If the edit value was changed by a user actually editing the record
    // (rather than a programmatic call to setEditValue()), and the edit-item had
    // a valueMap or optionDataSource set, we automatically pick up the display value from
    // that item and store it as an edit-value for the displayField of the record</li>
    //     <li>If the listGrid has a loaded record in its data set whose valueField value matches
    // the edit value for the valueField, we automatically apply the displayField value from that
    // record as an edit value for the displayField on the newly edited record.</li></ol>
    // In either case, the display value for the record is updated automatically
    // (and the warning would not be logged).
    // @visibility external
    //<
    warnOnUnmappedValueFieldChange:true,

    //or <code>autoFetchDisplayMap</code> is false at
    // the +link{listGrid.autoFetchDisplayMap,listGrid}
    // or +link{listGridField.autoFetchDisplayMap,field} level, the field will display the
    // record value from the +link{

    //> @attr listGrid.saveLocally (boolean : null : IRA)
    // For grids with a specified +link{ListGrid.dataSource}, this property can be set to
    // <code>true</code> to cause the grid directly update its local data set instead of
    // performing an operation against it's configured DataSource.
    // <p>
    // When using this mode, data must be provided to the grid via +link{listGrid.setData()},
    // and must be provided as 
    // <smartclient>a simple Array of Records</smartclient>
    // <smartgwt>a RecordList</smartgwt>.  Setting <code>saveLocally</code> is invalid if
    // either +link{fetchData()} is called or if a +link{ResultSet} is provided as the data
    // model.
    // <p>
    // <code>saveLocally</code> mode includes changes made via 
    // +link{listGrid.canEdit,inline editing}, record removal via +link{canRemoveRecords}, as
    // well as programmatic calls to +link{listGrid.updateData()},
    // +link{listGrid.addData,addData()} and +link{listGrid.removeData,removeData()}.  This
    // also causes saves to be performed synchronously (unlike normal DataSource operations).
    // <p>
    // Note that using this mode also disables the automatic cache synchronization provided by
    // the DataSource system - changes made to this grid are saved only to this grid's data
    // set.
    // <P>
    // See also +link{listGrid.filterLocalData} to allow filtering, such as filtering performed
    // by the +link{filterEditor}, to also work only with the local data set.
    // <P>
    // If saveLocally is unset, and +link{listGrid.filterLocalData} is true, the saveLocally behavior is
    // enabled by default
    // 
    // @see useRemoteValidators
    // @visibility external
    // @group databinding
    //<
    

    //> @attr ListGrid.saveRequestProperties (DSRequest Properties : null : IRWA)
    // For editable grids with a specified +link{listGrid.dataSource}, where
    // +link{listGrid.saveLocally} is false, this attribute may be used to specify standard
    // DSRequest properties to apply to all save operations performed by this grid (whether
    // triggered by user interaction, or explicit saveEdits or saveAllEdits call).
    // <P>
    // An example usage would be to customize the prompt displayed while saving is in progress
    // if +link{listGrid.waitForSave} is true.
    // <P>
    // Note that for more advanced customization of save operations,
    // +link{dataBoundComponent.addOperation} and +link{dataBoundComponent.updateOperation}
    // are available to developers, allowing specification of an explicit +link{operationBinding}
    // for the add / update operation performed on save.
    //
    // @visibility external
    // @group databinding
    // @group editing
    //<

    //> @attr ListGrid.useRemoteValidators (boolean : null : IRWA)
    // If +link{listGrid.saveLocally} is specified, but this grid is bound to a DataSource which
    // includes remote field validators, by default edits will be saved synchronously and
    // these validators will not be executed.<br>
    // Set this property to <code>true</code> to ensure these remote validators are called when
    // saving edits in saveLocally mode. Note that since these remote validators need to run on
    // the server, saving with this property set is asynchronous, even though the data that
    // ultimately gets updated is already present on the client.
    // @visibility external
    // @group databinding
    //<

    //> @attr listGrid.useAllDataSourceFields (boolean : null : IRW)
    // @include dataBoundComponent.useAllDataSourceFields
    // @group databinding
    //<

    //> @attr listGrid.showDetailFields (Boolean : true : IR)
    // Whether to include fields marked <code>detail:true</code> from this component's
    // <code>DataSource</code>.
    // <P>
    // When this property is <code>true</code>, the <code>ListGrid</code> will include all
    // detail fields unless fields have been specifically declared using the
    // +link{listGrid.fields} array.
    // <P>
    // Any field which has been included directly in the <code>fields</code> array will be
    // included regardless of the fields <code>detail</code> attribute.
    // <p>
    // Detail fields included will initially be hidden but the user may show these fields via
    // the default header context menu (+link{listGrid.showHeaderContextMenu}).
    // <P>
    // The field's visibility can also be overridden programatically using the standard
    // +link{listGrid.showField()}, +link{listGrid.hideField()} and +link{listGridField.showIf}
    // APIs, for example, set showIf:"true" to show a detail field initially.
    // <P>
    // Setting this property to false will completely exclude all detail fields from the list
    // grid's fields array, such that they cannot be shown by the user or programmatically.
    //
    // @group databinding
    // @visibility external
    //<
    showDetailFields:true,

    //> @attr listGrid.showEllipsisWhenClipped (boolean : true : IRW)
    // Should ellipses be displayed when cell content is clipped? May be overridden at the field 
    // level via +link{listGridField.showEllipsisWhenClipped}
    // @visibility external
    //<
    showEllipsisWhenClipped:true,
    
    //> @attr ListGrid.titleField (String : see below : IRW)
    // Best field to use for a user-visible title for an individual record from this grid.
    // If +link{ListGrid.dataSource} is non null, this property may be specified on the
    // dataSource instead.
    // <p>
    // If not explicitly set, titleField looks for fields named "title", "name", and "id"
    // in that order.  If a field exists with one of those names, it becomes the titleField.
    // If not, then the first field is designated as the titleField.
    //  @visibility external
    //<

    //> @attr listGrid.dataProperties (ResultSet : null :IRWA)
    // For databound ListGrids, this attribute can be used to customize the +link{ResultSet}
    // object created for this grid when data is fetched
    // @group databinding
    // @visibility external
    //<


    // Saved Search
    // ---------------------------------------------------------------------------------------
    savedSearchItemDefaults: {
        _constructor: "SavedSearchItem"
    },

    //> @attr listGrid.saveDefaultSearch (boolean : true : IR)
    // Saves the name of the default search to localStorage, under the key "sc_defaultSearch:" + minimal
    // locator.
    // <p>
    // See +link{SavedSearches} "Default Searches" for why this is stored separately from the search itself
    // if there is no saved default search, but there is a +link{SavedSearches.defaultField}, the first
    // user-specfic search marked default will be used, otherwise the first admn search marked default
    // <p>
    // If +link{autoFetchData} is enabled, the autoFetch will be postponed as needed until a default search can be
    // looked up and applied.  If anything fails in the default search lookup, an autoFetch will still be
    // performed (without any saved search information)
    // @visibility external
    //<
    saveDefaultSearch: true,

    //> @attr listGrid.canSaveSearches (boolean : true : IR)
    // When enabled (the default), causes a "Saved views >" submenu to appear in the header context menu, last, allowing the user to
    // create new saved searches, select previously saved searches, and edit or copy existing searches.
    // <p>
    // Note that disabling this feature does not mean that saved searches are disallowed - you can stil implement a separate UI via a +link{SavedSearchItem}
    // that targets this component. But, when disabled, the grid-integrated menu described above will not be shown.
    // <p>
    // This feature uses the global settings found in +link{SavedSearches}.  Some aspects can be overridden for this
    // component.  See +link{savedSearchDS}, +link{savedSearchAdminRole}.
    // <p>
    // <b>Note:</b> this feature requires
    // +externalLink{https://www.smartclient.com/product/,SmartClient Pro} or better.
    // @visibility external
    //<
    


    //> @attr listGrid.savedSearchStoredState (SavedSearchStoredState : null : IR)
    // @include savedSearchItem.storedState
    // @visibility external
    //<
    savedSearchStoredState: null,

    //> @attr listGrid.noSavedSearchesText (HTMLString : "[None]" : IR)
    // Text to show in menu listing saved searches when there are no saved searches.
    // @visibility external
    // @group i18nMessages
    //<
    noSavedSearchesText: "[None]",

    //> @attr listGrid.savedSearchText (HTMLString : "Saved views" : IR)
    // Text to show for the saved searches submenu.
    // @visibility external
    // @group i18nMessages
    //<
    savedSearchText: "Saved views",

    //> @attr listGrid.newSearchText (HTMLString : "Save View..." : IR)
    // Text to show for saving the current view as a new "saved search".
    // @visibility external
    // @group i18nMessages
    //<
    newSearchText: "Save View...",

    //> @attr listGrid.savedSearchAdminSeparator (AutoChild ListGridRecord : {isSeparator:true} : IR)
    // Properties for the separator record between locally saved and admin searches.
    // @visibility external
    //<
    savedSearchAdminSeparatorDefaults: {
        isSeparator: true
    },

    //> @attr listGrid.savedSearchDS (String : null : IR)
    // Override of +link{SavedSearches.defaultDataSource} for this component.
    // @visibility external
    //<

    //> @attr listGrid.savedSearchAdminRole (String : null : IR)
    // Override of +link{SavedSearches.adminRole} for this component.
    // @visibility external
    //<

    // Grouping
    // ---------------------------------------------------------------------------------------

    //> @object GroupNode
    //
    // An auto-generated subclass of +link{TreeNode} representing the group nodes
    // in a grouped +link{ListGrid}.
    //
    // @see listGrid.groupBy()
    // @treeLocation Client Reference/Grids/ListGrid
    // @group grouping
    // @visibility external
    //<

    //> @attr groupNode.groupMembers (Array of ListGridRecord | GroupNode : see below : R)
    // Array of ListGridRecord that belong to this group, or, for multi-field grouping, array
    // of groupNodes of subgroups under this groupNode.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr groupNode.groupTitle (HTMLString : see below : R)
    // The computed title for the group, which results from +link{listGridField.getGroupTitle()}
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr groupNode.groupValue (Any : see below : R)
    // The value from which groups are computed for a field,
    // which results from +link{listGridField.getGroupValue()}
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr groupNode.groupName (FieldName : see below : R)
    // Name of the field being grouped by this node.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr listGrid.originalData (Object : null : R)
    // When grouped, a copy of the original ungrouped data.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr listGrid.groupTree (AutoChild Tree : null : R)
    // The data tree that results from a call to  +link{listGrid.groupBy()}.
    // This will be a +link{ResultTree} if +link{listGrid.dataSource} is
    // present, otherwise it will be a +link{Tree}.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @type GroupStartOpen
    // Possible values for the state of ListGrid groups when groupBy is called
    //
    // @value "all" open all groups
    // @value "first" open the first group
    // @value "none" start with all groups closed
    // @visibility external
    //<

    //> @attr listGrid.groupStartOpen (GroupStartOpen | Array : "first" : IRW)
    // Describes the default state of ListGrid groups when groupBy is called.
    //
    // Possible values are:
    // <ul>
    // <li>"all": open all groups
    // <li>"first": open the first group
    // <li>"none": start with all groups closed
    // <li>Array of group values that should be opened
    // </ul>
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    groupStartOpen:"first",

    //> @attr listGrid.canCollapseGroup (Boolean : true : IR)
    // Can a group be collapsed/expanded? When true a collapse/expand icon is shown
    // (+link{groupIcon,groupIcon}) and the user can collapse or expand the group by
    // clicking either the row as a whole or the opener icon (see +link{collapseGroupOnRowClick});
    //
    // When false the group icon is not shown and clicking on the row does
    // not change group state. Additionally +link{groupStartOpen,groupStartOpen} is
    // initialized to "all".
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    
    canCollapseGroup:true,
    
    //> @attr listGrid.collapseGroupOnRowClick (boolean : true : IR)
    // If +link{canCollapseGroup} is true, will a click anywhere on the group row
    // toggle the group's expanded state? If false, the user must click the
    // +link{groupIcon} directly to toggle the group.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    collapseGroupOnRowClick:true,

    //> @attr listGrid.groupTitleField (String : null : IR)
    // When a list grid is +link{listGrid.groupBy(),grouped}, each group shows
    // under an auto generated header node. By default the title of the group will be
    // shown, with a hanging indent in this node, and will span all columns in the grid.
    // Setting this property causes the titles of auto-generated group nodes to appear as
    // though they were values of the designated field instead of spanning all columns
    // and record values in the designated groupTitleField will appear indented under
    // the group title in a manner similar to how a TreeGrid shows a Tree.
    // <P>
    // Note if +link{listGrid.showGroupSummaryInHeader} is true, the header nodes will not show
    // a single spanning title value by default - instead they will show the summary values for
    // each field. In this case, if groupTitleField is unset, a
    // +link{listGrid.showGroupTitleColumn,groupTitleColumn} can be automatically generated to
    // show the title for each group.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    
    getGroupTitleField : function () {
        return this.groupTitleField;
    },

    _isGroupTitleField : function (field) {
        var groupTitleField = this.getGroupTitleField();
        return groupTitleField == null ? field._isGroupTitleColumn :
                                         field.name == groupTitleField;
    },

    //> @attr listGrid.showGroupTitleColumn (Boolean : true : IR)
    // If this grid is +link{listGrid.groupBy(),grouped} and +link{listGrid.showGroupSummaryInHeader}
    // is true, instead of group header nodes showing up with a single cell value spanning the full
    // set of columns, summaries for each field will show up in the appropriate columns of the
    // header node.
    // <P>
    // In this case there are 2 options for where the group title will show up. Developers may
    // specify an existing field to put the title values into via +link{listGrid.groupTitleField}.
    // If no groupTitleField is specified, this property may be set to <code>true</code>
    // which causes a <code>groupTitleColumn</code> to be automatically generated.
    // Each group header will show the group title in this column (records within the group will
    // not show a value for this column). The column appears in the leftmost position within the
    // grid (unless +link{listGrid.showRowNumbers} is true, in which case this column shows up
    // in the second-leftmost position), and by default will auto-fit to its data.
    // <P>
    // To customize this field, developers may modify
    // +link{listGrid.groupTitleColumnProperties}
    // <smartclient>or
    // +link{listGrid.groupTitleColumnDefaults} at the class level.</smartclient>
    // @visibility external
    //<
    showGroupTitleColumn:true,

    //> @attr listGrid.groupTitleColumnProperties (ListGridField Properties : null : IR)
    // Custom properties for the automatically generated <code>groupTitleColumn</code>.
    // <P>
    // See +link{listGrid.showGroupTitleColumn} for an overview of the groupTitleColumn.
    // @visibility external
    //<
    //groupTitleColumnProperties:null,

    //> @attr listGrid.groupTitleColumnDefaults (ListGridField Properties : object : IR)
    // Default properties for the automatically generated <code>groupTitleColumn</code>.
    // Default object includes properties to enable autoFitWidth to group title values.
    // <P>
    // To modify the behavior or appearance of this column, developers may set
    // +link{listGrid.groupTitleColumnProperties} at the instance level, or override this
    // object at the class level. If overriding this object, we recommend using
    // +link{class.changeDefaults()} rather than replacing this object entirely.
    // <P>
    // See +link{listGrid.showGroupTitleColumn} for an overview of the groupTitleColumn.
    // @visibility external
    //<
    groupTitleColumnDefaults:{
        canEdit:false,
        canFilter:false,
        canHide:false,
        canReorder:false,
        showDefaultContextMenu:false,
        autoFreeze:true,

        sortNormalizer:function (recordObject,fieldName,context) {
            return recordObject.groupTitle;
        },

        autoFitWidth:true,
        autoFitWidthApproach:"value",
        title:"&nbsp;"
    },

    // We actually show the special group title column if
    // - we're showing the group summary in the header
    // - we have no explicitly specified group title field
    // - the showGroupTitleColumn flag is true
    showingGroupTitleColumn : function () {
        return (this.isGrouped && this.showGroupSummary && this.showGroupSummaryInHeader
                && this.showGroupTitleColumn && this.getGroupTitleField() == null);
    },

    // groupTitleColumnName: This could be modified to display an actual field within the
    // grid data, but the developer might as well use groupTitleField instead.
    // Leaving unexposed for now.
    groupTitleColumnName:"groupTitle",

    getGroupTitleColumn : function () {
        var grid = this;
        var groupTitleColumn = isc.addProperties(
            {   _isGroupTitleColumn:true,
                // 'grid' available through closure
                getAutoFreezePosition: function () { return grid.getGroupTitleColumnPosition() }
            },
            this.groupTitleColumnDefaults,
            this.groupTitleColumnProperties
        );

        if (groupTitleColumn.name == null) {
            groupTitleColumn.name = this.groupTitleColumnName;
        }
        return groupTitleColumn;
    },

    getGroupTitleColumnPosition : function () {
        // This is really just a sanity check - we don't expect to be calling this method when
        // we're not showing the special groupTitleColumn
        if (!this.showingGroupTitleColumn()) return -1;

        
        var pos = 0;
        if (this.shouldShowRowNumberField())  pos++;
        if (this.shouldShowDragHandleField()) pos++;
        if (this.shouldShowCheckboxField())   pos++;
        if (this.shouldShowExpansionField())  pos++;
        return pos;
    },

    singleCellGroupHeaders : function () {
        return this._singleCellGroupHeaders(this.showGroupSummary, this.showGroupSummaryInHeader);
    },
    _singleCellGroupHeaders : function (showGroupSummary, showGroupSummaryInHeader) {
        if (this.getGroupTitleField() != null) return false;
        if (showGroupSummary && showGroupSummaryInHeader) return false;
        return true
    },

    //> @attr listGrid.showGroupSummaryInHeader (Boolean : false : IRW)
    // If this grid is +link{listGrid.groupBy(),grouped}, and +link{listGrid.showGroupSummary}
    // is true, setting this property causes field summary values for each group to be displayed
    // directly in the group header node, rather than showing up at the bottom of each
    // expanded group.
    // <P>
    // Note that this means the group header node will be showing multiple field values
    // rather than the default display of a single cell spanning all columns containing the
    // group title. Developers may specify an explicit +link{listGrid.groupTitleField}, or
    // rely on the automatically generated +link{listGrid.showGroupTitleColumn,groupTitleColumn}
    // to have group titles be visible as well as the summary values.
    // <P>
    // Also note that multi-line group summaries are not supported when showing
    // the group summary in the group header. If multiple
    // +link{listGridField.summaryFunction,field summary functions} are defined for some field
    // only the first will be displayed when this property is set to true.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    showGroupSummaryInHeader:false,

    //> @attr listGrid.showCollapsedGroupSummary (Boolean : false : IRW)
    // Should group summaries be visible when the group is collapsed?
    // <P>
    // This property only applies to +link{listGrid.groupBy(),grouped} grids showing
    // +link{listGrid.showGroupSummary,group summary rows}. When set to true, the
    // group summary row(s) for each group will show up under the group header nodes when
    // the group is collapsed, or at then end of the grouped set of data if the group
    // is expanded.
    // <P>
    // This property has no effect if +link{showGroupSummaryInHeader} is true.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    showCollapsedGroupSummary:false,

    //> @method listGridField.getGroupValue()
    // Return the value which records should be grouped by.
    // <P>
    // All records for which getGroupValue() returns the same value appear in the same
    // group.  Default is the result of +link{listGrid.getCellValue}.
    // <P>
    // While any type of value may be returned, avoiding the use of string values may
    // result in improved performance. In this case, +link{listGridField.getGroupTitle()}
    // may be implemented to map a numeric group value into a legible string.
    //
    // @param   value (Any)   raw value for the cell, from the record for the row
    // @param   record (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter (see +link{listGrid.getEditValues()})
    // @param   field (Object)    Field object for which to get group value
    // @param   fieldName (String)    The name of the field
    // @param   grid (ListGrid) the ListGrid displaying the cell
    // @return (Any) Group value to which this record belongs
    //
    // @see listGrid.groupBy()
    // @see listGridField.getGroupTitle()
    // @group grouping
    // @visibility external
    // @example customGrouping
    //<

    //> @method listGridField.getGroupTitle()
    // Return the title that should be shown to the user for the group with the
    // <code>groupValue</code> passed as a parameter.
    // <P>
    // Default title is the groupValue itself.
    //
    // @group grouping
    //
    // @param   groupValue (Any)   the value from the group is created, the result of
    //  +link{listGridField.getGroupValue()}
    // @param   groupNode (GroupNode) the node in the grid containing the group.
    // @param   field (Object)    Field object for which to get group value
    // @param   fieldName (String)    The name of the field
    // @param   grid (ListGrid) the ListGrid displaying the cell
    // @return (Any) Group value to which this record belongs
    //
    // @see listGrid.groupBy()
    // @see listGridField.getGroupValue()
    // @visibility external
    // @example customGrouping
    //<

    //> @attr listGridField.groupingModes (ValueMap : null : IR)
    // If this field can be grouped, this attribute represents the set of grouping styles that 
    // are available.  For example, a "date" field might be able to be 
    // grouped by week or month, as well as by the date itself.
    // <P>
    // If <code>groupingModes</code> are present and
    // +link{listGrid.canGroupBy,grouping is enabled}, the menu for this field includes a
    // submenu of possible grouping modes generated from the <code>groupingModes</code> valueMap.
    // When the user selects a particular grouping mode,
    // +link{listGridField.groupingMode,field.groupingMode} is set to the user's chosen mode,
    // and this choice can be detected via the <code>field</code> parameter to
    // +link{listGridField.getGroupValue()} in order to provide different modes of grouping.
    // <P>
    // The user may also choose to group records without specifying a grouping mode, in this case,
    // the +link{listGridField.defaultGroupingMode} is used.
    // <P>
    // Note that <code>getGroupValue</code>, <code>groupingModes</code> et al can be specified on
    // +link{SimpleType} declarations.  See this list of
    // +link{group:builtinGroupingModes, builtin grouping modes} for more information.    
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.groupingMode (Identifier : null : IR)
    // For a field that allows multiple +link{listGridField.groupingModes,grouping modes},
    // the current grouping mode.
    // <P>
    // This property is set when a user chooses a particular grouping mode, and may be set on
    // ListGrid creation to affect the initial grouping.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.defaultGroupingMode (Identifier : null : IR)
    // Default groupingMode used when the user does not specify a mode or grouping is triggered
    // programmatically and +link{listGridField.groupingMode,field.groupingMode} is unset.
    // See +link{listGridField.groupingModes,field.groupingModes}.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.groupPrecision (Integer : null : IR)
    // For fields of type:"float" or derived from float, number of digits after the decimal point
    // to consider when grouping.
    // <P>
    // For example, <code>groupPrecision:2</code> indicates that 45.238 and 45.231 group together,
    // but 45.22 and 45.27 are separate.
    // <P>
    // See also +link{listGridField.groupGranularity,groupGranularity} for grouping by broader
    // ranges.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.groupGranularity (Integer : null : IR)
    // Granularity of grouping for numeric fields.
    // <P>
    // Groups will be formed based on ranges of values of size <code>groupGranularity</code>.  For
    // example, if groupGranularity were 1000, groups would be 0-1000, 1000-2000, etc.
    //
    // @group grouping
    // @visibility external
    //<

    //> @attr listGridField.canHilite (boolean : null : IRW)
    // Determines whether this field can be hilited.  Set to false to prevent this
    // field from appearing in HiliteEditor.
    //
    // @visibility external
    //<

    //> @attr listGridField.showHilitesInGroupSummary (Boolean : null : IRW)
    // Determines whether hiliting for this field is shown in a group summary.
    // Set to false to prevent this field from showing hilite in a group summary.
    // <P>
    // All hilites in group summary rows can be controlled with the
    // +link{listGrid.showHilitesInGroupSummary} property.
    //
    // @visibility external
    //<

    //> @attr listGridField.canGroupBy (Boolean : true : IRW)
    // Determines whether this field will be groupable in the header context menu.
    //
    // @see listGrid.groupBy()
    // @visibility external
    //<

    //> @attr listGridField.canSortClientOnly (Boolean : false : IRW)
    // When true, this field can only be used for sorting if the data is entirely client-side.
    //
    // @visibility external
    //<

    //> @attr listGridField.showDefaultContextMenu (Boolean : true : IRW)
    // When set to false, this field will not show a context menu in its header.
    //
    // @visibility external
    //<

    //> @attr listGridField.canExport (Boolean : null : IR)
    //  Dictates whether the data in this field be exported.  Explicitly set this
    //  to false to prevent exporting.  Has no effect if the underlying
    //  +link{dataSourceField.canExport, dataSourceField} is explicitly set to
    //  canExport: false.
    //
    // @visibility external
    //<

    //> @attr listGridField.exportRawValues (Boolean : null : IR)
    //  Dictates whether the data in this field should be exported raw by
    // +link{listGrid.exportClientData, exportClientData()}.  If set to true for a
    // field, the values in the field-formatters will not be executed for data in this field.
    // Decreases the time taken for large exports.
    //
    // @visibility external
    //<

    //> @attr listGridField.exportRawNumbers (Boolean : null : IR)
    // Dictates whether numeric values should be exported as raw numbers instead of
    // formatted values when using +link{listGrid.exportClientData, exportClientData()}.
    // <P>
    // This property is only consulted if <code>exportRawValues</code> is not set to
    // true at the +link{listGrid.exportRawValues,grid} or
    // +link{listGridField.exportRawValues,field} level. That property causes all values,
    // including numeric values, to be exported unformatted.
    // <P>
    // This is useful for cases where an explicit ListGrid formatter function simply displays the number
    // as a formatted string for the user (for example "1,234"). Exporting that formatted
    // string rather than the underlying numeric value causes spreadsheet applications such as
    // Excel to lose some functionality.
    // <P>
    // If this property is not explicitly set, numeric values will be exported as raw
    // numbers for +link{DSRequest.exportAs,XLS and OOXML export} only.
    // <P>
    // This property overrides the setting at the +link{listGrid.exportRawNumbers,grid} level.
    //
    // @visibility external
    //<
    
    //> @attr listGridField.summaryValue (HTMLString : null : IRW)
    // The value to display for a ListGridField when it appears in the +link{listGrid.summaryRow,summaryRow}.  The
    // default for normal fields is null and for special fields, like the +link{listGrid.checkboxField,checkboxField},
    // the default is to show a blank value (a non-breaking space).
    // @visibility external
    //<

    //> @attr listGrid.groupNodeStyle (String : "groupNode" : IRW)
    // The CSS style that +link{listGrid.groupBy,group} rows will have.
    // <P>
    // Note that this is not a +link{listGrid.getBaseStyle(),base style}, so, if this
    // property is set, group nodes will not show stateful styling
    // (different styles for +link{listGrid.showRollOver},
    // +link{listGrid.alternateRecordStyles}, etc). To enable stateful styling for
    // groupNodes, set this property to <code>null</code> and specify a
    // +link{groupNodeBaseStyle}
    //
    // @group grouping
    // @see group:grouping
    // @visibility external
    //<
    groupNodeStyle: "groupNode",

    //> @attr listGrid.groupNodeBaseStyle (String : null : IRW)
    // +link{listGrid.getBaseStyle(),Base style} for +link{listGrid.groupBy,group} rows.
    // <P>
    // Note that this property has no effect if +link{listGrid.groupNodeStyle} is
    // non null.
    //
    // @group grouping
    // @see group:grouping
    // @visibility external
    //<
    groupNodeBaseStyle: null,

    //> @attr listGrid.groupIcon (SCImgURL : "[SKINIMG]/TreeGrid/opener.gif" : IRW)
    // The URL of the base icon for the group icons in this listGrid. Default value may 
    // be overridden by the +link{group:skinning,current skin}.
    //
    // @group grouping
    // @see group:grouping
    // @visibility external
    //<
    groupIcon: "[SKINIMG]/TreeGrid/opener.gif",

    //> @attr listGrid.groupIconSize (Number : 16 : IRW)
    // Default width and height of group icons for this ListGrid.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    groupIconSize: 16,

    //> @attr listGrid.groupIndentSize (Number : 20 : IRW)
    // Default number of pixels by which to indent subgroups relative to parent group.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @see listGrid.getGroupNodeHTML
    // @visibility external
    //<
    groupIndentSize: 20,

    //> @attr listGrid.groupLeadingIndent (Number : 10 : IRW)
    // Default number of pixels by which to indent all groups.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @see listGrid.getGroupNodeHTML
    // @visibility external
    //<
    groupLeadingIndent: 10,

    //> @attr listGrid.canGroupBy (Boolean : true : IRW)
    // If false, grouping via context menu will be disabled.
    //
    // @group grouping
    // @see listGrid.groupBy()
    // @visibility external
    //<
    canGroupBy: true,

    //> @attr listGrid.groupByMaxRecords (int : 1000 : IRW)
    // Maximum number of records to which a groupBy can be applied. If there are more records,
    // grouping will not be available via the default header context menu, and calls to
    // +link{listGrid.groupBy()} will be ignored.
    // <P>
    // The maximum exists because ListGrid grouping is performed in-browser, hence requires loading of
    // all records that match the current filter criteria before records can be grouped.  The default
    // maximum represents a number of records which are safe to load in legacy browsers such as Internet
    // Explorer 8 (modern browsers can handle far more), and is also a good upper limit from the
    // perspective of loading data from a database.
    // <P>
    // Going beyond this limit can cause "script running slowly" errors from legacy browsers (as well as
    // high database load).  To build an interface for grouping that handles arbitrary data volume, use
    // a TreeGrid with +link{treeGrid.loadDataOnDemand} with server-side grouping code.
    //
    // @group grouping
    // @see groupBy
    // @visibility external
    //<
    groupByMaxRecords: 1000,

    //> @attr listGrid.groupByAsyncThreshold (int : 50 : IRW)
    // When grouping is requested with this number of records or more, an asynchronous approach is
    // used to avoid the browser showing a "script is running slowly.." message prompting the
    // user to stop execution of JavaScript.
    // <p>
    // Note that +link{groupByMaxRecords} must be set at least as high as +link{groupByAsyncThreshold}
    // or asynchronous grouping will never be used.
    // <p>
    // During async grouping, interactivity is blocked and the +link{asynchGroupingPrompt} is shown
    // to the user, then hidden when grouping completes; +link{groupByComplete} then fires.
    // <p>
    // Note that this async processing covers grouping <b>only</b> - it does not cover whole grid or
    // per-group summaries, client-side sort or filter, or other operations that may cause the browser
    // to show the "script is running slowly" prompt when working with very large sets of records in a
    // grid.
    // <p>
    // At this time, there is no generally effective way to avoid this warning dialog appearing with very
    // large datasets in Microsoft's Internet Explorer (IE).  IE's severely flawed detection algorithm for
    // runaway scripts has been shown to interrupt computations after only 0.2 seconds elapsed time
    // even if the computation would have finished in 0.3 seconds.  Optimizations that reduce
    // execution time can sometimes trigger the "script running slowly" dialog sooner.  Since not
    // every operation can reasonably be made asynchronous, the current recommendation is to avoid
    // working with overly large datasets until the affected versions of IE are obsoleted.
    // @visibility external
    //<
    groupByAsyncThreshold: 50,

    //> @attr listGrid.showAsynchGroupingPrompt (Boolean : null : IR)
    // If set to false, do not show the +link{asynchGroupingPrompt} dialog during
    // +link{groupByAsyncThreshold,asynchronous grouping}.
    // @visibility external
    //<

    //> @attr listGrid.asynchGroupingPrompt (HTMLString : "${loadingImage}&nbsp;Grouping data..." : IR)
    // The prompt to display while interactivity is blocked during +link{groupByAsyncThreshold,asynchronous grouping}.
    // @group i18nMessages
    // @visibility external
    //<
    asynchGroupingPrompt: "${loadingImage}&nbsp;Grouping data...",

    //> @attr listGrid.isGrouped (boolean : false : R)
    // True if this listGrid is grouped, false otherwise
    //
    // @group grouping
    // @visibility external
    // @see     groupBy
    //<

    //> @attr listGrid.nullGroupTitle (String : '-none-' : IRW)
    // Default alias to use for groups with no value
    //
    // @group grouping
    // @visibility external
    // @see     groupBy
    //<
    nullGroupTitle: "-none-",

    //> @attr listGrid.groupByField (String | Array of String : see below : IR)
    // List of fields to group grid records. If only a single field is used, that field
    // may be specified as a string. After initialization, use +link{listGrid.groupBy()}
    // to update the grouping field list, instead of modifying groupByField directly.
    // @group grouping
    // @visibility external
    // @see groupBy
    // @example dynamicGrouping
    //<


    // ----------------------
    // Value icons
    // The valueIcons object is a mapping between values and image URLs - when specified
    // we show the valueIcon image either next to, or instead of the normal cell value.

    //> @attr listGridField.valueIcons (Map<String,String> : null : IRW)
    // This property is a mapping from data values for this field to +link{SCImgURL,urls} for
    // icons to display for those data values.  
    // <p>
    // For example, given a field named "status" with possible values
    // "Normal", "Slow", "Offline", the follow definition would show various icons for that
    // field:
    // <P>
    // <smartclient>
    // <pre>
    // fields : [
    //     { name:"status",
    //       valueIcons: {
    //           Normal : "greenIcon.png",
    //           Slow : "yellowIcon.png",
    //           Offline : "redIcon.png"
    //       }
    //     },
    //     ... other fields ...
    // ]
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    // ListGridField statusField = new ListGridField("status");
    // statusField.setValueIcons(new HashMap&lt;String, String>() {{
    //    put("Normal", "greenIcon.png");
    //    put("Slow", "yellowIcon.png");
    //    put("Offline", "redIcon.png");
    // }});
    // </pre>
    // </smartgwt>
    // <p>
    // If a simple value-to-URL mapping is not enough, you can override +link{ListGrid.getValueIcon()}
    // to customize the behavior.  You can even specify an empty <code>valueIcons</code> map
    // and use +link{ListGrid.getValueIcon()} to return arbitrary icons with no fixed mapping.
    // <p>
    // <code>valueIcons</code> can either be displayed alongside the normal value or can
    // replace the normal field value so that only the icon is shown.  See
    // +link{listGridField.showValueIconOnly}.  When placed alongside the value, use
    // +link{valueIconOrientation} to control left- vs right-side placement.
    // <P>
    // If inline editing is enabled for this field, editors displayed for this field will also
    // show valueIcons.  This may be overridden by explicitly setting
    // +link{listGridField.editorValueIcons}.
    // <P>
    // Note that the following attributes related to valueIcon styling will also be picked up
    // by the editor from the ListGridField object unless explicitly specified via the
    // equivalent <code>editor_</code> attributes:<br>
    // +link{listGridField.valueIconWidth}<br>
    // +link{listGridField.valueIconHeight}<br>
    // +link{listGridField.valueIconSize}<br>
    // +link{listGridField.valueIconLeftPadding}<br>
    // +link{listGridField.valueIconRightPadding}<br>
    // +link{listGridField.imageURLPrefix}<br>
    // +link{listGridField.imageURLSuffix}
    // <P>
    // If +link{listGridField.valueIconClick()} is defined for the field, a pointer
    // cursor will be shown when the user rolls over the valueIcon, and the valueIconClick
    // method will execute when the user clicks the icon.
    //
    // @group imageColumns
    // @visibility external
    //<
    
    //> @method listGridField.valueIconClick()
    //
    // Executed when the user clicks on a +link{listGridField.valueIcons,value icon} within
    // this field. Return false to suppress default behavior of firing +link{recordClick} 
    // handlers, etc.
    //
    // @param   viewer      (ListGrid)  the listGrid that contains the click event
    // @param   record      (ListGridRecord)    the record that was clicked on
    // @param   recordNum   (number)    number of the record clicked on in the current set of
    //                                  displayed records (starts with 0)
    // @param   field       (ListGridField) the field that was clicked on (field definition)
    // @param   rawValue    (Any)   raw value of the cell (before valueMap, etc applied)
    // @param   editor      (FormItem) If this cell is being +link{listGrid.canEdit,edited}, 
    //  this method will fire when the user clicks the valueIcon on the edit item for the
    //  cell, passing in the editor item as the <code>editor</code> parameter. If the cell
    //  is not being edited, this value will be null.
    // @return  (boolean)   false to stop event bubbling
    //
    // @group   events
    //
    // @see attr:listGridField.valueIcons
    // @visibility external
    //<


    //> @attr listGrid.valueIconSize (number : 16 : IRW)
    // Default width and height of value icons for this ListGrid.
    // Can be overridden at the listGrid level via explicit +link{ListGrid.valueIconWidth} and
    // +link{ListGrid.valueIconHeight}, or at the field level via +link{ListGridField.valueIconSize},
    // +link{ListGridField.valueIconWidth} and {ListGridField.valueIconHeight}
    // @visibility external
    // @group imageColumns
    // @see ListGrid.valueIconWidth
    // @see ListGrid.valueIconHeight
    // @see ListGridField.valueIconSize
    //<
    valueIconSize:16,


    //> @attr listGrid.valueIconWidth (number : null : IRW)
    // Width for value icons for this listGrid.
    // Overrides +link{ListGrid.valueIconSize}.
    // Can be overridden at the field level
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGrid.valueIconHeight (number : null : IRW)
    // Height for value icons for this listGrid.
    // Overrides +link{ListGrid.valueIconSize}.
    // Can be overridden at the field level
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.valueIconSize (number : null : IRW)
    // Default width and height of value icons in this field.
    // Takes precedence over valueIconWidth, valueIconHeight and valueIconSize specified at
    // the ListGrid level.
    // Can be overridden via +link{ListGridField.valueIconWidth} and {ListGridField.valueIconHeight}
    // @visibility external
    // @group imageColumns
    // @see ListGrid.valueIconSize
    // @see ListGridField.valueIconWidth
    // @see ListGridField.valueIconHeight
    //<

    //> @attr listGridField.valueIconWidth (number : null : IRW)
    // Width for value icons for this listGrid field.
    // Overrides +link{ListGrid.valueIconSize}, +link{ListGrid.valueIconWidth}, and
    // +link{ListGridField.valueIconSize}.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.valueIconHeight (number : null : IRW)
    // Height for value icons for this listGrid field.
    // Overrides +link{ListGrid.valueIconSize}, +link{ListGrid.valueIconHeight}, and
    // +link{ListGridField.valueIconSize}.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr   listGridField.valueIconLeftPadding (number : null : IRW)
    // How much padding should there be on the left of valueIcons for this field
    // Overrides +link{listGrid.valueIconLeftPadding}
    // @group imageColumns
    // @see ListGridField.valueIcons
    // @visibility external
    //<

    //> @attr   listGridField.valueIconRightPadding (number : null : IRW)
    // How much padding should there be on the right of valueIcons for this field
    // Overrides +link{listGrid.valueIconRightPadding}
    // @group imageColumns
    // @see ListGridField.valueIcons
    // @visibility external
    //<

    //> @attr listGridField.editorValueIcons (Map<String,String> : null : IRW)
    // When some cell in this field is being edited, setting this property will specify the
    // value icons to display in the cell's editor. If unset, the editor's valueIcons
    // will be determined in the same way as it would be for a static cell.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.editorValueIconWidth (number : null : IRW)
    // When some cell in this field is being edited, setting this property will specify the
    // width for value icons in the cell's editor. If unset, the editor's valueIcon width and
    // height will be determined in the same way as it would be for a static cell.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.editorValueIconHeight (number : null : IRW)
    // When some cell in this field is being edited, setting this property will specify the
    // height for value icons in the cell's editor. If unset, the editor's valueIcon width and
    // height will be determined in the same way as it would be for a static cell.
    // @group imageColumns
    // @visibility external
    //<

    //> @attr listGridField.showValueIconOnly (boolean : null : IRW)
    // If this field has a valueIcons property specified, setting this property causes
    // the valueIcon for each value to be displayed in the cell without also showing the
    // record's value for the field.
    // <P>
    // If unset the default behavior is to show the icon only if an explicit valueMap is
    // specified as well in addition to a valueIcons map, otherwise show both the valueIcon and
    // value for the cell.
    // <P>
    // Note that if this field is editable +link{FormItem.showValueIconOnly} will be passed
    // through to editors displayed in this field.
    //
    // @group imageColumns
    // @see listGridField.valueIcons
    // @see listGridField.suppressValueIcon
    // @visibility external
    //<

    // NOTE: showValueIconOnly: the use cases are:
    // - represent a value as an icon only to minimize space
    // - show text, but add an icon as decoration, either to all values, or to emphasize some
    //   values for quicker scanning
    // The property 'showValueIconOnly' allows the developer to explicitly show the valueIcon
    // with or without text.  If showValueIconOnly is unset, we make the assumption that:
    // - if the field is *not* constrained to a fixed set of values (has no valueMap), there's
    //   no way to have icons for all the values, so the purpose of the icons is to add
    //   emphasis to certain values [so we show both text and images]
    // - otherwise the developer has an icon for every possible value, so there is no need for
    //   the value to also be displayed - we size the field large enough to accommodate the icon
    //   only, and suppress the text.

    //> @attr   listGridField.suppressValueIcon (boolean : null : IRW)
    // If this field has a valueIcons property specified, setting this property to true will
    // prevent the valueIcon being written out into this field's cells.
    // <P>
    // Note this property may also be set to false to avoid showing the standard
    // +link{listGrid.booleanTrueImage} and +link{listGrid.booleanFalseImage} for fields of type
    // <code>boolean</code>.
    //
    // @group imageColumns
    // @see listGridField.valueIcons
    // @see listGridField.showValueIconOnly
    // @visibility external
    //<

    //> @attr   listGridField.valueIconOrientation (String : null : IRW)
    // If we're showing a valueIcon for this field should it appear to the left or the right
    // of the text?  By default the icon will appear to the left of the textual value -
    // set this to "right" to show the icon on the right of the text.
    // Has no effect if +link{listGridField.showValueIconOnly} is true
    // @visibility external
    // @group imageColumns
    //<
    

    //> @attr   listGrid.valueIconLeftPadding (number : 2 : IRW)
    // How much padding should there be on the left of valueIcons by default
    // Can be overridden at the field level
    // @group imageColumns
    // @see ListGridField.valueIcons
    // @visibility external
    //<
    valueIconLeftPadding:2,

    //> @attr   listGrid.valueIconRightPadding (number : 2 : IRW)
    // How much padding should there be on the right of valueIcons by default
    // @group imageColumns
    // Can be overridden at the field level
    // @see ListGridField.valueIcons
    // @visibility external
    //<
    valueIconRightPadding:2,

    // ------------
    // Hilite Icons
    // ------------

    //> @attr listGrid.hiliteIcons (Array of String : ["[SKINIMG]/Dialog/notify.png", "[SKINIMG]/Dialog/warn.png", "[SKINIMG]/actions/approve.png"] : IR)
    // @include dataBoundComponent.hiliteIcons
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconPosition (HiliteIconPosition : "before" : IR)
    // @include dataBoundComponent.hiliteIconPosition
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconSize (number : 12 : IRW)
    // @include dataBoundComponent.hiliteIconSize
    // @group hiliting
    // @see hiliteIconWidth
    // @see hiliteIconHeight
    // @see ListGridField.hiliteIconSize
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconWidth (number : null : IRW)
    // @include dataBoundComponent.hiliteIconWidth
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteIconHeight (number : null : IRW)
    // @include dataBoundComponent.hiliteIconHeight
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGrid.hiliteIconLeftPadding (number : 2 : IRW)
    // @include dataBoundComponent.hiliteIconLeftPadding
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGrid.hiliteIconRightPadding (number : 2 : IRW)
    // @include dataBoundComponent.hiliteIconRightPadding
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconPosition (HiliteIconPosition : null : IR)
    // When +link{listGrid.hiliteIcons} are present, where the hilite icon will be placed
    // relative to the field value.  See +link{type:HiliteIconPosition}.
    // Overrides +link{listGrid.hiliteIconPosition}.
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconSize (number : null : IRW)
    // Default width and height of +link{listGrid.hiliteIcons, hilite icons} in this field.
    // Takes precedence over hiliteIconWidth, hiliteIconHeight and hiliteIconSize specified at
    // the component level.
    // Can be overridden via +link{ListGridField.hiliteIconWidth} and
    // +link{ListGridField.hiliteIconHeight}
    // @group hiliting
    // @see ListGrid.hiliteIconSize
    // @see ListGridField.hiliteIconWidth
    // @see ListGridField.hiliteIconHeight
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconWidth (number : null : IRW)
    // Width for hilite icons for this field.
    // Overrides +link{listGrid.hiliteIconSize}, +link{listGrid.hiliteIconWidth}, and
    // +link{ListGridField.hiliteIconSize}.
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGridField.hiliteIconHeight (number : null : IRW)
    // Height for hilite icons for this field.
    // Overrides +link{listGrid.hiliteIconSize}, +link{listGrid.hiliteIconHeight}, and
    // +link{ListGridField.hiliteIconSize}.
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGridField.hiliteIconLeftPadding (number : null : IRW)
    // How much padding should there be on the left of +link{DataBoundComponent.hiliteIcons, hilite icons}
    // for this field?
    // Overrides +link{listGrid.hiliteIconLeftPadding}
    // @group hiliting
    // @visibility external
    //<

    //> @attr   listGridField.hiliteIconRightPadding (number : null : IRW)
    // How much padding should there be on the right of +link{DataBoundComponent.hiliteIcons, hilite icons}
    // for this field?
    // Overrides +link{listGrid.hiliteIconRightPadding}
    // @group hiliting
    // @visibility external
    //<


    

    //> @attr   ListGridField.imageURLPrefix (String : null : IRWA)
    // If this field has type [+link{type:ListGridFieldType}] set to <code>"image"</code>
    // and the URL for the image displayed is not absolute, the path of the URL will be relative
    // to this string<br>
    // Alternatively, if this field displays any valueIcons, this prefix will be applied to
    // the beginning of any +link{ListGridField.valueIcons} when determining the
    // URL for the image.
    // @group imageColumns
    // @visibility external
    // @example imageType
    //<

    //> @attr   ListGridField.imageURLSuffix (String : null : IRWA)
    // If any cells in this field are showing a value icon (see: +link{ListGridField.valueIcons})
    // or this is has +link{type:ListGridFieldType} set to <code>"image"</code>, the value
    // of this property will be appended to the end of the URL for the icon displayed.<br>
    // Typical usage might be to append a file type such as <code>".gif"</code> to the
    // filename of the image.<br>
    // For editable fields, this property will also be passed through to any editors as
    // +link{FormItem.imageURLSuffix}.
    // @group imageColumns
    // @visibility external
    // @example imageType
    //<

    //> @attr   ListGridField.editorImageURLPrefix (String : null : IRWA)
    // When some cell in this field is being edited, this property can be used to apply
    // an explicit +link{FormItem.imageURLPrefix} to the editor in question.
    // This can be used to modify the valueIcons within the editor.<br>
    // If unset, but +link{ListGridField.imageURLPrefix} is specified, that will be used
    // instead.
    // @group editing
    // @visibility external
    //<

    //> @attr   ListGridField.editorImageURLSuffix (String : null : IRWA)
    // When some cell in this field is being edited, this property can be used to apply
    // an explicit +link{FormItem.imageURLSuffix} to the editor in question.
    // This can be used to modify the valueIcons within the editor.<br>
    // If unset, but +link{ListGridField.imageURLPrefix} is specified, that will be used
    // instead.
    // @group editing
    // @visibility external
    //<

    //> @attr   listGrid.imageSize (number : 16 : IRW)
    // Default size of thumbnails shown for fieldTypes image and imageFile.  Overrideable on a
    // per-field basis via +link{attr:ListGridField.imageSize} or
    // +link{attr:ListGridField.imageWidth}/+link{attr:ListGridField.imageHeight}
    //
    // @group imageColumns
    // @visibility external
    //<
    imageSize: 16,

    //> @attr   listGridField.imageSize (number : 16 : IRW)
    // Size of images shown for fieldTypes image and imageFile in this field.
    // This setting overrides the global ListGrid default +link{attr:ListGrid.imageSize}.
    // <P>
    // If set to a String, assumed to be a property on each record that specifies the image
    // height.  For example, if <code>field.imageSize</code> is "logoSize",
    // <code>record.logoSize</code> will control the size of the image.
    //
    // @see attr:ListGridField.imageWidth
    // @see attr:ListGridField.imageHeight
    //
    // @group imageColumns
    // @visibility external
    //<

    //> @attr   listGridField.imageWidth (number : 16 : IRW)
    // Width of images shown for fieldTypes image and imageFile in this field.
    // <P>
    // If set to a String, assumed to be a property on each record that specifies the image
    // width.  For example, if <code>field.imageWidth</code> is "logoWidth",
    // <code>record.logoWidth</code> will control the width of the image.
    //
    // @see attr:ListGrid.imageSize
    // @see attr:ListGridField.imageSize
    // @see attr:ListGridField.imageHeight
    //
    // @group imageColumns
    // @visibility external
    //<

    //> @attr   listGridField.imageHeight (number : 16 : IRW)
    // Height of image shown for fieldTypes image and imageFile in this field.
    // <P>
    // If set to a String, assumed to be a property on each record that specifies the image
    // height.  For example, if <code>field.imageHeight</code> is "logoHeight",
    // <code>record.logoHeight</code> will control the height of the image.
    //
    // @see attr:ListGrid.imageSize
    // @see attr:ListGridField.imageSize
    // @see attr:ListGridField.imageWidth
    //
    // @group imageColumns
    // @visibility external
    //<

    // ListGridField
    // ---------------------------------------------------------------------------------------

    //  -- Define the 'listGridField' pseudo class for doc
    
    //> @object ListGridField
    // An ordinary JavaScript object containing properties that configures the display of
    // and interaction with the columns of a +link{ListGrid}.
    //
    // @see ListGrid.fields
    // @see ListGrid.setFields
    // @inheritsFrom DBCField
    // @treeLocation Client Reference/Grids/ListGrid
    // @visibility external
    //<

    //> @type ListGridFieldType
    // ListGrids format data for viewing and editing based on the <i>type</i> attribute of the
    // field.  This table describes how the ListGrid deals with the various built-in types.
    //
    // @value "text"    Simple text rendering for view.  For editing a text entry field is shown.
    // If the length of the field (as specified by the +link{attr:dataSourceField.length}
    // attribute) is larger than the value specified by +link{attr:listGrid.longTextEditorThreshold}, a
    // text input icon is shown that, when clicked on (or field is focused in) opens a larger
    // editor that expands outside the boundaries of the cell (textarea by default, but
    // overrideable via +link{ListGrid.longTextEditorType}).
    //
    // @value "boolean" For viewing and editing a checkbox is shown with a check mark for the
    // <code>true</code> value and no check mark for the <code>false</code> value. This behavior
    // may be suppressed by setting +link{listGridField.suppressValueIcon} for the field. See
    // +link{ListGrid.booleanTrueImage} for customization.
    //
    // @value "integer" A whole number, e.g. <code>123</code>. Consider setting
    // +link{listGridField.editorType,editorType} to use a +link{SpinnerItem}.
    //
    // @value "float" A floating point (decimal) number, e.g. <code>1.23</code>. 
    // Consider setting +link{listGridField.editorType,editorType} to use a +link{SpinnerItem}.
    //
    // @value "date" Field value should be a <code>Date</code> instance representing a logical
    // date, with no time of day information.  See +link{group:dateFormatAndStorage} for
    // details of the logical date type and how it is represented and manipulated.
    // <P>
    // Dates will be formatted using +link{listGridField.dateFormatter,ListGridField.dateFormatter}
    // if specified, otherwise
    // +link{ListGrid.dateFormatter,ListGrid.dateFormatter}.
    // If both these attributes are unset, dates are formatted
    // using the standard +link{DateUtil.setShortDisplayFormat(),short display format} for dates.
    // <P>
    // For editing, by default a +link{DateItem} is used with +link{DateItem.useTextField} set
    // to true, providing textual date entry plus a pop-up date picker. The
    // +link{DateItem.dateFormatter, dateFormatter} and +link{DateItem.inputFormat, inputFormat}
    // for the editor will be picked up from the ListGridField, if specified.
    //
    // @value "time" Field value should be a <code>Date</code> instance representing a logical
    // time, meaning time value that does not have a specific day and also has no timezone.  See
    // +link{group:dateFormatAndStorage} for details of the logical time type and how it is
    // represented and manipulated.
    // <P>
    // Times will be formatted using +link{listGridField.timeFormatter,ListGridField.timeFormatter}
    // if specified,
    // otherwise +link{ListGrid.timeFormatter,ListGrid.timeFormatter}.
    // <P>
    // If both these attributes are unset, times are formatted using the standard
    // +link{Time.shortDisplayFormat,short display format} for times.
    // <P>
    // For editing, by default a +link{TimeItem} is used. The
    // +link{TimeItem.timeFormatter, timeFormatter} for the editor will be picked up from
    // the ListGridField, if specified.
    //
    // @value "datetime" Field value should be a <code>Date</code> instance representing a
    // specific date and time value.  See +link{group:dateFormatAndStorage} for details of the
    // datetime type and how it is represented and manipulated.
    // <P>
    // Dates will be formatted using +link{listGridField.dateFormatter,ListGridField.dateFormatter}
    // if specified, otherwise
    // +link{ListGrid.datetimeFormatter,ListGrid.datetimeFormatter}.
    // If both these attributes are unset, dates are formatted
    // using the standard +link{DateUtil.setShortDatetimeDisplayFormat(),short display format} for
    // datetime values.
    // <P>
    // For editing, by default a +link{DateTimeItem} is used, providing textual date entry plus
    // a pop-up date picker.  The +link{DateItem.dateFormatter, dateFormatter} and
    // +link{DateItem.inputFormat, inputFormat} for the editor will be picked up from the
    // ListGridField, if specified.
    //
    // @value "sequence" Same as <code>text</code>
    //
    // @value "link"     Renders a clickable html link (using an HTML anchor tag: &lt;A&gt;).
    // The target URL is the value of the field, which is also the default display value.  You
    // can override the display value by setting +link{attr:listGridRecord.linkText} or
    // +link{attr:listGridField.linkText}.
    // <P>
    // Clicking the link opens the URL in a new window by default.  To change this behavior,
    // you can set <code>field.target</code>, which works identically to the "target"
    // attribute on an HTML anchor (&lt;A&gt;) tag.  See +link{listGridField.target} for more
    // information.
    // <P>
    // In inline edit mode, this type works like a text field.
    // <P>
    // To create a link not covered by this feature, consider using
    // +link{listGridField.formatCellValue()} along with +link{Canvas.linkHTML()}, or simply
    // +link{listGrid.getCellStyle,styling the field} to look like a link, and providing
    // interactivity via +link{listGridField.recordClick,field.recordClick()}.
    //
    // @value "image"   Renders a different image in each row based on the value of the field.  If
    // this URL is not absolute, it is assumed to be relative to
    // +link{ListGridField.imageURLPrefix} if specified. The size of the image is controlled by
    // +link{attr:listGridField.imageSize}, +link{attr:listGridField.imageWidth},
    // +link{attr:listGridField.imageHeight} (and by the similarly-named global default
    // attributes on the ListGrid itself).
    // <P>
    // You can also specify the following attributes on the field: <code>activeAreaHTML</code>, and
    // <code>extraStuff</code> - these are passed to +link{method:canvas.imgHTML} to generate the
    // final URL.
    // <P>
    // Note if you want to display icons <b>in addition to</b> the normal cell value, you
    // can use +link{listGridField.valueIcons,valueIcons} instead.
    //
    // @value "icon" Shows +link{listGridField.icon,field.icon} in every cell, and also in the
    // header.  Useful for a field that is used as a button, for example, launches a detail
    // window or removes a row.  Implement a +link{listGridField.recordClick,field.recordClick}
    // to define a behavior for the button.
    // <P>
    // NOTE: for a field that shows different icons depending on the field value, see
    // +link{listGridField.valueIcons}.
    // <P>
    // <code>type:"icon"</code> also defaults to a small field width, accommodating just the icon
    // with padding, and to a blank header title, so that the header shows the icon only.
    // <P>
    // +link{listGridField.iconWidth,field.iconWidth} and related properties configure
    // the size of the icon both in the header and in body cells.
    // <P>
    // If you want the icon to appear only in body cells and not in the header, set
    // +link{listGridField.cellIcon,field.cellIcon} instead, leaving field.icon null.
    //
    // @value "binary"  For viewing, the grid renders a 'view' icon (looking glass) followed by a
    // 'download' icon and then the name of the file is displayed in text.  If the user clicks the
    // 'view' icon, a new browser window is opened and the file is streamed to that browser
    // instance, using +link{dataSource.viewFile()}.  For images and other file types with
    // known handlers, the content is typically displayed inline - otherwise the browser will
    // ask the user how to handle the content.  If the download icon is clicked,
    // +link{dataSource.downloadFile()} is used to cause the browser to show a "save" dialog.
    // There is no inline editing mode for this field type.
    //
    // @value "imageFile"   Same as <code>binary</code>
    //
    // @value "summary" Show a calculated summary based on other field values within the
    //  current record. See +link{listGridField.recordSummaryFunction} for more information
    //
    // @value "any"       Fields of this type can contain any data value and have no default 
    // formatting or validation behavior. This is useful as the 
    // +link{SimpleType.inheritsFrom,parent type} for SimpleTypes
    // where you do not want any of the standard validation or formatting logic
    // to be inherited from the standard built-in types.
    //
    // @value "localeInt" An integer number with locale-based formatting, e.g. <code>12,345,678</code>.
    // See +link{group:localizedNumberFormatting,Localized Number Formatting}
    // for more info.
    // 
    // @value "localeFloat" A float number with locale-based formatting, e.g. <code>12,345.67</code>.
    // See +link{group:localizedNumberFormatting,Localized Number Formatting}
    // for more info.
    //
    // @value "localeCurrency" A float number with locale-based formatting and using currency
    // symbol, e.g. <code>$12,345.67</code>.
    // See +link{group:localizedNumberFormatting,Localized Number Formatting}
    // for more info.
    //
    // @value "phoneNumber" A telephone number.  Uses +link{formItem.browserInputType} "tel" to
    // hint to the device to restrict input.  On most mobile devices that have
    // software keyboards, this cause a specialized keyboard to appear which
    // only allows entry of normal phone numbers.  When displayed read-only,
    // a "phoneNumber" renders as an HTML link with the "tel:" URL scheme,
    // which will invoke the native phone dialing interface on most mobile
    // devices.  In addition, the CSS style "sc_phoneNumber" is applied.
    // <p>
    // By default, "phoneNumber" fields do not include validators, however the
    // following validator definition would limit to digits, dashes and the
    // "+" character:
    // xml:
    // <p>
    //     &lt;validator type="regexp" expression="^(\(?\+?[0-9]*\)?)?[0-9_\- \(\)]*$"
    //         errorMessage="Phone number should be in the correct format e.g. +#(###)###-##-##" /&gt;
    //     <smartclient>
    // <p>
    // or directly in JavaScript:
    // <p>
    // <pre>
    // {type:"regexp", expression:"^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$", 
    //     errorMessage:"Phone number should be in the correct format e.g. +#(###)###-##-##"}
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <p>
    // or directly in Java:
    // <p>
    // <pre>
    // RegExpValidator v = new RegExpValidator();
    // v.setType(ValidatorType.REGEXP);
    // v.setErrorMessage("Phone number should be in the correct format e.g. +#(###)###-##-##");
    // v.setExpression("^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$");
    // </pre>
    // </smartgwt>
    // and adding "#" and "*" to the regular expressions above would allow for
    // users to enter special keys sometimes used for extension numbers or
    // pauses
    //
    // @see attr:listGridField.type
    // @see type:FieldType
    // @visibility external
    // @example gridsDataTypes
    //<

    //> @attr listGridField.type (ListGridFieldType : "text" : [IR])
    //  ListGrids picks a renderer for the view and edit mode of a field based on this attribute.
    //  See +link{ListGridFieldType} for a summary of how types are rendered.
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @group  appearance
    //  @visibility external
    //<

    //> @attr listGridField.name (FieldName : null : [IR])
    // Name of this field.  Must be unique within this ListGrid as well as a valid JavaScript
    // identifier - see +link{FieldName} for details and how to check for validity.
    // <P>
    // The name of field is also the property in each record which holds the value for that
    // field.
    // <P>
    // If a +link{listGrid.dataSource} is specified and the DataSource has a field with the
    // same name, the ListGridField and DataSourceField are merged, with any properties on the
    // ListGridField overriding those on the DataSourceField.
    //
    // @group data
    // @visibility external
    //<

    //> @attr listGridField.dataPath (String : null : [IRA])
    // dataPath for this field. This property allows the grid to display details of nested data
    // structures in a flat list of columns.
    // @group data
    // @visibility external
    //<

    //> @attr listGridField.title (String : null : [IRW])
    // A title for this field, to display in the header for the field and in other
    // contexts such as the +link{listGrid.canPickFields,menu for picking visible fields}.
    // <P>
    // Note: if you want to use HTML tags to affect the display of the header, you should do so
    // via +link{listGridField.headerTitle} instead so that other places where the title
    // appears in the UI are not affected.  For example, you might set <code>headerTitle</code>
    // to an empty string to suppress the header title on a narrow column, but you would retain
    // the normal title in the <code>title</code> property to avoid a blank menu item in the
    // field picker menu, +link{databoundComponent.editHilites,hilite editor} and other contexts.
    // <P>
    // Alternately you can specify a +link{getFieldTitle()} method on the field to return the
    // HTML for the field title.
    //
    // @group  appearance
    // @see method:listGridField.getFieldTitle()
    // @visibility external
    //<

    //> @attr listGridField.showTitle (boolean : null : [IRW])
    // This property may be set to <code>false</code> to explicitly suppress display of
    // the field title in the column header button for the field.
    // @visibility external
    //<

    //> @method listGridField.getFieldTitle()
    // If your derivation of the field title is more complex than specifying a static string,
    // you can specify a getFieldTitle() method on your field to return the title string.
    // Otherwise you can use the +link{title} attribute on the field to specify the title.
    // <P>
    // You can use +link{listGrid.setFieldProperties,setFieldProperties()} to dynamically
    // update the title.
    //
    // @param viewer (ListGrid) pointer back to the ListGrid
    // @param fieldNum (number) index of this field in the grid's fields array.
    // @return  (String) Field title.
    // @group appearance
    // @see attr:listGridField.title
    // @visibility external
    //<

    //> @attr listGridField.wrap (Boolean : null : [IRW])
    // Should the field title wrap if there is not enough space horizontally to accommodate it.
    // If unset, default behavior is derived from +link{listGrid.wrapHeaderTitles}.  (This is a
    // soft-wrap - if set the title will wrap at word boundaries.)
    // <P>
    // <b>Notes:</b><ul>
    // <li>If autofitting is active, +link{width} and +link{minWidth} can be set to control the
    // minimum field width - see the links for details.
    // <li>This feature is incompatible with +link{listGrid.clipHeaderTitles}, and
    // <code>clipHeaderTitles</code> will be disabled for wrapping fields.</ul>
    //
    // @see attr:listGrid.minFieldWidth
    // @visibility external
    //<

    //> @attr listGridField.rotateTitle (Boolean : null : [IR])
    // Whether to rotate the field's title so it's rendered vertically from bottom to top.
    // If unset, default behavior is derived from +link{listGrid.rotateHeaderTitles}.
    // @see listGrid.rotateHeaderTitles
    // @visibility external
    //<

    //> @attr listGridField.valign (VerticalAlignment : null : [IR])
    // Specifies vertical alignment in the column header for this field: "top", "center", or 
    // "bottom".  If unset, default behavior is derived from +link{listGrid.headerTitleVAlign}.
    // @see listGrid.rotateHeaderTitles
    // @visibility external
    //<

    //> @attr listGridField.cellPrompt (HTMLString : null : IRW)
    // HTML to show in a hover over cells in this field.  Useful for fixed hover text, such as 
    // a tooltip for an icon in a field of type "icon".  To show a custom prompt per cell,
    // see +link{listGridField.hoverHTML, hoverHTML}.
    // @visibility external
    //<
    
    //> @attr listGridField.hoverWrap (Boolean : null : IRW)
    // This property may be set to customize the <code>wrap</code> attribute for the
    // canvas shown when the mouse hovers over cells in this field. Note that this causes a 
    // soft-wrap - if set, the hover text will wrap at word boundaries.
    // <P>
    // If unset, default behavior is derived from +link{listGrid.headerHoverWrap}.
    // @visibility external
    //<

    //> @attr listGridField.hoverWidth (Integer : null : IRW)
    // Specifies the width of the canvas shown when the mouse hovers over cells in this field. 
    // <P>
    // If unset, default behavior is derived from +link{listGrid.headerHoverWidth}.
    // @visibility external
    //<

    //> @attr listGridField.target (String : "_blank" : IRW)
    // By default, clicking a link rendered by this item opens it in a new browser window.  You
    // can alter this behavior by setting this property.  The value of this property will be
    // passed as the value to the <code>target</code> attribute of the anchor tag used to render
    // the link.
    // <P>
    // If you set listGridField.target to "javascript", the default behavior is to catch and
    // consume mouse-clicks that would result in the link being followed.  Instead, the
    // +link{listGrid.cellClick()} event is fired for the containing cell.
    //
    // @visibility external
    //<

    //> @method listGridField.showIf()
    // An optional +link{group:stringMethods,stringMethod} which if provided, is evaluated to
    // conditionally determine whether this field should be displayed.
    // Evaluated on initial draw, then reevaluated on explicit
    // calls to <code>listGrid.refreshFields()</code> or <code>listGrid.setFields()</code>.
    // <P>
    // Use <code>+link{listGridField.hidden,hidden}:true</code> or <code>showIf:"false"</code>
    // to set a ListGrid field to initially hidden.<br>
    // The user will still be able to show the field via a context menu. 
    // This may be suppressed by setting +link{listGridField.canHide} to false, or by 
    // setting +link{listGrid.canPickFields} to false to suppress the
    // field-picker entirely.
    // <P>
    // Note that explicit calls to +link{listGrid.showField,grid.showField()} or hideField()
    // will wipe out the <code>showIf</code> expression, as will the end user showing and
    // hiding columns via the +link{listGrid.showHeaderContextMenu,header contextMenu}.
    // <P>
    // Also note that fields marked as +link{DataSourceField.detail,detail:true} will be hidden by
    // default even if +link{ListGrid.showDetailFields} is <code>true</code>. To show detail fields
    // inherited from a DataSource, include an explicit field definition for the field and
    // set this property to return <code>true</code>.
    // <P>
    // Note that the +link{listGridField.visibleWhen} attribute also exists as a criteria-based
    // way to dynamically determine field visibility.
    //
    // @param list (ListGrid) A pointer to the listGrid containing the field
    // @param field (ListGridField) the ListGridField object
    // @param fieldNum (Integer) the index of the field
    // @return (boolean) whether the field should be shown
    //
    // @group appearance
    // @see method:ListGrid.refreshFields
    // @visibility external
    //<

    //> @attr listGridField.hidden  (Boolean : null : IR)
    // Marks field as initially hidden.<br>
    // The user will still be able to show the field via a context menu. 
    // This may be suppressed by setting +link{listGridField.canHide} to false, or by 
    // setting +link{listGrid.canPickFields} to false to suppress the
    // field-picker entirely.
    // <p>
    // To mark a field as completely hidden (not shown to a user at all, in any component), set
    // +link{DataSourceField.hidden} instead.
    //
    // @group appearance
    // @visibility external
    //<


    //> @attr listGridField.visibleWhen (Criteria : null : IR)
    // Criteria to be evaluated to determine whether this field should be visible.
    // <P>
    // This criteria is dynamic and will be renterpreted each time the rule context changes.
    // Note that calling +link{listGrid.showField()} or +link{listGrid.hideField()} explicitly
    // will cause any visibleWhen attribute to be dropped.
    //
	// @group ruleCriteria
	// @visibility external
    //<

    //> @attr listGridField.enableWhen (Criteria : null : IR)
    // Criteria to be evaluated to determine whether this field should be enabled.
    // <P>
    // This criteria is dynamic and will be renterpreted each time the rule context changes.
    //
	// @group ruleCriteria
	// @visibility external
    //<

    //> @attr listGridField.readOnlyWhen (Criteria : null : IR)
    // Criteria to be evaluated to determine whether this field should be editable.
    // <P>
    // This criteria is dynamic and will be renterpreted each time the rule context changes.
    //
	// @group ruleCriteria
	// @visibility reify
    //<

    //> @attr listGridField.frozen (boolean : null : IR)
    // Whether this field should be "frozen" for the purposes of horizontal scrolling.  See
    // +link{group:frozenFields}.
    //
    // @group frozenFields
    // @visibility external
    //<

    //> @attr listGridField.canFreeze (boolean : null : IR)
    // Whether this field should display freezing/unfreezing options in its header context menu.
    // See +link{group:frozenFields}.
    // @see method:listGrid.getHeaderContextMenuItems()
    // @group frozenFields
    // @visibility external
    //<

    //> @attr listGridField.autoFreeze (boolean : null : IR)
    // Whether this field should be automatically frozen when other fields are frozen.  When
    // true, the field will be automatically frozen to the extreme of the grid.  The
    // automatically generated +link{listGrid.checkboxField, checkbox},
    // +link{listGrid.expansionField, expansion} and
    // +link{listGrid.rowNumberField, rowNumber} fields are examples of fields that specify
    // <code>autoFreeze: true</code>.
    // <P>
    // You can control the position of this field in the array of frozen fields by providing a
    // +link{listGridField.getAutoFreezePosition} implementation.
    // @group frozenFields
    // @visibility external
    //<

    //> @method listGridField.getAutoFreezePosition()
    // When a field has +link{listGridField.autoFreeze,autoFreeze} set to true, developers can
    // implement this method to indicate where in the frozen-fields array this field should
    // appear.
    // <P>
    // Some automatically generated fields, such as
    // +link{listGrid.rowNumberField, rowNumberField},
    // +link{listGrid.expansionField, expansionField} and
    // +link{listGrid.checkboxField, checkboxField}, provide default implementations of this
    // method.
    // @return (number) the index at which this autoFreeze field should appear in the frozen body
    // @group frozenFields
    // @visibility external
    //<

    //> @attr listGridField.canHide (boolean : null : IRW)
    // If set to false, this field will be omitted from the column picker that appears in the
    // header context menu when +link{listGrid.canPickFields} is enabled.  This means that the
    // end user will not be able to hide it if it's currently shown, or show it if it's
    // currently hidden.
    // <P>
    // If this property is set to <code>false</code>, and the 
    // +link{listGrid.useAdvancedFieldPicker,advanced field picker} is shown, if the field
    // is +link{hidden}, the field will not show in the list of available fields. If the
    // field is visible, it will be displayed in the list of currently visible fields, but
    // the advanced field picker user interface will disallow hiding it.
    //
    // @see method:listGrid.getHeaderContextMenuItems()
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridField.canDragResize (boolean : null : IR)
    // Whether this field can be dragResized using the mouse.  If unset, the default behavior
    // is governed by +link{listGrid.canResizeFields}.
    // @visibility external
    //<

    //> @attr listGridField.canReorder (boolean : null : IR)
    // Whether this field can be reordered using the mouse.  If unset, the default behavior is
    // governed by +link{listGrid.canReorderFields}.  Note that setting this property to
    // <code>false</code> will lock this field from being moved - that is, the user is
    // prevented from moving this field directly by dragging with the mouse, or by dropping
    // another field onto this field.
    // <P>
    // Note that setting <code>canReorder:false</code> on a field in the middle of a grid is
    // mostly useless, since it's possible that such a "locked" field may still be reordered
    // automatically, as a result of the user dragging one unlocked field onto another unlocked
    // field.
    // <P>
    // Fields in +link{listGrid.headerSpans,headerSpans} are treated as if they have
    // <code>canReorder:false</code> to keep the fields in the span together, except that
    // unlocked fields not in a span may be drag-reordered across them, even if they're at the
    // header's extreme left or right.  HeaderSpans themselves may not be drag-reordered.
    // @group dragging
    // @visibility external
    //<

    //> @attr listGridField.ignoreKeyboardClicks (boolean : null : IRW)
    // If the user is navigating through the grid using the keyboard, record click or double click
    // events may be generated via keyboard interactions (see +link{listGrid.generateClickOnSpace},
    // +link{listGrid.generateClickOnEnter}, +link{listGrid.generateDoubleClickOnSpace},
    // +link{listGrid.generateDoubleClickOnEnter} and +link{listGrid.arrowKeyAction}).
    // <P>
    // These synthetic events have both a target row and column.
    // Setting this flag to true ensures that this field will never be considered the target for
    // a keyboard click event.
    // @group events
    // @visibility external
    //<
    
    

    //> @attr listGridField.excludeFromState
    // @include dataSourceField.excludeFromState
    // @see ListGrid.getViewState()
    //<

     
    //> @attr listGridField.excludeFromFieldPicker
    // @include dataSourceField.excludeFromFieldPicker
    //<

    // Grid, Group and Record-level summaries
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.showGridSummary (Boolean : null : IR)
    // If +link{listGrid.showGridSummary} is true, should this field show a summary value.
    // If unset, this field will show a summary value in the summary row if an
    // explicit +link{listGridField.summaryFunction} is specified or if a
    // +link{SimpleType.getDefaultSummaryFunction(),default summary function} is defined
    // for the specified field type.
    // @visibility external
    //<

    //> @attr listGridField.showGroupSummary (boolean : null : IR)
    // If +link{listGrid.showGroupSummary} is true, should this field show a summary value
    // in a summary row when the grid is grouped?
    // If unset, this field will show a summary value in the summary row if an
    // explicit +link{listGridField.summaryFunction} is specified or if a
    // +link{SimpleType.getDefaultSummaryFunction(),default summary function} is defined
    // for the specified field type.
    // @visibility external
    //<

    //> @attr listGridField.summaryFunction (SummaryFunction | Array of SummaryFunction : null : IR)
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true,
    // this attribute can be used to specify
    // an explicit +link{type:SummaryFunction} for calculating the summary value to
    // display.
    // <P>
    // If an array of summaryFunctions is specified, they will be executed in turn and the
    // grid will show multiple summary rows at the grid or group level (or both)
    // containing the resulting values.
    // @visibility external
    //<

    //> @attr listGridField.summaryValueTitle (String : null : IR)
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true and the
    // +link{listGridField.summaryFunction} is set to <code>"title"</code>, this attribute may be
    // set to a string to display in the group and/or grid summary. If unspecified the
    // +link{listGridField.title} will show up in the summary.
    // @visibility external
    //<

    //> @method listGridField.getGridSummary() [A]
    // If +link{listGrid.showGridSummary} is true, and this method is specified it will be
    // called to generate the summary value to be displayed in the grid summary row. Note that
    // this is called instead of making use of the +link{listGridField.summaryFunction}.
    // <P>
    // As with +link{listGrid.getGridSummary()} this method may return an array of results -
    // in this case each result will show up in a separate row in the +link{listGrid.summaryRow}
    // grid.
    // <P>
    // If this grid is grouped, and +link{listGrid.showGroupSummary} is true, this method
    // will be passed a third parameter - an array of group-level summaries.
    // @param records (Array of ListGridRecord) records for which a summary is being generated
    // @param field (ListGridField) pointer to the field for which summary value is being generated
    // @param [groupSummaries] (Array of Object) If this grid is grouped and
    //  +link{listGrid.showGridSummary} is specified, this parameter contains an array of already-
    //  calculated summary values for each group in the grid. Each element in this array will
    //  be an object containing calculated summary values for each field in the grid, as well as
    //  a specified groupValue and groupName, allowing the developer to determine which group this
    //  summary value comes from
    // @return (Any) summary value to display.
    // @visibility external
    //<

    //> @attr listGridField.formatGridSummary (StringMethod : null : IR)
    // Optional stringMethod to format the summary value displayed
    // in the +link{listGrid.showGridSummary,grid summary}.
    // Takes a single parameter <code>value</code> and should return the formatted version
    // of that value. If specified this will be applied instead of any formatting logic applied
    // via +link{listGridField.formatCellValue()}, +link{listGrid.formatCellValue()}, etc.
    // <P>
    // Note that for fields with a specified summary function of "count", if no custom formatting
    // is applied, we default to formatting the count value by appending
    // <code>field.pluralTitle</code> if defined, otherwise <code>field.title</code> to the
    // numeric count value returned by the standard count function. To change this behavior for
    // such fields, specify an explicit 'formatGridSummary' and/or 'formatGroupSummary' method
    // @visibility external
    //<

    //> @method listGridField.getGroupSummary() [A]
    // If +link{listGrid.showGroupSummary} is true, and this method is specified it will be
    // called to generate the field summary value to be displayed for each group level summary row.
    // Note that this is called instead of making use of the +link{listGridField.summaryFunction}.
    // <P>
    // This method may return an array of results - in this case the group will show multiple summary
    // rows, with each entry in the array showing up in a different record.
    //
    // @param records (Array of ListGridRecord) records for which a summary is being generated
    //  (so all records in the group).
    // @param field (ListGridField) pointer to the field for which summary value is being generated
    // @param [groupNode] (Object) object with specified groupValue and groupName for this group
    // @return (Any) summary value to display
    // @visibility external
    //<

    //> @attr listGridField.formatGroupSummary (StringMethod : null : IR)
    // Optional stringMethod to format the group level summary values for this field displayed via
    // +link{listGrid.showGroupSummary}.
    // Takes a single parameter <code>value</code> and should return the formatted version
    // of that value.  If specified this will be applied instead of any formatting logic applied
    // via +link{listGridField.formatCellValue()}, +link{listGrid.formatCellValue()}, etc.
    // <P>
    // Note that for fields with a specified summary function of "count", if no custom formatting
    // is applied, we default to formatting the count value by appending
    // <code>field.pluralTitle</code> if defined, otherwise <code>field.title</code> to the
    // numeric count value returned by the standard count function. To change this behavior for
    // such fields, specify an explicit 'formatGridSummary' and/or 'formatGroupSummary' method
    // @visibility external
    //<

    //> @method listGridField.getRecordSummary() [A]
    // Only applies to +link{listGridFieldType,summary-type} fields. If specified, this
    // method will be called to generate the record summary value to be displayed for each row
    // in this field.  When this method is called, current values for other 
    // +link{listGridFieldType,summary-type} fields have not yet been stored on the record, but
    // are accessible via +link{listGrid.getRecordSummary()}.
    // <P>
    // Note that if specified, this is called instead of making use of the
    // +link{listGridField.recordSummaryFunction}.
    // <P>
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true, this
    // field's value in the summary row[s] will still be calculated by calling this method.
    // In this case, the record object passed in will contain summary values for each field.
    // If custom handling is required for this case, it may be detected by checking the
    // record object's +link{listGridRecord.isGroupSummary} and +link{listGridRecord.isGridSummary}
    // attributes.
    // @param record (ListGridRecord) record for which a summary is being generated
    // @param field (ListGridField) this field
    // @param grid (ListGrid) the grid
    // @return (Any) summary value to display
    // @visibility external
    //<

    //> @attr listGridField.recordSummaryFunction (RecordSummaryFunction : null : IR)
    // Only applies to fields of type <code>"summary"</code>.
    // Fields of this type will display a calculated value based on the other field values
    // within the current record.
    // <P>
    // This attribute specifies how the summary field value will be calculated. See
    // +link{type:RecordSummaryFunction} for valid options.
    // <P>
    // A subset of the ListGrid's fields will be passed to the RecordSummaryFunction.
    // <P>
    // The fields to be used for the summary calculation can be determined either by explicitly 
    // listing them (+link{listGridField.includeInRecordSummaryFields}), or by setting 
    // +link{listGridField.includeInRecordSummary} to true on fields that should be included and 
    // false on fields that should not.  
    // <P>
    // By default, all visible fields of numeric type are used.  Note that, in this mode, if the 
    // user is able to hide some fields, this could change the formula.  If this isn't desirable, 
    // consider setting +link{listGridField.canHide} to prevent fields from being hidden.  
    // Consider this even if fields to include in the summary are explicitly listed, as hidden 
    // fields involved in a visible calculation can be confusing for an end user.
    // <P>
    // If +link{listGrid.showGridSummary} or +link{listGrid.showGroupSummary} is true, this
    // field's value in the summary row[s] will still be calculated by calling this method.
    // In this case, the record object passed in will contain summary values for each field.
    // If custom handling is required for this case, it may be detected by checking the
    // record object's +link{listGridRecord.isGroupSummary} and +link{listGridRecord.isGridSummary}
    // attributes.
    // @see listGrid.recordSummaryAttributePrefix
    // @visibility external
    //<

    //> @attr listGridField.partialSummary (boolean : null : IR)
    // Only applies to fields of type <code>"summary"</code>.
    // This attribute is set on a summary field, when calculating the summary value from
    // some record, the summary function will only be passed the fields before this summary field.
    // This may be useful for displaying running totals across a record.
    // <P>
    // Note that this feature would typically be used with
    // +link{listGrid.canReorderFields,canReorderFields:false}
    // @visibility external
    //<

    //> @attr listGridField.includeInRecordSummary (boolean : null : IR)
    // If a listGrid is showing a field of type summary, should this field be passed to the
    // recordSummaryFunction when calculating the summary value to display.
    // If unset, fields are included if they are of type "integer" or "float" only (since most
    // summary functions perform numeric calculations). See also
    // +link{listGridField.includeInRecordSummaryFields}.
    // @visibility external
    //<

    //> @attr listGridField.includeInRecordSummaryFields (Array of FieldName : null : IR)
    // If this listGrid has any fields of type <code>"summary"</code> and
    // this field will be +link{listGridField.includeInRecordSummary,included} in summary calculations
    // by default, this attribute provides an opportunity to explicitly specify which summary fields
    // the record should be displayed in.
    // <P>
    // Specified as an array of fieldNames. If set, this field value will only be included for
    // record summary value calculations for summary fields who's name is included in this array.
    // @visibility external
    //<

    //> @attr listGridField.applyAfterSummary (Boolean : null : IRW)
    // If +link{listGridField.userFormula} is set for this field, and this grid is showing
    // +link{listGrid.showGroupSummary,group summaries} or a
    // +link{listGrid.showGridSummary,grid summary}, this property determines what field value
    // should be present in those summary rows. Should the field apply the user-formula to the
    // calculated summary row, or should it apply a standard grid or group summary to the
    // user-formula values displayed in the grid?
    // <P>
    // Default behavior may be specified at the grid level via +link{listGrid.applyFormulaAfterSummary}
    // @visibility external
    //<

    // Header button icons
    // ---------------------------------------------------------------------------------------
    // Include all relevant docs from StatefulCanvas

    //> @attr listGridField.icon (SCImgURL: null : [IR])
    // Optional icon to show next to the title for this field.
    // Should be set to a URL to an image. Relative paths will be evaluated starting at
    // the imgDir of this component. This URL is partial - it may be updated to indicate
    // the current disabled (etc) state of the field.
    // <p>
    // If +link{listGridField.type,field.type} is set to "icon", this icon will also be shown
    // in every cell of this field - see also +link{listGridField.cellIcon,field.cellIcon}.
    // <p>
    // To change this property after fields have been passed to +link{listGrid.setFields()},
    // use +link{listGrid.setFieldIcon()}.
    //
    // @visibility external
    //<

    //> @attr listGridField.iconSize (Integer : null : [IR])
    // If +link{listGridField.icon} is specified, this property can be used to specify the
    // size of the icon to be displayed in the ListGrid header button.
    // (See +link{StatefulCanvas.iconSize})
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.iconWidth (Integer : null : [IR])
    // If +link{listGridField.icon} is specified, this property can be used to specify the
    // width of the icon to be displayed in the ListGrid header button.
    // (See +link{StatefulCanvas.iconWidth})<br>
    // If this field is editable, and +link{ListGridField.editorIconWidth} is unset, this
    // property will be passed onto the editors for this field as +link{FormItem.iconWidth},
    // which will effect the default size for +link{ListGridField.icons, icons} displayed
    // in the editor.
    // @see listGridField.icon
    // @see listGridField.icons
    // @visibility external
    //<

    //> @attr listGridField.iconHeight (Integer : null : [IR])
    // If +link{listGridField.icon} is specified, this property can be used to specify the
    // height of the icon to be displayed in the ListGrid header button.
    // (See +link{StatefulCanvas.iconHeight})<br>
    // If this field is editable, and +link{ListGridField.editorIconHeight} is unset, this
    // property will be passed onto the editors for this field as +link{FormItem.iconWidth},
    // which will effect the default size for +link{ListGridField.icons, icons} displayed
    // in the editor.
    // @see listGridField.icon
    // @see listGridField.icons
    // @visibility external
    //<

    //> @attr listGridField.iconOrientation (String : "left" : [IR])
    // If this field is showing an icon, should it appear to the left or right of the title?<br>
    // Valid options are <code>"left"</code> or <code>"right"</code>
    // @see listGridField.icon
    // @visibility external
    //<
    // iconOrientation JS doc not included from statefulCanvas as that refers to
    // setIconOrientation(), and we don't have an exposed way to get at the ListGrid field
    // header button at runtime.

    //> @attr listGridField.iconSpacing (int : 6 : [IR])
    // @include statefulCanvas.iconSpacing
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showDisabledIcon (Boolean : true : [IR])
    // @include statefulCanvas.showDisabledIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showRollOverIcon (Boolean : false : [IR])
    // @include statefulCanvas.showRollOverIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showFocusedIcon (Boolean : false : [IR])
    // @include statefulCanvas.showFocusedIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showDownIcon (Boolean : false : [IR])
    // @include statefulCanvas.showDownIcon
    // @see listGridField.icon
    // @visibility external
    //<

    //> @attr listGridField.showSelectedIcon (Boolean : false : [IR])
    // @include statefulCanvas.showSelectedIcon
    // @see listGridField.icon
    //  @visibility external
    //<

    //> @attr listGridField.cellIcon (SCImgURL : null : [IR])
    // For a field of type:"icon" only, set the icon that appears in body cells.  Unless
    // setting +link{listGridField.icon,field.icon}, setting field.cellIcon will not show an
    // icon in the header.
    // <p>
    // To change this property after fields have been passed to +link{listGrid.setFields()},
    // use +link{listGrid.setFieldCellIcon()}.
    //
    // @visibility external
    //<

    //> @attr   listGridField.iconCursor       (Cursor : null : IRWA)
    // Specifies the cursor to display when the mouse pointer is over an icon image in a cell
    // for either a field of type +link{listGridField.icon,icon} or a 
    // +link{listGridField.valueIcons,valueIcon}.
    // <P>
    // If not explicitly specified, see +link{listGrid.getIconCursor()} for how <code>"icon"</code>
    // fields determine icon image cursors, and +link{listGrid.getValueIconCursor()} for how
    // value icon image cursors are determined.
    //
    //  @visibility external
    //<


    //> @attr listGridField.showFileInline (boolean : null : [IR])
    // For a field of type:"imageFile", indicates whether to stream the image and display it
    // inline or to display the View and Download icons.
    //
    // @visibility external
    //<

    //> @attr listGridField.showEllipsisWhenClipped (Boolean : null : IRW)
    // Should ellipses be displayed when this field's cell content is clipped? To set this 
    // property at the grid level, use +link{listGrid.showEllipsisWhenClipped}
    // @visibility external
    //<
    
    //> @attr listGridField.format (FormatString : null : IR)
    // +link{FormatString} for numeric or date formatting.  See +link{dataSourceField.format}.
    // @group exportFormatting
    // @visibility external
    //<

    //> @attr listGridField.exportFormat (FormatString : null : IR)
    // +link{FormatString} used during exports for numeric or date formatting.  See
    // +link{dataSourceField.exportFormat}.
    // @group exportFormatting
    // @visibility external
    //<

    // FormItem icons
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.icons (Array of FormItemIcon Properties: null : [IRA])
    // If this field is editable, this property can be used to specify
    // +link{FormItem.icons, icons} to be displayed in the editors displayed for this field
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.editorIconWidth (number : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconWidth}.<br>
    // If this property unset, the iconWidth property from the editor can be picked up from
    // +link{listGridField.iconWidth} instead.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.editorIconHeight (number : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconHeight}.<br>
    // If this property unset, the iconHeight property from the editor can be picked up from
    // +link{listGridField.iconHeight} instead.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.defaultIconSrc (String : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.defaultIconSrc}.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.iconPrompt (String : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconPrompt}.
    // @see listGridField.icons
    // @group editing
    // @visibility internal
    //<

    //> @attr listGridField.iconHSpace (String : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconHSpace}.
    // @see listGridField.icons
    // @group editing
    // @visibility internal
    //<

    //> @attr listGridField.iconVAlign (String : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.iconVAlign}.
    // @see listGridField.icons
    // @group editing
    // @visibility external
    //<

    // editor picker icon
    
    //> @attr listGridField.showPickerIcon (boolean : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.showPickerIcon}.
    // @group editing
    // @visibility pickerIcon
    //<

    //> @attr listGridField.pickerIconSrc (String : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.pickerIconSrc}.
    // @group editing
    // @visibility pickerIcon
    //<

    //> @attr listGridField.pickerIconWidth (Integer : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.pickerIconWidth}.
    // @group editing
    // @visibility pickerIcon
    //<

    //> @attr listGridField.pickerIconHeight (Integer : null : [IRA])
    // If this field is editable, this property will be passed to editors displayed for
    // cells within this field as +link{FormItem.pickerIconHeight}.
    // @group editing
    // @visibility pickerIcon
    //<

    // Summary Title
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.summaryTitle (String : null : [IRWA])
    // Optional long summary title for this field, provided in addition to
    // +link{listGridField.title}. This gives the developer an option to use a very short,
    // or empty title for the ListGrid column (where space may be a factor), but have a longer
    // value available to be used elsewhere.
    // <p>
    // By default this value will be used for the title of the context-menu item
    // for showing/hiding the listGrid field when the user right-clicks on the ListGrid header.
    //
    // @group appearance
    // @see attr:listGridField.title
    // @deprecated Rather than customizing the summaryTitle developers should typically use
    //  the +link{listGridField.headerTitle} attribute to show a different
    //  title in the column header button than the title used elsewhere.
    // @visibility external
    //<

    //> @method listGridField.getSummaryTitle() [A]
    // Optional string method to return a long summary title for this field, if a dynamic
    // summary title is required for this field.
    //
    // @param viewer (ListGrid) pointer back to the ListGrid
    // @param field (ListGridField) pointer to the field object
    // @group appearance
    // @see attr:listGridField.summaryTitle
    // @see attr:listGridField.title
    // @deprecated Rather than customizing the summaryTitle developers should typically use
    //  the +link{listGridField.headerTitle} attribute to show a different
    //  title in the column header button than the title used elsewhere.
    // @visibility external
    //<

    // Header Appearance
    // ---------------------------------------------------------------------------------------

	//> @attr listGridField.width (Number | String : "*" : [IRW])
	// The width of this field, specified as either an absolute number of pixels,
	// a percentage of the remaining space like "25%", or "*" to split remaining space among
    // all fields which have "*". <P>
    // Caution: stretch sizes are currently ignored if the field is being autofitted
    // (see +link{listGrid.autoFitFieldWidths}), unless +link{listGrid.showHeader} is false.
    // <P>
    // Note: if autofitting is active for a field, the width will default to the numerical
    // autofit width for that field (so it will not be stretched larger to fill available
    // space).  Otherwise, if not autofitting, the width will default to "*" causing it to be
    // automatically stretched.
    // <P>
    // The width may be defaulted to a numerical value based on +link{dataSourceField.length}
    // if no +link{listGridField.valueMap} is set, subject to the initial values of
    // +link{minWidth} and +link{listGrid.minFieldWidth}.  If you'd rather have the field
    // stretched-sized to fit the available space, set its initial width to "*".
    // <P>
    // See also +link{listGrid.minFieldWidth} to ensure no field goes below a minimum size.
    // <P>
    // Use +link{listGrid.resizeField} to programmatically change field width after creation.
    // <P>
    // Use +link{listGrid.getFieldWidth} to access the rendered field width after
    // the ListGrid is drawn.
    //
    // @see ListGrid.autoFitFieldWidths
    // @see listGridField.minWidth
    // @see listGridField.maxWidth
	// @group appearance
	// @visibility external
	//<

	//> @attr listGridField.minWidth (Number : null : [IRW])
	// When a field is subject to autofitting (see +link{listGrid.autoFitFieldWidths}), sets the
    // minimum width of the field.  The actual allowed minimum will be the maximum of:<ul>
    // <li> this property,
    // <li> +link{width} (if a number),
    // <li> the aufofit value determined by the widest value content in this field's column
    // <li> +link{listGrid.minFieldWidth}
    // </ul>
	// @group appearance
    // @see listGridField.width
	// @visibility external
	//<

	//> @attr listGridField.maxWidth (Number : null : [IRW])
	// When +link{listGrid.showHeader} is false and a field is subject to autofitting (see
    // +link{listGrid.autoFitFieldWidths}), sets the maximum width of the field.  The actual
    // effective maximum will be the largest of this property, +link{minWidth}, and 
    // +link{listGrid.minFieldWidth}.  That is, +link{minWidth} and 
    // +link{listGrid.minFieldWidth} dominate this property.
	// @group appearance
    // @see listGridField.width
	// @visibility external
	//<
    
    //> @attr   listGridField.align (Alignment : null : [IRW])
    // Horizontal alignment for field's column header: "left", "right"
    // or "center". Applied to the column header title and cells by default. A separate
    // alignment for cells can be specified via +link{listGridField.cellAlign}.
    // <P>
    // If null, the default alignment depends on the field's declared +link{type} - generally
    // "left" except for numbers which are "right" - and if +link{rotateTitle} has been
    // specified, the default is always "center".
    // <P>
    // Note that if this field is editable, the alignment of cells in the body will also be
    // reflected in any editors for the field.
    //  @group  appearance
    //  @visibility external
    //<

    //> @attr listGridField.headerBaseStyle (CSSStyleName : null : [IRW])
    // Custom base style to apply to this field's header button instead of
    // +link{listGrid.headerBaseStyle}.<br>
    // Note that depending on the header button constructor, you may have to override
    // +link{listGridField.headerTitleStyle} as well.
    // @group appearance
    // @visibility external
    //<
    
    //> @attr listGridField.spannedHeaderBaseStyle (CSSStyleName : null : [IRW])
    // Custom base style to apply to this field's header button instead of
    // +link{listGrid.spannedHeaderBaseStyle} when the grid is showing header spans.<br>
    // @group gridHeader, appearance, headerSpan
    // @visibility external
    //<

    //> @attr listGridField.headerTitleStyle (CSSStyleName : null : [IRW])
    // Custom titleStyle to apply to this field's header button instead of
    // +link{listGrid.headerTitleStyle}.<br>
    // Note that this will typically only have an effect if
    // +link{listGrid.headerButtonConstructor} is set to +link{class:StretchImgButton} or a subclass
    // thereof.
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridField.headerTitle (String : null : IR)
    // Optional title for the header button for this field. If specified this will be
    // displayed in the header button instead of +link{listGridField.title} or
    // +link{listGridField.name}. Set to an empty string to suppress the title in the
    // header button entirely.
    // @group appearance
    // @see listGridField.title
    // @visibility external
    //<



    // Header Spans
    // ---------------------------------------------------------------------------------------
    // - known limitations
    //   - can't reorder a column to before or after a spanned set of columns, if the spanned
    //   columns are at the start or end of the visible fields.
    //   - several uses of this.Super(), instead of the faster this.invokeSuper() approach.
    //   Attempt to use invokeSuper() failed, likely because the header is not a discrete
    //   class, but an instance of Toolbar, and my guess (Alex) is that Class.invokeSuper()
    //   doesn't handle this particular case.


    //> @attr listGrid.headerSpans (Array of HeaderSpan : null : IRW)
    // Header spans are a second level of headers that appear above the normal ListGrid headers,
    // spanning one or more listGrid fields in a manner similar to a column-spanning cell in an
    // HTML table.
    // <P>
    // A header span can be created by simply naming the fields the header should span.  The
    // example below creates a headerSpan that spans the first two fields of the ListGrid.
    // <smartclient>
    // <pre>
    //    isc.ListGrid.create({
    //        headerHeight:40,
    //        fields : [
    //            { name:"field1" },
    //            { name:"field2" },
    //            { name:"field3" }
    //        ],
    //        headerSpans : [
    //            {
    //                fields: ["field1", "field2"],
    //                title: "Field 1 and 2"
    //            }
    //        ]
    //    });
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    //      ListGrid grid = new ListGrid();
    //      grid.setHeaderHeight(40);
    //      grid.setFields(new ListGridField[] {
    //          new ListGridField("field1"),
    //          new ListGridField("field2"),
    //          new ListGridField("field3")
    //      });
    //      grid.setHeaderSpans(new HeaderSpan[] {
    //          new HeaderSpan("Field 1 and 2", new String[] {"field1", "field2"})
    //      });
    // </pre>
    // </smartgwt>
    // Header spans can be nested, allowing fields to be grouped by multiple levels of
    // granularity. See +link{headerSpan.spans} for further information on nesting spans.
    // <P>
    // Header spans will automatically react to resizing of the headers they span, and will be
    // hidden automatically when all of the spanned fields are hidden.
    // <P>
    // Header spans appear in the +link{listGrid.header,header} area of the ListGrid, sharing space
    // with the existing headers, so it's typical to set +link{listGrid.headerHeight} to
    // approximately double its normal height when using headerSpans, or if using nested header
    // spans, the default header height multiplied by the number of levels of header spans to be
    // shown.
    // <P>
    // See +link{headerSpan} for many properties that allow the control of the appearance of
    // headerSpans.
    // <smartclient>
    // Note that headerSpans are created via the +link{AutoChild} pattern, hence
    // you can change the SmartClient component being used, or any of its properties.
    // </smartclient>
    // <P>
    // Neither headerSpans themselves nor the fields within them may be drag reordered, but other
    // unspanned headers may be.
    // <P>
    // A span can only span adjacent fields - if a span is defined and the spanned fields don't
    // sit next to each other in the specified fields array, the fields array will be automatically
    // reordered to match the order specified in the span's +link{headerSpan.fields} array.
    // <P>
    // Note that headerSpans primarily provide a visual cue for grouping multiple headers
    // together.  If you have an OLAP, data "cube" or multi-dimensional data model, the
    // +link{CubeGrid} component is the right choice.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpanHeight (Integer : null : IR)
    // Default height for a +link{listGrid.headerSpans,headerSpan} with no height specified.
    // <P>
    // If <code>headerSpanHeight</code> is not specified (the default), headerSpans will be 1/2
    // of +link{listGrid.headerHeight}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpanVAlign (VAlign : "center" : IR)
    // Default alignment for +link{listGrid.headerSpans,headerSpans} with no
    // +link{headerSpan.valign} specified.
    //
    // @group headerSpan
    // @visibility external
    //<
    headerSpanVAlign: "center",

    //> @attr listGrid.unspannedHeaderVAlign (VAlign : null : IR)
    // When +link{listGrid.headerSpans,headerSpans} are in use, this property sets the default
    // vertical alignment for fields which do <b>not</b> have a headerSpan.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpanConstructor (SCClassName : null : IR)
    // +link{SCClassName,SmartClient Class} to use for headerSpans.  Typically a +link{Button} or
    // +link{StretchImgButton} subclass.
    // <P>
    // If unset, headerSpans will be created using the +link{listGrid.headerButtonConstructor}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr listGrid.headerSpan (MultiAutoChild StatefulCanvas : null : IR)
    // +link{listGrid.headerSpans,headerSpans} are created via the +link{AutoChild} pattern, hence
    // <code>headerSpanConstructor</code>, <code>headerSpanDefaults</code> and
    // <code>headerSpanProperties</code> are valid.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @object HeaderSpan
    // A header span appears as a second level of headers in a ListGrid, spanning one or more
    // ListGrid columns and their associated headers.
    // <P>
    // See +link{listGrid.headerSpans}.
    // <P>
    // In addition to the properties documented here, all other properties specified on the
    // headerSpan object will be passed to the +link{Class.create,create()} method of the
    // +link{listGrid.headerSpanConstructor}.  This allows you to set properties such as
    // +link{button.baseStyle} or +link{stretchImgButton.src} directly in a
    // <code>headerSpan</code>.
    //
    // @group headerSpan
    // @treeLocation Client Reference/Grids/ListGrid
    // @visibility external
    //<

    //> @attr headerSpan.name (Identifier : null : IR)
    // Name for this headerSpan, for use in APIs like +link{listGrid.setHeaderSpanTitle()}.
    // <P>
    // Name is optional, but if specified, must be unique for this ListGrid (but not globally
    // unique) as well as a valid JavaScript identifier, as specified by ECMA-262 Section 7.6
    // (the <smartclient>+link{String.isValidID()}</smartclient><smartgwt>StringUtil.isValidID()
    // </smartgwt> function can be used to test whether a name is a valid JavaScript
    // identifier).
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.fields (Array of String : null : IR)
    // List of fields that this header spans.  Fields should be identified by their value for
    // +link{listGridField.name}.
    // <P>
    // Developers may define multiple levels of header-spans by specifying +link{headerSpan.spans}
    // however a span cannot be specified with both <code>fields</code> and <code>spans</code>.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.spans (Array of HeaderSpan : null : IR)
    // This property allows developer to "nest" header spans, grouping fields together by
    // multiple layers of granularity.
    // <P>
    // For example a group of fields could be nested within two layers of header spans as follows:
    // <smartclient>
    // <pre>
    // { title:"Europe", spans:[
    //      {title:"France", fields:["Paris", "Lyon"]},
    //      {title:"UK", fields:["London", "Glasgow"]},
    //      {title:"Spain", fields:["Barcelona"]}
    //  ]
    // }
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    //      HeaderSpan france = new HeaderSpan("France", new String[] {"Paris", "Lyon"});
    //      HeaderSpan uk = new HeaderSpan("UK", new String[] {"London", "Glasgow"});
    //      HeaderSpan spain = new HeaderSpan("Spain", new String[] {"Barcelona"});
    //
    //      HeaderSpan europe = new HeaderSpan();
    //      europe.setTitle("Europe");
    //      europe.setSpans(france, uk, spain);
    // </pre>
    // </smartgwt>
    // Note that a span definition can not include both <code>spans</code>
    // and +link{headerSpan.fields,fields}.
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.title (String : null : IR)
    // A title for this headerSpan, to display in the headerSpan button for this headerSpan
    // and in other contexts such as the +link{listGrid.canPickFields,menu for picking visible fields}.
    //
    // Note: if you want to use HTML tags to affect the display of the header, you should do so
    // via +link{headerSpan.headerTitle} instead so that other places where the title
    // appears in the UI are not affected.  Refer to discussion at +link{listGridField.title}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.headerTitle (String : null : IR)
    // Optional title for the headerSpan button for this headerSpan. If specified this will be
    // displayed in the headerSpan button instead of +link{headerSpan.title}. Set to an empty
    // string to suppress the title in the header button entirely.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.headerBaseStyle (CSSStyleName : null : [IRW])
    // Custom base style to apply to the header button created for this span instead
    // of +link{listGrid.headerBaseStyle}.
    // <P>
    // Note that depending on the header button constructor, you may have to specify
    // +link{headerSpan.headerTitleStyle} as well.
    // @group appearance
    // @visibility external
    //<

    //> @attr headerSpan.headerTitleStyle (CSSStyleName : null : [IRW])
    // Custom titleStyle to apply to the header button created for this span instead of
    // +link{listGrid.headerTitleStyle}.
    // <p>
    // Note that this will typically only have an effect if
    // +link{listGrid.headerButtonConstructor} is set to +link{class:StretchImgButton} or a subclass
    // thereof.
    // @see headerSpan.headerBaseStyle
    // @group appearance
    // @visibility external
    //<

    //> @attr headerSpan.height (Integer : null : IR)
    // Height of this headerSpan.  Defaults to +link{listGrid.headerSpanHeight}.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.valign (VerticalAlignment: null : IR)
    // Vertical alignment of the title of this headerSpan.
    // <P>
    // Defaults to listGrid.headerSpanVAlign if unset.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.align (Alignment: "center" : IR)
    // Horizontal alignment of the title of this headerSpan.
    //
    // @group headerSpan
    // @visibility external
    //<

    //> @attr headerSpan.wrap (Boolean : null : [IR])
    // Should the span title wrap if there is not enough space horizontally to accommodate it.
    // If unset, default behavior is derived from +link{listGrid.wrapHeaderSpanTitles}.  (This
    // is a soft-wrap - if set the title will wrap at word boundaries.)
    //
    // @see listGridField.wrap
    // @visibility external
    //<

    //> @attr listGrid.showTreeColumnPicker (Boolean : true : IR)
    // When +link{listGrid.headerSpans} are in use, whether to show a hierarchical column picker
    // that includes both headerSpans and normal headers, with normal headers indented under
    // headerSpans similarly to how a +link{TreeGrid} displays a Tree.
    // <P>
    // If <code>showTreeColumnPicker</code> is false, no column picker will be shown on the
    // headerSpan itself, and the column picker for a clicked on a normal field header will include
    // only normal fields.
    //
    // @group headerSpan
    // @visibility external
    //<
    showTreeColumnPicker: true,

    //> @attr listGrid.spannedHeaderBaseStyle (CSSStyleName : null : IR)
    // +link{Button.baseStyle} to apply to the field header buttons for
    // this ListGrid when showing header spans.
    // Note that, depending on the +link{listGrid.headerButtonConstructor, Class} of the header
    // buttons, you may also need to set +link{listGrid.headerTitleStyle}.
    // @group   gridHeader, appearance, headerSpan
    // @visibility external
    //<

    // Cell Styling
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.cellAlign (Alignment : null : [IRW])
    // Horizontal alignment for cells in this field's column: "left", "right"
    // or "center".<br>
    // If null, alignment is derived from +link{ListGridField.align}. If this field is editable,
    // the alignment of cells in the body will also be reflected in any editors for the field.
    //  @group  appearance
    //  @visibility external
    //<

    //> @attr listGrid.reverseRTLAlign (Boolean : true : [IRW])
    // If a page is rendered in +link{isc.Page.isRTL(),RTL mode}, should
    // cell alignments specified +link{listGridField.cellAlign} be reversed (so
    // an <code>align:"right"</code> field will have content aligned on the left and
    // vice versa)?
    // <P>
    // This is true by default to match user expectation that text flows from
    // start-to end and is aligned with the start of text flow (left in LTR mode,
    // right in RTL mode) by default. May be set to false to have the specified
    // alignments be taken literally in RTL mode.
    // @group RTL
    // @visibility external
    //<
    reverseRTLAlign:true,


    //> @attr   listGridField.baseStyle (CSSStyleName : null : [IRW])
    //  Custom base style to apply to all cells in this field instead of +link{ListGrid.baseStyle}
    //  To override the baseStyle at the row level, use
    //  +link{ListGrid.recordBaseStyleProperty, record[listGrid.recordBaseStyleProperty]}
    //  instead.
    // @see ListGrid.recordBaseStyleProperty
    // @group appearance
    // @visibility external
    // @example gridCells
    //<

    // Sorting (per field)
    // ---------------------------------------------------------------------------------------

    //> @attr   listGridField.canSort (Boolean : true : [IRW])
    //  Enables or disables sorting by this column. If false, interactive
    //  sorting via header-clicks or menu-items will have no effect, but direct scripted calls
    //  to +link{ListGrid.sort, sort()} or +link{ListGrid.setSort, setSort()} will work as
    //  expected.
    //  @group  sorting
    //  @see    method:ListGrid.sort
    //  @see    attr:ListGrid.canSort
    //  @visibility external
    //<

    //> @attr listGridField.sortDirection (SortDirection : null : [IRW])
    // Specifies the default sorting direction for this column. If specified on the
    // +link{listGrid.sortField,default sort field} for the listGrid, sorting occurs
    // automatically, otherwise this will be the default direction when the user clicks the
    // field header, or calls +link{ListGrid.sort()} without specifying an explicit sort
    // direction.
    // <P>
    // Overrides ListGrid.sortDirection
    //  @group  sorting
    //  @see type:SortDirection
    //  @visibility external
    //<

    //> @method listGridField.sortNormalizer() (A)
    // Optional function to return the value that should be used when sorting this field.
    // <P>
    // Note that, if the dataset exceeds +link{ListGrid.dataPageSize} and hence paging is
    // introduced, the grid relies on the server to provide sorting, and the sortNormalizer
    // will no longer be called.
    // <P>
    // For custom sort orders that can be executed both client and server, consider
    // +link{dataSourceField.sortByField}.
    //
    // @param recordObject    (Object)    record to normalize
    // @param fieldName       (String)    name of the field on which sorting occurred
    // @param context (ListGrid) A pointer back to the list grid displaying this field will
    //   be available as the <code>context</code> argument. Note that you can also get a pointer
    //   to the field definition object by calling <code>context.getField(fieldName)</code>
    //  @return (Any)   normalized value for sorting
    //  @group  sorting
    //  @visibility external
    //  @example dataTypes
    //<
    
    //> @attr listGridField.selectCellTextOnClick (Boolean : null : [IRW])
    // Should the cell content be natively selected (ready for copying to clip-board) 
    // on click?
    // <P>
    // See +link{listGrid.selectCellTextOnClick} for more information.
    // @visibility external
    //<

    // Editing (per field)
    // ----------------------------------------------------------------------------------------

    //> @attr listGridField.canEdit (boolean : null : [IRW])
    // This property establishes default editability for the field.  May be overridden by setting
    // the 'canEdit' property at the listGrid level. If not explicitly set and this grid is bound
    // to a dataSource, the +link{listGrid.canEditFieldAttribute} may be used to set default
    // editability at the field level.
    // <p>
    // An override of +link{listGrid.canEditCell} can be used for more dynamic control over whether
    // fields can be edited.
    //
    // <smartgwt><P>Note that this property may validly be <code>null</code> as a distinct state
    // from <code>false</code>.  See +link{listGrid.fieldIsEditable()} for an API that will
    // always return <code>true</code> or <code>false</code> as to whether editing is possible
    // by default.</smartgwt>
    //
    // @group  editing
    // @see attr:listGrid.canEdit
    // @see attr:listGrid.recordEditProperty
    // @see method:listGrid.canEditCell
    // @visibility external
    // @example disableEditing
    //<

    //> @attr listGridField.alwaysShowEditors (boolean : null : [IRW])
    // When this attribute is set, editors will be rendered into every row of the grid for
    // this field, rather than showing up in a single record at a time.
    // This attribute is only valid when +link{listGrid.editByCell} is false
    // @group editing
    //<
    


    //> @attr listGridField.defaultValue (Any : null : [IRW])
    // If this field +link{listGridField.canEdit, can be edited}, this property can be used to
    // specify a default value for this field's editor when adding new rows to the grid.
    // @see listGrid.startEditingNew()
    // @group editing
    // @visibility external
    //<

    //> @method listGridField.defaultDynamicValue()
    // +link{FormItem.defaultDynamicValue} to be applied to the cell editor for this field
    // when +link{listGridField.canEdit,editing}.
    // <P>
    // Note that editors are only generated for fields that are actually written out, and
    // as such <code>defaultDynamicValue</code> will not apply to
    // +link{listGridField.hidden,hidden fields}, or fields that are not drawn due to
    // +link{listGrid.showAllColumns,incremental column rendering}.
    // <P>
    // To apply arbitrary default values to the grid when editing new records, developers may
    // use the +link{listGrid.startEditingNew(),newValues parameter of startEditingNew()}.
    //
    // @param   item    (FormItem)  The editor for the cell itself (also available as "this").
    //                              Note that in addition to the standard FormItem APIs available
    //                              on the editor, it also has:<br>
    //                              - a pointer back to the containing listGrid
    //                              [<code>item.grid</code>]<br>
    //                              - the colNum being edited [<code>item.colNum</code>]<br>
    //                              - the rowNum being edited [<code>item.rowNum</code>]
    // @param   form    (DynamicForm) the managing DynamicForm instance
    // @param   values  (Object)      the current set of values for the form as a whole
    // @return (Any) dynamically calculated default value for this field's edit item.
    // @group editing
    // @visibility external
    //<

    //> @attr   listGridField.enterKeyEditAction (EnterKeyEditAction : "done" : [IRW])
    // What to do when a user hits enter while editing this field?<br>
    // Overrides the <code>enterKeyEditAction</code> as specified at the listGrid level while
    // focus is in this field.
    //  @group  editing
    //  @visibility external
    //<

    //> @attr   listGridField.escapeKeyEditAction (EscapeKeyEditAction : "cancel" : [IRW])
    // What to do when a user hits escape while editing this field?<br>
    // Overrides the <code>escapeKeyEditAction</code> as specified at the listGrid level while
    // focus is in this field.
    //  @group  editing
    //  @visibility external
    //<

    //> @attr   listGridField.arrowKeyEditAction (ArrowKeyEditAction : null : [IRW])
    // What to do when a user hits arrow key while editing this field?<br>
    // See +link{listGrid.getArrowKeyEditAction()}.
    //  @group  editing
    //  @visibility external
    //<

    
    //> @attr   listGridField.nextTabColNum (number : null : [IRWA])
    // If specified, when the user hits tab while editing this field, editing will move to the
    // specified colNum in the next row (or the first editable field after it), rather than the
    // next editable field in this row.
    //  @group  editing
    //  @visibility advancedInlineEdit
    //<

    //> @attr   listGridField.previousTabColNum (number : null : [IRWA])
    // If specified, when the user hits shift+tab while editing this field, editing will move
    // to the specified colNum in the previous row (or the first editable field before it),
    // rather than the previous editable field in this row.
    //  @group  editing
    //  @visibility advancedInlineEdit
    //<

    //> @attr listGridField.editorType (FormItemClassName : null : [IRWA])
    //      Name of form item class to use for the form item created to edit this field.
    //      (Only used if this field is editable).<br>
    //      Note: If this is not specified, the edit-form item type may be derived from the
    //      <code>editorType</code> property, typically inherited from datasource fields, or
    //      from the <code>type</code> of the field (showing the appropriate form item for
    //      the data-type). See the +link{group:editing} overview for more on editing ListGrid
    //      fields.
    //  @group  editing
    //  @see attr:listGrid.canEdit
    //  @visibility external
    //  @example customEditors
    //<
    // link to editing group documentation included as that describes the additional
    // "rowNum", "colNum" and "grid" properties stored on the editor.
    
    //> @attr   listGridField.editorProperties (FormItem Properties : null : [IRWA])
    // Properties to apply the the form item created to edit this field. (Only used if
    // this field is editable).
    // <P>
    // For example, if you have a field "shoeSize" with +link{dataSourceField.editorType} set
    // to "SpinnerItem" in order to use a SpinnerItem as your field editor, and you want to pass the
    // +link{spinnerItem.step} property to the created SpinnerItem:
    // <pre>
    //    fields : [
    //        { name:"shoeSize", editorType:"SpinnerItem",
    //          editorProperties : { step:0.5 } },
    //        ... other fields ...
    //    ]
    // </pre>
    //
    // @group editing
    // @visibility external
    // @example customEditors
    //<

    //> @attr listGridField.initialValue (Any : null : IR)
    // In an editable ListGrid, initial value for this field when the user begins editing a new
    // record.
    // <p>
    // <code>initialValue</code> applies only if a new record is created by end user action (such
    // as navigating past the end of the data when +link{listGrid.listEndEditAction} is "next") or
    // by a call to +link{listGrid.startEditingNew()} that <i>does not specify the
    // <code>initialValues</code></i> argument.
    //
    // @group editing
    // @visibility external
    //<
    
	//> @attr   listGrid.modalEditing (boolean : null : [IRWA])
	//      If this property is true, any mouse click outside of the open cell editors
    //      will end editing mode, hiding the cell editors and saving any changes to those
    //      cell values.
    // @group  editing
    // @visibility external
    // @example modalEditing
    //<

    //> @method listGridField.editorEnter (A)
    // Callback fired when the user first starts editing a cell.
    // <P>
    // This callback is typically used to establish dynamic default values via
    // +link{listGrid.setEditValue()} or +link{listGrid.setEditValues()}.
    //
    // @param record (ListGridRecord) record for the cell being edited.  <b>Will be null</b>
    //                                for a new, unsaved record.
    // @param value (Any) value for the cell being edited
    // @param rowNum (int)  row number for the cell
    // @param colNum (int)  column number of the cell
    // @param grid (ListGrid) ListGrid to which this field belongs
    // @group editing
    // @visibility external
    //<

    //> @method listGridField.editorExit (A)
    // Callback fired when the user attempts to navigate away from the current edit cell,
    // or complete the current edit.<br>
    // Return false from this method to cancel the default behavior (Saving / cancelling the
    // current edit / moving to the next edit cell)
    //
    // @param   editCompletionEvent (EditCompletionEvent)  What interaction triggered this
    //                                                          edit cell exit
    // @param   record     (ListGridRecord) record for the cell being edited
    // @param   newValue   (Any)    new edit value for the cell being edited. Note that if the
    //    user has not made any changes this will be undefined
    // @param   rowNum     (int)    row number for the cell
    // @param   colNum     (int)    column number of the cell
    // @param   grid    (ListGrid)  ListGrid to which this field belongs
    // @return  (boolean)   Returning false from this method will cancel the default behavior
    //                      (for example saving the row) and leave the editor visible and focus
    //                      in this edit cell.
    //  @group  editing
    //  @see listGrid.editorExit
    // @visibility external
    //<

    //> @method listGridField.cellChanged()
    // Callback fired when field changes value as the result of a cell edit.  Fired only on
    // successful save of edit, when the new value doesn't match the value before editing.<br>
    // <p>
    // Same signature as +link{method:listGrid.cellChanged()}, but defined on a per-field
    // basis.
    //
    // @param   record     (ListGridRecord) record for the cell being changed
    // @param   newValue   (Any)    new value for the cell
    // @param   oldValue   (Any)    old value for the cell
    // @param   rowNum     (number) row number for the cell
    // @param   colNum     (number) column number of the cell
    // @param   grid       (ListGrid)   grid where cell was changed.
    //
    // @group  editing
    // @see method:listGrid.cellChanged()
    // @visibility external
    //<

    //> @attr listGridField.validators (Array of Validator : null : [IRW])
    // Array of +link{class:Validator} objects for this field.  When the user edits cells in
    // this field, these validators will be applied to the edited value.<br>
    // Note: for databound listGrids, this property may be specified on the
    // +link{class:DataSourceField}, enabling both client and server side validation.
    // @see class:Validator
    // @see listGridField.required
    // @group gridValidation
    // @visibility external
    // @example dataValidation
    //<

    //> @attr listGridField.validateOnChange (boolean : null : [IRW])
    // If set to true, any +link{listGridField.validators} for this field will be run whenever
    // the value of the field is changed.
    // <P>
    // Analogous to the +link{FormItem.validateOnChange} property.
    // @group gridValidation
    // @visibility external
    //<

    //> @attr listGridField.required (Boolean : null : [IRW])
    // When the user edits cells in this field, is this value required to be non-empty
    // in order for validation to pass.<br>
    // Note: for databound listGrids, this property may be specified on the
    // +link{class:DataSourceField}, enabling both client and server side validation.
    //
    // @see listGridField.validators
    // @group gridValidation
    // @visibility external
    //<

    //> @attr listGridField.displayFormat (Varies : null : [IRWA])
    // For fields of type <code>"date"</code>, set this property to a valid
    // +link{dateDisplayFormat} to specify how the date should be formatted.<br>
    // For fields of type <code>"time"</code>, set this property to a valid
    // +link{type:TimeDisplayFormat, TimeDisplayFormat} to specify how the time should be formatted.<br>
    // If unset, display format may be set at the listGrid level via +link{ListGrid.dateFormatter}
    // or +link{ListGrid.timeFormatter}.
    // <p>
    // If this field is editable the displayFormat will also be passed to the editor created
    // to edit this field.  For dates you may also need to set +link{listGridField.inputFormat}.
    //
    // @see listGridField.inputFormat
    // @see listGrid.dateFormatter
    // @see listGrid.timeFormatter
    // @deprecated Use +link{listGridField.dateFormatter} and +link{listGridField.timeFormatter}
    //  instead.
    // @visibility external
    //<

    //> @attr listGridField.dateFormatter (DateDisplayFormat : null : [IRW])
    // Display format to use for date type values within this field.
    // <P>
    // The +link{listGridField.timeFormatter} may also be used to format underlying Date values as
    // times (omitting the date part entirely). If both <code>dateFormatter</code> and
    // <code>timeFormatter</code> are specified on a field, for
    // fields specified as +link{listGridField.type,type "time"} the
    // <code>timeFormatter</code> will be used, otherwise the <code>dateFormatter</code>
    // <P>
    // If <code>field.dateFormatter</code> and <code>field.timeFormatter</code> is unspecified,
    // date display format may be defined at the component level via
    // +link{ListGrid.dateFormatter,ListGrid.dateFormatter}, or for fields of type <code>"datetime"</code>
    // +link{ListGrid.datetimeFormatter,ListGrid.datetimeFormatter}. Otherwise the
    // default is to use the system-wide default short date format, configured via
    // +link{DateUtil.setShortDisplayFormat()}.  Specify any valid +link{type:DateDisplayFormat} to
    // change the format used by this item.
    // <P>
    // If this field is editable the dateFormatter will also be passed to the editor created
    // to edit this field. Note that you can also specify an explicit +link{listGridField.inputFormat}
    // which will be passed through to the editor as well, though this is not typically required
    // as the input format should be automatically derived by the SmartClient system
    // for standard DateDisplayFormats.
    //
    // @see listGrid.dateFormatter
    // @see listGrid.datetimeFormatter
    // @see listGridField.timeFormatter
    // @visibility external
    //<

    //> @attr listGridField.timeFormatter (TimeDisplayFormat : null : [IRWA])
    // Time-format to apply to date type values within this field.  If specified, any
    // dates displayed in this field will be formatted as times using the appropriate format.
    // This is most commonly only applied to fields specified as type <code>"time"</code> though
    // if no explicit +link{listGridField.dateFormatter} is specified it will be respected for other
    // fields as well.
    // <P>
    // If unspecified, a timeFormatter may be defined
    // +link{ListGrid.timeFormatter,at the component level} and will be respected by fields
    // of type <code>"time"</code>.
    // <P>
    // If this field is editable, the timeFormatter will also be passed to the editor created to
    // edit this field as +link{formItem.timeFormatter}.
    //
    // @group appearance
    // @visibility external
    //<
    //timeFormatter:null

    //> @attr listGridField.decimalPrecision (number : null : [IRW])
    // @include dataSourceField.decimalPrecision
    //
    // @group appearance
    // @serverDS allowed
    // @visibility external
    //<

    //> @attr listGridField.decimalPad (number : null : [IRW])
    // @include dataSourceField.decimalPad
    //
    // @group appearance
    // @serverDS allowed
    // @visibility external
    //<

    //> @attr listGridField.inputFormat (DateInputFormat : null : [IRWA])
    // For fields of type <code>"date"</code> or <code>"datetime"</code>, if this is an editable
    // listGrid, this property allows you to specify the +link{DateItem.inputFormat, inputFormat}
    // applied to the editor for this field.
    // @see listGridField.dateFormatter
    // @visibility external
    //<

    //> @attr listGridField.isRemoveField (boolean : null : [IRA])
    // If set to true and +link{listGrid.canRemoveRecords} is true, this field will be rendered
    // as the remove-field for this grid. In most common usage scenarios this field will essentially
    // be a placeholder indicating where the remove field should be rendered, meaning properties
    // other than <code>isRemoveField</code>, such as <code>name</code> or <code>title</code>, may
    // be left unset.
    // @see listGrid.canRemoveRecords
    // @visibility external
    //<

    //> @attr listGridField.isDragHandle (boolean : null : [IRA])
    // If set to true and +link{listGrid.useDragHandles} is true, this field will be treated as
    // the +link{listGrid.dragHandleField, drag handle field} for records in this grid with
    // respect to touch interaction.  However, visibility and field order for this field won't
    // be managed automatically by the Framework, as it is for the
    // +link{listGrid.dragHandleField} autochild.
    // <P>
    // Note that this is only fully supported for fields of +link{type}: "icon", for which we
    // can easily generate the necessary HTML and CSS to ensure proper behavior across browsers.
    // @see listGrid.showDragHandles()
    // @group dragHandleField
    //<

    //> @method listGridField.recordClick()
    //
    // Executed when this field is clicked on.  Note that if +link{ListGrid.recordClick()} is
    // also defined, it will be fired for fields that define a recordClick handler if the
    // field-level handler returns true. Return false to prevent the grid-level handler from firing.
    //
    // @param   viewer      (ListGrid)  the listGrid that contains the click event
    // @param   record      (ListGridRecord)    the record that was clicked on
    // @param   recordNum   (number)    number of the record clicked on in the current set of
    //                                  displayed records (starts with 0)
    // @param   field       (ListGridField) the field that was clicked on (field definition)
    // @param   fieldNum    (number)    number of the field clicked on in the listGrid.fields
    //                                  array
    // @param   value       (Any)    value of the cell (after valueMap, etc. applied)
    // @param   rawValue    (Any)   raw value of the cell (before valueMap, etc applied)
    // @param editedRecord (ListGridRecord) the clicked record with any unsaved
    //                                   edit values overlaid (see <code>listGrid.getEditedRecord()</code>).
    // @return  (boolean)   false to stop event bubbling
    //
    // @group   events
    //
    // @see method:listGrid.recordClick()
    // @visibility external
    // @example recordClicks
    //<

    //> @method listGridField.recordDoubleClick()
    //
    // Executed when this field is double-clicked.  Note that if
    // +link{ListGrid.recordDoubleClick()} is also defined, it will be fired for fields that define
    // a recordDoubleClick handler if the field-level handler returns true. Return false to prevent
    // the grid-level handler from firing.
    //
    //
    // @param   viewer      (ListGrid)  the listGrid that contains doubleclick event
    // @param   record      (ListGridRecord)    the record that was double-clicked
    // @param   recordNum   (number)    number of the record clicked on in the current set of
    //                                  displayed records (starts with 0)
    // @param   field       (ListGridField) the field that was clicked on (field definition)
    // @param   fieldNum    (number)    number of the field clicked on in the listGrid.fields
    //                                  array
    // @param   value       (Object)    value of the cell (after valueMap, etc. applied)
    // @param   rawValue    (Object)    raw value of the cell (before valueMap, etc applied)
    
    // @return  (boolean)   false to stop event bubbling
    //
    // @group   events
    //
    // @see method:listGrid.recordClick()
    // @visibility external
    // @example recordClicks
    //<

    // Filtering
    // ---------------------------------------------------------------------------------------

    //> @attr   listGridField.canFilter (boolean : null : [IRW])
    //      If showing a filter row for this ListGrid, should the filter criteria for this
    //      field be editable
    //  @group  filterEditor
    //  @visibility external
    //  @example disableFilter
    //<

    //> @attr listGridField.filterEditorValueMap (Object : null : [IRW])
    //  If this listGrid is showing a filter row, this property can be used to specify a
    //  mapping of internal data to/from display values to be in the appropriate filter
    //  row form item.
    //  @visibility external
    //  @group filterEditor
    //<

    //> @attr listGrid.useMultiSelectForFilterValueMaps (boolean : true : IRWA)
    // If +link{listGrid.showFilterEditor} is true, when creating a SelectItem 
    // for editing criteria for a field with a ValueMap, should the SelectItem
    // default to +link{SelectItem.multiple,multiple:true}?
    // <P>
    // This overrides +link{SearchForm.useMultiSelectForValueMaps} on the filterEditor's
    // edit form.
    // @visibility external
    //<
    useMultiSelectForFilterValueMaps:true,

    //> @attr listGridField.filterEditorType (FormItemClassName : null : [IRWA])
    //      If this ListGrid is showing a filter row, this property can be used to
    //      specify the form item class to use for the filter form item associated with this
    //      field
    //      (Only used if this field is not canFilter:false).<br>
    //      Note: If this is not specified, the edit-form item type may be derived from the
    //      'editorType' property, typically inherited from datasource fields, or from the
    //      'type' of the field (showing the appropriate form item for the data-type).
    //  @group  filterEditor
    //  @visibility external
    //<

    //> @attr   listGridField.defaultFilterValue (Any : null : [IRWA])
    // If this ListGrid is showing a filter row, this property can be used to apply a default
    // value to show in the filter editor for this field.
    // @group filterEditor
    // @visibility external
    //<
    

    //> @attr   listGridField.filterEditorProperties (FormItem Properties : null : [IRWA])
    // If this ListGrid is showing a filter row
    // (+link{listGrid.showFilterEditor,showFilterEditor}:true), this property
    // can be used to specify properties for the appropriate filter form item.
    // @group filterEditor
    // @visibility external
    //<
    
    //> @attr listGridField.operator (OperatorId : null : [R])
    // When +link{listGrid.allowFilterOperators, allowFilterOperators} is true, this read-only
    // property is set to the 
    // +link{Operator, filter/search operator} currently assigned to this field.  You can also
    // retrieve a field's current operator by calling +link{listGrid.getFieldSearchOperator}.
    // <p>
    // For a discussion of the various filtering and criteria-management APIs and when to use
    // them, see the +link{group:gridFiltering, Grid Filtering overview}.
    // <p>
    // While this property can be affected by users, via the
    // +link{listGrid.filterUsingText, "Filter using"} submenu of the grid's 
    // +link{listGrid.showHeaderContextMenu, headerContextMenu}, it can't be set directly in 
    // code.
    // <p>
    // However, developers can call +link{listGrid.setFieldSearchOperator} to modify a field's 
    // current operator, or +link{listGrid.clearFieldSearchOperator} to reset a field to it's 
    // default operator.
    // <p>
    // To specify a particular default operator for a field, see 
    // +link{listGridField.filterOperator}.
    // @see filterOperator
    // @visibility external
    //<

    //> @attr listGridField.filterOnKeypress (Boolean : null : [IRWA])
    // If set this will override the 
    // +link{listGrid.filterOnKeypress, filterOnKeypress setting at the grid level}
    // <p>
    // For a discussion of the various filtering and criteria-management APIs and when to use
    // them, see the +link{group:gridFiltering, Grid Filtering overview}.
    // @group filterEditor
    // @see listGrid.fetchDelay
    // @visibility external
    //<

    //> @attr listGridField.showFilterEditorHovers (Boolean : null : IR)
    // When set to false, no hover is shown for the field editor in this field. Otherwise,
    // a hover shows the current field's criteria description along with the
    // +link{listGrid.filterWindowCriteria} description if configured.
    // <p>
    // All hovers for the filter editor can be disabled using
    // +link{listGrid.showFilterEditorHovers}.
    // <p>
    // The descriptive text for criteria is formatted by +link{DataSource.getAdvancedCriteriaDescription}.
    // 
    // @see listGrid.showFilterEditorHovers
    // @visibility external
    //<

    //> @attr listGrid.fetchDelay (number : 300 : IRWA)
    // If we're showing the filterEditor (+link{listGrid.showFilterEditor} is true), 
    // and +link{filterByCell} or +link{filterOnKeypress} are enabled, this
    // property is the delay in milliseconds between the user changing the filter and the
    // filter request being sent to the server. If multiple changes are made to the filter
    // within this fetch delay, only the most recent will actually cause a re-filter
    // @see explicitFetchDelay
    // @group filterEditor
    // @visibility external
    //<
    fetchDelay:300,

    //> @attr listGrid.explicitFetchDelay (number : 0 : IRWA)
    // If we're showing the filterEditor (+link{listGrid.showFilterEditor} is true), this
    // property determines the delay in kicking off the filter request if the current filter
    // values are submitted by clicking the filter button or hitting return.  By default, this
    // property is set to zero so that a filter request is immediately sent.
    // @see fetchDelay
    // @group filterEditor
    // @visibility external
    //<
    explicitFetchDelay:0,

    //> @attr listGridField.shouldPrint (boolean : null : IRW)
    // Whether this field should be included in the printable representation of the grid.
    //
    // @group printing
    // @visibility external
    //<

    // AutoComplete
    // ---------------------------------------------------------------------------------------

    //> @attr listGridField.autoComplete (AutoComplete : null : IRW)
    // Whether to allow browser autoComplete when editing this field.
    // <p>
    // If unset, defaults to listGrid.autoComplete
    //
    // @see listGrid.autoComplete
    // @visibility external
    //<

    //> @attr listGridField.uniqueMatch (boolean : null : IRW)
    // When autoComplete is enabled, whether to offer only unique matches to the user.
    // <p>
    // If unset, defaults to listGrid.uniqueMatch.
    //
    // @see listGrid.uniqueMatch
    // @visibility autoComplete
    //<
    uniqueMatch:true,


    // Formatting (per field)
    // --------------------------------------------------------------------------------------------

    //> @method listGridField.getCellValue()
    // A stringMethod which returns the cell value to display for this field for some record.
    // If defined, called by ListGrid.getCellValue().  Called in the scope of the field object.
    //
    // Deprecated as of Jan 12 05 in favor of +link{listGridField.formatCellValue()}, because 
    // 'getCellValue()' is a lower-level API which handles (for example) returning the HTML
    // for editors within the cell.
    //
    // @param  viewer  (ListGrid)  the ListGrid for which we're returning a cellValue
    // @param  record  (Object)    the current record object
    // @param  recordNum   (number)    row-index of the current record
    // @param  field   (ListGridField) current field object
    // @param  fieldNum    (number)    column-index of the current field
    // @param  value   (Any)   unformatted value for this field, determined via
    //                          ListGrid.getRawCellValue()
    // @see    method:listGrid.getCellValue
    // @see method:listGridField.formatCellValue
    // @group  display_values
    // @visibility internal
    // @return (Any)   value to display in the ListGrid cell
    // @deprecated As of SmartClient 5.5, use +link{listGridField.formatCellValue}.
    //<

    // We provide separate formatters for the raw value displayed in a static cell, and the
    // value displayed in an editor.
    // This makes sense because:
    // - developers are likely to want to apply different formats - for example including some
    //   raw HTML in the static value, but not in the value displayed in a text based editor.
    // - the more common 'formatCellValue()' needs no parser to convert from the formatted value
    //   back to the raw value
    // If a developer wishes to apply the same formatter in both cases, the suggested approach
    // would be to write a single formatter function and have it be called from both methods.

    //> @method listGridField.formatCellValue()
    // Return the HTML to display in cells of this field.
    // <P>
    // Given the raw value for this field as taken from the record Formatter to apply to the
    // static values displayed in cells for this field.
    // <P>
    // <i>Example usage</i>: formatting a currency value stored in cents (so "100" to "$1.00")<br>
    // The value passed to this method is the raw value for the cell.<br>
    // Takes precedence over <code>formatCellValue</code> defined at the grid level for cells
    // in this field.
    // <P>
    // Note: this formatter will not be applied to the values displayed in cells being edited.
    // The +link{listGridField.formatEditorValue,formatEditorValue()} is provided for that purpose.
    //
    // @group display_values
    //
    // @param   value (Any)   raw value for the cell, from the record for the row
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter (see +link{listGrid.getEditValues()})
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @param   grid    (ListGrid) the ListGrid displaying the cell
    // @return (HTMLString) HTML to display in the cell
    //
    // @see listGrid.formatCellValue()
    // @see listGridField.formatEditorValue()
    // @deprecated <smartgwt>Use +link{ListGridField.setCellFormatter()} or 
    // +link{ListGrid.setCellFormatter()} to install a +link{class:CellFormatter}.
    //  This method is not a valid override point for the default behavior.</smartgwt>
    // @visibility external
    // @example formatValues
    //<

    //> @method listGridField.formatInactiveCellValue()
    // Field-level formatter for inactive content.
    // <P>
    // If present, this method will be invoked instead of +link{listGridField.formatCellValue()} in cases 
    // where the grid is rendering non-interactive content outside. 
    // See +link{listGrid.formatInactiveCellValue()} for more details.
    // <P>
    // @param   value (Any)   raw value for the cell, from the record for the row
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter (see +link{listGrid.getEditValues()})
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @param   grid    (ListGrid) the ListGrid displaying the cell
    // @return (HTMLString) HTML to display in the cell
    //
    // @see listGrid.formatInactiveCellValue()
    // @visibility external
    //<    
    
    //> @attr listGridField.escapeHTML (boolean : null : IRW)
    // By default HTML values in ListGrid cells will be interpreted by the browser.
    // Setting this flag to true will causes HTML characters to be escaped, meaning the
    // raw value of the field (for example <code>"&lt;b&gt;AAA&lt;/b&gt;"</code>) is displayed
    // to the user rather than the interpreted HTML (for example <code>"<b>AAA</b>"</code>)
    // @see skipLineBreaks
    // @visibility external
    //<

    //> @attr listGridField.skipLineBreaks (boolean : null : IRW)
    // By default, when +link{escapeHTML,escaping HTML}, we convert line breaks (\r\n, \r, and
    // \n) to HTML &lt;br&gt tags so that visible cell content respects the original break
    // characters. Set this property true to instead show the content as a single line (or
    // potentially wrapped to avoid clipping if +link{ListGrid.wrapCells} is true).
    // <P>
    // If defaulted to null, behavior is determined by +link{listGrid.skipLineBreaks}.
    // @see escapeHTML
    // @visibility external
    //<

    //> @attr listGridField.linkText (String : null : IRW)
    // The HTML to display in cells of this field if the fieldType is set to link.
    // <P>
    // This property sets linkText that will be the same for all records.  You can set linkText
    // on a per-record basis via +link{attr:listGridRecord.linkText}.
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @see attr:listGridRecord.linkText
    //  @see attr:listGrid.linkTextProperty
    //  @see attr:listGridField.linkTextProperty
    //  @group  display_values
    //  @visibility external
    //  @example linkImage
    //<

    //> @attr listGridField.linkTextProperty (String : null : IRW)
    // Name of the property in a ListGridRecord that holds the HTML to display in cells of this
    // field if the fieldType is set to "link".
    //
    //  @see type:ListGridFieldType
    //  @see type:FieldType
    //  @see attr:listGridRecord.linkText
    //  @see attr:listGridField.linkText
    //  @see attr:listGrid.linkTextProperty
    //  @group  display_values
    //  @visibility external
    //<

    //> @attr listGridField.linkURLPrefix (String : null : IRWA)
    // If this field has type [+link{type:ListGridFieldType}] set to <code>"link"</code>,
    // setting this property will apply a standard prefix to the link URL for cells in this field.
    // @visibility external
    //<


    //> @attr listGridField.linkURLSuffix (String : null : IRWA)
    // If this field has type [+link{type:ListGridFieldType}] set to <code>"link"</code>,
    // setting this property will apply a standard suffix to the link URL for cells in this field.
    // @visibility external
    //<

    // --------------------
    // Editing

    //> @method listGridField.formatEditorValue
    // Return the value to display in cells of this field which are being edited.
    // <P>
    // <i>Example usage</i>: converting a stored value in cents (100) to a dollar-and-cents
    // value in the editor (1.00)
    // <P>
    // The value passed to this method is the raw value for the cell.
    // <P>
    // <code>formatEditorValue</code> takes precedence over +link{listGrid.formatEditorValue()}
    // defined at the grid level for cells in this field.
    // <P>
    // To convert the formatted value displayed within an editor back to a raw value, implement
    // +link{listGridField.parseEditorValue} as well.
    //
    // @group editing
    //
    // @param   value (Any)   raw value for the cell being edited
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @param   grid    (ListGrid Instance) A pointer to the ListGrid displaying the cell
    // @return (Any) formatted value to display in the editor
    //
    // @see listGridField.formatCellValue()
    // @see listGrid.formatEditorValue()
    // @see listGridField.parseEditorValue()
    //
    // @visibility external
    //<

    //> @method listGridField.parseEditorValue
    // Method used to convert the value displayed in an editor for some cell in this field into
    // a raw value for saving.<br>
    // Takes precedence over <code>parseEditorValue</code> defined at the grid level.
    //
    // @group editing
    //
    // @param   value (Any)   value displayed in the editor for the cell
    // @param   record (Object) record object for the row being edited. May be null if this
    //                          is a new row being added to the end of the list.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @param   grid    (ListGrid Instance) A pointer to the ListGrid displaying the cell
    // @return (Any) raw value for the field derived from formatted value in editor
    // @see listGrid.parseEditorValue()
    // @see listGridField.formatEditorValue()
    // @visibility external
    //<

    //> @attr listGridField.valueMap (Object | Array of String : null : IRW)
    // Array of legal values for this field, or an Object where each property maps a stored
    // value to a user-displayable value.<br>
    // Note that if this field is editable (see +link{listGrid.canEdit},
    // +link{listGridField.canEdit}), editors displayed for this field will pick up their
    // valueMap either from this value or from +link{listGridField.editorValueMap}.
    // <P>
    // See also +link{dataSourceField.valueMap}.
    //
    // @group display_values
    // @see ListGrid.setValueMap()
    // @see ListGrid.getDisplayValue()
    // @visibility external
    // @example listType
    //<

    //> @attr listGridField.sortByMappedValue (boolean : null : IRW)
    // If +link{listGridField.valueMap} is set, and the grid is +link{listGrid.setSort(),sorted}
    // by this field, should the data be sorted by the underlying data value or the
    // mapped display value. If unset, will sort by display value. Set to <code>false</code>
    // to sort by underlying data value. Note that this has no effect if
    // a +link{listGridField.sortNormalizer} has been specified.
    // @visibility external
    //<

    //> @attr listGridField.multiple (Boolean : null : IR)
    // Indicates that this field should always be Array-valued. This property will be
    // passed through to the generated edit-item when editing the field - so if
    // +link{listGridField.valueMap} is set, the default editor will be a +link{SelectItem} with
    // +link{SelectItem.multiple} set to true.
    // <P>
    // Note that for databound grids it typically makes sense to set +link{DataSourceField.multiple}
    // rather than setting the property directly on the ListGridField object.
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.editorValueMap (ValueMap : null : IRW)
    // A valueMap to use for editors shown for this field.  By default if this is not
    // specified +link{listGridField.valueMap,field.valueMap} will be used instead.
    // <P>
    // Dynamic valueMaps can be provided by implementing +link{listGrid.getEditorValueMap()}.
    //
    // @group editing
    // @visibility external
    // @see listGrid.getEditorValueMap()
    // @see listGrid.setEditorValueMap()
    //<

    //> @method listGridField.change()
    // If this field is editable, any +link{formItem.change, change} handler specified
    // on the ListGridField will be passed onto the editors for this field.
    // <P>
    // Note that if +link{listGridField.canToggle} is true, the user may change the value of
    // a boolean field without going into edit mode by single clicking on the field. In this
    // case the +link{listGridField.change()} and +link{listGridField.changed()} handlers will
    // fire but the <code>form</code> and <code>item</code> parameters will be null.
    //
    // @param   form    (DynamicForm) the managing DynamicForm instance
    // @param   item    (FormItem)    the editor (form item) itself (also available as "this").
    //                              Note that in addition to the standard FormItem APIs available
    //                              on the editor, it also has:<br>
    //                              - a pointer back to the containing listGrid
    //                              [<code>item.grid</code>]<br>
    //                              - the colNum being edited [<code>item.colNum</code>]<br>
    //                              - the rowNum being edited [<code>item.rowNum</code>]
    // @param   value   (Any)         The new value of the form item
    // @param   oldValue    (Any)     The previous value of the form item
    // @return (Boolean) The change may be cancelled <smartclient>by returning false</smartclient>
    // @see listGridField.changed()
    // @see listGrid.cellChanged()
    // @group editing
    // @visibility external
    //<

    //> @method listGridField.changed()
    // If this field is editable, any +link{formItem.changed, changed} handler specified
    // on the ListGridField will be passed onto the editors for this field.
    // Note that if +link{listGridField.canToggle} is true, the user may change the value of
    // a boolean field without going into edit mode by single clicking on the field. In this
    // case the +link{listGridField.change()} and +link{listGridField.changed()} handlers will
    // fire but the <code>form</code> and <code>item</code> parameters will be null.
    //
    // @param   form    (DynamicForm) the managing DynamicForm instance
    // @param   item    (FormItem)    the editor (form item) itself (also available as "this").
    //                              Note that in addition to the standard FormItem APIs available
    //                              on the editor, it also has:<br>
    //                              - a pointer back to the containing listGrid
    //                              [<code>item.grid</code>]<br>
    //                              - the colNum being edited [<code>item.colNum</code>]<br>
    //                              - the rowNum being edited [<code>item.rowNum</code>]
    // @param   value   (Any)         The current value (after the change).
    // @see listGridField.change()
    // @see listGrid.cellChanged()
    // @group editing
    // @visibility external
    //<

    //> @attr listGridField.emptyCellValue (HTMLString : "&nbsp;" : IRW)
    // The value to display for a cell whose value is null or the empty string after
    // applying +link{listGridField.formatCellValue(),formatting} and valueMap (if any).
    // <p>
    // This is the field-specific attribute.  You may also set the emptyCellValue at the grid
    // level to define the emptyCellValue for all empty fields in the grid.
    //
    // @group display_values
    // @see listGrid.emptyCellValue
    // @visibility external
    // @example emptyValues
    //<

    // Field.optionDataSource
    // --------------------------------------------------------------------------------------------

    //> @attr listGridField.autoFetchDisplayMap (boolean : null : [IRW])
    // If true, automatically fetches records and derives a valueMap from
    // +link{listGridField.optionDataSource}.
    // <p>
    // Same as +link{listGrid.autoFetchDisplayMap}, but defined on a per-field basis.
    //
    // @group display_values
    // @see listGrid.autoFetchDisplayMap
    // @visibility external
    //<

    //> @attr listGridField.displayValueFromRecord (boolean : null : IRWA)
    // If a +link{listGridField.displayField} is set, should this field show record values from
    // the <code>displayField</code>?
    // <P>
    // If +link{listGridField.displayField} is specified, and there is no separate
    // +link{listGridField.optionDataSource}, by default we will show display-field values
    // from the same record. Setting this property to false would disable this behavior.
    // <P>
    // Alternatively, if there is a +link{listGridField.optionDataSource} (and
    // +link{listGridField.autoFetchDisplayMap} is false), the displayField would be ignored
    // for the field and the underlying +link{listGridField.name,record[fieldName] value} would
    // be displayed to the user. This property may be set to true to override this behavior and
    // pick up values from the <code>displayField</code> for display in this field even when there
    // is an optionDataSource set.
    // <P>
    // Note that this property has no effect on fields with an explicitly specified valueMap, or
    // with an optionDataSource where +link{listGridField.autoFetchDisplayMap} is true.
    // @visibility external
    //<

    //> @attr listGridField.optionTextMatchStyle (TextMatchStyle : null : [IR])
    // For fields with an +link{listGridField.optionDataSource}, where
    // +link{listGridField.autoFetchDisplayMap} is true, this property will govern
    // the <code>textMatchStyle</code> attribute of the +link{DSRequest} parameter passed to
    // +link{DataSource.fetchData()} when retrieving the remote data set to be used as
    // a basis for this field's valueMap.
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionFilterContext (DSRequest Properties : null : [IR])
    // If this field has an optionDataSource specified and
    // +link{listGridField.autoFetchDisplayMap,autoFetchDisplayMap} is set, this attribute
    // provides a way to customize the dataSource request issued to fetch the display map from
    // the option dataSource.  This provides, among other capabilities, a way to trigger the
    // server to return summary records.
    // @see group:serverSummaries
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionOperationId (String : null : [IR])
    // If this field has an optionDataSource specified and
    // +link{listGridField.autoFetchDisplayMap,autoFetchDisplayMap} is set, this attribute
    // provides a way to customize the +link{DSRequest.operationId} passed to
    // <code>dataSource.fetchData()</code> when retrieving the display map from the option
    // dataSource.
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionDataSource (String : null : [IRW])
    // Derive a +link{valueMap} by fetching records from another DataSource and extracting
    // the +link{listGridField.valueField,valueField} and
    // +link{listGridField.displayField,displayField} in the loaded records, to derive one
    // valueMap entry per record loaded from the optionDataSource.
    // <P>
    // Unlike the similar use of +link{pickList.optionDataSource} for +link{PickList,pickLists}
    // used during editing or filtering, <code>listGridField.optionDataSource</code> causes the
    // <b>entire set of records from the optionDataSource to be fetched</b>, without paging.
    // Hence listGridField.optionDataSource is appropriate only for smaller valueMaps.  For very
    // large valueMap situations, such as an accountId field that should be displayed as an
    // accountName where there are thousands of accounts, the correct approach is:
    // <ul>
    // <li> do not set listGridField.optionDataSource
    // <li> declare two fields in the DataSource, eg "accountId" and "accountName".
    // <li> Set the +link{ListGridField.displayField} attribute on the data field to the
    //      name of the display field.
    // <li> When fetching records for display in a grid, have your server send back values for
    //      both fields, but show only the data field ("accountId") in the grid.
    // </ul>
    // In this case the cells in the accountId field will show the record value from the
    // accountName field.  This approach means the valueMap will never be loaded in its
    // entirety, instead, each loaded record contains the valueMapping for that one record, as
    // a pair of fields within the record.
    // <p>
    // If you are using the SmartClient Server Framework with the SQL or JPA/Hibernate built-in
    // connectors, this entire approach can be achieved very easily using the
    // +link{dataSourceField.includeFrom} setting - see the
    // +link{dataSourceField.includeFrom,docs for includeFrom} for details.
    // <P>
    // Notes:
    // <ul>
    // <li>When using the above approach, it is key that the server return <b>both</b>
    // the underlying stored value <b>and</b> the display value, as suggested above.
    // This approach allows the +link{pickList.optionDataSource} property to be used to
    // provide paged valueMaps during inline editing and
    // +link{ListGrid.showFilterEditor,inline filtering}. This can be achieved by setting the
    // <code>optionDataSource</code> attribute on the form item used to edit the field
    // via +link{listGridField.editorProperties} (for editing) or
    // +link{listGridField.filterEditorProperties,field.filterEditorProperties} (for
    // filtering), without specifying an optionDataSource at the listGridField level.
    // Alternatively developers can use +link{listGridField.autoFetchDisplayMap} to
    // suppress the fetch against the optionDataSource at the listGrid level.</li>
    // <li>Setting <code>listGridField.optionDataSource</code> to the same dataSource as the
    // listGrid is not the same as omitting the optionDataSource setting entirely. Unless
    // +link{listGridField.autoFetchDisplayMap} has been set to explicitly disable fetching,
    // a fetch will be performed against the dataSource to build a valueMap which will be used
    // as the definitive mapping from data to display values, rather than picking up the display
    // values from the records themselves. This distinction is required to support cases where
    // the +link{listGridField.valueField} points to a different field in the grid (useful for
    // hierarchical relationships, for example), or where +link{listGridField.optionCriteria} or
    // +link{listGridField.optionOperationId} are specified and return different data from
    // the records displayed within the grid.</li>
    // <li>If a displayField is specified, with no associated optionDataSource, and the field is
    // editable, updating the edit value for the field may not automatically update the displayField
    // edit value, meaning the user may not realize the edit value has been modified.
    // If the new value came from the user editing the field, and the edit item has
    // a valueMap or optionDataSource specified, the display value is picked up automatically and
    // stored out on the displayField for the record. However if the value was set programmatically,
    // the developer should also set the edit value for the display field to ensure the displayed
    // value reflects the new edit value. Note that when this occurs, a warning will be logged
    // which can be disabled via +link{listGrid.warnOnUnmappedValueFieldChange}.</li>
    // <li>For very advanced usage a developer can use +link{listGridField.displayValueFromRecord}
    // to explicitly tell the grid whether or not to display the display field value for the record
    // in this field when a displayField is specified. See documentation on that property for more
    // information</li>
    // </ul>
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.valueField (String : null : [IRW])
    // Specifies the +link{listGridField.optionDataSource} field used to retrieve the stored
    // values that are to be mapped to the display values (specified by
    // +link{listGridField.displayField}). Note that if this field is editable this will also
    // be applied to this field's editors.
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.displayField (String : null : [IRW])
    // Specifies the +link{listGridField.optionDataSource} field used to retrieve the display
    // values that are to be mapped from the internal values specified by +link{valueField}.
    // <P>
    // If no <code>optionDataSource</code> is defined for the field, the cell will display
    // the displayField value for the current record instead of the underlying value for
    // this field.  This approach can be used for situations where field values need a stored
    // value to displayed value mapping, but the set of all possible values is too large to
    // load as a +link{ValueMap} - see +link{listGridField.optionDataSource} for more details
    // on this approach.  Note that if this field is editable this will also be applied to this
    // field's editors.  +explorerExample{largeValueMapSQL,This sample} illustrates this
    // approach achieved via a server-side SQL join.
    // <p>
    // The display value for a record with a specified <code>displayField</code> can be
    // picked up via +link{ListGrid.getDisplayValue()}.
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.sortByDisplayField (boolean : null : [IRW])
    // For a field with <code>displayField</code> configured, should client-side sorting
    // be performed on the display field value? Unless explicitly set to <code>false</code>
    // the display field value is used.
    //
    // @group display_values
    // @visibility external
    //<

    //> @attr listGridField.optionCriteria (Criteria : null : [IRW])
    // If +link{optionDataSource} is set for this ListGridField, criteria specified in this
    // attribute will be passed to the dataSource when performing the fetch operation to
    // determine data-value to display-value mappings
    // <P>
    // See also +link{listGridField.optionTextMatchStyle}.
    // @group display_values
    // @visibility external
    //<


    // ---------

    //> @attr listGridField.includeFrom (String : null : [IR])
    // Indicates this field's values should be fetched from another, related DataSource.
    // The individual field will inherit settings such as +link{listGridField.type,field.type}
    // and +link{listGridField.title,field.title} from the related DataSource just like
    // fields from the primary DataSource.
    // <P>
    // When +link{listGrid.fetchData(),fechData()} is called, the automatically created +link{DSRequest} will
    // specify +link{dsRequest.additionalOutputs} requesting the field, and any +link{Criteria}
    // generated by the component will likewise refer to the field from the related DataSource.
    // <P>
    // It's an error to use this property if the ListGrid does not have a DataSource at all.
    // The related DataSource must be loaded or a warning will be logged and the field
    // definition ignored.
    // <P>
    // This value is expected to be set to the following format
    // <code>dataSourceID.fieldName</code> where <i>dataSourceID</i> is the ID of the
    // related dataSource and <i>fieldName</i> is the name of the field from that dataSource
    // from which you wish to retrieve values. Note that if this property is set and
    // +link{ListGridField.name,field.name} is not explicitly specified, this field's <code>name</code> will
    // default to the <i>fieldName</i> value from this property.
    // <p>
    // Note about automatic cache updates: "update" and "add" operations
    // submitted automatically by this ListGrid will include
    // <code>dsRequest.additionalOutputs</code> to ensure all data necessary
    // for cache updates is returned by the server.
    // <p>
    // If your grid shows data that can be edited elsewhere in the UI (not by
    // inline editing), to avoid problems with +link{ResultSet} automatic
    // cache synchronization, you may need to switch from using
    // <code>listGridField.includeFrom</code> to
    // <code>dataSourceField.includeFrom</code>.  This is because
    // server responses to "add" and "update" operations which are initiated
    // outside of this grid do not know about the
    // <code>listGridField.includeFrom</code> setting, and so will not
    // automatically return data for fields included in this way.  Switching
    // to <code>dataSourceField.includeFrom</code> ensures the field is
    // always included in server responses, avoiding the issue.
    //
    // @group display_values
    // @visibility crossDS
    //<

    // ----------------------------------------------------------------------------------------
    // Don't show scrollbars -- scrolling occurs in the body

    //> @attr listGrid.overflow (Overflow : Canvas.HIDDEN : IRW)
    // Since +link{body} is configured with overflow: auto by default, no overflow
    // is expected for the +link{listGrid} itself so by default it has overflow: hidden.
    // @see layout.overflow
    // @visibility external
    //<
    overflow:isc.Canvas.HIDDEN,

    //> @attr listGrid.backgroundColor (String : "white" : IRW)
    // @group appearance
    //<
    backgroundColor:"white",

    //> @attr listGrid.minHeight (number : varies : IRW)
    // Sets the +link{canvas.minHeight,minimum height} for the entire list (smaller than this
    // doesn't tend to work very well).  If not set, this value will be defaulted when
    // +link{draw()} is called to something reasonable based on whether we're showing the
    // +link{showFilterEditor,filter editor}, +link{showHeader,header}, 
    // +link{showGridSummary,summary rows}, and/or the +link{showEmptyMessage,empty message}.
    // Any top or bottom CSS padding specified by +link{emptyMessageStyle} will be taken into
    // account, increasing <code>minHeight</code> so that the empty message can be shown without
    // overflow.
    // <P>
    // <b>Note:</b> Minimum sizes do not apply to all situations.
    // See +link{canvas.minWidth,minimum sizing rules} for details.
    //
    // @group sizing
    // @see canvas.minHeight
    // @visibility external
    //<

    // sum up contributions from each member of LG as a VLayout
    _getDefaultMinHeight : function () {
        var minHeight = this.cellHeight + this.getVMarginBorderPad();
        
        if (this.showHeader)       minHeight += this.headerHeight;
        if (this.showFilterEditor) minHeight += this.filterEditorHeight;
        if (this.showEmptyMessage) minHeight += this._getEmptyMessageStyleVPad();
        if (this.showGridSummary)  minHeight += this.summaryRowHeight;
        return minHeight;
    },

    defaultWidth:200,

    //> @attr listGrid.fieldIdProperty (String : "name" : IRA)
    //  Property to be used as field identifier on listGridField objects.
    //  The ID of the field is also the property in each record which holds the value
    //  for that field.
    //      @group  data
    //<
    // defaulted on Canvas
    

    //> @attr listGrid.recordSummaryAttributePrefix (String : "_" : IRA)
    // Prefix prepended to the name of a +link{listGridField.recordSummaryFunction,"summary"}
    // +link{listGridField.type,type} field when accessing its value as record metadata.
    // The Framework may write out this value to make rendering the cell values or calculating
    // a +link{showGridSummary,grid summary row} or +link{showGroupSummary,group summary rows}
    // more efficient.
    // @see listGridField.type
    // @see listGridField.recordSummaryFunction
    // @visibility external
    //<
    recordSummaryAttributePrefix: "_",

    _getRecordSummaryAttributeProperty : function (field) {
        var fieldName = isc.isA.String(field) ? field : field.name;
        return this.recordSummaryAttributePrefix + fieldName;
    },

    // GridRenderer properties
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.showAllRecords (Boolean : false : [IRW])
    // Whether all records should be drawn all at once, or only records visible in the
    // viewport.
    // <P>
    // Drawing all records causes longer initial rendering time, but allows smoother vertical
    // scrolling.  With a very large number of records, showAllRecords will become too slow.
    // <P>
    // This setting is incompatible with +link{dataFetchMode}: "paged" as it requires all
    // records matching the criteria to be fetched from the server at once.
    //
    // @see drawAheadRatio
    // @see drawAllMaxCells
    // @group performance
    // @visibility external
    // @example autofitRows
    //<
    //showAllRecords:false,

    //> @attr listGrid.showAllColumns (Boolean : false : IR)
    // @include gridRenderer.showAllColumns
    //<
    //showAllColumns:false,

    //> @attr listGrid.drawAllMaxCells (int : 250 : IRWA)
    // @include gridRenderer.drawAllMaxCells
    // @group performance
    // @visibility external
    //<
    drawAllMaxCells:250,


    //> @attr listGrid.drawAheadRatio (float : 2.0 : IRW)
    // How far should we render records ahead of the currently visible area?  This is expressed as
    // a ratio from viewport size to rendered area size.
    // <P>
    // Tweaking drawAheadRatio allows you to make tradeoffs between continuous scrolling speed vs
    // initial render time and render time when scrolling by large amounts.
    // <P>
    // NOTE: Only applies when showAllRecords is false.
    //
    // @group performance
    // @visibility external
    // @example databoundFetch
    //<
    drawAheadRatio: isc.Browser.useHighPerformanceGridTimings ? 2.0 : 1.3,

    //> @attr listGrid.quickDrawAheadRatio (float : 2.0 : IRW)
    // @include gridRenderer.quickDrawAheadRatio
    // @group performance
    //<
    quickDrawAheadRatio: isc.Browser.useHighPerformanceGridTimings ? 2.0 : 1.0,

    //> @attr listGrid.instantScrollTrackRedraw (Boolean : true : IRW)
    // @include gridRenderer.instantScrollTrackRedraw
    // @group performance
    // @visibility external
    //<

    //> @attr listGrid.scrollRedrawDelay (int : 0 : IRW)
    // @include gridRenderer.scrollRedrawDelay
    // @group performance
    // @visibility external
    //<
    scrollRedrawDelay: isc.Browser.useHighPerformanceGridTimings ? 0 : 75,

    //> @attr listGrid.dragScrollRedrawDelay (int : 75 : IRW)
    // @include gridRenderer.dragScrollRedrawDelay
    // @group performance
    // @visibility external
    //<
    dragScrollRedrawDelay: 75,
    
    //> @attr listGrid.scrollWheelRedrawDelay (Integer : 0 : IRW)
    // While scrolling an incrementally rendered grid, using the mouseWheel, time in 
    // milliseconds to wait before redrawing, after the last mouseWheel movement by the user.  
    // If not specified +link{scrollRedrawDelay} will be used as a default for both
    // drag scrolling and mouseWheel scrolling.
    // <P>
    // Note that if specified, this value will typically be larger than 
    // +link{scrollRedrawDelay}. From experimentation, the default setting of 
    // <code>250</code> is typically enough time for a user to rapidly scroll through a
    // grid (rotating the scroll wheel with repeated flicks), without redrawing between
    // rotations, but this will differ depending on how long the redraw takes. A larger
    // delay may be warranted for grids with large numbers of columns, heavy custom 
    // formatting, etc.
    // <P>
    // See also
    // +link{gridRenderer.instantScrollTrackRedraw} for cases where this delay is skipped.
    //
    // @group performance
    // @visibility external
    //<
    scrollWheelRedrawDelay: isc.Browser.useHighPerformanceGridTimings ? 0 : 250,

    //> @attr listGrid.touchScrollRedrawDelay (Integer : 0 : IRW)
    // While scrolling an incrementally rendered grid, using the inertial scrolling, time in 
    // milliseconds to wait before redrawing, after the last touchScroll by the user.  
    // If not specified +link{scrollRedrawDelay} will be used as a default for both
    // drag scrolling and touch scrolling.
    // <P>
    // Note that if specified, this value will typically be larger than 
    // +link{scrollRedrawDelay}.
    // <P>
    // See also
    // +link{gridRenderer.instantScrollTrackRedraw} for cases where this delay is skipped.
    //
    // @group performance
    // @visibility external
    //<
    touchScrollRedrawDelay: isc.Browser.useHighPerformanceGridTimings ? 0 : 300,
    
    //> @attr listGrid.virtualScrolling (boolean : null : [IRA])
    // When incremental rendering is switched on and there are variable record heights, the virtual
    // scrolling mechanism manages the differences in scroll height calculations due to the
    // unknown sizes of un-rendered rows to make the scrollbar and viewport appear correctly.
    // <P>
    // When the <code>virtualScrolling</code> system is active, the last scroll position
    // scrolls the last record to the top of the viewport, leaving blank space underneath.
    // This is a necessary and unavoidable consequence of mapping the position of the scrollbar
    // thumb to an unknown amount of remaining space without being able to know the total
    // scrollable area in advance (since record heights vary).
    // <P>
    // virtualScrolling is switched on automatically when +link{fixedRecordHeights} is false and
    // also when
    // using the +link{listGrid.showRecordComponents,recordComponents subsystem}, as
    // recordComponents expand the rows that contain them. This flag should be manually enabled
    // when calling +link{listGrid.addEmbeddedComponent()} if embedded components can
    // cause record sizes to expand beyond specified cellHeight.
    // <P>
    // virtualScrolling is also automatically enabled when +link{listGrid.canExpandRecords} is true
    // to handle the fact that expanded rows may render at variable heights.
    //
    // @see recordComponentHeight
    // @visibility external
    //<

    //> @attr listGrid.dataPageSize (Integer : null : IRW)
    // @include dataBoundComponent.dataPageSize
    // @group performance
    // @visibility external
    // @example databoundFetch
    //<

    //> @attr listGrid.dataFetchMode (FetchMode : "paged" : IR)
    // @include dataBoundComponent.dataFetchMode
    // @see listGrid.showAllRecords
    //<

    // configures ResultSet.fetchDelay, delay in MS before fetches are triggered
    
    // NOTE: setting this value to 0 causes filterData() to fire its callback twice - at least
    // in part because RS acts synchronously in this case and various LG/DBC logic expects to
    // markForRedraw() which acts on a timer.
    //
    //> @attr ListGrid.dataFetchDelay (Integer : 1 : IRWA)
    // Delay in milliseconds before fetching data.
    // <P>
    // Note: the floor value for this attribute is 1.  If you set this value to zero, it will
    // be defaulted to 1 for you instead.
    //
    // @group databinding
    // @see DataBoundComponent.dataFetchDelay
    // @see ResultSet.fetchDelay
    // @visibility external
    //<
    dataFetchDelay : isc.Browser.useHighPerformanceGridTimings ? 1 : 300,

    //> @attr listGrid.body (MultiAutoChild GridRenderer : null : R)
    // GridRenderer used to render the dataset.
    // <p>
    // Note that this is a multi-instance component when there are frozen fields because in
    // addition to the primary body AutoChild, a "frozen body" AutoChild is created to render
    // the frozen portion of the dataset.
    // @see ListGrid.getBody()
    // @visibility external
    //<
    body:null,

    bodyConstructor:"GridBody",

    //> @attr listGrid.bodyOverflow (Overflow : isc.Canvas.AUTO : [IRWA])
    // Overflow setting for the "body", that is, the area of the grid where data values are
    // rendered.
    // <P>
    // <b>This is a very advanced setting</b> which is typically only changed by subclasses
    // of ListGrid which never show a header.  To achieve auto-fitting, instead use properties
    // such as +link{listGrid.autoFitData}, +link{listGrid.autoFitFieldWidths} and
    // +link{listGrid.fixedRecordHeights}.
    //
    //      @visibility external
    //      @group  sizing
    //      @example autofitRows
    //<
    bodyOverflow:isc.Canvas.AUTO,
    

    //> @attr listGrid.bodyBackgroundColor (String : "white" : IRW)
    // Background color applied to the ListGrid body (that is, the area of the grid where
    // data values are rendered).<br>
    // Note that this will typically not be visible to the user unless there are few enough
    // rows that there is visible space in the body below the last row. To style data cells,
    // override +link{ListGrid.baseStyle} instead.
    //      @group  appearance
    // @visibility external
    //<
    bodyBackgroundColor:"white",

    //> @attr listGrid.bodyStyleName (CSSStyleName : null : IRW)
    // CSS style used for the body of this grid.  If applying a background-color to the body
    // via a CSS style applied using this property, be sure to set
    // +link{ListGrid.bodyBackgroundColor} to <code>null</code>.
    //      @group  appearance
    // @visibility external
    //<
    //bodyStyleName:null,

    // whether to allow the body and header to have different border sizes and automatically
    // adjust the body column sizes to compensate such that column boundaries line up.
    allowMismatchedHeaderBodyBorder : true,

    //> @attr listGrid.emptyCellValue (HTMLString : "&nbsp;" : IRW)
    // The value to display for cells whose value is null or the empty string after applying
    // +link{listGrid.formatCellValue(),formatting} and valueMap (if any).
    // <p>
    // This is the grid-wide attribute.  You may also set the emptyCellValue on a per-field basis.
    //
    // @group cellStyling
    // @see listGridField.emptyCellValue
    // @visibility external
    // @example emptyValues
    //<
    emptyCellValue:"&nbsp;",

    //> @attr listGrid.minimumCellHeight (number : 20 : IR)
    // Minimum height for ListGrid cells, settable by the skin, based on the size of the 
    // checkbox media used for boolean fields plus minimal surrounding padding.  
    // <code>minimumCellHeight</code> is used by +link{Canvas.resizeControls()} to 
    // avoid shrinking ListGrid rows so much that correct display is impossible.  
    // Do not set minimumCellHeight on a per-instance basis - it's only for use in custom skins.
    // @visibility external
    //<
    minimumCellHeight:20,

    //> @attr listGrid.cellHeight (number : 20 : [IRW])
    // Default height for each row in pixels. See +link{listGrid.fixedRecordHeights} and
    // +link{listGrid.enforceVClipping} for information on how rows are sized when 
    // cell content height exceeds this specified value.
    // @visibility external
    // @example multilineValues
    //<
    cellHeight:20,

    //> @attr listGrid.normalCellHeight (number : 20 : [IRWA])
    // If +link{listGrid.baseStyle} is unset, base style will be derived from
    // +link{listGrid.normalBaseStyle} if this grid has fixed row heights and
    // the specified +link{listGrid.cellHeight} matches this value. Otherwise
    // +link{listGrid.tallBaseStyle} will be used.
    // @visibility external
    //<
    normalCellHeight:20,

    //> @attr listGrid.fixedRecordHeights (Boolean : true : IRWA)
    // Should we vertically clip cell contents, or allow rows to expand vertically to show all
    // contents?
    // <P>
    // If we allow rows to expand, the row height as derived from
    // +link{gridRenderer.getRowHeight(),getRowHeight()} or the
    // default +link{cellHeight} is treated as a minimum.
    // <P>
    // Setting <code>fixedRecordHeights</code> to false enables the +link{virtualScrolling}
    // system.
    // <P>
    // <b>NOTE:</b><ul>
    // <li>Setting fixedRecordHeights to false for +link{CubeGrid} is not supported, though a
    // similar option for the row headers is available as +link{CubeGrid.autoSizeHeaders}.
    // <li>By default, for performance reasons, clipping is not enforced for
    // some kinds of content (such as images) on all browsers.  Set
    // +link{enforceVClipping,enforceVClipping:true} to enforce clipping for
    // all types of content on all browsers.
    // </ul>
    //
    // @include gridRenderer.fixedRowHeights
    // @example autofitValues
    //<
    fixedRecordHeights: true,
    
    //> @attr listGrid.variableRecordHeightFields (Array of ListGridField : null : IRWA)
    // If +link{listGrid.fixedRecordHeights} is false, and this grid has 
    // +link{listGridField.frozen,frozen fields}, this property may be used to identify
    // a specific field or set of fields expected to vertically overflow the specified 
    // +link{listGrid.cellHeight}, causing rows to expand.
    // <P>
    // This is an advanced property provided for performance improvement. By expressly
    // specifying which fields can drive the rendered heights of rows, the system can
    // target logic to ensure row heights are consistent across frozen and unfrozen fields,
    // etc on cells from those specific fields, making such logic more efficient.
    // <P>
    // Note that setting this property will not cause other fields to be clipped
    // @visibility internal
    //<
    // We currently use this to optimize the rowHeightSpacerHTML strategy for
    // specific columns.
     
    
//     variableRecordHeightFields:null,

    //> @attr listGrid.enforceVClipping (Boolean : false : IRW)
    // For performance reasons, even when +link{fixedRecordHeights} is set, vertical clipping
    // is not enforced by default for some kinds of content (such as images) on all browsers.
    // Set +link{enforceVClipping,enforceVClipping:true} to enforce clipping for all types of
    // content on all browsers.
    // <P>
    // This additional setting is likely to be phased out as browsers improve.
    //
    // @visibility external
    //<
    

    //> @attr listGrid.fixedFieldWidths (Boolean : true : IRWA)
    // Should we horizontally clip cell contents, or allow columns to expand horizontally to
    // show all contents?
    // <P>
    // If we allow columns to expand, the column width is treated as a minimum.
    // <P>
    // NOTE: the header does not automatically respond to expanded field widths.
    // If your grid is showing a header we'd recommend developers consider
    // setting +link{listGrid.autoFitFieldWidths} rather than using this attribute.
    // @group cellStyling
    // @visibility external
    //<
    // NOTE: doc is duplicated here because in the ListGrid we need to discuss the header.
    fixedFieldWidths:true,
    
    // Frozen fields combined with variable rowHeights
    
    matchFrozenRowHeightsApproach:"rowHeightSpacerHTML",
    
    // autoFit attributes

    //> @type Autofit 
    // Possible values to change the behavior of how data will fill the ListGrid.
    // @value "vertical" expand vertically to accommodate records.
    // @value "horizontal" expand horizontally to accommodate fields.
    // @value "both" expand horizontally and vertically to accommodate content.
    // @group autoFitData
    // @visibility external
    //<

    //> @attr listGrid.autoFitData (Autofit : null : IRW)
    // Should this ListGrid automatically expand to accommodate the size of records and fields?
    // <P>
    // Valid settings are
    // <ul><li><code>"vertical"</code>: expand vertically to accommodate records.</li>
    //     <li><code>"horizontal"</code>: expand horizontally to accommodate fields.</li>
    //     <li><code>"both"</code>: expand horizontally and vertically to accommodate content.</li>
    // </ul>
    // How far the ListGrid will expand may be limited via the following properties:
    // +link{ListGrid.autoFitMaxHeight}, +link{ListGrid.autoFitMaxRecords},
    // +link{ListGrid.autoFitMaxWidth}, +link{ListGrid.autoFitMaxColumns}.
    // <P>
    // Note that this property causes the grid as a whole to expand to fit records or fields.
    // To have the fields or records themselves expand to fit cell contents, see
    // +link{listGrid.autoFitFieldWidths} and +link{listGrid.fixedRecordHeights}.
    // @group autoFitData
    // @visibility external
    //<

    //> @attr listGrid.autoFitMaxHeight (Integer : null : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"vertical"</code> or <code>"both"</code> this
    // property provides an upper limit on how far the ListGrid will expand vertically to accommodate
    // its content. If content exceeds this height, scrollbars will be introduced as usual.
    // In addition to this property, +link{ListGrid.autoFitMaxRecords} allows you to limit vertical
    // expansion based on the number of rows to be rendered.
    // @group autoFitData
    // @visibility external
    //<

    //> @attr ListGrid.autoFitMaxRecords (int : 50 : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"vertical"</code> or <code>"both"</code> this
    // property provides the maximum number of records for which the ListGrid will expand. If more
    // records are present, scrolling will be introduced to reach them as normal.
    // If unset, by default the ListGrid will expand to accommodate as many records as are present.
    // @group autoFitData
    // @visibility external
    //<
    autoFitMaxRecords:50,

    //> @attr ListGrid.autoFitExtraRecords (Integer : null : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"vertical"</code> or <code>"both"</code>,
    // setting this property will cause the ListGrid body to size large enough to accommodate
    // the actual data and also leave this many extra rows' worth of blank space below the last
    // record. If a maximum size is specified via +link{listGrid.autoFitMaxHeight} or
    // +link{listGrid.autoFitMaxRecords}, it will still be respected. Once the data set
    // is large enough to fill or exceed that space, this property no longer has an effect.
    // @group autoFitData
    // @visibility external
    //<
//    autoFitExtraRecords:0,

    //> @attr listGrid.autoFitMaxWidth (Integer | String : null : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"horizontal"</code> or <code>"both"</code>
    // this property provides an upper limit on how far the ListGrid will expand horizontally to
    // accommodate its content. Value may be specified as a numeric pixel value or
    // a percentage value.
    // <P>
    // If content exceeds this width, scrollbars will be introduced as usual.
    // In addition to this property, +link{ListGrid.autoFitMaxColumns} allows you to limit
    // horizontal expansion based on the number of columns to be rendered.
    // @group autoFitData
    // @visibility external
    //<
    
    //>@method listGrid.getDataSource()
    // The DataSource that this component should bind to for default fields and 
    // for performing +link{DSRequest,DataSource requests}.
    //
    // @return (DataSource)  Datasource object for this ListGrid instance.
    // @visibility external
    //<
    
    //> @method listGrid.getAutoFitMaxWidth()
    // Returns the +link{listGrid.autoFitMaxWidth}. Note that this method always returns
    // an integer value - autoFitMaxWidth specified as a percentage will be resolved
    // to a pixel value before being returned.
    //
    // @return (Integer) autoFitMaxWidth pixel value
    // @visibility external
    // @group autoFitData
    //<
    getAutoFitMaxWidth : function () {
        var width = this.autoFitMaxWidth;
        if (width != null) {
            if (!isc.isA.Number(width)) {
                if (this._autoFitMaxPixelWidth == null) {
                    this._autoFitMaxPixelWidth = 
                        this._convertPercentageWidth(this.autoFitMaxWidth);
                }
                width = this._autoFitMaxPixelWidth;
            }
        }
        return width;
    },
    
    // Method to resolve a percentage width value to a pixel value based on the
    // size of this widget's container
    // Used for autoFitMaxWidth
    
    _convertPercentageWidth : function (percentWidth) {

        // get the relevant full size
        // this is the page width/height if this canvas has no parents, or
        // the parent element's inner width/height, otherwise
        var parent, fullSize, insideParent;
        
        // viewport vs outer size determined by percentBox setting
        if (this.percentSource || (this.snapTo && this.masterElement)) {
            parent = this.percentSource || this.masterElement;
            insideParent = (this.percentBox == this._$viewport),
            fullSize = (insideParent ? parent.getViewportWidth()
                                                  : parent.getVisibleWidth());
        } else {
            parent = this.parentElement;

            
            if (isc.Layout && isc.isA.Layout(parent) && parent.hasMember(this)) {
                fullSize = !parent.vertical ? parent.getTotalMemberSpace() :
                                        parent.getBreadth() - parent._getBreadthMargin();
            } else if (parent) {
                fullSize = parent.getInnerWidth();
            } else {
                fullSize = isc.Page.getWidth();
            }
        }
        
        
        
        return Math.round((parseInt(percentWidth, 10) / 100) * fullSize);
        
    },
    
    _resolvePercentageSize : function () {
        if (this.autoFitMaxWidth != null && !isc.isA.Number(this.autoFitMaxWidth)) {
            delete this._autoFitMaxPixelWidth;
            // Mark for adjust overflow - this will resize the grid as a whole if necessary
            if (this.body) {
                this.body._markForAdjustOverflow("Resolving percentage autoFitMaxWidth");
            }
        }
        this.Super("_resolvePercentageSize", arguments);
    },
    
    
    
    //> @attr ListGrid.autoFitMaxColumns (int : 50 : IRW)
    // If +link{listGrid.autoFitData} is set to <code>"horizontal"</code> or <code>"both"</code>
    // this property provides the maximum number of columns for which the ListGrid will expand.
    // If more columns are present, scrolling will be introduced to reach them as normal.
    // If unset the ListGrid will expand to accommodate as many columns as are defined for the
    // grid.
    // @group autoFitData
    // @visibility external
    //<
    autoFitMaxColumns:50,


    //> @attr listGrid.canAutoFitFields (Boolean : true : IRW)
    // Can the user perform one-time autofit for specific columns in this grid?
    // <P>
    // If set to true, the default header menu will include options to auto fit
    // +link{listGrid.autoFitAllText,all fields} such that they fit their
    // content or titles as specified via +link{listGridField.autoFitWidthApproach}.<br>
    // Autofitting of individual fields via a
    // +link{listGrid.autoFitFieldText,header context menu item}, or the
    // +link{listGrid.headerAutoFitEvent} will also be enabled when this
    // property is set unless +link{listGridField.canAutoFitWidth} is explicitly set to false
    // <P>
    // Note that the ability to perform one-time autofitting of fields via this 
    // subsystem is separate from the programmatic autofit behavior enabled 
    // via +link{listGrid.autoFitFieldWidths}.
    // <P>
    // This subsystem is requires canResizeFields be enabled and will be disabled if
    // that property is set to false
    // @visibility external
    // @group autoFitFields
    //<
    
    canAutoFitFields:true,
    

    //> @type AutoFitEvent
    // Event on a listGrid header to trigger auto-fit of the listgrid field.
    // @value "doubleClick" React to a double click on the listGrid header.
    // @value "click" React to a click on the listGrid header.
    // @value "none" No event will trigger auto-fit.
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.headerAutoFitEvent (AutoFitEvent : "doubleClick" : IR)
    // Event on a ListGrid header that triggers auto fitting to data and/or title.
    // <P>
    // Note that if sorting is enabled for the field and the headerAutoFitEvent is "click", both
    // sorting and autofit occur on a click.
    // <P>
    // Only has an impact when +link{listGrid.canAutoFitFields} or 
    // +link{listGridField.canAutoFitWidth} is set to <code>true</code>.
    //
    // @visibility external
    // @group autoFitFields
    //<
    headerAutoFitEvent:"doubleClick",

    //> @attr listGridField.canAutoFitWidth (Boolean : null : IR)
    // Should the user be allowed to perform one-time autofitting of this field via
    // a header context-menu option?
    // <P>
    // When enabled, the default header context menu for this field will
    // include an item to auto-fit the field and users will be able to autofit the field
    // via the +link{listGrid.headerAutoFitEvent}.
    // <P>
    // If unset, these behaviors are enabled when +link{listGrid.canAutoFitFields} is true.
    // <P>
    // If this property is set to false, and +link{listGrid.canAutoFitFields} is true,
    // this field will be ommitted from auto-fit when the user selects the header menu 
    // option to +link{listGrid.autoFitAllText,auto fit all fields}.
    // <P>
    // Note - this property governs user-initiated auto-fit only. It has no impact on
    // autoFit set up via +link{listGridField.autoFitWidth} and +link{listGrid.autoFitFieldWidths}.
    // <P>
    // Note that if +link{listGrid.showRecordComponents,showing record components}, per-cell record
    // components are not taken into account when determining the size for column auto fit.
    // The default +link{listGrid.getDefaultFieldWidth()} implementation looks at cell content
    // only. We typically recommend that, for fields showing record-components, 
    // +link{listGridField.autoFitWidth} and +link{listGrid.canAutoFitFields} be disabled, or if 
    // the record components are of a predictable size, a +link{listGridField.defaultWidth}
    // be specified.<br>
    // This is particularly pertinent where +link{listGrid.recordComponentPosition}
    // is set to "within", in which case cells' content is often empty or completely covered
    // by record-components.
    //
    // @see listGrid.autoFitDateFields
    // @see listGrid.autoFitTimeFields
    // @visibility external
    //<

    //> @attr listGridField.autoFitWidth (Boolean : null : IR)
    // Should this listGrid field autofit its width to either titles or content?
    // <P>
    // This overrides the +link{listGrid.autoFitFieldWidths} attribute on a per-field basis.
    // <P>
    // Note that if +link{listGrid.showRecordComponents,showing record components}, per-cell record
    // components are not taken into account when determining the size for column auto fit.
    // The default +link{listGrid.getDefaultFieldWidth()} implementation looks at cell content
    // only. We typically recommend that, for fields showing record-components, 
    // +link{listGridField.autoFitWidth} and +link{listGridField.canAutoFitWidth} be disabled, or if 
    // the record components are of a predictable size, a +link{listGridField.defaultWidth}
    // be specified.<br>
    // This is particularly pertinent where +link{listGrid.recordComponentPosition}
    // is set to "within", in which case cells' content is often empty or completely covered
    // by record-components.        
    //
    // @see listGrid.autoFitDateFields
    // @see listGrid.autoFitTimeFields
    // @visibility external
    // @group autoFitFields
    //<
    
    //> @attr listGridField.defaultWidth (Integer : null : IR)
    // Optional "default width" for this field. If set, this value will be returned by the
    // +link{listGrid.getDefaultFieldWidth()} method, and used as the autoFit size for
    // the field's content.
    //
    // @visibility external
    // @group autoFitFields
    //<

    //> @attr listGrid.autoFitFieldWidths (Boolean : null : IR)
    // Should ListGrid fields autofit their widths to titles or content?
    // This property may be overridden on a per-field basis via +link{listGridField.autoFitWidth}.
    // Developers may wish to consider disabling autoFit for fields known to have 
    // exceptionally long content as this can lead to large horizontal scrollbars and unwieldy UI.
    // <P>
    // The +link{listGrid.autoFitWidthApproach} controls whether fitting is to values, titles
    // or both. This property may also be overridden on a per field basis.
    // <P>
    // If +link{listGridField.width,field.width} is also set on the field, it will be taken as a minimum width.
    // +link{listGrid.minFieldWidth} will also be respected.
    // <P>
    // By default, the entire available width of the grid will still be used, by allocating any "extra"
    // space to specific columns - see +link{listGrid.autoFitFieldsFillViewport} for details on
    // controlling this behavior.
    // <P>
    // When this feature is enabled, autofitting is active on an ongoing basis.
    // Autofitting will be performed:
    // <ul>
    //  <li> whenever the dataset is completely changed or rows are added or removed
    //  <li> whenever a field which is autofitting is changed
    //  <li> on a manual call to +link{listGrid.autoFitField()} or
    //       +link{listGrid.autoFitFields()}
    // </ul>
    // Auto-fitting behavior continues until the user resizes the field manually, at which
    // point it stops. The user can also perform a one-time auto-fit of fields via
    // the header context menu if +link{listGrid.canAutoFitFields} is enabled.
    // <P>
    // When autofitting to column values, +link{listGrid.getDefaultFieldWidth()} will be
    // called to determine the space required for a field's values. This method
    // uses values from the rendered set of rows to calculate the required column width, which means the
    // field width may still be smaller than values from non-rendered rows.  See
    // +link{listGrid.showAllRecords} and +link{listGrid.drawAheadRatio}) to control incremental
    // rendering of rows.
    // <P>
    // Note that for <code>icon</code> type fields, the +link{listGrid.autoFitIconFields}
    // property setting may turn on auto-fit-width behavior for specific fields by default,
    // even if <code>autoFitFieldWidths</code> is false for the grid as a whole.
    // <P>
    // Using this feature has a performance penalty roughly comparable to always rendering
    // one additional field per field where autofitting is enabled.  Specifically, enabling it
    // for all fields would be comparable to <i>both</i> doubling the number of fields
    // <i>and</i> disabling +link{listGrid.showAllColumns,horizontal incremental rendering}.
    // In a grid where only half the fields are normally visible and hence only half are
    // normally rendered, this would be roughly 4 times slower overall.
    // <P>
    // This performance penalty is a result of +link{getDefaultFieldWidth()} having to
    // render out the data set offscreen and measure the rendered content - it does not apply
    // for cases where this method can return a simple fixed values (as with icon fields).
    // <P>
    // Which fields are currently autofitting is saved as part of the
    // +link{getViewState,view state} of the ListGrid.
    // <P>
    // Interaction with wrapping: If +link{listGrid.wrapCells,wrapping of cell values} is 
    // enabled, autoFit behavior based on +link{listGrid.autoFitWidthApproach,cell content}
    // will render fields wide enough to contain the <i>unwrapped</i> cell values.
    // If +link{listGridField.wrap,wrapping of field titles} is enabled, when fitting to 
    // a title, a field will render wide enough to accommodate the <i>wrapped</i> title without
    // clipping (so wide enough for the natural wrap-point / longest word or unwrappable string).
    //
    // @visibility external
    // @group autoFitFields
    //<
    

    //> @attr listGrid.autoSizeHeaderSpans (Boolean : false : IR)
    // If this listGrid has specified +link{listGrid.headerSpans}, setting this
    // attribute to true will cause spans to expand to accommodate long titles if necessary.
    // @visibility external
    // @group headerSpan
    // @group autoFitFields
    //<
    autoSizeHeaderSpans:false,


    //> @attr listGrid.autoFitClipFields (Array of String : null : IR)
    // If +link{listGrid.autoFitFieldWidths} is enabled and the calculated field sizes
    // are wide enough that horizontal scrolling would be introduced, this attribute may be
    // set to an array of fieldNames, causing those fields to be clipped rather than
    // forcing horizontal scrollbars to appear.
    // <P>
    // Note: If any +link{ListGridField.frozen,frozen columns} are included in this list they
    // will not be clipped.
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.autoFitFieldsFillViewport (Boolean : true : IR)
    // If +link{listGrid.autoFitFieldWidths} is enabled, and extra space is available after
    // autofitting all fields, should the grid automatically expand one field to fill the extra
    // space.
    // <P>
    // When enabled, the field to expand may be specified via +link{autoFitExpandField}.
    // <P>
    // Note this logic will not expand a +link{ListGridField.frozen,frozen column}.
    //
    // @group autoFitFields
    // @visibility external
    //<
    autoFitFieldsFillViewport:true,

    //> @attr listGrid.autoFitExpandField (String : null : IR)
    // The field to expand if +link{listGrid.autoFitFieldWidths} and
    // +link{autoFitFieldsFillViewport} are enabled and
    // auto-fitting will not fill all available horizontal space.
    // <P>
    // If unset, will default to the text field with the longest
    // +link{dataSourceField.length} if length is set, otherwise, the first text
    // field with no width specified.
    // <P>
    // Note that expanding +link{ListGridField.frozen,frozen columns} is not supported.
    // @group autoFitFields
    // @visibility external
    //<

    //> @type AutoFitWidthApproach
    // How should field width be determined when +link{listGridField.autoFitWidth} is true?
    // @value "value" Size field to fit to the data value(s) contained in the field.
    // @value "title" Size field to fit the field title
    // @value "both" Size field to fit either the field title or the data values in the field
    //  (whichever requires more space).
    //
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.autoFitWidthApproach (AutoFitWidthApproach : "value" : [IRW])
    // When a user requests column autofitting via the
    // +link{getHeaderContextMenuItems,header context menu} or via a
    // +link{headerAutoFitEvent,mouse gesture}, what autofit approach is used.
    // @group autoFitFields
    // @visibility external
    //<
    autoFitWidthApproach:"value",

    // If we're autoFitting to values, and we're showing a grid summary, should the
    // grid summary values be taken into account when sizing columns?
    // By default they are - set this flag to false to disable this behavior.
    includeGridSummaryInAutoFitWidth:true,

    //> @attr listGridField.autoFitWidthApproach (AutoFitWidthApproach : null : [IRW])
    // When a user requests column autofitting via the
    // +link{listGrid.getHeaderContextMenuItems,header contextMenu} or via a
    // +link{listGrid.headerAutoFitEvent,mouse gesture}, what autofit approach is used. If set, this
    // setting overrides the autoFitWidthApproach specified at the ListGrid level.
    // @group autoFitFields
    // @visibility external
    //<

    //> @type AutoFitIconFieldType
    // How should fields of +link{listGridFieldType,type:"icon"} be sized by default?
    // @value "none" Apply no special sizing to icon fields - treat them like any other
    //   field in the grid
    // @value "iconWidth" size the field to accommodate the width of the icon
    // @value "title" size the field to accommodate the title (or the width of the icon if
    //   it exceeds the width of the title.
    //
    // @group autoFitFields
    // @visibility external
    //<

    //> @attr listGrid.autoFitIconFields (AutoFitIconFieldType : "title" : [IRW])
    // SmartClient listGrids have special logic to automatically size fields that
    // are displayed as an icon - that is fields with
    // +link{listGridFieldType,type:"icon"}, fields displaying only
    // +link{listGridField.showValueIconOnly,value icons}, and boolean fields (which
    // are rendered as a checkmark type icon by default.
    // <P>
    // This attribute controls this behavior - governing whether icon fields should
    // be sized to fit their content (icon), title, or whether to disable this
    // behavior. Setting this value to <code>"title"</code> or <code>"iconWidth"</code>
    // will cause +link{listGridField.autoFitWidth} to be enabled by default for all
    // icon fields with the +link{listGridField.autoFitWidthApproach} set to
    // <code>"value"</code> or <code>"both"</code> as appropriate. Note that the
    // width required for the icons is calculated by +link{listGrid.getDefaultFieldWidth()}
    // which performs a simple calculation based on the specified icon width for these
    // types of fields.
    // <P>
    // This setting governs default behavior for icon fields - for specific fields within
    // a grid, this default behavior can be overridden by setting an explicit
    // +link{listGridField.width} or
    // explicitly enabling +link{listGridField.autoFitWidth} and setting
    // +link{listGridField.autoFitWidthApproach} on the field in question.
    // @see listGrid.autoFitFieldWidths
    // @group autoFitFields
    // @visibility external
    //<
    autoFitIconFields:"title",
    
    //> @attr listGrid.autoFitDateFields (AutoFitWidthApproach : "value" : IRW)
    // Should listGrids automatically size date fields to fit their values or titles?
    // If set to <code>"value"</code>, fields of type date will be rendered at the
    // size specified by +link{listGrid.defaultDateFieldWidth}, 
    // (or +link{listGrid.defaultEditableDateFieldWidth} for editable fields). This static
    // value is appropriate for dates rendered with the standard short-date formatter.
    // If set to <code>"title"</code> or <code>"both"</code>, the drawn width of the title
    // will be taken into account when sizing the column.
    // <P>
    // This is achieved by enabling +link{listGridField.autoFitWidth,autoFitWidth:true}
    // on date fields when this property is set to anything other than <code>"none"</code>,
    // setting the +link{listGridField.autoFitWidthApproach} to the value specified here
    // and having logic in +link{listGrid.getDefaultFieldWidth()} pick up the
    // +link{listGrid.defaultDateFieldWidth} or +link{listGrid.defaultEditableDateFieldWidth}
    // if appropriate.
    // @group autoFitFields
    // @visibility external
    //<
    autoFitDateFields:"value",

    
    defaultFieldWidthScaleFactors: {
        Date: 6, EditableDate: 4, DateTime: 9, EditableDateTime: 6, Time: 6
    },
    
    //> @attr listGrid.defaultDateFieldWidth (Integer : varies : IRW)
    // Default width for date type fields. See +link{listGrid.autoFitDateFields} for
    // details on how this property is used.
    // @group autoFitFields
    // @visibility external
    //<
    defaultDateFieldWidth: 60,
    
    //> @attr listGrid.defaultEditableDateFieldWidth (Integer : varies : IRW)
    // Default width for editable date type fields. See +link{listGrid.autoFitDateFields} for
    // details on how this property is used.
    // @group autoFitFields
    // @visibility external
    //<
    defaultEditableDateFieldWidth: 94,

    //> @attr listGrid.defaultDateTimeFieldWidth (Integer : varies : IRW)
    // Default width for datetime type fields. See +link{listGrid.autoFitDateFields} for
    // details on how this property is used.
    // @group autoFitFields
    // @visibility external
    //<
    defaultDateTimeFieldWidth: 92,
    
    //> @attr listGrid.defaultEditableDateTimeFieldWidth (Integer : varies : IRW)
    // Default width for editable datetime type fields. See +link{listGrid.autoFitDateFields}
    // for details on how this property is used.
    // @group autoFitFields
    // @visibility external
    //<
    defaultEditableDateTimeFieldWidth: 130,
    
    //> @attr listGrid.autoFitTimeFields (AutoFitWidthApproach : "value" : IRW)
    // Should listGrids automatically size time fields to fit their values or titles?
    // If set to <code>"value"</code>, fields of type time will be rendered at the
    // size specified by +link{listGrid.defaultTimeFieldWidth}. This static
    // value is appropriate for dates rendered with the standard time formatter.
    // If set to <code>"title"</code> or <code>"both"</code>, the drawn width of the title
    // will be taken into account when sizing the column.
    // <P>
    // This is achieved by enabling +link{listGridField.autoFitWidth,autoFitWidth:true}
    // on date fields when this property is set to anything other than <code>"none"</code>,
    // setting the +link{listGridField.autoFitWidthApproach} to the value specified here
    // and having logic in +link{listGrid.getDefaultFieldWidth()} pick up the
    // +link{listGrid.defaultTimeFieldWidth} if appropriate.
    // @group autoFitFields
    // @visibility external
    //<
    autoFitTimeFields:"value",
    
    //> @attr listGrid.defaultTimeFieldWidth (Integer : varies : IRW)
    // Default width for time type fields. See +link{listGrid.autoFitDateFields} for
    // details on how this property is used.
    // @group autoFitFields
    // @visibility external
    //<
    defaultTimeFieldWidth: 65,

    //> @attr listGrid.skipLineBreaks (boolean : null : IRW)
    // Whether to skip line breaks for all fields by default when
    // +link{listGridField.escapeHTML,escaping HTML}.  This property can be overridden at the
    // field level by +link{listGridField.skipLineBreaks}.
    // @see listGridField.escapeHTML
    // @visibility external
    //<
    shouldSkipLineBreaks : function (field) {
        var skipLineBreaks = field.skipLineBreaks;
        return skipLineBreaks || skipLineBreaks != false && this.skipLineBreaks;
    },

    //> @attr listGrid.leaveScrollbarGap (Boolean : true : IRW)
    // Whether to leave a gap for the vertical scrollbar, even when it's not present.
    // <P>
    // Note that if leaveScrollbarGap is false and vertical scrolling is introduced, fields
    // will be resized to fit the smaller body area if possible, in order to avoid horizontal
    // scrolling also being required.
    //
    // @group appearance
    // @visibility external
    // @example autofitRows
    //<
    
    leaveScrollbarGap:true,

    // leaveScrollbarGap has meaning at the Layout level. We don't expect to ever show a vscrollbar
    // at the actual ListGrid level so override 'getBreadth' to avoid leaving a gap outside the
    // actual component members (header, body etc).
    getBreadth : function () {
        return this.getInnerWidth();
    },

    // if leaveScrollbarGap is false, whether to resize fields when vscrolling is introduced
    resizeFieldsForScrollbar:true,

    //> @attr listGrid.autoFit (boolean : false : IRWA)
    // If true, make columns only wide enough to fit content, ignoring any widths specified.
    // Overrides fixedFieldWidths.
    // <P>
    // NOTE: the header does not automatically respond to expanded field widths
    //  @group  sizing
    //<
    
    //autoFit:false,

    //> @attr listGrid.wrapCells (Boolean : false : IRWA)
    // Should content within cells be allowed to wrap?
    // <P>
    // Even if content is allowed to wrap, if +link{fixedRecordHeights} is set, the content
    // will be clipped off at the cell boundary.  Either set a larger, fixed +link{cellHeight}
    // to reveal more content, or set +link{fixedRecordHeights} to false to allow auto-sizing.
    //
    // @example autofitValues
    // @visibility external
    //<
    //wrapCells:false,

    //> @attr listGrid.preserveWhitespace (Boolean : false : IRWA)
    // Should cells be written out with css that will preserve whitespace?
    // <P>
    // If true, depending on the value of +link{listGrid.wrapCells}, the css generated
    // for cells will use the
    // +externalLink{https://www.w3.org/wiki/CSS/Properties/white-space#Values,white-space}
    // property values of <code>pre</code> or <code>pre-wrap</code>.
    // This avoids collapsing sequences of whitespace without requiring
    // special <i>&amp;nbsp;</i> characters.
    //
    // @visibility external
    //<
    
    
    //> @attr listGrid.showClippedValuesOnHover (Boolean : null : IRA)
    // @include gridRenderer.showClippedValuesOnHover
    //<
    showClippedValuesOnHover:null,

    //> @attr listGrid.cellSpacing (number : 0 : [IRW])
    // @include gridRenderer.cellSpacing
    // @visibility internal
    //<
    
    cellSpacing:0,

    //> @attr listGrid.cellPadding (number : 2 : [IRW])
    // @include gridRenderer.cellPadding
    //<
    cellPadding:2,

    //> @attr listGrid.dateFormatter (DateDisplayFormat : null : [IRW])
    // How should Date type values be displayed in this ListGrid by default?
    // <P>
    // This property specifies the default DateDisplayFormat to apply to Date values
    // displayed in this grid for all fields except those of +link{listGridField.type,type "time"}
    // (See also +link{listGrid.timeFormatter}).<br>
    // If +link{listGrid.datetimeFormatter} is specified, that will be applied by default
    // to fields of type <code>"datetime"</code>.
    // <P>
    // Note that if +link{listGridField.dateFormatter} or +link{listGridField.timeFormatter} are
    // specified those properties will take precedence over the component level settings.
    // <P>
    // If unset, date values will be formatted according to the system wide
    // +link{DateUtil.setShortDisplayFormat(),short display format} or
    // +link{DateUtil.setShortDatetimeDisplayFormat(),short datetime display format} for
    // datetime type fields.
    // <P>
    // If this field is editable the dateFormatter will also be passed to the editor created
    // to edit this field as +link{DateItem.dateFormatter, dateFormatter}.
    // In this case you may also need to set +link{listGrid.dateInputFormat}.
    //
    // @visibility external
    //<
    //dateFormatter:null,

    //> @attr listGrid.datetimeFormatter (DateDisplayFormat : null : [IRW])
    // Display format to use for fields specified as type 'datetime'.  Default is to use the
    // system-wide default date time format, configured via
    // +link{DateUtil.setShortDatetimeDisplayFormat()}.  Specify any
    // valid +link{type:DateDisplayFormat} to change the display format for datetimes used by this grid.
    // <smartclient>
    // May be specified as a function. If specified as  a function, this function will be executed in the scope of the Date
    // and should return the formatted string.
    // </smartclient>
    // <P>
    // May also be specified at the field level via
    // +link{listGridField.dateFormatter}
    // <P>
    // If this field is editable the dateFormatter will also be passed to the editor created
    // to edit this field as +link{DateItem.dateFormatter, dateFormatter}.
    // In this case you may also need to set +link{listGrid.dateInputFormat}.
    //
    // @see listGridField.dateFormatter
    // @group appearance
    // @visibility external
    //<

    //> @attr listGrid.dateInputFormat (DateInputFormat : null : [IRWA])
    // If this is an editable listGrid, this property will specify the
    // +link{DateItem.inputFormat, inputFormat} applied to editors for fields of type
    // <code>"date"</code>. May be overridden per field via +link{listGridField.inputFormat}.
    // @see listGrid.dateFormatter
    // @visibility external
    //<

    // function to call appropriate date formatter
    // Note: this is executed in the scope of a field object - see 'applyFieldDefaults'
    _formatDateCellValue : function (value, field, grid, record, rowNum, colNum) {

        if (isc.isA.Date(value)) {
            // A developer may force a "date" or "datetime" type field value to be displayed as time
            // by specifying a timeFormatter and no dateFormatter on the field.
            if (grid._formatAsTime(field)) {
                var formatter = grid._getTimeFormatter(field);
                var isLogicalTime = isc.SimpleType.inheritsFrom(field.type, "time");
                return isc.Time.toTime(value, formatter, isLogicalTime);
            }

            var isDatetime = field && isc.SimpleType.inheritsFrom(field.type, "datetime"),
                isLogicalDate = !isDatetime && isc.SimpleType.inheritsFrom(field.type, "date"),
                formatter = grid._getDateFormatter(field);

            // rely on date.toShortDateTime() / toShortDate() to handle applying the
            // custom formatter if specified, otherwise picking up the appropriate system-wide
            // default for the data type.
            // The second parameter to toShortDateTime() explicitly causes the date to be displayed
            // in the custom timezone set up in Time.setDefaultDisplayTimezone
            if (isDatetime) return value.toShortDateTime(formatter, true);
            return value.toShortDate(formatter, !isLogicalDate);
        }
        return value;
    },

    // Date formatting helpers:
    // Called from formatDateCellValue() / formatTimeCellValue() [which are type-specific formatters
    // applied to fields as part of field init], and also as a catch-all for
    // Date type values in fields of some other specified data-type.
    // We use a consistent pattern across DataBoundComponents:
    // - developer can specify explicit dateFormatter / timeFormatter per field and they'll be used.
    //   if both are specified dateFormatter takes precedence except in "time" type fields.
    // - developer can specify dateFormatter, datetimeFormatter and timeFormatter per component and
    //   they'll be used if no per-field settings are found.

    // If a field has a JS Date value, should we format it as a time? True for "time" type fields
    // or fields with an explicit time formatter only.
    _formatAsTime : function (field) {
        if (field == null) return false;

        // If at the field level the timeFormatter is defined *(and there's no date formatter)
        // respect it.
        if (field.timeFormatter != null && field.dateFormatter == null) return true;
        // timeFormatter null and dateFormatter non-null --> format as date
        
        if (field.dateFormatter != null && field.timeFormatter == null) return false;
        return isc.SimpleType.inheritsFrom(field.type, "time");
    },

    _getDateFormatter : function (field) {
        
        if (field == null) return this.dateFormatter;
        
        if (field.dateFormatter != null) return field.dateFormatter;
        // displayFormat is back-compat at this point - only applies to fields of type
        // date or datetime (or subtypes thereof)
        if (field.displayFormat != null && 
            (isc.SimpleType.inheritsFrom(field.type, "date") || isc.SimpleType.inheritsFrom(field.type, "datetime"))) 
        {
            return field.displayFormat;
        }
        
        if (this.datetimeFormatter != null && isc.SimpleType.inheritsFrom(field.type, "datetime")) {
            return this.datetimeFormatter;
        }

        return this.dateFormatter;
    },

    // This picks up *explicit* dateInputFormat to pass through to the edit-item. No need to
    // include logic to derive from the display format if no explicit input format was specified,
    // that'll be handled by the FormItem code.
    _getDateInputFormat : function (field) {
        var inputFormat;
        if (field) inputFormat = field.inputFormat
        if (!inputFormat) inputFormat = this.dateInputFormat;
        return inputFormat;
    },

    // function to call appropriate number formatter
    // If no number formatter is defined, the default formatter will be used [standard 'toString']
    // is the default
    _formatNumberCellValue : function (value, field, grid, record, rowNum, colNum) {
        if (isc.isA.Number(value)) {
            if (isc.SimpleType.inheritsFrom(field.type, "float") &&
                (field.decimalPrecision != null || field.decimalPad != null))
            {
                return isc.Canvas.getFloatValueAsString(
                        value, field.decimalPrecision, field.decimalPad);
            } else if (field.precision != null) {
                return isc.Canvas.getNumberValueAsString(value, field.precision, field.type);
            } else {
                var formatter = (field.numberFormatter || field.formatter || grid.numberFormatter);
                return value.toFormattedString(formatter);
            }
        }

        // If passed a non-number just return it
        return value;
    },

    //> @attr listGrid.timeFormatter (TimeDisplayFormat : "toShortPaddedTime" : [IRW])
    // Display format to use for fields specified as type 'time'.  May also be specified at
    // the field level via +link{listGridField.timeFormatter}.<br>
    // If unset, time fields will be formatted based on the system wide
    // +link{Time.shortDisplayFormat}.<br>
    // If this field is editable, the timeFormatter will also be passed to the editor
    // created to edit any time type fields as +link{TimeItem.timeFormatter}
    // @group appearance
    // @visibility external
    //<
    timeFormatter:"toShortPaddedTime",

    _getTimeFormatter : function (field) {
        if (field != null) {
            if (field.timeFormatter != null) return field.timeFormatter;
            if (field.displayFormat != null && isc.SimpleType.inheritsFrom(field.type, "time")) {
                return field.displayFormat;
            }
        }
        return this.timeFormatter;
    },

    // function to call appropriate time formatter
    // Note: this is executed in the scope of a field object - see 'applyFieldDefaults'
    _formatTimeCellValue : function (value, field, grid, record, rowNum, colNum) {
        var time = value;
        if (isc.isA.String(time)) {
            // Pass in the 'validTime' param - If we're given a string which doesn't
            // parse to a time we don't want to display "12:00 am"
            time = isc.Time.parseInput(time, true);
        }
        if (isc.isA.Date(time)) {
            // If dateFormatter is set on the field, and timeFormatter is not, we respect it
            // even for fields of explicit type "time"
            if (!grid._formatAsTime(field)) {
                
                return time.toShortDate(grid._getDateFormatter(field), true);
            }
            var formatter = grid._getTimeFormatter(field);

            // If we're passed an invalid formatter
            return isc.Time.toTime(time, formatter, true);
        }
        return value;
    },

    _formatBinaryCellValue : function (value, field, grid, record, rowNum, colNum) {
        
        if (isc.isA.String(value)) return value;
        if (record == null) return null;

        var fieldName = field.name,
            ds = grid.getDataSource(),
            filenameField = (ds ? ds.getFilenameField(fieldName) : null) || fieldName + "_filename",
            fileName = record[filenameField],
            value
        ;

        if (field.type=="imageFile" && field.showFileInline == true) {
            var urlProperty = fieldName + "_imgURL";

            if (!record[urlProperty]) {
                var dimensions = isc.Canvas.getFieldImageDimensions(field, record),
                    image = grid.getDataSource().getFileURL(record, field.name);

                dimensions.width = dimensions.width || grid.imageSize;
                dimensions.height = dimensions.height || grid.imageSize;
                value = record[urlProperty] =
                    isc.Canvas.imgHTML(image, dimensions.width, dimensions.height,
                                       null, null, isc.Canvas._$allowRelativeSrc);
            } else
                value = record[urlProperty];
        } else {
            if (field.showFileInline == true) { // non-imageFile field
                this.logWarn("_formatBinaryCellValue(): Unsupported field-type for showFileInline: "+field.type);
            }

            
            if (!field.filenameSuppressed && (fileName == null || isc.isAn.emptyString(fileName))) {
                return this.emptyCellValue;
            }

            var viewAction = "'" + grid.getID() +".view",
                dlAction = "'" + grid.getID() +".download",
                completion = "";
            if (field && field.name) {
                completion = "Cell(" + rowNum + ", \"" + field.name + "\")'";
            } else {
                completion = "Row(" + rowNum + ")'";
            }
            var viewIconHTML = isc.Canvas.imgHTML({
                src: "[SKIN]actions/view.png",
                width: 16,
                height: 16,
                extraCSSText: "cursor:" + isc.Canvas.POINTER_OR_HAND,
                eventStuff: " onclick=" + viewAction + completion
            });
            var downloadIconHTML = isc.Canvas.imgHTML({
                src: "[SKIN]actions/download.png",
                width: 16,
                height: 16,
                extraCSSText: "cursor:" + isc.Canvas.POINTER_OR_HAND,
                eventStuff: " onclick=" + dlAction + completion
            });

            value = viewIconHTML + "&nbsp;" + downloadIconHTML +
                (fileName ? "&nbsp;" + fileName : "");
        }

        return value;
    },

    // value is rendered as an anchor - the href and name of the anchor is the value.  By default
    // opens in a new browser window - this can be overridden by setting the 'target' property on
    // the record.
    //
    // The name of the link can be overridden by setting the 'linkName' property on the record.  By
    // default we use the value.
    _$linkTemplate:[
        "<a href='",
        ,   // 1: HREF
        "' target='",
        ,   // 3: name of target window
        // onclick handler enables us to prevent popping a window if (EG) we're masked.
        //                      5: ID
        "' onclick='if(window.",     ,") return ",
                //  7:ID                         9:rowNum,     11:colNum
                         ,"._linkClicked(event,",        ,",",          ,");'>",
        ,   // 13: link text
        "</a>"
    ],
    _$doubleEscapedQuote:"\\'",
    _$_blank:"_blank",

    _formatLinkCellValue : function (value, field, grid, record, rowNum, colNum) {
        if (value == null || isc.is.emptyString(value)) return value;

        // target window
        var target = field.target ?
                        field.target.replaceAll(grid._$singleQuote, grid._$doubleEscapedQuote) :
                        grid._$_blank;
        // get the linkText property. If defined on the field, use that, otherwise
        // use the linkTextProperty from the grid.
        var linkTextProp = field.linkTextProperty ? field.linkTextProperty : grid.linkTextProperty;
        var linkText = (record && record[linkTextProp]) ? record[linkTextProp]
                                                            : field.linkText || value;

        // link URL
        var href = "" + value;

        if (target == "javascript") {
            // target is "javascript" - make the link inert and have the cellClick event fired
            // instead
            href = "javascript:void";
        } else {
            if (field.linkURLPrefix) href = field.linkURLPrefix + href;
            if (field.linkURLSuffix) href = href + field.linkURLSuffix;
            href = href.replaceAll(grid._$singleQuote, grid._$doubleEscapedQuote);
        }

        // combine
        var template = grid._$linkTemplate;
        template[1] = href;
        template[3] = target;
        var ID = grid.getID();
        template[5] = ID;
        template[7] = ID;
        template[9] = rowNum;
        template[11] = colNum;
        template[13] = linkText;

        return template.join(isc.emptyString);
    },

    _linkClicked : function (event, rowNum, colNum) {
        // don't allow the click if the cell should not be interactive.
        var record = this.getRecord(rowNum),
            mustCancel = (
                this.destroyed || !this.isDrawn() || !this.isVisible() ||
                isc.EH.targetIsMasked(this.body) ||
                !this.recordIsEnabled(record, rowNum, colNum)),
            field = this.getField(colNum);

        if (event.target == "javascript" || field.target == "javascript") {
            mustCancel=true;
            this.cellClick(record, rowNum, colNum);
        }

        if (mustCancel) {
            
            if (!isc.Browser.isIE) {
                event.preventDefault();
            }

            return false;
        }
        return true;
    },

    //> @attr listGrid.linkTextProperty (String : "linkText" : [IRW])
    // Property name on a record that will hold the link text for that record.
    // <P>
    // This property is configurable to avoid possible collision with data values in the
    // record.
    // <P>
    // Use +link{listGridField.linkTextProperty} if you have more than one link field and
    //
    // @see type:ListGridFieldType
    // @see type:FieldType
    // @see attr:listGridField.linkText
    // @see attr:listGridField.linkTextProperty
    // @group  display_values
    // @visibility external
    //<
    linkTextProperty : "linkText",

    // value is a URL to an image
    _formatImageCellValue : function (value, field, grid, record, rowNum, colNum) {
        // if no value is stored, just return an empty string so we don't render a broken image
        if (value == null || isc.isAn.emptyString(value)) return isc.emptyString;

        // if any of field.imageWidth/Height/Size are set as strings, assume they are property
        // names on the record
        
        var dimensions = isc.Canvas.getFieldImageDimensions(field, record);

        dimensions.width = dimensions.width || grid.imageSize;
        dimensions.height = dimensions.height || grid.imageSize;

        
        var src = value,
            prefix = field.imageURLPrefix || field.baseURL || field.imgDir;

        // If imageURLSuffix is specified, apply it to the value
        if (field.imageURLSuffix != null) src += field.imageURLSuffix;

        

        return isc.Canvas.imgHTML(src, dimensions.width, dimensions.height, null,
                                  field.extraStuff, prefix, field.activeAreaHTML, null, null,
                                  null, null, field.eventStuff);
    },

    // show field.icon in the cell
    _formatIconCellValue : function (value, field, grid, record, rowNum, colNum) {
        // prevent an icon from being shown in the filter editor if the field has canFilter
        if (isc.isA.RecordEditor(grid) && grid.isAFilterEditor() && field.canFilter == false) return null;

        if (field._iconHTML) return field._iconHTML;
        var cursor = grid.getIconCursor(field),
            extraCSSText;
        if (cursor != null) {
            if (cursor == isc.Canvas.HAND && isc.Browser._usePointerCursorForHand) {
                cursor = isc.Canvas.POINTER;
            }
            extraCSSText = "cursor:" + cursor;
        }

        var imgConfig = {
            src:field.cellIcon || field.icon,
            width:field.iconWidth || field.iconSize || grid.imageSize,
            height:field.iconHeight || field.iconSize || grid.imageSize
        };
        if (extraCSSText) imgConfig.extraCSSText = extraCSSText;
        field._iconHTML = isc.Canvas.imgHTML(imgConfig);
        return field._iconHTML;
    },

    // CSS styles
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.fastCellUpdates (Boolean: true : I)
    // @include gridRenderer.fastCellUpdates
    // @group performance
    //<
    // explicitly set fastCellUpdates at the LG level
    // this will be passed through to our body and allows us to check
    // this.fastCellUpdates directly rather than looking at the attribute on the body
    
    fastCellUpdates:isc.Browser.isIE && !isc.Browser.isIE9,

    //> @method listGrid.setFastCellUpdates()
    // @include gridRenderer.setFastCellUpdates()
    // @visibility external
    //<
    // explicit implementation keeps this.fastCellUpdates in sync with the version in the
    // body so we can check it directly in this.getBaseStyle
    setFastCellUpdates : function (fcu) {
        if (this.body != null) {
            this.body.setFastCellUpdates(fcu);
            // if the body refused to set to the specified
            // value, respect that.
            fcu = this.body.fastCellUpdates;
        }
        if (this.frozenBody != null) {
            this.frozenBody.setFastCellUpdates(fcu);
        }
        this.fastCellUpdates = fcu;
    },

    //> @attr listGrid.baseStyle (CSSStyleName : null : [IR])
    // +link{gridRenderer.baseStyle,base cell style} for this listGrid.
    // If this property is unset, base style may be derived from +link{listGrid.normalBaseStyle}
    // or +link{listGrid.tallBaseStyle} as described in
    // +link{listGrid.getBaseStyle()}.
    // <P>
    // See +link{group:cellStyleSuffixes} for details on how stateful suffixes are combined
    // with the base style to generate stateful cell styles.
    //
    // @visibility external
    // @group appearance
    //<

    //> @attr listGrid.normalBaseStyle (CSSStyleName : "cell" : [IR])
    // "Normal" baseStyle for this listGrid. Only applies if +link{listGrid.baseStyle} is
    // set to null.
    // <P>
    // If <code>baseStyle</code> is unset, this
    // property will be used as a base cell style if the grid is showing fixed height rows, and
    // the specified cellHeight matches +link{listGrid.normalCellHeight} (and in Internet Explorer,
    // +link{listGrid.fastCellUpdates} is false). Otherwise +link{listGrid.tallBaseStyle} will
    // be used.
    // <P>
    // Having separate styles defined for fixed vs. variable height rows allows the developer
    // to specify css which is designed to render at a specific height (typically using
    // background images, which won't scale), without breaking support for styling rows
    // of variable height.
    // <P>
    // See +link{group:cellStyleSuffixes} for details on how stateful suffixes are combined
    // with the base style to generate stateful cell styles.
    //
    // @see listGrid.getBaseStyle()
    // @visibility external
    //<
    normalBaseStyle:"cell",

    //> @attr listGrid.tallBaseStyle (CSSStyleName : "cell" : [IR])
    // "Tall" baseStyle for this listGrid. Only applies if +link{listGrid.baseStyle} is
    // set to null.
    // <P>
    // If <code>baseStyle</code> is unset, this
    // property will be used as a base cell style unless the grid is showing fixed height
    // rows with a specified cellHeight that matches +link{listGrid.normalCellHeight}, in
    // which case +link{listGrid.normalBaseStyle} will be used. Note that in Internet Explorer
    // if +link{listGrid.fastCellUpdates} is true, <code>tallBaseStyle</code> will also be
    // used even if the cellHeight matches the specified <code>normalCellHeight</code> for the
    // grid.
    // <P>
    // See +link{group:cellStyleSuffixes} for details on how stateful suffixes are combined
    // with the base style to generate stateful cell styles.
    //
    // @see listGrid.getBaseStyle()
    // @visibility external
    //<
    tallBaseStyle:"cell",

    
    

    //> @attr listGrid.editFailedBaseStyle (CSSStyleName : null : [IRWA])
    //  A base name for the CSS class applied to cells when editing has failed.<br>
    //  If this listGrid is editable, this style will be applied to any edited cells for which
    //  validation failed.<br>
    //  As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected",
    //  or "Disabled" appended to it according to the state of the cell.<br>
    // If null, cells for which editing has failed will be rendered using the normal base style
    // classNames, but with custom CSSText applied as derived from <code>this.editFailedCSSText</code>
    // @visibility external
    // @group   appearance
    // @see baseStyle
    // @see editFailedCSSText
    //<
    editFailedBaseStyle:null,   //"cellEditFailed",

    //> @attr listGrid.editFailedCSSText (String : "color:red;border:1px solid red;" : [IRWA])
    //  Custom CSS text to be applied to cells when editing has failed.<br>
    //  If this listGrid is editable, this css text will be applied to any edited cells for which
    //  validation failed, on top of the base style for the cell.<br>
    // For further customization of styling for cells that failed editing validation, use
    // <code>this.editFailedBaseStyle</code> instead.
    // @visibility external
    // @group   appearance
    // @see editFailedBaseStyle
    //<
    editFailedCSSText:"color:red;border:1px solid red;",

    //> @attr listGrid.editPendingBaseStyle (CSSStyleName : null : [IRA])
    // A base name for the CSS class applied to cells containing pending (unsaved) edits<br>
    // As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected",
    // or "Disabled" appended to it according to the state of the cell.
    // <P>
    // If this property is null (the default setting), cells with pending edits will pick up
    // custom css text to be applied on top of the normal base style from
    // <code>this.editPendingCSSText</code>.
    //
    // @group appearance
    // @see baseStyle
    // @visibility external
    //<
    editPendingBaseStyle:null, //"cellEditPending",

    //> @attr listGrid.editPendingCSSText (String : "color:#0066CC;" : [IRWA])
    // Custom CSS text to be applied to cells with pending edits that have not yet been
    // submitted.<br>
    // For further customization of styling for cells with pending edits use
    // <code>this.editPendingBaseStyle</code> instead.
    // @group appearance
    // @see editFailedBaseStyle
    // @visibility external
    //<
    editPendingCSSText:"color:#0066CC;",

    //> @attr listGrid.recordCustomStyleProperty (String : "customStyle" : IRW)
    // @include GridRenderer.recordCustomStyleProperty
    // @visibility external
    // @see listGrid.getCellStyle()
    // @see listGrid.recordBaseStyleProperty
    //<
    recordCustomStyleProperty:"customStyle",

    //> @attr listGrid.recordBaseStyleProperty (String : "_baseStyle" : [IRWA])
    // This attribute allows custom base styles to be displayed on a per-record basis.
    // To specify a custom base-style for some record set
    // <code>record[listGrid.recordBaseStyleProperty]</code> to the desired base style name -
    // for example if <code>recordBaseStyleProperty</code> is <code>"_baseStyle"</code>, set
    // <code>record._baseStyle</code> to the custom base style name.
    //
    // @visibility external
    // @group appearance
    // @see listGrid.baseStyle
    //<
    recordBaseStyleProperty:"_baseStyle",

    //> @attr listGrid.frozenBaseStyle (String : null : [IRW])
    // If this listGrid contains any frozen fields, this property can be used to apply a custom
    // baseStyle to all cells in those frozen fields. If unset, the standard base style will be
    // used for both frozen and unfrozen cells.
    // @visibility external
    // @group appearance, frozenFields
    // @see listGrid.baseStyle
    // @see listGridField.frozen
    //<

    //> @attr listGrid.shrinkForFreeze (Boolean : false : IRWA)
    // If this list grid is showing any +link{listGridField.frozen,frozen} fields, and a horizontal
    // scrollbar is visible at the bottom of the liquid columns, should an equivalent scrollbar gap
    // be left visible below the frozen columns?<br>
    // Note that if set to <code>true</code> any backgroundColor or border applied to the ListGrid
    // will show up below the bottom row of the frozen column(s).
    // @group frozenFields
    // @visibility external
    //<
    shrinkForFreeze:false,

    //> @attr listGrid.alternateRecordStyles (Boolean : false : [IRW])
    // @include gridRenderer.alternateRowStyles
    // @group cellStyling
    // @example gridCells
    //<
    //alternateRecordStyles:false,
   
    //> @attr listGrid.alternateRecordSuffix (String : "Dark" : [IRW])
    // @include gridRenderer.alternateRowSuffix
    // @group cellStyling
    // @example gridCells
    //<
    alternateRecordSuffix:"Dark",
   
    //> @attr listGrid.alternateRecordFrequency (number : 1 : [IRW])
    // @include gridRenderer.alternateRowFrequency
    // @group cellStyling
    //<
    alternateRecordFrequency:1,   

    //> @attr listGrid.alternateFieldStyles (boolean : false : [IRW])
    // @include gridRenderer.alternateColumnStyles
    // @visibility external
    // @group cellStyling
    //<
    //alternateFieldStyles:false,

    //> @attr listGrid.alternateFieldSuffix (String : "AltCol" : [IRW])
    // @include gridRenderer.alternateColumnSuffix
    // @group cellStyling
    //<
    alternateFieldSuffix:"AltCol",

    //> @attr listGrid.alternateFieldFrequency (number : 1 : [IRW])
    // @include gridRenderer.alternateColumnFrequency
    // @visibility external
    // @group cellStyling
    //<
    alternateFieldFrequency:1,

    //> @attr listGrid.alternateBodyStyleName (CSSStyleName : null : [IRWA])
    // Optional css style to apply to the body if +link{listGrid.alternateRecordStyles} is true
    // for this grid. If unset +link{listGrid.bodyStyleName} will be used to style the body
    // regardless of the +link{listGrid.alternateRecordStyles,alternateRecordStyles} setting.
    // @visibility external
    //<

    // property you can set per-record to add custom CSSText
    recordCSSTextProperty : "cssText",

    //> @attr listGrid.includeHilitesInSummaryFields
    // @include dataBoundComponent.includeHilitesInSummaryFields
    // @visibility external
    //<

    //> @method listGrid.shouldIncludeHiliteInSummaryField()
    // @include dataBoundComponent.shouldIncludeHiliteInSummaryField
    // @visibility external
    //<

    //> @attr listGrid.showHiliteInCells (boolean : false : IRWA)
    // When cell styling is being updated (updateCellStyle()), should the HTML content of the
    // cell also be updated?  If false, only the cell's CSS styling will be updated.
    //
    // You should turn this on if you've implemented 
    // +link{listGrid.formatCellValue(),formatting} that adds styling cues to a cell
    // (like an inline image), which need be updated as the cell switches states.
    // (eg, if you would use different HTML for a selected cell's contents).
    //      @group  hiliting, drawing
    //<
    //showHiliteInCells:false,

    //> @attr listGrid.showHilitesInGroupSummary (boolean : true : IRW)
    // Determines whether hiliting for any field in this grid is shown in a group summary.
    // This setting affects all fields of the grid.
    // <P>
    // To suppress hilites for a specific field see +link{listGridField.showHilitesInGroupSummary}.
    // <P>
    // Hiliting in summary fields (columns) can be enabled by setting
    // +link{listGrid.includeHilitesInSummaryFields,includeHiliteInSummaryField} to true.
    //
    // @visibility external
    //<
    showHilitesInGroupSummary:true,

    //> @attr listGrid.hiliteCanReplaceValue (boolean : null : IR)
    // If set, end users can create advanced hiliting rules that will use the
    // +link{hilite.replacementValue} feature to cause values in hilited cells
    // to be replaced with a user-entered value.  For example, a user could create a hilite rule
    // that replaces numeric values ranging from 0.5 to 1.0 with the text "LOW".
    // <p>
    // Specifically, when the "Add Advanced Rule" button is pressed and
    // <code>hiliteCanReplaceValue</code> is true, the user will see a text entry field titled
    // "Replace value with" (+link{hiliteReplaceValueFieldTitle}) and if they enter a value, that
    // value will appear in the grid cell in lieu of the cell's original value.
    //
    // @group hiliting
    // @visibility external
    //<

    //> @attr listGrid.hiliteReplaceValueFieldTitle (String : "Replace value with" : IR)
    // Title used for the text box shown when +link{listGrid.hiliteCanReplaceValue} is set.
    // @group i18nMessages
    // @visibility external
    //<
    hiliteReplaceValueFieldTitle : "Replace value with",
    
    //> @attr listGrid.hiliteHTMLAfterFormat (boolean : true : IR)
    // If set to true, custom HTML applied as part of hiliting will be applied after
    // +link{listGrid.formatCellValue(),formatting} for each cell. If false, hilite
    // HTML will be applied before formatting.
    // <P>
    // This applies to the following hilite properties:
    // <ul>
    // <li>+link{Hilite.replacementValue}</li>
    // <li>+link{Hilite.htmlBefore}</li>
    // <li>+link{Hilite.htmlAfter}</li>
    // <li>+link{Hilite.htmlValue}</li>
    // </ul>
    // <P>
    // May be overridden per field via +link{listGridField.hiliteHTMLAfterFormat}
    //
    // @visibility external
    //<
    // Also the undocumented
    // <li>+link{Hilite.htmlOpposite}</li>
    hiliteHTMLAfterFormat:true,

    //> @attr listGridField.hiliteHTMLAfterFormat (Boolean : null : IR)
    // If set to true, custom HTML applied as part of hiliting will be applied after
    // +link{listGrid.formatCellValue(),formatting} for each cell in this column. If false, hilite
    // HTML will be applied before formatting.
    // <P>
    // This attribute overrides +link{listGrid.hiliteHTMLAfterFormat} as defined at the
    // component level.
    //
    // @visibility external
    //<

    //> @attr listGrid.showSelectedStyle (Boolean : true : IRW )
    // @include gridRenderer.showSelectedStyle
    //<
    showSelectedStyle : true,

    // Keyboard handling
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.generateClickOnSpace (Boolean : true : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits space,
    // the cell will respond to a click event.
    // @visibility external
    //<
    generateClickOnSpace : true,

    //> @attr listGrid.generateClickOnEnter (Boolean : false : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits Enter,
    // the cell will respond to a click event.
    // @visibility external
    //<
    //generateClickOnEnter : false,

    //> @attr listGrid.generateDoubleClickOnSpace (Boolean : false : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits Space,
    // the cell will respond to a double click event.
    // @visibility external
    //<
    // generateDoubleClickOnSpace : false,

    //> @attr listGrid.generateDoubleClickOnEnter (Boolean : true : IRWA)
    // If true, when the user navigates to a cell using arrow keys and hits Enter,
    // the cell will respond to a double click event.
    // @visibility external
    //<
    generateDoubleClickOnEnter : true,

    //> @attr listGrid.arrowKeyAction (String : null : IRWA)
    // Action to perform when the listGrid has keyboard focus (but not editing focus) and a user
    // presses the arrow keys to navigate around the grid.
    // <P>
    // If +link{canSelectCells} is true, navigation occurs by cell - the user can move
    // to a new cell in any direction.<br>
    // If +link{canSelectCells} is false, navigation typically occurs by row - the user can
    // move up or down throw the rows in the grid.
    // <P>
    // For actions that fire events (click or doubleClick), both cell and record level events are
    // fired (for example for arrowKeyAction <code>"activate"</code>, +link{cellDoubleClick()}
    // and +link{recordDoubleClick()} are fired for the new position.<br>
    // Note that if +link{canSelectCells} is false, the events will be fired as if a click or
    // double click had occurred on the first cell where
    // +link{listGridField.ignoreKeyboardClicks} is not true.
    // <P>
    // Possible actions are:
    // <ul>
    // <li><code>"select"</code> : select the next row or cell in the grid and call 
    //     click handlers.</li>
    // <li><code>"selectOnly"</code> : select the next row or cell in the grid without firing 
    //      click handlers.</li>
    // <li><code>"focus"</code> : move focus to the next row or cell in the grid without 
    //     changing the selection or calling click handlers.</li>
    // <li><code>"activate"</code> : select and activate the next row or cell in the list (calls
    //  <code>recordDoubleClick</code> handler)</li>
    // <li><code>"none"</code> : no action</li>
    // <li> <code>null</code> : if +link{listGrid.selectionAppearance} is "checkbox", behaves as if set
    //  to "focus"; otherwise, behaves as if set to "select"</li>
    // </ul>
    // <P>
    // Note: If this grid is editable, behavior while editing is governed by the result of 
    // +link{listGrid.getArrowKeyEditAction()}.
    // <P>
    // See also +link{listGrid.generateClickOnEnter}, +link{listGrid.generateClickOnSpace},
    // +link{listGrid.generateDoubleClickOnEnter} and +link{listGrid.generateDoubleClickOnSpace}
    //
    // @group events
    // @visibility external
    //<
    arrowKeyAction: null,

    //> @attr ListGrid.hiliteRowOnFocus (Boolean : null : IRW)
    // When the grid body gets keyboard focus, should we highlight the current focus row,
    // using the rollover cell style?
    // <P>
    // This property may be explicitly set to control this behavior independently of
    // +link{showRollOver}.
    // Otherwise (if this property is null), we will show the roll-over styling for the
    // keyboard focus row if +link{showRollOver} is true.
    // @visibility external
    //<
    
//    hiliteRowOnFocus:null,

    //> @attr listGrid.showRecordComponents (boolean : null : IRW)
    // When enabled, +link{createRecordComponent()} will be called when saved rows are being
    // rendered, and any returned component will be displayed embedded within the row or cell.
    // <P>
    // recordComponents are not created for newly added rows which have not yet been saved.  
    // See the +link{group:unsavedRecords, Handling Unsaved Records overview} for more
    // information.
    // <P>
    // Depending on the +link{showRecordComponentsByCell} setting,
    // <code>createRecordComponent()</code> will be called either once per row, or once for
    // every cell.
    // <P>
    // Depending on +link{recordComponentPosition}, components can either be placed underneath
    // normal record or cell content ("expand" setting) or placed so that they overlap normal
    // cell content ("within" setting).  For the "within" setting, the default is to fill the
    // row or cell, but the component can specify percent size or even use
    // +link{canvas.snapTo,snapTo-positioning} to place itself within the row or cell.
    // <p>
    // The "expand" setting is incompatible with +link{canFreezeFields,frozen columns}
    // <i>unless</i> all <code>recordComponents</code> are the same height and they are present
    // in every row, in which case the fixed height of all <code>recordComponents</code> can be
    // set via +link{recordComponentHeight} to re-enable frozen fields.
    // <p>
    // Using <code>recordComponents</code> potentially means creating one component for every
    // visible grid row or cell and so can impact performance.  Before using this subsystem:
    // <ul>
    // <li> consider using +link{listGridField.valueIcons} (possibly with a specified 
    //      +link{listGridField.valueIconClick()} handler) for icons based on field values
    //      which may be displayed alone in the cell or alongside standard content
    //      (see +link{listGridField.showValueIconOnly});
    // <li> for clickable icons representing actions that can be taken on a record, also 
    //      consider using +link{type:ListGridFieldType,a field of type "icon"}, or 
    //      multiple such fields
    // <li> for controls that only need to appear on rollover, consider
    //      +link{showRollOverCanvas,rollOver controls}
    // <li> if you are trying to customize the editor for a field, you can provide a custom
    //      control via +link{listGridField.editorType}, and +link{formItem.icons} are a common
    //      way to add clickable buttons.  You can also
    //      +link{getEditorType,provide different controls per record}.  These options are
    //      usually better that using <code>recordComponents</code> as custom editors, since
    //      you won't have to manage issues like making the <code>recordComponent</code> appear
    //      only when editing, having changes affect +link{group:editing,editValues},
    //      triggering saves and handling validation errors, etc.
    // </ul>
    // <P>
    // See +link{recordComponentPoolingMode} for an overview of how best to optimize use of
    // <code>recordComponents</code> for different data sets.
    // <p>
    // Regardless of the pooling mode, you can explicitly refresh record components via
    // +link{listGrid.invalidateRecordComponents()} and
    // +link{listGrid.refreshRecordComponent()}.
    // <P>
    // <i>Interaction with +link{listGrid.autoFitFieldWidths,column auto-fit}</i>: per-cell record
    // components are not taken into account when determining the size for column auto fit.
    // The default +link{listGrid.getDefaultFieldWidth()} implementation looks at cell content
    // only. We typically recommend that, for fields showing record-components, 
    // +link{listGridField.autoFitWidth} and +link{listGridField.canAutoFitWidth} be disabled, or if 
    // the record components are of a predictable size, a +link{listGridField.defaultWidth}
    // be specified.<br>
    // This is particularly pertinent where +link{listGrid.recordComponentPosition}
    // is set to "within", in which case cells' content is often empty or completely covered
    // by record-components.
    //
    // @see recordComponentPosition
    // @see showRecordComponentsByCell
    // @see recordComponentPoolingMode
    // @see showRecordComponent()
    // @see createRecordComponent()
    // @see updateRecordComponent()
    //
    // @group recordComponents
    // @visibility external
    //<

    //> @type EmbeddedPosition
    // How a component should be embedded within its record or cell
    // @value "expand" component should be placed underneath normal record or cell content,
    //        expanding the records.  Expanding records can result in variable height rows,
    //        in which case +link{listGrid.virtualScrolling,virtualScrolling} should be
    //        enabled.
    // @value "within" component should be placed within the normal area of the record or cell.
    //        Percentage sizes will be treated as percentages of the record and
    //        +link{Canvas.snapTo} positioning settings are also allowed and refer to the
    //        rectangle of the record or cell. Note that for components embedded within cells,
    //        cell align and vAlign will be used if snapTo is unset (so top / left alignment
    //        of cell content will map to snapTo of "TL", etc).
    // @visibility external
    //<

    //> @attr listGrid.recordComponentPosition (EmbeddedPosition : null : IRW)
    // if +link{listGrid.showRecordComponents} is true, how should the component appear within
    // the cell. Valid options are
    // <ul><li><code>"within"</code>: the component will be rendered inside the record / cell.
    //  +link{canvas.snapTo} may be set to specify where the component should render within
    //  the row or cell, and +link{canvas.snapOffsetTop} / +link{canvas.snapOffsetLeft} may
    //  be set to indent recordComponents within their parent cells.
    //  Note that if unset, the component will show up at the top/left edge
    //  for components embedded within an entire row, or for per-cell components, cell
    //  align and valign will be respected.  Note also that, when rendering components "within"
    //  cells, specified component heights will be respected and will change the height of the
    //  row.  However, if you want components to completely fill a cell at it's default height,
    //  set height: "100%" or rows will render at the default height of the component. </li>
    // <li><code>"expand"</code>: the component will be written into the cell below the
    //  normal cell content, causing the cell to expand vertically to accommodate it.
    // <li><code>null</code>: If this attribute is unset, we will default to showing
    //  recordComponents with position <code>"within"</code> if
    //  +link{showRecordComponentsByCell} is true, otherwise using <code>"expand"</code>
    //  logic.
    // </ul>
    // @see showRecordComponents
    // @group recordComponents
    // @visibility external
    //<
    
//    recordComponentPosition:"expand",


    //> @attr listGrid.showRecordComponentsByCell (boolean : null : IRWA)
    // If true, shows +link{listGrid.showRecordComponents, recordComponents} in cells, rather
    // than just in records.
    // @group recordComponents
    // @visibility external
    //<

    //> @type RecordComponentPoolingMode
    // The method of component-pooling to employ for +link{listGrid.showRecordComponents,recordComponents}.
    // <P>
    // @value "viewport" components are destroyed when the record is not being rendered.  Best
    //        for large datasets where embedded components differ greatly per record.
    // @value "data" components are +link{canvas.clear,clear()ed} when not in the viewport, but
    //        stay with a record until the record is dropped from cache.  Best for guaranteed
    //        small datasets.
    // @value "recycle" components are pooled and will be passed to
    //       +link{listGrid.updateRecordComponent,updateRecordComponent()} with the
    //       <code>recordChanged</code> parameter set to true.  Best for large datasets where
    //       embedded components are uniform across different records and can be efficiently
    //       reconfigured to work with a new record
    // @visibility external
    //<

    //> @attr listGrid.recordComponentPoolingMode (RecordComponentPoolingMode : "viewport" : IRWA)
    // The method of +link{type:RecordComponentPoolingMode, component-pooling} to employ for
    // +link{showRecordComponents,recordComponents}.
    // <P>
    // The default mode is "viewport", which means that recordComponents are destroyed as soon
    // their record is no longer being rendered (scrolled out of the viewport, eliminated by
    // search criteria, etc).
    // <P>
    // For a large or dynamic data set where the components shown on different rows are
    // similar, switch to "recycle" mode, which pools recordComponents by detaching them from
    // records that are not visible and re-using them in other records.  In this mode, you
    // should implement +link{updateRecordComponent()} to apply any changes to make reused
    // components applicable to the new record they appear in, if necessary.  For example, if
    // you have several controls in your <code>recordComponents</code>, and not all of the
    // controls apply to every record, your <code>updateRecordComponent()</code> implementation
    // could simply hide or disable inapplicable controls, and this would be much faster than
    // creating a whole new set of controls every time a given record is scrolled into view.
    // <p>
    // If you are using +link{showRecordComponentsByCell,per-cell recordComponents}, and you
    // have components of different types in different columns and still want to take
    // advantage of component recycling, you can set +link{listGrid.poolComponentsPerColumn} to
    // ensure that components intended for one column are not recycled for use in another
    // column that should have a different component.
    // <P>
    // Note that, if different records have distinctly different components embedded
    // in them, or multiple columns in each record embed different components, you should
    // leave the recordComponentPoolingMode at "viewport" if your dataset is very large or
    // use "data" otherwise.
    // @group recordComponents
    // @visibility external
    //<
    recordComponentPoolingMode:"viewport",

    //> @attr listGrid.poolComponentsPerColumn (Boolean : true : IRW)
    // Should recycled +link{listGrid.showRecordComponents,record components}, be pooled
    // per column or per record. Only applies if +link{listGrid.showRecordComponentsByCell} is true.
    // <P>
    // When +link{listGrid.recordComponentPoolingMode} is "recycle" and you have components of
    // different types in different columns, set this property to true to ensure that
    // components intended for one column are not recycled for use in another column that
    // should have a different component.
    // <P>
    // If no components applicable to a particular column are available in the pool, the system
    // calls +link{listGrid.createRecordComponent, createRecordComponent}.
    //
    // @group recordComponents
    // @visibility external
    //<
    
    poolComponentsPerColumn:true,

	// Rollover
	// --------------------------------------------------------------------------------------------
    //>	@attr listGrid.showRollOver (Boolean : true : IRW)
    // Should we show different styling for the cell the mouse is over?
    // <p>
    // If true, the cell style will have the suffix "Over" appended.
    // <p>
    // Can be overridden on a per-record basis via +link{listGridRecord.showRollOver}.
    //
    // @group appearance
    // @visibility external
    //<
    // showRollOver: null, // !isc.Browser.isTouch

    //> @attr listGrid.recordShowRollOverProperty (String : "showRollOver" : IR)
    // Name of the property that can be set on a per-record basis to disabled rollover for an
    // individual record when +link{listGrid.showRollOver} is true.
    //
    // @group appearance
    // @visibility external
    //<
    recordShowRollOverProperty:"showRollOver",

    //> @attr listGridRecord.showRollOver (Boolean : null : IR)
    // Set to false to disable rollover for this individual record when +link{listGrid.showRollOver}
    // is true.
    // <p>
    // Note this property can be renamed to prevent collision with data members - see
    // +link{listGrid.recordShowRollOverProperty}.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridRecord.embeddedComponent (Canvas : null : IR)
    // A component that should be rendered on top of this record, similar to a
    // +link{listGrid.showRecordComponents,record component} but statically defined on the record.
    // <p>
    // The embedded component will default to covering all fields of the record, but specific fields
    // can be specified via +link{embeddedComponentFields}.
    // <p>
    // By default, the embeddedComponent will fill the entire vertical and horizontal space of the
    // record (or of the specified fields).  +link{embeddedComponentPosition} can be set to control
    // exact sizing behavior.
    // <smartclient>
    // <p>
    // When creating a component to use as an embedded component the component will most likely
    // end up drawing before the record it is due to be embedded within, therefore it is recommended
    // to set +link{canvas.autoDraw,autoDraw} to false on the embedded component.
    // </smartclient>
    // <p>
    // When a record with an <code>embeddedComponent</code> is eliminated from view by filtering or
    // because it is not currently rendered due to +link{listGrid.showAllRecords,incremental rendering}, the
    // ListGrid may +link{canvas.hide()} or +link{canvas.clear()} it.
    // <p>
    // If the current dataset is completely replaced (by a call to +link{listGrid.setData()} or
    // +link{listGrid.setDataSource()}, for example), any embedded component is
    // +link{canvas.deparent(),deparented} (which implies being +link{canvas.clear(),clear()ed}).
    // <p>
    // When a ListGrid is +link{canvas.destroy(),destroyed}, it will destroy() all embedded components
    // regardless of whether they are currently visible.  Use a call to +link{listGrid.setData()} immediately
    // before destroying the ListGrid to avoid this effect when unwanted.
    // <p>
    // For more advanced control over the lifecycle of components displayed over records, including
    // deferred creation and pooling, use the +link{listGrid.showRecordComponents,record components}
    // subsystem.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridRecord.embeddedComponentPosition (EmbeddedPosition : null : IR)
    // Sizing policy applied to the embedded component.  Default behavior if unspecified is the same
    // as +link{EmbeddedPosition} "within" (fill space allocated to the record, including the ability
    // use percentage sizing and snapTo offset).  Use "expand" to have the record expand to accommodate
    // the embedded components' specified sizes instead.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGridRecord.embeddedComponentFields (Array of String : null : IR)
    // Fields where the +link{embeddedComponent} will be displayed, if specified.
    // <p>
    // Regardless of the order of fields specified, the component will appear from whichever field is
    // earlier in the current visible order to whichever field is later, inclusive of the specified
    // fields.
    // <p>
    // To have the component appear in just one field, either specify a single-element Array or
    // specific a two element Array with both fields the same.
    // <p>
    // If either field is hidden or invalid (no such field), the component will occupy only a single
    // field.  If both fields are hidden, the component will be hidden until one or more of the fields
    // are shown.
    //
    // @group appearance
    // @visibility external
    //<

    //> @attr listGrid.useCellRollOvers (Boolean : null : IRW)
    // Are rollovers cell-level or row-level?
    // @visibility external
    //<

    //> @attr listGrid.showRollOverCanvas (Boolean : null : IRWA)
    // When enabled, when the mouse moves over a row or cell (depending on
    // +link{useCellRollOvers}), an arbitrary Canvas can be shown layered on top of the row or
    // cell (the +link{listGrid.rollOverCanvas}), layered underneath the row or cell (the
    // +link{listGrid.rollUnderCanvas}), or both. 
    // <P>
    // This can be used to dynamically show controls or informational displays only on
    // rollover.  For example, controls to delete a row might appear only on rollover so they
    // do not clutter the static display, or a "rollUnder" Canvas could be used to display
    // additional information that can appear behind normal cell values (like displaying
    // percent complete via as a bar of color that appears behind text values).
    // <p>
    // +link{canvas.snapTo,snapTo positioning} can be used to place the
    // rollOver/rollUnderCanvas.  With <code>useCellRollOvers</code>, positioning is relative
    // to the cell, for row-level rollOver, position is relative to the portion of the
    // row that is scrolled into view (this implies a row-level rollOver/UnderCanvas can never
    // be placed horizontally scrolled out of view, but this is possible for a cell-level
    // rollOver).  
    // <p>
    // <code>snapTo</code> positioning makes it easy to do something like place a button at the
    // right edge of the grid, next to the scrollbar: just set snapTo:"R" on the
    // <code>rollOverCanvas</code>.
    // <p>
    // The rollOver/rollUnder Canvas can be a single static component (the same for all
    // cells/rows) configured via the +link{AutoChild} system, or can instead be provided
    // dynamically by implementing +link{getRollOverCanvas()} and/or +link{getRollUnderCanvas()}.
    // <p>
    // The rollOver/rollUnder canvas will be automatically added to the grid's
    // +link{listGrid.body,body} as an 
    // +link{listGrid.addEmbeddedComponent(),embedded component}.<br>
    // For grids with +link{listGridField.frozen,frozen fields}, the behavior is as follows:
    // <ul><li>If +link{useCellRollOvers} is false (the default), embedded components
    //   will be added to both the body and the frozen body</li>
    // <li>Otherwise the component will be added to whichever body contains the cell the
    //   user is currently over</li></ul>
    // The rollOver/rollUnder canvas added to the frozen body will be created by calling
    // the +link{getFrozenRollOverCanvas()} or +link{getFrozenRollUnderCanvas()} methods.
    // The default implementation for these methods matches their equivalents for non-frozen
    // rollOver / rollUnder canvases - it will use the autoChild subsystem to create a
    // canvas from the +link{rollOverCanvas} autoChild configuration.
    // <p>
    // <code>showRollOverCanvas</code> has no effect if +link{showRollOver} is <code>false</code>.
    // <P>
    // See also +link{listGrid.showSelectedRollOverCanvas}.
    //
    // @example gridRollOverReticleEffect
    // @example rolloverControls
    // @group rowEffects
    // @see ListGrid.showRollUnderCanvas
    // @visibility external
    //<
    //showRollOverCanvas:null,

    //> @attr listGrid.rollOverCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showRollOver,showRollOver}
    // is <code>true</code> and +link{ListGrid.showRollOverCanvas,showRollOverCanvas} is
    // <code>true</code> or for selected records, if
    // +link{listGrid.showSelectedRollOverCanvas,showSelectedRollOverCanvas} 
    // is true. This component will be created and displayed above the current rollOver
    // row or cell.
    // <P>
    // Note that if this grid has frozen fields, the +link{AutoChild} subsystem will use the 
    // <code>rollOverCanvas</code> configuration settings to create the +link{frozenRollOverCanvas}
    // (displayed in the frozen listGrid body).
    // <p>
    // The <code>rollOverCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the current roll over record object in the grid
    // @example gridRollOverReticleEffect
    // @example rolloverControls
    // @group rowEffects
    // @see ListGrid.frozenRollOverCanvas
    // @see ListGrid.rollUnderCanvas
    // @visibility external
    //<
    
    //> @attr listGrid.frozenRollOverCanvas (Canvas : null : RA)
    // Automatically generated canvas embedded in the grid's frozen body if 
    // +link{ListGrid.showRollOver,showRollOver}
    // is <code>true</code> and +link{ListGrid.showRollOverCanvas,showRollOverCanvas} is
    // <code>true</code> or for selected records, if
    // +link{listGrid.showSelectedRollOverCanvas,showSelectedRollOverCanvas} 
    // is true. This component will be created and displayed above the current rollOver
    // row or cell in the frozen body.
    // <P>
    // The frozenRollOverCanvas will be created using the +link{AutoChild} subsystem, and
    // will derive its configuration from the +link{rollOverCanvas}
    // autoChild properties (<code>"rollOverCanvasProperties"</code>, et al).
    // <p>
    // The <code>frozenRollOverCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the current roll over record object in the grid
    //
    // @group rowEffects
    // @see ListGrid.rollOverCanvas
    // @see ListGrid.frozenRollUnderCanvas
    // @visibility external
    //<
    
    //> @attr listGrid.showRollUnderCanvas (Boolean : null : IRWA)
    // If roll overs are enabled, should the +link{ListGrid.rollUnderCanvas,rollUnderCanvas}
    // be displayed?
    // <p>
    // Use of the <code>showRollUnderCanvas</code> is enabled if +link{ListGrid.showRollOver,showRollOver}
    // is <code>true</code>, and either +link{ListGrid.showRollOverCanvas,showRollOverCanvas}
    // is <code>true</code> and <code>showRollUnderCanvas</code> is unset, or <code>showRollUnderCanvas</code>
    // is explicitly set to <code>true</code>.
    // <P>
    // See also +link{listGrid.showSelectedRollUnderCanvas}.
    //
    // @example gridAnimatedSelection
    // @see ListGrid.showRollOverCanvas
    // @visibility external
    //<
    //showRollUnderCanvas:null,

    //> @attr listGrid.rollUnderCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showRollOver,showRollOver}
    // is <code>true</code>, and either +link{ListGrid.showRollOverCanvas,showRollOverCanvas}
    // is <code>true</code> and +link{ListGrid.showRollUnderCanvas,showRollUnderCanvas} is
    // unset, or <code>showRollUnderCanvas</code> is explicitly set to <code>true</code>.
    // This component will be created and displayed behind the current rollOver row or cell in the
    // page's z-order, meaning that it will only be visible if the cell styling is transparent.
    // <P>
    // Note that if this grid has frozen fields, the +link{AutoChild} subsystem will use the 
    // <code>rollUnderCanvas</code> configuration settings to create the +link{frozenRollUnderCanvas}
    // (displayed in the frozen listGrid body).
    // <p>
    // The <code>rollUnderCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the current roll over record object in the grid
    // @example gridAnimatedSelection
    // @group rowEffects
    // @visibility external
    //<
    
    //> @attr listGrid.frozenRollUnderCanvas (Canvas : null : RA)
    // Automatically generated canvas embedded in the grid's frozen body as a 
    // +link{listgrid.rollUnderCanvas,roll under canvas}.
    // This component will be created and displayed above the current rollOver
    // row or cell in the frozen body.
    // <P>
    // The frozenRollUnderCanvas will be created using the +link{AutoChild} subsystem, and
    // will derive its configuration from the +link{rollUnderCanvas}
    // autoChild properties (<code>"rollUnderCanvasProperties"</code>, et al).
    // <p>
    // The <code>frozenRollUnderCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the current roll over record object in the grid
    //
    // @group rowEffects
    // @see ListGrid.rollUnderCanvas
    // @see ListGrid.frozenRollOverCanvas
    // @visibility external
    //<    
    
    //> @attr listGrid.showSelectedRollOverCanvas (Boolean : false : IRWA)
    // This setting causes the +link{listGrid.rollOverCanvas,roll over canvas} to be
    // displayed when the user rolls over selected records in the grid (but not when
    // rolling over other records). This can be useful to display a "Selected Over"
    // appearance which can't be easily achieved via standard cell styling.
    // @group rowEffects
    // @visibility external
    //<

    //> @attr listGrid.showSelectedRollUnderCanvas (Boolean : false : IRWA)
    // This setting causes the +link{listGrid.rollUnderCanvas,roll under canvas} to be
    // displayed when the user rolls over selected records in the grid (but not when
    // rolling over other records). This can be useful to display a "Selected Over"
    // appearance which can't be easily achieved via standard cell styling.
    // <P>
    // As with +link{listGrid.showRollUnderCanvas}, if this property is unset, but
    // the related +link{listGrid.showSelectedRollOverCanvas} property is true, both the
    // the roll under and roll under canvases will be displayed as the user rolls 
    // over selected records.
    // @group rowEffects
    // @visibility external
    //<
    
    //> @attr listGrid.showRollOverInExpansion (Boolean : null : IRWA)
    // This setting causes the +link{listGrid.rollOverCanvas,roll over canvas} to be
    // sized to cover the normal row and the expansion layout. Otherwise the
    // rollOverCanvas is only shown for the un-expanded part of the row.
    // @group rowEffects
    // @visibility external
    //<

    // We enable showSelectedRollOverCanvas and showRollOverInExpansion in the Tahoe
    // skin to provide the "Selected over" focus glow
    // - a box shadow which extends beyond the edges of the rows - not easily 
    // achievable via CSS on the cells themselves.
    
    
    //> @attr listGrid.preserveFocusStylingOnMouseOut (Boolean : true : IRWA)
    // If +link{listGrid.showRollOver} or +link{listGrid.hiliteRowOnFocus} is true
    // the current keyboard focus row for navigation via arrow keys, etc, will
    // be hilighted with <code>"Over"</code> styling. This is particularly 
    // valuable to indicate which row has keyboard focus where there are multiple 
    // selected rows, or where the user is navigating without changing selection 
    // (see +link{listGrid.arrowKeyAction}).<br>
    // However, note that as the user interacts with the rows using the mouse, the rollover 
    // styling will be updated to reflect the mouse position if +link{showRollOver} is true.
    // <P>
    // When the user rolls the mouse off the grid, the default behavior is to re-style
    // the current focus row with <code>"Over"</code> styling if the grid has keyboard
    // focus. That way a user has a clear visual indication of where navigation 
    // would start. This may be disabled by setting <code>preserveFocusStylingOnMouseOut</code>
    // to false.
    //
    // @visibility external
    //<
    preserveFocusStylingOnMouseOut: true,

    //>Animation

    //> @attr listGrid.animateRollOver (Boolean : false : IRWA)
    // If the +link{ListGrid.rollOverCanvas,rollOverCanvas} is enabled, setting this property
    // to <code>true</code> ensures that when the <code>rollOverCanvas</code> is displayed it
    // is animated into view via +link{Canvas.animateShow()}. Note that the animation effect
    // may be customized via +link{Canvas.animateShowEffect}, +link{Canvas.animateShowTime} and
    // +link{Canvas.animateShowAcceleration} set in <code>rollOverCanvasProperties</code>.
    // @group rowEffects
    // @visibility external
    //<
    animateRollOver: false,

    //> @attr listGrid.animateRollUnder (Boolean : false : IRWA)
    // If the +link{ListGrid.rollUnderCanvas,rollUnderCanvas} is enabled, setting this property
    // to <code>true</code> ensures that when the <code>rollUnderCanvas</code> is displayed it
    // is animated into view via +link{Canvas.animateShow()}. Note that the animation effect
    // may be customized via +link{Canvas.animateShowEffect}, +link{Canvas.animateShowTime} and
    // +link{Canvas.animateShowAcceleration} set in <code>rollUnderCanvasProperties</code>.
    // @example gridAnimatedSelection
    // @group rowEffects
    // @visibility external
    //<
    animateRollUnder: false,

    //<Animation

    //> @attr listGrid.showBackgroundComponents (Boolean : false : IRW)
    // If <code>true</code> this grid will create and show per-row backgroundComponents
    // as detailed +link{listGrid.backgroundComponent,here}.
    // @visibility external
    //<

    //> @attr listGrid.backgroundComponent (MultiAutoChild Canvas : null : IR)
    // Has no effect unless +link{listGrid.showBackgroundComponents} is <code>true</code>.
    // <P>
    // Canvas created and embedded in the body behind a given record.   When
    // +link{listGridRecord.backgroundComponent} is set, this autoChild canvas
    // will be constructed (if listGridRecord.backgroundComponent is not already a Canvas) and
    // its properties combined with those of listGridRecord.backgroundComponent and then
    // displayed behind a specific record in the page's z-order, meaning
    // it will only be visible if the cell styling is transparent.
    // @group rowEffects
    // @visibility external
    //<
    backgroundComponentDefaults: {
        snapTo:"TL",
        autoDraw: false,
        opacity: "50%"
    },

    // Hover
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.canHover (boolean : null : [IRW])
    // @include gridRenderer.canHover
    // @group hovers
    // @see attr:listGrid.showHover
    // @see attr:listGridField.showHover
    // @example valueHoverTips
    //<
    // are hover events and hover popups enabled?
    //canHover:false,

    //> @attr listGrid.showHover (Boolean : true : [IRW])
    // If true, and +link{ListGrid.canHover, canHover} is also true, shows popup hover text 
    // next to the mouse when the user hovers over a cell.  The content of the hover is 
    // determined by +link{ListGrid.cellHoverHTML, cellHoverHTML()}.
    // <P>
    // This is the default setting for the grid and can be overridden on a 
    // +link{listGridField.showHover, per-field} basis.
    // @group hovers
    // @see ListGrid.canHover
    // @see ListGrid.cellHoverHTML()
    // @visibility external
    //<
    // if canHover:true, should we show hover popups?
    showHover: true,

    //> @attr listGrid.showClippedHeaderTitlesOnHover (boolean : true : [IRA])
    // If true and a header button's title is clipped, then a hover containing the full field
    // title is enabled.
    // @group hovers
    // @see ListGrid.headerTitleClipped()
    // @see ListGrid.headerHoverHTML()
    // @visibility external
    //<
    showClippedHeaderTitlesOnHover: true,

    //> @attr listGridField.showHover (boolean : null : IRW)
    // Whether to show hovers for this field.  The default hover will be the contents of the
    // cell the user is hovering over, and can be customized via
    // +link{listGridField.hoverHTML,field.hoverHTML()}.
    // <P>
    // +link{ListGrid.showHover} can be set to true to cause hovers to be shown for all fields
    // by default.  In this case, <code>field.showHover</code> can be set to false to suppress
    // hovers for an individual field.
    // <P>
    // All hovers can be disabled, regardless of other settings, by setting
    // +link{ListGrid.canHover} to false.
    // @visibility external
    // @example valueHoverTips
    //<

    //> @attr listGridField.showHoverComponents (Boolean : null : IRW)
    // When set to true and showHover is also true for the field, shows a widget hovering at 
    // the mouse point.
    // <P>
    // A number of builtin modes are provided - see +link{type:HoverMode}.
    // <P>
    // Also supported at the +link{listGrid.showHoverComponents, ListGrid-level}.
    // @group hoverComponents
    // @visibility external
    //<

    // can be set to false to cause hover to be per-row instead of per-cell
    //hoverByCell:true,

    // if canHover:true, should an active hover remain active until we leave the listGrid?
    // default behavior is to clear/deactivate the hover on each cellOut/rowOut
    //keepHoverActive:false,

    // the space between the borders of the cell and the hover, in pixels
    cellHoverOutset:5,

    // Note: hoverWidth, hoverStyle, et al will be picked up by the grid renderer when showing
    // cell hovers (handled by GridRenderer class)

    //> @attr listGrid.hoverStyle (CSSStyleName : "gridHover" : [IRWA])
    // Style to apply to hovers shown over this grid.
    // @see listGrid.showHover
    // @group hovers
    // @visibility external
    //<
    hoverStyle:"gridHover",

    //> @attr listGridField.prompt (HTMLString : null : IR)
    // Causes a tooltip hover to appear on the header generated for this field (effectively
    // sets +link{canvas.prompt} for the header).
    //
    // @visibility external
    //<

    //> @attr listGridField.editorHint (HTMLString : null : IRW)
    // Specifies "hint" string to show when the field is edited to indicate something to the
    // user.  For a field using a +link{TextItem} editor, the hint is shown within the field by
    // default.
    //
    // @visibility reify
    //<

    // Selection
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.selection (Selection | CellSelection : null : [RA])
    // @include listGrid.selectionManager
    // @getter noauto
    // @group selection
    // @deprecated in favor of +link{selectionManager()}
    // @visibility external
    //<
    

    //> @attr listGrid.selectionManager (Selection | CellSelection | MultiLinkSelection : null : [RA])
    // The +link{group:selection,Selection object} associated with the <code>ListGrid</code>.
    // @group selection
    // @visibility external
    //<
    

    //> @attr listGrid.selectionAppearance (SelectionAppearance : "rowStyle" : IRW)
    // How selection of rows should be presented to the user.
    // <P>
    // For <code>selectionAppearance:"checkbox"</code> with multiple selection
    // allowed, you would typically use +link{listGrid.selectionType}:"simple" (the default).  Because
    // <code>selectionType</code> and <code>selectionAppearance</code> are unrelated,
    // the combination of <code>selectionAppearance:"checkbox"</code> and
    // <code>selectionType:"multiple"</code> results in a grid where multiple selection can
    // only be achieved via shift-click or ctrl-click.
    // <P>
    // If using <code>"checkbox"</code> for a +link{listGrid}, see also
    // +link{listGrid.checkboxField} for customization APIs.
    // <P>
    // If using <code>"checkbox"</code> for a +link{treeGrid}, an extra icon,
    // +link{treeGrid.getExtraIcon} is not supported. Additionally only
    // +link{listGrid.selectionType}:"simple" and "single" are supported.
    // You can also toggle the display of a disabled checkbox on a treeGrid, displayed
    // when the node can't be selected, via +link{TreeGrid.showDisabledSelectionCheckbox}.
    // <p>
    // Note that the default behavior when you enable checkbox selection is to continue to show
    // the selected style.  This can be changed by setting +link{showSelectedStyle} to false.
    // @group selection
    // @visibility external
    //<
    selectionAppearance: "rowStyle",

    //> @attr listGrid.canSelectAll (boolean : null : [IRW])
    // Controls whether a checkbox for selecting all records appears in the header with
    // +link{listGrid.selectionAppearance, selectionAppearance} set to "checkbox"
    //
    // @group selection
    // @visibility external
    //<
    
    //> @attr listGrid.showHeaderPartialSelection (boolean : null : [IRW])
    // Should partial selection of all records be shown in header with a special icon?
    // The partial icon will show in the header when +link{listGrid.canSelectAll} is
    // enabled and at least one record is selected but all records are not selected.
    // To only show all selected and none selected states, set this attribute to <code>false</code>.
    //
    // @group selection
    // @visibility external
    //<
    
    //> @attr listGrid.canSelectGroups (boolean : false : [IRW])
    // Controls whether a checkbox for selecting +link{listGrid.groupBy(),groups} appears
    // in the group node if +link{selectionAppearance} is set to <code>"checkbox"</code>
    // @group selection
    // @visibility external
    //<
    
    //> @attr listGrid.showPartialSelection (Boolean : false : [IRW])
    // Should partially selected parents (in a Tree data set) be shown with special icon?
    // This has an impact in grouped grids where +link{canSelectGroups} is true. The
    // partial icon will show up for the group header node when a group is partially
    // selected.
    // @group selection
    // @visibility external
    //<

    //> @attr listGrid.deselectOnPartialCheckboxClick (Boolean : false : [IRW])
    // Should partially selected checkbox be deselected or selected on click? This setting
    // affects +link{canSelectAll, header selection checkbox}, +link{canSelectGroups, group
    // checkboxes} and folder checkbox selection in a Tree data set.
    // <p>
    // By default clicking a partially selected checkbox selects it.
    // @group selection
    // @visibility external
    //<

    //> @attr listGrid.selectionType (SelectionStyle : null : [IRW])
    // Defines a listGrid's clickable-selection behavior.
    // <P>
    // The default selection appearance is governed by +link{listGrid.selectionAppearance}: if
    // selectionAppearance is "checkbox", this will be "simple", otherwise, this will be
    // "multiple".
    //
    // @group   selection, appearance
    // @see type:SelectionStyle
    //      @visibility external
    // @example multipleSelect
    //<
    selectionType:null,

    //> @attr listGrid.selectionProperty (String : null : IRA)
    // If specified, the selection object for this list will use this property to mark records
    // as selected.  In other words, if this attribute were set to <code>"isSelected"</code>
    // any records in the listGrid data where <code>"isSelected"</code> is <code>true</code>
    // will show up as selected in the grid. Similarly if records are selected within the grid
    // after the grid has been created, this property will be set to true on the selected
    // records.
    //
    // @group  selection, appearance
    // @visibility external
    //<
    //selectionProperty:null,

    //> @attr listGrid.reselectOnUpdate (boolean : true : IRA)
    // If true, when an update operation occurs on a selected record in a
    // +link{listGrid.dataSource,databound} listGrid, ensure the updated record is
    // re-selected when the operation completes.
    // The +link{listGrid.reselectOnUpdateNotifications} attributes governs whether
    // +link{listGrid.selectionUpdated()} and +link{listGrid.selectionChanged()} will fire
    // when this occurs.
    // @visibility external
    //<
    // This property is passed to the selection object in DBC.createSelectionModel()
    reselectOnUpdate:true,

    //> @attr listGrid.reselectOnUpdateNotifications (SelectionNotificationType : "selectionChanged" : IRWA)
    // if +link{listGrid.reselectOnUpdate} is true, this property governs what
    // selection changed notifications should be triggered when a selected record
    // is edited then automatically reselected when the edited data is merged into
    // the data set.
    // @visibility external
    //<
    reselectOnUpdateNotifications:"selectionChanged",

    //> @attr listGrid.recordCanSelectProperty (String : "canSelect" : IRA)
    // If set to false on a record, selection of that record is disallowed.
    // @visibility external
    //<
    recordCanSelectProperty:"canSelect",

    //> @attr listGridRecord.canSelect (boolean : null : IR)
    //
    // Default property name denoting whether this record can be selected. Property name may be
    // modified for the grid via +link{listGrid.recordCanSelectProperty}.
    //
    // @visibility external
    //<

    //> @attr listGrid.canSelectCells (Boolean : false : IR)
    // Enables cell-level selection behavior as well as
    // +link{useCellRollOvers,cell-level rollover}.
    // <P>
    // To query and manipulate cell-level selections, use +link{getCellSelection()} to retrieve
    // the +link{CellSelection}.
    // <P>
    // Note that the ListGrid has a data model of one +link{Record} per row, unlike the
    // +link{CubeGrid} which supports one +link{CellRecord} per cell.  For this reason
    // record-oriented APIs that act on the selection will act on entire Records that have
    // <i>any</i> selected cells (examples include drag and drop and transferSelectedData()).
    // <P>
    // More generally, <code>canSelectCells</code> is primarily intended to enable developers
    // to build Excel-like interactions on local datasets, by using +link{setData()} plus
    // +link{saveLocally}:true rather than record-oriented DataSources and data binding.
    // You can also use <code>canSelectCells</code> in conjunction with +link{selectionAppearance} 
    // set to "checkbox" to complete this experience.
    // <P>
    // The following keyboard selection behaviors are enabled with this property in
    // addition to standard single-selection Arrow Key navigation:
    // <P>
    // SHIFT +        [Arrow Key]:  begin or continue incremental selection
    // <P>
    // SHIFT + CTRL + [Arrow Key]:  incremental selection to the end of row or column
    // <P>
    // CTRL  + A: select all cells (enabled only with +link{listGrid.canSelectAll})
    // <P>
    // Incremental selection allows selection of rows and columns of cells via keyboard
    // or mouse provided the shift key is down.  Behavior is designed to match Excel.
    // Thus, if a previous selection has begun, cells will be selected from that origin.
    // <P>
    // Users may also navigate through cells using the <i>Tab</i> and <i>Shift+Tab</i>
    // keypresses if +link{listGrid.navigateOnTab} is true. When a user tabs to the
    // end of the row, the +link{listGrid.rowEndEditAction} is used to determine whether
    // to shift selection to the next row, return to the beginning of the same row, or
    // simply move on through the page's tab order.
    //
    // @visibility external
    //<
    //canSelectCells:false,

    //> @attr listGrid.screenReaderNavigateByCell (boolean : false : IRW)
    // If +link{isc.setScreenReaderMode(),screen reader mode is enabled}, and
    // +link{listGrid.canSelectCells} is true should the user be able to navigate 
    // the grid cell-by-cell, highlighting and focusing on individual cells within the
    // selected row via left and right arrow keypresses?
    // <P>
    // If +link{listGrid.canSelectCells} is true, this property will have no effect as
    // all navigation is by cell.
    // 
    // @visibility external
    //<
    
    screenReaderNavigateByCell:false,

    //> @attr listGrid.navigateOnTab (boolean : null : IRW)
    // If +link{listGrid.canSelectCells} is true, this property allows the user
    // to navigate through the cells of a grid using Tab and Shift+Tab keypresses.
    // When a user tabs to the
    // end of the row, the +link{listGrid.rowEndEditAction} is used to determine whether
    // to shift selection to the next row, return to the beginning of the same row, or
    // simply move on through the page's tab order.
    // <P>
    // Note - if this property is not explicitly set, navigateOnTab behavior will be 
    // enabled for grids unless +link{isc.setScreenReaderMode(),screenReader mode is on} in 
    // which case it will be disabled.<br> 
    // Developers should be aware that setting <code>navigateOnTab</code> explicitly to true
    // enabled the behavior even in screenReader mode. This may have an impact on the 
    // accessibility of an application - screen reader mode users navigating the
    // application via the keyboard would have to tab through every single data cell
    // in the grid grid before being able to tab to the next component.
    //
    // @visibility external
    //<
    
    navigateOnTab:null,

    shouldNavigateOnTab : function () {
        var navigateOnTab = this.navigateOnTab;
        if (navigateOnTab == null) navigateOnTab = !isc.screenReader;
        return this.canSelectCells && navigateOnTab;
    },
    // Undocumented corollary for arrowKeyAction for navigateOnTab
    tabKeyAction:"select",

    //> @attr listGrid.useCopyPasteShortcuts (Boolean : null : IRW)
    // For ListGrids with +link{listGrid.canSelectCells,canSelectCells:true}, enabling this
    // property will cause the listGrid to intercept standard browser copy/paste shortcut
    // keys and perform the following behavior.
    // <ul>
    // <li><i>ctrl+c</i>: retrieve selected cell data 
    //     via a call to +link{listGrid.getSelectedCellData()}, and temporarily store it 
    //     in memory in a "clipboard" variable.</li>
    // <li><i>ctrl+v</i>: apply any previously copied data stored in the "clipboard" variable 
    //     into the current grid selection via +link{listGrid.applyCellData}.</li>
    // <li><i>ctrl+d</i>: copy cell values from top row of selected cells down to all rows
    // <li><i>ctrl+r</i>: copy cell values from left column of selected cells right to all columns
    // </ul>
    // <b>Note:</b> setting this property to true will disable standard copy and paste behavior
    // to the native Browser or OS-level clipboard. To copy data to and
    // from applications outside of the browser, use the technique shown in the
    // +explorerExample{gridToExcel,Grid to Excel} and
    // +explorerExample{excelToGrid,Excel to Grid} samples.
    // <P>
    // If this property is unset, default behavior will enable these shortcuts if
    // +link{listGrid.canSelectCells} is true, and +link{listGrid.canDragSelectText} and
    // +link{listGrid.selectCellTextOnClick} are both false, so as to minimize the chances
    // of interfering with native copy and paste of cell content.
    // @visibility external
    //<
    useCopyPasteShortcuts: null,
    _shouldUseCopyPasteShortcuts : function () {
        if (!this.canSelectCells) return false;

        var canSelectCellText = this.canDragSelectText || this.selectCellTextOnClick;
        if (this.useCopyPasteShortcuts == null) {
            return !canSelectCellText;
        } else {
            if (canSelectCellText && !isc.ListGrid._loggedCopyPasteWarning) {
                this.logWarn("Both 'useCopyPasteShortcut' and either " + 
                    "'canDragSelectText' or 'selectCellTextOnClick' is enabled for this grid. " +
                    "This configuration will allow the user to select cell content for copying " +
                    "but will intercept the OS level 'copy' keyboard shortcut, potentially " +
                    "resulting in a confusing user experience.");
                isc.ListGrid._loggedCopyPasteWarning = true;
            }
            return this.useCopyPasteShortcuts;
        }
    },

    //> @attr listGrid.originBaseStyle (CSSStyleName : null : IRW)
    // Name of a CSS Style to use as the +link{listGrid.baseStyle} for a cell that
    // is currently a selection origin for shifted incremental cell selection.
    // Only has an effect if +link{listGrid.canSelectCells} is true.
    // <P>
    // @visibility external
    //<
    //originBaseStyle: null,

    //> @attr listGrid.copyEmptyCells (boolean : true : IRW)
    // Determines whether empty cells (those with an undefined value) are present
    // in the records generated by +link{listGrid.getSelectedCellData}, If true, an
    // empty cell in the selection will be added to the record with a null value.
    // If false, an empty cell will not be represented in the record at all.
    //<
    copyEmptyCells: true,

    //> @attr listGrid.canDragSelect (Boolean : false : IRW)
    //  If this property is true, users can drag the mouse to select several rows or cells.
    //  This is mutually exclusive with rearranging rows or cells by dragging.
    // <p>
    // <strong>NOTE:</strong> If <code>canDragSelect</code> is initially enabled or might be
    // dynamically enabled after the grid is created, it may be desirable to disable
    // +link{Canvas.useTouchScrolling,touch scrolling} so that touch-dragging records/cells
    // selects them rather than starting a scroll. If +link{Canvas.disableTouchScrollingForDrag}
    // is set to <code>true</code>, then touch scrolling will be disabled automatically.
    // However, for +link{group:accessibility,accessibility} reasons, it is recommended to
    // leave touch scrolling enabled and provide an alternative set of controls that can be
    // used to perform drag-selection.
    //  @group  selection
    //  @visibility external
    //  @example dragListSelect
    //<
    //canDragSelect:false,

    //> @attr listGrid.canDragSelectText (Boolean : false : IRW)
    // If this property is true, users can drag the mouse to select text within grid rows,
    // ready to be cliped to clipboard.<br>
    // This is mutually exclusive with
    // +link{canReorderRecords,rearranging rows or cells by dragging}, and with
    // +link{canDragSelect,drag selection of rows}.
    // <P>
    // To enable selecting cell text on click, see +link{listGrid.selectCellTextOnClick}.
    //
    // @group selection
    // @visibility external
    //<
    //canDragSelectText:false,

    //> @attr listGrid.canDropInEmptyArea (Boolean : true : IRW)
    // If set to false, dropping over an empty part of the grid body is disallowed and the
    // no-drop indicator is displayed.
    // @group dragdrop
    // @visibility external
    //<
    //canDropInEmptyArea: true,

    //> @attr listGrid.showSelectionCanvas (Boolean : null : IRWA)
    // If +link{ListGrid.selectionType,selectionType} is set to
    // <smartclient>"single",</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE},</smartgwt>
    // setting this property to <code>true</code> means selection will be displayed to the
    // user with the +link{ListGrid.selectionCanvas,selectionCanvas} and/or
    // +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas} rather than with CSS styling.
    // <p>
    // If <code>showSelectionCanvas</code> is set to <code>true</code>, then the
    // <code>selectionUnderCanvas</code> will automatically be enabled unless
    // +link{showSelectionUnderCanvas,showSelectionUnderCanvas} is set to <code>false</code>.
    // <p>
    // NOTE: It is recommended to use the <code>selectionUnderCanvas</code> rather than the
    // <code>selectionCanvas</code> if possible because the <code>selectionCanvas</code> is
    // stacked on top of the selected record and this may interfere with event handling in rare
    // cases. If no interactive components are shown in the <code>selectionCanvas</code> and it
    // simply provides custom styling, then the <code>selectionUnderCanvas</code> should be used
    // instead.
    // <p>
    // With +link{ListGrid.canFreezeFields,frozen fields}, the <code>selectionCanvas</code>
    // is displayed only over the non-frozen fields of the selected row.
    // @group rowEffects
    // @see ListGrid.showSelectionUnderCanvas
    // @visibility external
    //<
    //showSelectionCanvas:null,

    //> @attr listGrid.selectionCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showSelectionCanvas,showSelectionCanvas}
    // is <code>true</code> and the +link{ListGrid.selectionType,selectionType} is
    // <smartclient>"single".</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE}.</smartgwt>
    // This component will be created and displayed above the selected record whenever the
    // selection changes.
    // <p>
    // NOTE: It is recommended to use the +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas}
    // rather than the <code>selectionCanvas</code> if possible because the <code>selectionCanvas</code>
    // is stacked on top of the selected record and this may interfere with event handling in rare
    // cases. If no interactive components are shown in the <code>selectionCanvas</code> and it
    // simply provides custom styling, then the <code>selectionUnderCanvas</code> should be used
    // instead.
    // <p>
    // The <code>selectionCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the currently selected record in the grid
    // @group rowEffects
    // @see ListGrid.selectionUnderCanvas
    // @visibility external
    //<

    //> @attr listGrid.showSelectionUnderCanvas (Boolean : null : IRWA)
    // If +link{ListGrid.selectionType,selectionType} is set to
    // <smartclient>"single",</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE},</smartgwt>
    // and either +link{showSelectionCanvas,showSelectionCanvas} is <code>true</code> and
    // <code>showSelectionUnderCanvas</code> is unset, or <code>showSelectionUnderCanvas</code>
    // is explicitly set to <code>true</code>, then selection will be displayed to the
    // user with the +link{ListGrid.selectionCanvas,selectionCanvas} and/or
    // +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas} rather than with CSS styling.
    // Setting <code>showSelectionUnderCanvas</code> to <code>false</code> will disable
    // the use of the <code>selectionUnderCanvas</code>.
    // <p>
    // With +link{ListGrid.canFreezeFields,frozen fields}, the <code>selectionUnderCanvas</code>
    // is displayed only behind the non-frozen fields of the selected row.
    // @example gridRoundedSelection
    // @group rowEffects
    // @see ListGrid.showSelectionCanvas
    // @visibility external
    //<
    
    //showSelectionUnderCanvas:null,

    //> @attr listGrid.selectionUnderCanvas (AutoChild Canvas : null : RA)
    // AutoChild created and embedded in the grid if +link{ListGrid.showSelectionCanvas,showSelectionCanvas}
    // is <code>true</code> and +link{ListGrid.showSelectionUnderCanvas,showSelectionUnderCanvas}
    // is unset, or <code>showSelectionUnderCanvas</code> is explicitly set to <code>true</code>,
    // and the +link{ListGrid.selectionType,selectionType} is
    // <smartclient>"single".</smartclient>
    // <smartgwt>{@link com.smartgwt.client.types.SelectionStyle#SINGLE}.</smartgwt>
    // This component will be created and displayed behind the selected record whenever the
    // selection changes.
    // <p>
    // The <code>selectionUnderCanvas</code> has the following read-only attributes set:<br>
    // - <code>this.grid</code> - a pointer to the grid<br>
    // - <code>this.record</code> - a pointer to the currently selected record object in the grid
    // @example gridRoundedSelection
    // @group rowEffects
    // @see ListGrid.selectionCanvas
    // @visibility external
    //<

    //>Animation

    //> @attr listGrid.animateSelection (Boolean : false : IRWA)
    // If the +link{ListGrid.selectionCanvas,selectionCanvas} is enabled, setting
    // this property to <code>true</code> ensures that when the <code>selectionCanvas</code>
    // is displayed it is animated into view via +link{Canvas.animateShow()}. Note that the
    // animation effect may be customized via +link{Canvas.animateShowEffect},
    // +link{Canvas.animateShowTime} and +link{Canvas.animateShowAcceleration} set in
    // <code>selectionCanvasProperties</code>.
    // @group rowEffects
    // @see ListGrid.animateSelectionUnder
    // @visibility external
    //<
    animateSelection: false,

    //> @attr listGrid.animateSelectionUnder (Boolean : false : IRWA)
    // If the +link{ListGrid.selectionUnderCanvas,selectionUnderCanvas} is enabled, setting
    // this property to <code>true</code> ensures that when the <code>selectionUnderCanvas</code>
    // is displayed it is animated into view via +link{Canvas.animateShow()}. Note that the
    // animation effect may be customized via +link{Canvas.animateShowEffect},
    // +link{Canvas.animateShowTime} and +link{Canvas.animateShowAcceleration} set in
    // <code>selectionUnderCanvasProperties</code>.
    // @example gridAnimatedSelection
    // @group rowEffects
    // @see ListGrid.animateSelection
    // @visibility external
    //<
    animateSelectionUnder: false,

    //<Animation

    //> @attr listGrid.checkboxField (AutoChild ListGridField : null : IR)
    // Returns the specially generated checkbox field used when +link{selectionAppearance} is
    // "checkbox".  Created via the +link{AutoChild} pattern so that
    // <code>checkboxFieldDefaults</code> and <code>checkboxFieldProperties</code> are available
    // for skinning purposes. Note that +link{listGridField.shouldPrint} is <code>false</code>
    // for the checkboxField by default - if you want this column to show up in the grid's print
    // view, use <code>checkboxFieldProperties</code> to set this property to true.
    // <P>
    // This field will render an icon to indicate the selected state of each row, which, when
    // clicked will toggle the selection state. The icon src may be configured using
    // +link{listGrid.checkboxFieldTrueImage} and +link{listGrid.checkboxFieldFalseImage}, as
    // well as +link{listGrid.checkboxFieldImageWidth} and +link{listGrid.checkboxFieldImageHeight}.
    // <P>
    // The checkboxField can be detected by calling +link{listGrid.isCheckboxField()} on any
    // ListGridField object.
    //
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldTrueImage (SCImgURL : null :IRWA)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // determines the image to display in the checkbox field for a selected row.
    // If unset, the +link{listGrid.booleanTrueImage} will be used. Note that the special
    // value "blank" means that no image will be shown.
    // @see ListGrid.checkboxFieldFalseImage
    // @see ListGrid.checkboxFieldImageWidth
    // @see ListGrid.checkboxFieldImageHeight
    // @see ListGrid.printCheckboxFieldTrueImage
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldFalseImage (SCImgURL : null :IRWA)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // determines the image to display in the checkbox field for an unselected row.
    // If unset, the +link{listGrid.booleanFalseImage} will be used. Note that the special
    // value "blank" means that no image will be shown.
    // @see ListGrid.checkboxFieldTrueImage
    // @see ListGrid.checkboxFieldImageWidth
    // @see ListGrid.checkboxFieldImageHeight
    // @see ListGrid.printCheckboxFieldFalseImage
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldPartialImage (SCImgURL : null :IRWA)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // determines the image to display in the checkbox field for a partially selected row.
    // If unset, the +link{listGrid.booleanPartialImage} will be used. Note that the special
    // value "blank" means that no image will be shown.
    // @see ListGrid.checkboxFieldTrueImage
    // @see ListGrid.checkboxFieldImageWidth
    // @see ListGrid.checkboxFieldImageHeight
    // @see ListGrid.printCheckboxFieldPartialImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldPartialImage:null,

    //> @attr listGrid.printCheckboxFieldTrueImage (SCImgURL : null :IRWA)
    // If set, the +link{ListGrid.checkboxFieldTrueImage} to use when +link{group:printing,printing}.
    // @see ListGrid.checkboxFieldTrueImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldTrueImage:null,

    //> @attr listGrid.printCheckboxFieldFalseImage (SCImgURL : null :IRWA)
    // If set, the +link{ListGrid.checkboxFieldFalseImage} to use when +link{group:printing,printing}.
    // @see ListGrid.checkboxFieldFalseImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldFalseImage:null,

    //> @attr listGrid.printCheckboxFieldPartialImage (SCImgURL : null :IRWA)
    // If set, the +link{ListGrid.checkboxFieldPartialImage} to use when +link{group:printing,printing}.
    // @see ListGrid.checkboxFieldPartialImage
    // @group checkboxField
    // @group printing
    // @visibility external
    //<
    //printCheckboxFieldPartialImage:null,

    //> @attr listGrid.checkboxFieldImageWidth (Integer : null : IR)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // may be set to govern the width of the checkbox image displayed to indicate whether a row is
    // selected. If unset, the checkboxField image will be sized to match the
    // +link{listGrid.booleanImageWidth} for this grid.
    // @group checkboxField
    // @visibility external
    //<

    //> @attr listGrid.checkboxFieldImageHeight (Integer : null : IR)
    // If +link{listGrid.selectionAppearance} is set to <code>"checkbox"</code> this property
    // may be set to govern the height of the checkbox image displayed to indicate whether a row is
    // selected. If unset, the checkboxField image will be sized to match the
    // +link{listGrid.booleanImageHeight} for this grid.
    // @group checkboxField
    // @visibility external
    //<

    // Empty and loading messages
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.showEmptyMessage (Boolean : true : [IRW])
    // @include gridRenderer.showEmptyMessage
    // @example emptyGrid
    //<
    showEmptyMessage:true,

    //> @attr listGrid.emptyMessage (HTMLString : "No items to show." : [IRW])
    // @include gridRenderer.emptyMessage
    // @example emptyGrid
    //<
    emptyMessage:"No items to show.",

    setEmptyMessage : function (emptyMessage) {
        this.emptyMessage = emptyMessage;
        if (this.body && this.body.isDrawn()){
            this.body.markForRedraw();
        }
    },
            
    //> @attr listGrid.emptyMessageStyle (CSSStyleName : "emptyMessage" : [IRW])
    // The CSS style name applied to the +link{emptyMessage} if displayed.
    // @group emptyMessage
    // @visibility external
    //<
    emptyMessageStyle:"emptyMessage",

    _getEmptyMessageStyleVPad : function () {
        return isc.GridRenderer._getEmptyMessageStyleVPad(this.emptyMessageStyle);
    },

    //> @attr listGrid.filterButtonPrompt (String : "Filter" : [IR])
    // The prompt to show when the mouse hovers over the Filter button in the FilterEditor.
    // @group i18nMessages
    // @visibility external
    //<
    filterButtonPrompt : "Filter",


    //> @attr listGrid.loadingDataMessage (HTMLString : "${loadingImage}&nbsp;Loading data..." : IRW)
    // The string to display in the body of a listGrid while data is being loaded.
    // Use <code>"&#36;{loadingImage}"</code> to include +link{Canvas.loadingImageSrc,a loading image}.
    // @see loadingDataMessageStyle
    // @group emptyMessage, i18nMessages
    // @visibility external
    //<
    loadingDataMessage : "${loadingImage}&nbsp;Loading data...",

    //> @attr listGrid.loadingDataMessageStyle (CSSStyleName : "loadingDataMessage" : [IRW])
    // The CSS style name applied to the loadingDataMessage string if displayed.
    // @group emptyMessage
    // @visibility external
    //<
    loadingDataMessageStyle: "loadingDataMessage",

    //> @attr listGrid.loadingMessage (String : "&nbsp;" : IR)
    // If you have a databound listGrid and you scroll out of the currently loaded dataset, by
    // default you will see blank rows until the server returns the data for those rows.  The
    // loadingMessage attribute allows you to specify arbitrary html that will be shown in each
    // such "blank" record while the data for that record is loading.
    //
    // @group emptyMessage, i18nMessages
    // @visibility external
    //<
    loadingMessage:"&nbsp;",

    // Separator / Single Cell rows
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.singleCellValueProperty (String : "singleCellValue" : IRW)
    // If <code>record[this.singleCellValueProperty]</code> is set for some record, the
    // record will be displayed as a single cell spanning every column in the grid, with
    // contents set to the value of <code>record[this.singleCellValueProperty]</code>.
    // @visibility external
    //<
    singleCellValueProperty:"singleCellValue",

    //> @attr listGrid.isSeparatorProperty (String : "isSeparator" : IRW)
    // If <code>record[this.isSeparatorProperty]</code> is set for some record, the
    // record will be displayed as a simple separator row.
    // @visibility external
    //<
    isSeparatorProperty:"isSeparator",

    // Filter Editor (aka QBE)
    // ---------------------------------------------------------------------------------------

    //> @attr listGrid.showFilterEditor (boolean : false : IRW)
    // Should this listGrid display a filter row.  If true, this ListGrid
    // will be drawn with a single editable row, (separate from the body) with a filter button.
    // <P>
    // Values entered into this row are used as filter criteria to filter this List's data.
    // The +link{listGrid.filterByCell} and +link{listGrid.filterOnKeypress} attributes allow
    // developers to configure whether filtering occurs automatically on change or requires
    // an enter-keypress or filter button click.<br>
    // +link{listGrid.autoFetchTextMatchStyle} determines
    // the textMatchStyle for the request passed to +link{listGrid.fetchData()}.
    // <P>
    // The default +link{formItem.operator,search operator} for an item in the filterEditor can
    // be set via +link{listGridField.filterOperator}.   When <code>field.filterOperator</code> 
    // has been set calls to retrieve the criteria from the grid return +link{AdvancedCriteria}.  
    // See also +link{allowFilterOperators} for a UI that allows end users to change the search
    // operator on the fly
    // <P>
    // Note that if +link{listGrid.filterData()} or +link{listGrid.fetchData()} is called
    // directly while the filter editor is showing, the filter editor values will be updated to
    // reflect the new set of criteria. If you wish to retain the user entered filter criteria
    // and modify a subset of field values programmatically, this can be achieved by
    // copying the existing set of criteria and adding other changes - something
    // like this:
    // <smartclient>
    // <pre><code>
    //   var newCriteria = myListGrid.getFilterEditorCriteria();
    //   isc.DataSource.combineCriteria(newCriteria, {
    //      field1:"new value1",
    //      field2:"new value2"
    //   });
    //   myListGrid.setCriteria(newCriteria);
    // </code></pre>
    // </smartclient>
    // <smartgwt>
    // <pre><code>
    //   Criteria newCriteria = myListGrid.getFilterEditorCriteria();
    //   newCriteria = DataSource.combineCriteria(newCriteria,
    //      new Criteria("field1", "new value1")
    //   );
    //   myListGrid.setCriteria(newCriteria);
    // </code></pre>
    // </smartgwt>
    // In this example code we're using +link{listGrid.getFilterEditorCriteria()} rather than
    // +link{listGrid.getCriteria()} - this ensures that if the user has typed a new value into
    // the filter editor, but not yet clicked the filter button, we pick up the value the user
    // entered.  This sample code uses +link{dataSource.combineCriteria()} to combine the
    // existing filterEditorCriteria with some new custom criteria.  This technique is
    // applicable to both simple and advanced criteria.
    // <P>
    // If you call <code>filterData()</code> and pass in criteria for dataSource
    // fields that are not present in the ListGrid, these criteria will continue to be applied
    // along with the user-visible criteria.
    // <P>
    // <b>filterEditor and advanced criteria</b>: If a developer calls <code>filterData()</code>
    // on a ListGrid and passes in +link{AdvancedCriteria}, expected behavior of the filter
    // editor becomes ambiguous, since AdvancedCriteria has far more complex filter
    // expression support than the ordinary filterEditor can represent.
    // <P>
    // Default behavior for AdvancedCriteria will combine the AdvancedCriteria with the values
    // in the filter editor as follows:
    // <ul>
    // <li>If the top level criteria has operator of type "and":<br>
    //  Each field in the top level
    //  criteria array for which a 'canFilter' true field is shown in the listGrid will show up
    //  if the specified operator matches the default filter behavior
    //  (based on the +link{listGrid.autoFetchTextMatchStyle}).<br>
    //  If the user enters values in the filter editor, these will be combined with the
    //  existing AdvancedCriteria by either replacing or adding field level criteria at the top
    //  level.</li>
    // <li>If the top level criteria is a single field-criteria:<br>
    //  If the field shows up in the listGrid and is canFilter:true, it will be displayed to
    //  the user (if the operator matches the default filter behavior for the field).<br>
    //  If the user enters new filter criteria in the filterEditor, they will be combined with
    //  this existing criterion via a top level "and" operator, or if the user modifies the
    //  field for which the criterion already existed, it will be replaced.</li>
    // <li>Otherwise, if there are multiple top level criteria combined with an "or" operator,
    //  these will not be shown in the filter editor. Any filter parameters the user enters will
    //  be added to the existing criteria via an additional top level "and" operator, meaning
    //  the user will essentially filter a subset of the existing criteria</li>
    // </ul>
    //  @group filterEditor
    //  @visibility external
    //  @example filter
    //<
    
    // showFilterEditor:false

    //> @attr listGrid.canShowFilterEditor (boolean : true : IRW)
    // Should a menu item allowing the user to show or hide the 
    // +link{listGrid.showFilterEditor,filter editor} be displayed in 
    // the +link{listGrid.headerContextMenu, headerContextmenu}?
    // <P>
    // Note that if this ListGrid is not +link{listGrid.dataSource,bound to a dataSource} 
    // it can not be filtered. In this case the context menu
    // option to show the filterEditor will not be displayed even if 
    // <code>canShowFilterEditor</code> is true.
    //
    // @group filterEditor
    // @see showFilterEditorTitle
    // @see hideFilterEditorTitle
    // @visibility external
    // @example filter
    //<
    canShowFilterEditor: true,
    // Suppress the 'showFilterEditor' menu item unless the grid is actually filterable
    _canShowFilterEditor : function () {
        if (!this.canShowFilterEditor) return false;

        
        if (this.getDataSource() == null) return false;
        var hasFilterableField = false;
        var fields = this.getFields();
        if (fields != null) {
            for (var i = 0; i < fields.length; i++) {
                if (fields[i].canFilter != false) {
                    hasFilterableField = true;
                    break;
                }
            }
        }
        return hasFilterableField;
    },

    //> @attr listGrid.showFilterEditorTitle (String : "Show Filter Row" : IRW)
    // When +link{listGrid.canShowFilterEditor, canShowFilterEditor} is true, this is the title
    // for the filterEditor show/hide menu-item, in the 
    // +link{listGrid.headerContextMenu, headerContextmenu}, when the filterEditor is hidden.
    // <P>
    // +link{listGrid.hideFilterEditorTitle, hideFilterEditorTitle} affects the same menu-item
    // when the filterEditor is visible.
    // @group filterEditor, i18nMessages
    // @visibility external
    // @example filter
    //<
    showFilterEditorTitle: "Show Filter Row",
    
    //> @attr listGrid.hideFilterEditorTitle (String : "Hide Filter Row" : IRW)
    // When +link{listGrid.canShowFilterEditor, canShowFilterEditor} is true, this is the title
    // for the filterEditor show/hide menu-item, in the 
    // +link{listGrid.headerContextMenu, headerContextmenu}, when the filterEditor is visible.
    // <P>
    // +link{listGrid.showFilterEditorTitle, showFilterEditorTitle} affects the same menu-item
    // when the filterEditor is hidden.
    // @group filterEditor, i18nMessages
    // @visibility external
    // @example filter
    //<
    hideFilterEditorTitle: "Hide Filter Row",

    //> @attr listGrid.filterEditor (RecordEditor AutoChild : null : R)
    // If +link{listGrid.showFilterEditor} is set to true, the <code>filterEditor</code>
    // is automatically created as an AutoChild.
    // <P>
    // The filterEditor autoChild is a +link{RecordEditor} - essentially it is a specialized listGrid
    // in edit mode for editing a single set of values to be used as criteria. Once created, 
    // developers may access it and use standard listGrid APIs to interact with it.
    // For example, given a listGrid <i><code>myListGrid</code></i>,
    // live edit items could be accessed via<br>
    // <smartclient>
    // <code>
    // myListGrid.filterEditor.getEditFormItem(someFieldName);
    // </code>
    // </smartclient>
    // <smartgwt>
    // <code>
    // myListGrid.getFilterEditor().getEditFormItem(someFieldName);
    // </code>
    // </smartgwt>
    // <P>
    // Developers may configure the AutoChild using +link{filterEditorProperties}.
    //
    // @group filterEditor
    // @see filterEditorSubmit
    // @see filterOnKeypress
    // @see filterByCell
    // @visibility external
    //<

    //> @attr listGrid.filterEditorProperties (RecordEditor Properties : null : IR)
    // Properties to apply to the automatically generated +link{listGrid.filterEditor}
    // if +link{listGrid.showFilterEditor} is true.
    // @visibility external
    //<
    filterEditorDefaults : { 
        shouldPrint:false,
        // dataContext should not be auto-populated on the filter editor
        autoPopulateData:false
    },

    //> @attr listGrid.filterButtonProperties (Button Properties : null : IR)
    // If +link{listGrid.showFilterEditor} is true, this attribute may be used to customize the
    // filter button shown to the right of the filterEditor row.
    // @visibility external
    //<

    //> @attr listGrid.filterEditorHeight (number : 22 : IRW)
    // Height for the filterEditor, if shown.
    //
    //  @group filterEditor
    //  @visibility external
    //<
    filterEditorHeight:22,

    //> @attr listGrid.autoFetchAsFilter (boolean : null : IR)
    // Determines whether +link{filterData()} or +link{fetchData()} should be called when this
    // grid is initially filtered via +link{autoFetchData}, or filtered by the user via the
    // +link{showFilterEditor,filterEditor}.
    // @group databinding
    // @deprecated in favor of listGrid.autoFetchTextMatchStyle
    //<
    // Note: This was exposed in the 7.0 release candidate builds only.
    // Leaving supported (deprecated) but not publicly documented
    // If set, at init time, it will set textMatchStyle to exact or substring (handled in Canvas.js)

    //> @attr listGrid.autoFetchTextMatchStyle (TextMatchStyle : "substring" : IR)
    // When this grid is initially filtered via +link{autoFetchData}, or filtered by the user
    // via the +link{showFilterEditor,filterEditor}, this attribute can be used to set the
    // <code>textMatchStyle</code> on the dsRequest passed to <code>fetchData()</code>.
    // <P>
    // To use a mixture of textMatchStyles, set an appropriate
    // +link{formItem.operator, operator} on a field's
    // +link{listGridField.filterEditorProperties, filterEditorProperties}.
    // @group databinding
    // @visibility external
    //<
    // implemented in canvas.getInitialFetchContext() and recordEditor.performAction()
    autoFetchTextMatchStyle:"substring",

    
// Filter Operators

//> @attr listGrid.allowFilterOperators (Boolean : null : IR)
// Causes a menu item titled +link{filterUsingText,"Filter using"} to appear in the
// +link{showHeaderContextMenu,headerContextMenu} that allows the end user to pick an advanced
// +link{type:OperatorId,search operator} to use for this field.
// <p>
// Once an operator has been chosen, the active operator is indicated by an
// +link{operatorIcon} placed within the field (you can alternatively cause the
// icon to +link{alwaysShowOperatorIcon,always be present}).  The <code>operatorIcon</code> 
// shows the same textual representation of the search operator as is used by the
// +link{formItem.allowExpressions} feature.  Clicking on the icon provides a second way to 
// modify the search operator.  
// <p>
// This feature is enabled by default if +link{dataSource.supportsAdvancedCriteria()} is true, 
// for all fields where it is normally possible to filter by typing in a search string.  This 
// excludes field types such as "date" or "boolean" which show specialized filter controls.  
// Use +link{listGridField.allowFilterOperators} to disable this interface for individual 
// fields, or set +link{dataSourceField.canFilter} to false to disallow filtering entirely for 
// a field.
// <p>
// Note that this feature is similar to +link{listGrid.allowFilterExpressions}, which allows 
// the end users to directly type in characters such as "&gt;" to control filtering.
// <code>allowFilterOperators</code> is easier to use and more discoverable than
// <code>allowFilterExpressions</code>, and also avoids the drawback where special characters 
// like "&gt;" cannot be used in filter values.  However, <code>allowFilterExpressions</code> 
// allows users to make use of certain operators that <code>allowFilterOperators</code> does 
// not support, such as using the "betweenInclusive" operator by typing "5...10".
// <P>
// When both <code>allowfilterExpressions</code> and <code>allowFilterOperators</code> are set,
// filter expressions entered in to the edit-area are parsed and the operator automatically 
// applied to the +link{operatorIcon}.
// <P>
// If +link{allowFilterWindow} is enabled another option,
// +link{advancedFilteringText,"Advanced Filtering"}, is added to the "Filter using" menu.
//
// @see allowFilterWindow
// @visibility external
//<

// the default value of allowFilterOperators is null, on both ListGrid and ListGridField - at
// runtime, calculate an appropriate value for it, first checking the field, then the grid,
// and finally allowing filterOperators if the DS supports advancedCriteria
shouldAllowFilterOperators : function (field) {
    if (!this.showFilterEditor || this.allowFilterOperators == false) return false;
    
    if (!this.dataSource) return false;
    if (field) {
        if (isc.isA.String(field)) field = this.getFieldByName(field);
        if (!field) {
            // there's no field matching the fieldName we were passed
        } else {
            var editorClass = isc.FormItemFactory.getItemClass(this.getFilterEditorType(field));
            // no support for operators in non-TextItem fields
            if (!isc.isA.TextItem(editorClass)) return false;
            // support an undocumented flag, SimpleType.allowFilterOperators - if this is false,
            // return false - for now, deal with date and boolean here as well
            var type = field._simpleType,
                ST = isc.SimpleType
            ;
            if (type) {
                if (ST.inheritsFrom(type.type, "date") || ST.inheritsFrom(type.type, "datetime") ||
                    ST.inheritsFrom(type.type, "boolean")) return false;
                if (type.allowFilterOperators == false) return false;
            }

            // if the field specifies canFilter:false, return false
            if (field.canFilter == false) return false;
            // if the field specifies a value for allowFilterOperators, return it
            if (field.allowFilterOperators != null) return field.allowFilterOperators;
        }
    }
    // if the grid specifies canFilter:false, return false
    if (this.canFilter == false) return false;
    // if the grid specifies a value for allowFilterOperators, return it
    if (this.allowFilterOperators != null) return this.allowFilterOperators;
    // if there's a DS, return the result of supportsAdvancedCriteria()
    var ds = this.getDataSource();
    if (ds) return ds.supportsAdvancedCriteria();
    // otherwise, return false
    return false;
},

//> @attr listGrid.alwaysShowOperatorIcon (Boolean : null : IR)
// When +link{allowFilterOperators} is enabled, whether to show the +link{operatorIcon} for all
// filterable fields, or only for fields where the user has explicitly chosen a search operator
// different from the default operator for the field.
// <p>
// The default operator for a field is determined by +link{autoFetchTextMatchStyle} or by
// setting +link{listGridField.filterOperator} for a specific field.
// @visibility external
//<

shouldAlwaysShowOperatorIcon : function (field, item) {
    if (field) {
        if (isc.isA.String(field)) field = this.getFieldByName(field);
        if (field && field.alwaysShowOperatorIcon != null) return field.alwaysShowOperatorIcon;
        var filterEditor = this.getFilterEditor();
        if (!item && filterEditor) item = filterEditor.editor.getEditForm().getItem(field.name)
        if (item && item.alwaysShowOperatorIcon != null) return item.alwaysShowOperatorIcon;
    }
    if (this.alwaysShowOperatorIcon != null) return this.alwaysShowOperatorIcon;
    return false;
},

//> @attr listGrid.operatorIcon (MultiAutoChild FormItemIcon : null : I)
// Inline icon shown inside +link{listGrid.showFilterEditor,filter editor} fields when
// +link{allowFilterOperators} is enabled.
// @visibility external
//<

//> @attr listGrid.filterUsingText (String : "Filter using" : IR)
// Text for the menu item shown in the +link{showHeaderContextMenu,headerContextMenu} when
// +link{allowFilterOperators} is enabled.
// @group i18nMessages
// @visibility external
//<
filterUsingText: "Filter using",

//> @attr listGrid.defaultFilterOperatorSuffix (String : "(default)" : IR)
// Text to show after the name of the default filterOperator in the 
// +link{showHeaderContextMenu,headerContextMenu} when +link{allowFilterOperators} is enabled.
// @group i18nMessages
// @visibility external
//<
defaultFilterOperatorSuffix: "(default)",

// and some APis on ListGridField

//> @attr listGridField.allowFilterOperators (Boolean : null : IR)
// Per-field setting for +link{listGrid.allowFilterOperators}.  Can be used to enable
// the filter operators UI for a particular field if the ListGrid-level setting is not
// enabled, or to disable filter operators for a particular field if the ListGrid-level setting
// is enabled.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// @visibility external
//<

//> @attr listGridField.allowFilterExpressions (boolean : null : IR)
// Field-level setting for +link{listGrid.allowFilterExpressions}:true - controls whether search 
// expressions can be entered directly into the filter item for this field.  You can also have
// parsing of the expression remove the operator symbol and apply it to an 
// +link{listGrid.allowFilterOperators, icon} in the editor.,
// <P>
// This attribute can also be set at the +link{listGrid.allowFilterExpressions, ListGrid level}.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// @group advancedFilter
// @visibility external
//<

//> @attr listGridField.alwaysShowOperatorIcon (Boolean : null : IR)
// Per-field setting for +link{ListGrid.alwaysShowOperatorIcon}. Can be used to force a particular
// field to always show it's +link{ListGrid.operatorIcon, operatorIcon}, even if it has no 
// filter-value, or is using the default +link{listGridField.filterOperator, search operator}.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// @visibility external
//<

//> @attr listGridField.filterOperator (OperatorId : null : IR)
// With the +link{listGrid.showFilterEditor,FilterEditor} showing, the default +link{Operator} 
// to use when matching values for this field.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// <P>
// Users can override this default operator, or revert to it, with the 
// +link{listGrid.filterUsingText, "Filter using"} submenu, in the grid's 
// +link{listGrid.showHeaderContextMenu, headerContextMenu}; developers can use 
// +link{listGrid.setFieldSearchOperator} to modify the operator and 
// +link{listGrid.clearFieldSearchOperator} to reset to the default.
// <p>
// Note that you can set all FilterEditor fields to default to either substring or exact
// match via +link{listGrid.autoFetchTextMatchStyle,autoFetchTextMatchStyle}, but if you 
// want a mix of exact vs substring match on different fields, you need to use this 
// property, and your ListGrid will produce +link{AdvancedCriteria} rather than the 
// simpler +link{Criteria} format.  This is automatically and transparently handled by the 
// SmartClient Server's SQLDataSource and HibernateDataSource in Power Edition or above, 
// but if you have your own filtering implementation, it will need to be able to handle 
// AdvancedCriteria.
// @see listGridField.operator
// @visibility external
//<


	// Editing
	// --------------------------------------------------------------------------------------------
	//> @attr listGrid.canEdit (Boolean : null : [IRW])
	//      Can the user edit cells in this listGrid? Can be set for the listGrid, and overridden for
	//      individual fields.<br>
	//      If 'canEdit' is false at the listGrid level, fields can never be edited - in this case
	//      the canEdit property on individual fields will be ignored.<br>
	//      If 'canEdit' is set to true at the listGrid level, setting the 'canEdit' property to
	//      false at the field level will prevent the field from being edited inline unless a
	//      custom override of +link{canEditCell} allows it.<br>
	//      If 'canEdit' is not set at the listGrid level, setting 'canEdit' to true at the field
    //      level enables the field to be edited inline.
    //      <P>
    //      For more information on editing, see the +link{group:editing,editing overview}.
    //
	//      @visibility external
	//      @group  editing
	//      @see    startEditing()
    //      @see listGridField.canEdit
    //      @see listGrid.recordEditProperty
    //      @see listGrid.canEditCell()
	//      @see    fields
    //      @example editByRow
	//<
	//canEdit:null,

    //> @attr listGrid.canEditNew (Boolean : null : [IRW])
    //  Can the user add new rows?
    //  @group  editing
    //  @see attr:listGrid.canEdit
    //  @see attr:listGrid.recordEditProperty
    //  @visibility internal
    //<
    canEditNew: false,

    //> @attr listGrid.recordEditProperty (String : "_canEdit" : [IRWA])
    // Property name on a record that should be checked to determine whether the record may be
    // edited.
    // <br>
    // This property is configurable to avoid possible collision with data values in record.
    // With the default setting of "_canEdit", a record can be set non-editable by ensuring
    // record._canEdit == false.
    // <br>
    // For controlling editability for the entire grid or for a field, set grid.canEdit or
    // field.canEdit.
    //
    //  @group  editing
    //  @see attr:listGrid.canEdit
    //  @see attr:listGridField.canEdit
    //  @see method:listGrid.canEditCell
    //  @visibility external
    //<
    recordEditProperty:"_canEdit",

    //> @attr listGridRecord._canEdit (boolean : null : IR)
    //
    // Default property name denoting whether this record can be edited. Property name may be
    // modified for the grid via +link{listGrid.recordEditProperty}.
    //
    // @group  editing
    // @visibility external
    //<

    // Name for property used by internal '_testRowEditData' method to track whether
    // records have been compared to edit-data in order to map rowNums to edit values.
    // Customizable, in case of collision with record data - but unlikely to be overridden.
    editValuesTestedProperty:"_editValuesTested",

    //> @attr listGrid.alwaysShowEditors (boolean : null : [IRA])
    // When this attribute is set, editors will be appear to be present in every row of the 
    // grid, allowing the user to immediately start editing any cell, rather than showing 
    // up in a single record at a time.<br>
    // This attribute is only valid when +link{listGrid.editByCell} is false.
    // <P>
    // This setting has some limitations and is typically only used for simple grids with 
    // a limited set of fields and standard editors.
    // <ul>
    // <li>Not all formItem types are supported. Default editors for standard data types 
    //  (text, boolean, date, datetime, integer and float) are all supported, but custom
    //   editorType, including CanvasItem based editors are not. Fields with an unsupported
    //   editor type will show static values for all rows other than the current edit row, though
    //   users can start editing these with a single click</li> 
    // <li><code>alwaysShowEditors:true</code> grids do not support showing different
    //   editor types for the same field in different rows</li>
    // <li>In some cases there may be visual differences between the editor displayed in the
    //   edit row and the editor displayed in other rows.</li>
    // <li>From a design perspective, this mode presents a very "busy-looking" UI,
    //     which can made it harder to read the actual data. Functionally having 
    //     +link{listGrid.editEvent} set to "click" provides the same single-click to edit
    //     any cell user experience without the busy UI.</li>
    // <li>In some cases there may be a performance penalty for writing out so many controls
    //     (editors for every cell of the grid).</li>
    // </ul>
    // Note that in addition to alwaysShowEditors, listGrid support single-click editing
    // via +link{listGrid.editEvent,editEvent:"click"}, and, for boolean fields, 
    // +link{listGridField.canToggle}
    //
    // @group editing
    // @visibility external
    //<
    

    //> @attr listGrid.editByCell (boolean : null : [IRW])
    // Determines whether when the user edits a cell in this listGrid the entire row becomes
    // editable, or just the cell that received the edit event.
    // <P>
    // No effect if this.canEdit is false or null.
    //
    // @group editing
    // @see listGrid.canEdit
    // @example editByCell
    // @visibility external
    //<

    //> @attr listGrid.saveByCell (boolean : null : [IRW])
    // Whether edits should be saved whenever the user moves between cells in the current edit
    // row.
    // <P>
    // If unset, defaults to +link{editByCell,this.editByCell}.
    // <P>
    // To avoid automatic saving entirely, set +link{autoSaveEdits}:false.
    //
    //  @group  editing
    //  @visibility external
    //  @see listGrid.editByCell
    //<

    //> @attr listGrid.validateByCell (boolean : null : [IRW])
    // Whether client-side validation checks should be performed when the user moves between
    // cells in the current edit row.  If unset, defaults to +link{listGrid.editByCell}.
    // <P>
    // Note that validation always occurs when a row is to be saved, so setting
    // +link{saveByCell}:true forces validation on cell transitions.  To completely disable
    // automatic validation, set +link{neverValidate}:true.
    //
    // @group gridValidation
    // @visibility external
    // @see group:editing
    //<
    

    // autoValidate will disable validation on row-transitions, so validation will only
    // occur on save attempts.  Not currently exposed.
    autoValidate:true,

    //> @attr listGrid.validateOnChange (boolean : null : [IRW])
    // If true, validation will be performed on each edited cell when each editor's
    // "change" handler is fired.
    //
    // @see ListGridField.validateOnChange
    // @group gridValidation
    // @visibility external
    //<
    //validateOnChange:null

    //> @attr listGrid.neverValidate (boolean : null : [IRWA])
    // If true, validation will not occur as a result of cell editing for this grid.
    //  @group  gridValidation
    // @visibility external
    //<
    //neverValidate:null,


    //> @attr listGrid.canRemoveRecords (Boolean : false : IRW)
    // If set, provide UI for the user to remove records from the grid as an additional field
    // showing the +link{listGrid.removeIcon}, which, when clicked, will call
    // +link{listGrid.removeRecordClick()} which removes the row from the data set (or if
    // +link{deferRemoval} is true changes the +link{listGrid.markRecordRemoved()} status
    // for the record). Individual records can be marked to prevent removal - see
    // +link{listGrid.recordCanRemoveProperty}.
    // <P>
    // To add a confirmation dialog before a record is removed, set
    // +link{listGrid.warnOnRemoval}.
    // <P>
    // If deferring removal, the record will appear marked with the +link{removedCSSText}
    // until the removal is committed via a call to +link{saveEdits()}.
    // Otherwise, the record will disappear from view. If +link{listGrid.animateRemoveRecord}
    // is true, the removed record will appear to shrink out of view when it is removed.
    // <P>
    // By default the field will display the +link{listGrid.removeIcon} next to each record, and
    // will be rendered as the rightmost column. Two mechanisms exist to further modify this field:
    // <ul>
    // <li>To change the position of the remove-field, include an explicitly specified field with
    //     the attribute +link{listGridField.isRemoveField,isRemoveField:true} set. This will then
    //     be used as the remove field instead of adding a field to the beginning of the set of
    //     columns.</li>
    // <li>Additional direct configuration of the remove field may be achieved by modifying
    //     +link{listGrid.removeFieldProperties}.</li>
    // </ul>
    // If +link{deferRemoval} is true, when a record is marked as removed, the the icon will
    // change to display the +link{listGrid.unremoveIcon} for this row. Clicking on this icon
    // will call +link{listGrid.unmarkRecordRemoved()} to mark the record as no longer pending
    // deletion.
    // @group editing
    // @visibility external
    //<

    //> @attr listGrid.warnOnRemoval (Boolean : false : IRW)
    // If +link{listGrid.canRemoveRecords} is true, when the user clicks the remove icon
    // for some record, should we show a warning message
    // (defined as +link{listGrid.warnOnRemovalMessage}) and allow the user to cancel removal?
    // @visibility external
    //<
    warnOnRemoval:false,
    //> @attr listGrid.warnOnRemovalMessage (String : "Are you sure you want to delete this record?" : IRW)
    // Warning message to show the user on a click on the 'remove' icon
    // if +link{listGrid.canRemoveRecords} is true and
    // +link{listGrid.warnOnRemoval} is true.
    // @visibility external
    // @group i18nMessages
    //<
    warnOnRemovalMessage:"Are you sure you want to delete this record?",

    shouldShowRemoveField : function () {
        if (this.fieldSourceGrid != null) return this.fieldSourceGrid.shouldShowRemoveField();
        return this.canRemoveRecords;
    },

    //> @attr listGrid.recordRemovedProperty (String : "_removed" : IR)
    // Property name used as an edit-value on a record that has been marked for removal via
    // +link{listGrid.markRecordRemoved()}.
    //
    // @see listGridRecord.removed
    // @visibility internal
    //<
    // This property is internal - the "_removed" flag is obfuscated and unlikely to collide
    // with real world data but could be configured to be something different if this became an issue.
    recordRemovedProperty: "_removed",

    //> @method listGrid.markRecordRemoved()
    // Marks a record deleted such that a later call to +link{saveEdits()} or +link{saveAllEdits()}
    // will cause a "remove" +link{DSRequest} to be submitted.
    // <P>
    // A removed record is disabled and non-editable, and uses +link{removedCSSText} for its CSS
    // style, which by default will show strikethrough text.
    // <P>
    // Contrast this method with removeSelectedData(), which immediately submits a DSRequest to
    // remove the selected records from the dataset.
    // <P>
    // Records that have been marked for removal using this method may be 'unmarked' via a call to
    // +link{listGrid.unmarkRecordRemoved()}, or by discarding edit values (+link{discardEdits()}).
    //
    // @param rowNum (number) row number for the record to mark
    //
    // @group editing
    // @visibility external
    //<
    markRecordRemoved : function (rowNum, suppressRefresh) {
        if (!isc.isA.Number(rowNum)) rowNum = this.findRowNum(rowNum);
        // hide the edit form if we're mid-edit.
        if (this.getEditRow() == rowNum) this.hideInlineEditor();
        // deselect if we're selected.
        if (this.canSelectCells) {
            this.selectionManager.deselectRow(rowNum);
        } else {
            var record= this.getRecord(rowNum);
            this.selectionManager.deselect(record, rowNum);
        }
        this.setEditValue(rowNum, this.recordRemovedProperty, true,
                          suppressRefresh, false, suppressRefresh);
        if (!suppressRefresh) this.refreshRow(rowNum);
    },

    //> @method listGrid.markRecordsRemoved()
    // Marks an array of records deleted such that a later call to +link{saveEdits()} or 
    // +link{saveAllEdits()} will cause a "remove" +link{DSRequest} to be submitted.
    // <P>
    // This method is similar to +link{listGrid.markRecordRemoved} but should be more efficient
    // in avoiding unneeded duplicate refreshes due to the multiple records getting marked.
    //
    // @param records (Array of ListGridRecord | number) records or indices to mark removed
    //   
    // @see listGrid.markRecordRemoved
    // @group editing
    // @visibility external
    //<
    markRecordsRemoved : function (records) {
        if (records == null) return;
        if (!isc.isAn.Array(records)) records = [records];
        for (var i = 0; i < records.length; i++) {
            this.markRecordRemoved(records[i], true);
        }
    },

    //> @method listGrid.recordMarkedAsRemoved()
    // Returns true if the specified record is marked as removed via a call to
    // +link{markRecordRemoved()}
    // @param rowNum (int) index of row to verify
    // @return (Boolean) true if the specified record has been marked for removal
    // @visibility external
    // @group editing
    //<
    recordMarkedAsRemoved : function (rowNum) {
        if (rowNum == null) return false;
        if (!isc.isA.Number(rowNum)) {
            
            rowNum = this.getEditSessionRowNum(rowNum);
            if (rowNum == null) return false;
        }
        return (this.getEditValue(rowNum, this.recordRemovedProperty) == true);
    },

    //> @method listGrid.unmarkRecordRemoved()
    // Reverses a previous call to +link{markRecordRemoved()}.
    // <P>
    // Note that a record that is marked for removal and then un-marked retains any uncommitted
    // edits from before it was marked for removal.  These can be discarded with
    // +link{discardEdits()}.
    // @param rowNum (int) index of record to clear the 'removed'
    // @group editing
    // @visibility external
    //<
    unmarkRecordRemoved : function (rowNum, suppressRefresh) {
        if (!isc.isA.Number(rowNum)) rowNum = this.findRowNum(rowNum);
        this.clearEditValue(rowNum, this.recordRemovedProperty);
        if (!suppressRefresh) this.refreshRow(rowNum);
    },

    

    //> @attr listGrid.removedCSSText (String : "text-decoration:line-through;" : [IRWA])
    //  Custom CSS text to be applied to records that have been
    // +link{listGrid.markRecordRemoved(),marked for removal}.
    // <P>
    // This CSS text will be applied on top of standard disabled styling for the cell.
    //
    // @visibility external
    // @group   appearance
    //<
    removedCSSText:"text-decoration:line-through;",

    //> @method listGrid.markSelectionRemoved()
    // Marks the currently selected records as removed, as though +link{markRecordRemoved()} had
    // been called.
    //
    // @group editing
    // @visibility external
    //<
    markSelectionRemoved : function () {
        var records = this.getSelectedRecords(),
            recordsLength = records.length;
        for (var i = 0; i < recordsLength; ++i) {
            // We can pass the record object into markRecordRemoved even though it's doc'd
            // as taking just rowNum
            this.markRecordRemoved(records[i], true);
        }
        this.markForRedraw();
    },

    //> @attr listGrid.deferRemoval (boolean : null : IR)
    // When enabled, the field shown by +link{listGrid.canRemoveRecords} causes records to be
    // marked for future removal via +link{markRecordRemoved()} instead of immediately being
    // removed.
    // <P>
    // When a record has been marked for removal, an icon in the
    // <code>canRemoveRecords</code> field allowing it to be unmarked will be displayed.
    // <P>
    // If not explicitly specified by this property, removal of records will be deferred if
    // +link{autoSaveEdits} is false for the grid.
    // @group editing
    // @visibility external
    //<

    shouldDeferRemoval : function () {
        if (this.deferRemoval != null) return this.deferRemoval;
        return !this.autoSaveEdits;
    },

    //> @attr listGrid.removeIcon (SCImgURL : "[SKIN]/actions/remove.png" : IR)
    // When +link{ListGrid.canRemoveRecords} is enabled, default icon to show in
    // the auto-generated field that allows removing records.
    // @visibility external
    //<
    removeIcon:"[SKIN]/actions/remove.png",

    //> @attr listGrid.unremoveIcon (SCImgURL : "[SKIN]/actions/undo.png" : IR)
    // When +link{ListGrid.canRemoveRecords} is enabled, this icon will be shown in the
    // auto generated field fro removing records if the record has been marked as removed via
    // +link{listGrid.markRecordRemoved()}. At this point, clicking on the icon will
    // unmark the record as removed.
    // @visibility external
    //<
    unremoveIcon:"[SKIN]/actions/undo.png",

    //> @attr listGrid.removeIconSize (Number : 16 : IRW)
    // Default width and height of +link{removeIcon,remove icons} for this ListGrid.
    //
    // @visibility external
    //<
    removeIconSize: 16,

    //> @attr listGrid.animateRemoveRecord (Boolean : true : IRW)
    // When +link{ListGrid.canRemoveRecords} is enabled, should records be animated out of view
    // when they are removed by the user?
    // @visibility external
    //<
    // When showing alternate records styles, the styles will essentially be reassigned after the
    // animation completes which means we finish our smooth animation with what looks a little like
    // a jump - not clear how to avoid this, but we could warn about this in the attribute
    // description.
    animateRemoveRecord:true,

    //> @attr listGrid.animateRemoveTime (number : 100 : IRW)
    // When animating record removal
    // +link{listGrid.animateRemoveRecord,(see animateRemoveRecord)}, if
    // +link{listGrid.animateRemoveSpeed} is not
    // set, this property designates the duration of the animation in ms.
    // @group animation
    // @visibility animation
    // @see listGrid.animateRemoveRecord
    //<
    animateRemoveTime:100,

    //> @attr listGrid.animateRemoveSpeed (number : 200 : IRW)
    // When +link{listGrid.animateRemoveRecord, animating record removal}, this property
    // designates the speed of the animation in pixels per second. Takes precedence over the
    // +link{listGrid.animateRemoveTime} property, which allows the developer to specify a
    // duration for the animation rather than a speed.
    // @group animation
    // @visibility animation
    // @see listGrid.animateRemoveRecord
    //<
    animateRemoveSpeed:200,

    //> @attr listGrid.removeFieldTitle (String : "&nbsp;" : IRWA)
    // The title to use for the +link{listGrid.removeFieldDefaults, remove field}.
    // <P>
    // By default this title is not displayed in the remove column header button as the
    // +link{listGrid.removeFieldDefaults} sets +link{listGridField.showTitle} to <code>false</code>.
    // @visibility external
    //<
    removeFieldTitle: isc.nbsp,

    //> @attr listGrid.removeFieldDefaults (ListGridField Properties : {...} : IR)
    // Default configuration properties for the "remove field"
    // displayed when +link{ListGrid.canRemoveRecords} is enabled.
    // +link{classMethod:class.changeDefaults()} should be used when modifying this object.
    // <P>
    // The default configuration includes a +link{listGridField.recordClick()} handler which
    // calls +link{listGrid.removeData()} to actually perform the data removal.
    // @visibility external
    //<
    removeFieldDefaults:{
        type:"icon",
        width:24,
        showDefaultContextMenu:false,
        selectCellTextOnClick:false,
        canEdit:false,
        canHide:false,
        canSort:false,
        canGroupBy:false,
        canFilter:false,
        showTitle:false,
        canExport: false,
        autoFitWidth: false,
        canDragResize: false,
        canAutoFitWidth: false,
        ignoreKeyboardClicks:true,
        showGridSummary: false,
        showGroupSummary: false,
        summaryValue: "&nbsp;",
        // disable this from ever being assigned as the treeField
        treeField:false,

        // flag that means this is a special builtin field, not for formulas/export/etc
        featureField: true

        // No need for a recordClick handler.
        // We explicitly override '_rowClick()' on the gridBody class to fire the removeRecordClick
        // event. This handles the case where the icon is marked for removal already, therefore
        // disabled, so we wouldn't get a field.recordClick notification.

        // In setFields() we override 'formatCellValue' to return the appropriate icon
        // (removeIcon / unremoveIcon).

    },

    //> @attr listGrid.removeFieldProperties (ListGridField Properties : null : IR)
    // Configuration properties for the "remove field" displayed when
    // +link{ListGrid.canRemoveRecords} is enabled.
    // <smartclient>These configuration settings will be overlaid
    // on top of the +link{listGrid.removeFieldDefaults}.</smartclient>
    // @visibility external
    //<

    //> @attr listGrid.filterByCell (boolean : true : [IRWA])
    // If we're showing the +link{listGrid.showFilterEditor,filterEditor}, should this list
    // be filtered every time the user changes edit values for particular cells rather than
    // waiting for an Enter keypress or a click on the filterEditor submit button.
    // <P>
    // Note that by default fields in the filter editor will be set to 
    // +link{formItem.changeOnKeypress,changeOnKeypress:false}, so the grid will not filter as
    // the user types in text-based items.<br>
    // To enable filtering as the user types in text fields, we recommend the 
    // +link{filterOnKeypress} attribute. Also note that <code>filterOnKeypress:true</code>
    // implies filtering will occur on change to edit values for cells, even if <code>filterByCell</code>
    // is not set to true.
    //
    // @group filterEditor
    // @see listGrid.fetchDelay
    // @visibility external
    //<
    filterByCell:true,

    setFilterByCell : function (filterByCell) {
        this.filterByCell = filterByCell;
        var filterEditor = this.getFilterEditor();
        if (filterEditor) filterEditor._applySourceWidgetFilterByCell();
    },

    //> @attr listGrid.filterOnKeypress (boolean : false : [IRWA])
    // If we're showing the +link{listGrid.showFilterEditor,filterEditor}, should this list
    // be filtered for every keypress within the filter editor fields?
    // <P>
    // This is equivalent to setting +link{filterByCell} to true and explicitly setting
    // +link{formItem.changeOnKeypress} to true for each text-based field within the
    // +link{listGridField.filterEditorProperties}.
    // <P>
    // @group filterEditor
    // @see listGrid.fetchDelay
    // @visibility external
    //<

    //> @attr listGrid.waitForSave (Boolean : false : [IRWA])
    // If this is an editable listGrid, this property determines whether the user will be
    // able to dismiss the edit form, or navigate to another cell while the save is in
    // process (before the asynchronous server response returns).
    //  @group  editing
    // @visibility external
    //<
    //waitForSave:false,

    //> @attr listGrid.stopOnErrors (Boolean : false : [IRWA])
    // If this is an editable listGrid, this property determines how failure to save due to
    // validation errors should be displayed to the user.
    // <P>
    // If this property is true, when validation errors occur the errors will be displayed
    // to the user in an alert, and focus will be returned to the first cell to fail validation.
    // <P>
    // If false, the cells that failed validation will be silently styled with the
    // editFailedBaseStyle.
    // <p>
    // <b>Note:</b> stopOnErrors being set to true implies that 'waitForSave' is also true.
    // We will not dismiss the editor until save has completed if stopOnErrors is true.
    //
    // @group editing
    // @see waitForSave
    // @visibility external
    //<
    //stopOnErrors:false,

    //> @attr listGrid.autoSaveEdits (Boolean : true : [IRW])
    // If this ListGrid is editable, should edits be saved out when the user finishes editing
    // a row (or a cell if +link{ListGrid.saveByCell} is true).
    // <P>
    // The default of <code>true</code> indicates that edits will be
    // +link{saveByCell,automatically saved} as the
    // user navigates through the grid and/or +link{enterKeyEditAction,hits 'Enter'} to end
    // editing.  See the +link{group:editing,Grid Editing} overview for details.
    // <P>
    // Setting <code>autoSaveEdits</code> false creates a "mass update" / "mass delete"
    // interaction where edits will be retained for all edited cells (across rows if
    // appropriate) until +link{saveEdits()} is called to save a particular row, or
    // +link{saveAllEdits()} is called to save all changes in a batch.
    // <P>
    // <b>Note:</b> when +link{listGrid.groupByField,listGrid grouping} is enabled, or when
    // working with hierarchical data in a +link{treeGrid}, users have the option to hide
    // records from view by collapsing the parent folder or group. This, in conjunction with
    // <code>autoSaveEdits</code> being set to <code>false</code> can lead to a case where
    // a user is unable to save edits due to validation errors on hidden rows. Therefore we
    // recommend developers consider having validators in place such that errors are caught
    // and displayed to the user on change or editor exit rather than being caught only when
    // saving is attempted. If it's not possible for all validation to be performed immediately 
    // on row exit, we recommend that a different UI design be used that does not involve
    // <code>autoSaveEdits</code> being set to <code>false</code>.
    //
    // @group editing
    // @visibility external
    //<
    autoSaveEdits:true,

    // ListGrid validation error icon. Very similar API to the FormItem class validation error
    // icon.

    //> @attr ListGrid.showErrorIcons (boolean : true : IRW)
    //  If this grid is editable, and an edit has caused validation failure for some cell,
    //  should we show an icon to indicate validation failure?
    //  @group  errorIcon
    //  @visibility external
    //<
    showErrorIcons : true,

    //> @attr ListGrid.errorIconHeight (Integer : 16 : IRW)
    //      Height of the error icon, if we're showing icons when validation errors occur.
    //  @group  errorIcon
    //  @visibility external
    //<
    errorIconHeight : 16,

    //> @attr ListGrid.errorIconWidth (Integer : 16 : IRW)
    //      Height of the error icon, if we're showing icons when validation errors occur.
    //  @group  errorIcon
    //  @visibility external
    //<
    errorIconWidth : 16,

    //> @attr ListGrid.errorIconSrc (SCImgURL : "[SKIN]/ListGrid/validation_error_icon.png" : IRW)
    //      Src of the image to show as an error icon, if we're showing icons when validation
    //      errors occur.
    //  @group  errorIcon
    //  @visibility external
    //<
    errorIconSrc : "[SKIN]/validation_error_icon.png",

    //> @attr listGrid.confirmCancelEditing (Boolean : false : [IRW])
    // If this is an editable listGrid, when the user attempts to cancel an edit, should we
    // display a confirmation prompt before discarding the edited values for the record?
    //
    //  @visibility external
    //  @group  editing
    //<
    //confirmCancelEditing:false,

    //> @attr listGrid.cancelEditingConfirmationMessage (String : Cancelling this edit will discard unsaved changes for this record. Continue? : [IRW])
    // If this is an editable listGrid, and <code>this.confirmCancelEditing</code> is true
    // this property is used as the message to display in the confirmation dismissal prompt.
    //
    //  @visibility external
    //  @group  editing, i18nMessages
    //<
    cancelEditingConfirmationMessage:"Cancelling this edit will discard unsaved changes for this record. Continue?",

    //> @attr listGrid.confirmDiscardEdits (Boolean : true : [IRW])
    // For editable listGrids, outstanding unsaved edits when the user performs a new filter
    // or sort will be discarded. This flag determines whether we should display a confirmation
    // dialog with options to save or discard the edits, or cancel the action in this case.
    //
    //  @visibility external
    //  @group  editing
    //<
    confirmDiscardEdits:true,

    //> @attr listGrid.autoConfirmSaveEdits (Boolean : false : [IRW])
    // For editable listGrids, outstanding unsaved edits when the user performs a new filter
    // or sort will be discarded by default. This flag determines whether we should save such
    // edits automatically in this case.  See also +link{listGrid.confirmDiscardEdits}, which 
    // allows the user to choose whether to save or discard the unsaved edits.
    //  @visibility external
    //  @group  editing
    //<
    autoConfirmSaveEdits:false,

    //> @attr listGrid.confirmDiscardEditsMessage (String : "This action will discard unsaved changes for this list.": [IRW])
    // If <code>this.confirmDiscardEdits</code> is true, this property can be used to customize the
    // error message string displayed to the user in a dialog with options to
    // cancel the action, or save or discard pending edits in response to sort/filter actions
    // that would otherwise drop unsaved edit values.
    // @visibility external
    // @group editing, i18nMessages
    //<
    confirmDiscardEditsMessage:"This action will discard all unsaved changes for this list.",

    //> @attr listGrid.discardEditsSaveButtonTitle (String :"Save" : IRW)
    // If +link{listGrid.confirmDiscardEdits} is true this is the title for the save button
    // appearing in the lost edits confirmation dialog. Override this for localization if necessary.
    // @visibility external
    // @group editing, i18nMessages
    //<
    discardEditsSaveButtonTitle:"Save",

    //> @attr listGrid.addNewBeforeEditing (boolean : false : IRWA)
    // When creating a new edit record via 'startEditingNew()' [or tabbing beyond the end
    // of the last editable field in a list], should we contact the server to create a
    // server-side record before editing begins?
    // @group   editing
    // @visibility advancedInlineEdit
    //<
    //addNewBeforeEditing:false,

    //> @attr listGrid.rowEndEditAction (RowEndEditAction : null : IRW)
    // If the user is editing a record in this listGrid, and attempts to navigate to a field
    // beyond the end of the row, via tab (or shift-tab off the first editable field), this
    // property determines what action to take:<ul>
    // <li>"next": start editing the next (or previous) record in the list
    // <li>"same": put focus back into the first editable field of the same record.
    // <li>"done": hide the editor
    // <li>"stop": leave focus in the cell being edited
    // <li>"none": no action
    // </ul>
    // @group editing
    // @visibility external
    //<
    //rowEndEditAction:"next",

    //> @attr listGrid.listEndEditAction (RowEndEditAction : null : IRW)
    // If the user is editing the last record in this listGrid, and attempts to navigate
    // beyond the last row either by tabbing off the last editable field, or using the down
    // arrow key, this property determines what action to take:<ul>
    // <li>"next": start editing a new record at the end of the list.
    // <li>"done": hide the editor
    // <li>"stop": leave focus in the cell being edited
    // <li>"none": no action
    // </ul>
    // <P>
    // See the +link{group:editing,Grid Editing overview} and also the
    // +link{group:unsavedRecords,Editing Unsaved Records overview} for context about how newly
    // added records behave.
    //
    // @group editing
    // @visibility external
    // @example enterNewRows
    //<
    
    //listEndEditAction:"stop",

    //> @attr listGrid.showNewRecordRow (boolean    : null  : [IRW])
    // If this is an editable ListGrid, setting this property to true causes an extra 
    // row with the +link{listGrid.newRecordRowMessage} to be displayed below the last record.
    // <P>
    // Clicking this row will start editing a new record at the end of the data set, as if
    // +link{listGrid.startEditingNew()} had been called.
    // <P>
    // Note that for +link{listGrid.dataSource,databound grids}, the new record row will
    // be suppressed if the grid has not +link{listGrid.fetchData(),fetched data}, unless
    // +link{listGrid.saveLocally} has been set.
    //
    // @visibility external
    //<

    //> @attr listGrid.newRecordRowMessage (String : "-- Add New Row --" : IR)
    // If this listGrid is showing the 'newRecordRow' (used for adding new rows to the end
    // of the data), this property determines what message should be displayed in this row.
    //
    // @group editing, i18nMessages
    // @visibility external
    //<
    newRecordRowMessage:"-- Add New Row --",

    shouldShowNewRecordRow : function () {
        return this.showNewRecordRow && 
                // If this.canEdit is false editing is disallowed (hide the row)
                // If true allow it
                // *if unset, it's ambiguous - we could loop through the fields looking
                //   for editable fields but we don't currently do this
                this.canEdit &&
                // If we're databound, suppress the row if we've never fetched
                // unless we're saving locally!
                (this.getDataSource() == null || this.shouldSaveLocally() ||
                    (isc.ResultSet && isc.isA.ResultSet(this.data))
                ); 
    },

    //> @attr listGrid.enterKeyEditAction (EnterKeyEditAction : "done" : IRW)
    // What to do when a user hits enter while editing a cell:
    // <ul>
    // <li>"nextCell": start editing the next editable cell in this record (or the first
    //     editable cell in the next record if focus is in the last editable cell in the row)
    // <li>"nextRow": start editing the same field in the next row (skipping any rows where
    //      that would be a non-editable cell.
    // <li>"nextRowStart": start editing the first editable cell in the next row.
    // <li>"done": hide the editor (editing is complete)
    // </ul>
    // Note that if this.autoSaveEdits is true, this may cause a save of the current edit values
    // @group   editing
    // @visibility external
    //<
    enterKeyEditAction:"done",

    //> @attr listGrid.escapeKeyEditAction (EscapeKeyEditAction : "cancel" : IRW)
    // What to do when a user hits escape while editing a cell:<ul>
    // <li>"cancel": close the editor and discard the current set of edit values
    // <li>"done": just close the editor (the edit is complete, but the edited values are retained).
    // </ul>
    // Note that if +link{autoSaveEdits} is true, this may cause a save of the current edit values
    // @group editing
    // @visibility external
    //<
    escapeKeyEditAction:"cancel",
    
    //> @attr   listGrid.arrowKeyEditAction (ArrowKeyEditAction : null : [IRW])
    // What to do when a user hits arrow key while editing a field?<br>
    // If not explicitly specified +link{listGrid.getArrowKeyEditAction()} 
    // will return an appropriate action depending on the field type.
    //
    //  @group  editing
    //  @visibility external
    //<
    


    //> @type ListGridEditEvent
    // Event that will trigger inline editing.
    //
    // @value "click"       A single mouse click triggers inline editing
    // @value "doubleClick" A double click triggers inline editing
    // @value "none"        No mouse event will trigger editing.  Editing must be
    //                      programmatically started via +link{listGrid.startEditing()}
    //                      (perhaps from an external button) or may be triggered by
    //                      keyboard navigation if +link{listGrid.editOnFocus} is set.
    //
    // @group editing
    // @visibility external
    //<

    //> @attr listGrid.editEvent (ListGridEditEvent : "doubleClick" : IRW)
    // Event that will trigger inline editing, see +link{type:ListGridEditEvent} for options.
    // <P>
    // Note this setting has no effect unless +link{canEdit} has been set to enable editing.
    // <P>
    // See also +link{editOnFocus} and +link{startEditing}.
    //
    // @group editing
    // @visibility external
    // @example editByRow
    //<
    editEvent:isc.EH.DOUBLE_CLICK,

    //> @attr listGrid.editOnFocus (boolean : null : [IRWA])
    // Should we start editing when this widget receives focus (if this ListGrid supports
    // editing)?
    // <P>
    // Note that this property being set to true will cause editing to occur on a single
    // click, even if +link{editEvent} is <code>"doubleClick"</code>, because single clicking
    // the grid will place keyboard focus there automatically.
    // <P>
    // If this property is set together with +link{listEndEditAction} being set to "next", 
    // users can create a new edit row in an empty grid by simply tabbing into the grid.
    //
    // @group editing
    // @visibility external
    //<
    // Note that +link{canFocusInEmptyGrid} must be set to <code>true</code> for this
    // to be supported.
    // Note - editOnFocus behavior is slightly more complicated than might be imagined. Actual
    // behavior:
    // - focus must go to the body (not the header) to start editing.
    // - if we are currently editing, getting focus will not trigger a new edit.
    // - if the focus is a result of clicking on the listGrid body, we will only start editing
    //   if the user clicked on an editable cell -- this is the same behavior as with
    //   editEvent:"click"
    // - otherwise when this widget receives focus, the first editable row will become editable.

    //> @attr listGrid.editOnF2Keypress (Boolean : true : [IRWA])
    // Should we start editing when the widget has focus and the user presses the "f2" key
    // (if this ListGrid supports editing)?
    // <P>
    // Note that if +link{listGrid.editEvent} is set to <code>"click"</code> or
    // <code>"doubleClick"</code>, the <code>Space</code> or <code>Enter</code> key may
    // also be used to start editing, depending on the value for +link{generateClickOnSpace},
    // +link{generateDoubleClickOnSpace}, +link{generateClickOnEnter} and
    // +link{generateDoubleClickOnEnter}.
    // <P>
    // If +link{listGrid.canEdit} is false, or +link{listGrid.editEvent} is set to "none" this
    // property has no effect.
    //
    // @group editing
    // @visibility external
    //<
    // Tested on:
    // FF 4.0.1 (Mac)
    // Chrome 11.0.696.77 (Mac)
    // Safari 5.0.5 (Mac)
    // IE 8 (XP)
    editOnF2Keypress:true,

    
    //> @attr listGrid.editOnKeyPress (boolean : null : [IRWA])
    // If set to true, when this grid has focus, if the user starts typing character keys
    // we'll start editing the focused cell.
    // @group editing
    // @visibility internal
    //<

    //> @attr listGrid.moveEditorOnArrow (boolean : null : [IRWA])
    // If +link{listGrid.editOnKeyPress, editOnKeyPress} is true, once the user starts editing
    // a cell by typing while focused in it, should left / right arrow keys cause the
    // edit cell to shift horizontally?
    // @group editing
    // @visibility internal
    //<
    

    //> @attr listGrid.selectOnEdit (Boolean : true : [IRWA])
    //  When the user starts editing a row, should the row also be selected?
    //  <P>
    //  See +link{listGrid.editSelectionType} for how edit-selection behaves.
    // @group editing
    // @visibility external
    //<
    selectOnEdit : true,

    //>@attr listGrid.editSelectionType (SelectionStyle : "single" : IRW)
    // If +link{listGrid.selectOnEdit} is true, what should be the edit-selection behavior
    // be?
    // <P>
    // Default setting of <code>"single"</code> will cause the edit row to be automatically
    // selected and any other selection in the grid to be dropped.<br>
    // If set to <code>"multiple"</code>, selection will be additive (as a record goes 
    // into edit mode, it is selected in addition to any pre-existant selection).
    // <P>
    // If set to <code>null</code> behavior is as follows:<ul>
    // <li>For grids with +link{listGrid.selectionType} set to
    // <code>"simple"</code> edit rows will be selected additively - this is the same
    // behavior as if the <code>editSelectionType</code> was <code>"multiple"</code></li>
    // <li>Otherwise edit rows will be selected singly - this is the same behavior as
    // if the <code>editSelectionType</code> was <code>"single"</code></li>
    // </ul>
    // @visibility external
    //<
     
    
    editSelectionType: "single",
    
    //> @attr listGridField.canToggle (Boolean : varies : IRWA)
    // Allows a boolean or +link{valueMap,valueMapped} field to be edited without going into
    // edit mode. When this attribute is set, clicking on the field will change the value - for
    // boolean fields toggling between <code>true</code> and <code>false</code>, and for valueMapped
    // fields, advancing the value to the next option in the valueMap.
    // <P>
    // To enable this feature, +link{listGrid.canEdit} must be set to true.
    // For boolean type fields <code>canToggle</code> is true by default, meaning setting
    // <code>canEdit</code> to true implies the user can toggle the value via a single click
    // without going into edit mode. You can disable this by explicitly setting
    // <code>canToggle</code> to false for a boolean field.<br>
    // Note that you can enable toggling only (without allowing the user to edit other fields)
    // by just setting +link{listGrid.editEvent,grid.editEvent:"none"}.
    // <P>
    // If +link{listGrid.editEvent} is set to "click", when the user clicks on the field,
    // the value will be toggled, and inline editing will be triggered as usual.
    // Otherwise the toggled value will be saved immediately to the server, or if
    // +link{listGrid.autoSaveEdits} has been set to false, will be stored as an edit value
    // for the record.
    //
    // @group editing
    // @visibility external
    //<

    //> @attr listGrid.enumCriteriaAsInitialValues (Boolean : true : IR)
    // In a ListGrid that has a DataSource and has filter criteria that include values for
    // fields declared as +link{type:FieldType,type "enum"} in the DataSource, by default a newly
    // edited row will use those filter criteria as initial values.
    // <P>
    // For example, if a ListGrid is showing all Accounts that have status:"Active" and a new row
    // is created, the new row will default to status:"Active" unless this flag is set to false.
    //
    // @group editing
    // @visibility external
    //<
    enumCriteriaAsInitialValues:true,

    //> @attr listGrid.application (Application : null : IRW)
    //      Application to use when saving edited values in a databound ListGrid
    //  @group  editing
    //<

    //> @attr listGrid.autoComplete (AutoComplete : null : IRW)
    // Whether to do inline autoComplete in text fields during inline editing<br>
    // Overridden by +link{ListGridField.autoComplete} if specified.
    // If unset picks up the default from the appropriate editor class (subclass of FormItem).
    //
    // @see listGridField.autoComplete
    // @group autoComplete
    // @visibility external
    //<
    //autoComplete:null,

    //> @attr listGrid.uniqueMatch (boolean : true : IRW)
    // When SmartClient autoComplete is enabled, whether to offer only unique matches to the
    // user.
    // <p>
    // Can be individually enabled per TextItem, or if set for the grid as a whole, can
    // be set differently for individual fields.
    //
    // @see listGridField.uniqueMatch
    // @group autoComplete
    // @visibility autoComplete
    //<

    // autoSelectEditors - if true when the user starts editing a cell always select the content
    // of the cell
    autoSelectEditors:true,
    // defaults for the form used for inline editing
    
    editFormDefaults: {
        
        canSelectText:true,
        autoDraw:false,
        // gotcha: if the user has e.g. enabled implicitSave on all DynamicForms, disable it
        // here because the various endEdit actions will then fire a duplicate save
        implicitSave: false,
        implicitSaveOnBlur: false,        
        // disable tabbing to icons by default
        // Overridden in the MiniDateRangeItem at the item level as there's no
        // focusable element except the picker for that item type
        
        canTabToIcons:false,

        // show error icons on the left by default
        errorOrientation:"left",
        showErrorText:false,
        showErrorStyle:false,
        
        itemKeyPress:function (item, keyName, characterValue) {
            return this.grid.editorKeyPress(item, keyName, characterValue);
        }
    },

    //> @attr listGrid.longTextEditorThreshold (int : 255 : IRW)
    // When the length of the field specified by +link{attr:dataSourceField.length} exceeds this
    // value, the ListGrid shows an edit field of type +link{attr:listGrid.longTextEditorType}
    // rather than the standard text field when the field enters inline edit mode.
    //
    // @group editing
    // @visibility external
    //<
    longTextEditorThreshold : 255,

    //> @attr listGrid.longTextEditorType (String : "PopUpTextAreaItem" : IRW)
    // When the length of the field specified by +link{attr:dataSourceField.length} exceeds
    // <code>this.longTextEditorThreshold</code> show an edit field of this type
    // rather than the standard text field when the field enters inline edit mode.
    //
    // @group editing
    // @visibility external
    //<
    longTextEditorType : "PopUpTextAreaItem",

    // functions installed into FormItems used for inline editing.
    // Note - these will be executed in the scope of the form item (not in the scope of the
    // ListGrid).
    //
    // Set up keyboard handling on form items to handle user navigation via "Enter", "Escape",
    // "Tab" keypresses, etc.
    //
    // NOTE: in Moz, if the user is holding down tab and we are cancelling the field change
    // *while logging to an open Log window*, we'll be stuck in the field indefinitely.  This
    // is probably a non-bug but can look like a freeze.
    //
    // row editing: Cancel tab to prevent focus cycling through the visible form items, since
    // for the first/last editable or visible item, we want to place focus in newly drawn
    // editors (on next/previous row, or just in newly drawn area that we scrolled into)
    editorKeyDown : function (item, keyName) {
        
        if (isc.Browser.isMoz && item && item.multiple &&
            isc.isA.NativeSelectItem(item) && keyName == "Enter")
        {
            item._selectedOnEnterKeydownSet = true;
            item._selectedOnEnterKeydown = item.getValue();
        }
    },

    isMultiLineEditor : function (item) {
        return item.getIsMultiLineEditor();
    },
    editorKeyPress : function (item, keyName, characterValue) {

        // We will return false to cancel native behavior on any key event for the keys
        // used for navigating around the edit cells (arrow keys, tab, etc.)
        var EH = isc.EH,
            returnValue,
            editEvent;

        var isMultiLineEditor =  this.isMultiLineEditor(item);
        
        
        if (keyName == "Enter") {
            // If the event occurred over an icon, we don't want to interfere with it, as
            // enter will activate the link (for accessibility)
            if (item.getFocusIconIndex() != null) return;

            // allow enter to work normally for text areas.  Alt + Enter overrides.
            if (isMultiLineEditor && isc.EH.altKeyDown() == false) {
                return returnValue;
            }
            if (item._selectedOnEnterKeydownSet) {
                var oldVal = item._selectedOnEnterKeydown;
                delete item._selectedOnEnterKeydown;
                delete item._selectedOnEnterKeydownSet;
                item.setValue(oldVal);
            }
            editEvent = isc.ListGrid.ENTER_KEYPRESS;
            returnValue = false;

        } else if (keyName == "Escape") {
            editEvent = isc.ListGrid.ESCAPE_KEYPRESS;
            returnValue = false;
    
        } else if (keyName == "Arrow_Up") {
        
            var action = this.getArrowKeyEditAction(item, keyName);
            if (action == "none") {
                return returnValue;
            }
            editEvent = isc.ListGrid.UP_ARROW_KEYPRESS;
            returnValue = false;

        } else if (keyName == "Arrow_Down") {
            var action = this.getArrowKeyEditAction(item, keyName);
            if (action == "none") {
                return returnValue;
            }

            editEvent = isc.ListGrid.DOWN_ARROW_KEYPRESS;
            returnValue = false;

        // if the user started editing via editOnKeyPress and the 'moveEditorOnArrow' flag is true
        // we shift cells on left/right arrow
        } else if (this.moveEditorOnArrow && this._editSessionFromKeyPress) {
            if (keyName == "Arrow_Left") {
                editEvent = isc.ListGrid.LEFT_ARROW_KEYPRESS;
                returnValue = false;
            } else if (keyName == "Arrow_Right") {
                editEvent = isc.ListGrid.RIGHT_ARROW_KEYPRESS;
                returnValue = false;
            }
        }

        if (editEvent != null) {
            
            
            if (isc.EH.clickMaskUp()) {
                isc.EH.setMaskedFocusCanvas(null, isc.EH.clickMaskRegistry.last());
            }

            // Fire cellEditEnd to handle saving out the value / moving to the next cell as
            // appropriate
            this.cellEditEnd(editEvent);
        }
        return returnValue;
    },
    
    //> @method listGrid.getArrowKeyEditAction()
    // How should "Up" and "Down" arrow keypresses be handled when the user is editing
    // an item in the grid.
    // <P>
    // Returning "none" will cause the grid to take no action and allow default up/down
    // arrow key behavior within the editor to proceed. Returning "editNext" will create
    // an appropriate +link{type:EditCompletionEvent} (<i>"arrow_up"</i> or
    // <i>"arrow_down"</i> and cause the grid to start editing the previous or next row).
    // <P>
    // Default behavior varies by item type. For items where up and down arrows have
    // significant functionality to the editor this method returns <i>"none"</i>, allowing
    // that standard behavior to proceed. This includes:<br>
    // - Multi line editors (such as TextAreaItems)<br>
    // - SelectItems<br>
    // - SpinnerItems<br>
    // For other items, the default return value will be <i>"edit_next"</i>
    // <P>
    // To override these defaults, developers may specify an explicit arrowKeyEditAction
    // at the +link{listGrid.arrowKeyEditAction,grid}, or 
    // +link{listGridField.arrowKeyEditAction,field} level.
    // @param item (FormItem) Edit item receiving the up or down arrow keypress event
    // @param keyName (KeyName) Key pressed (one of "Arrow_Up" or "Arrow_Down")
    // @return (ArrowKeyEditAction) action to take
    // @visibility external
    //<
    
    getArrowKeyEditAction : function (item, keyName) {
    
        var field = this.getField(item.name),
            arrowKeyAction = field.arrowKeyEditAction || this.arrowKeyEditAction;
        if (arrowKeyAction != null) return arrowKeyAction;
        
        var textArea = this.isMultiLineEditor(item);
        
        if (textArea && !isc.EH.altKeyDown()) arrowKeyAction = "none";
        else if (isc.isA.SpinnerItem(item) && !isc.EH.altKeyDown()) arrowKeyAction = "none";
        else if (isc.isA.SelectItem(item) && !isc.EH.ctrlKeyDown()) arrowKeyAction = "none";
        else if (isc.isA.PresetCriteriaItem(item) && !isc.EH.ctrlKeyDown()) arrowKeyAction = "none";
        else if (isc.EH.ctrlKeyDown() && isc.EH.shiftKeyDown()) arrowKeyAction = "none";
        else {
            arrowKeyAction = "editNext";
        }
        
        return arrowKeyAction;
        
    },

    
    // Override elementFocus on the form items:
    // If we're editing the whole row, and the user clicks in a new field to focus in it,
    // call 'editCellEnd' method to perform validation / saving on the previous
    // edit field (if required).
    
    _editFormItem_elementFocus : function (suppressHandlers) {
        var cell = this._setLGEditCellForFocus(suppressHandlers);
        this.Super("elementFocus", arguments);
        this._fireLGEditorEnter(cell[0], cell[1]);
    },
    _editFormItem_setLGEditCellForFocus : function (suppressHandlers) {

        

        var form = this.form,
            lg = form.grid;
        
        
        var rowNum, colNum, fieldName, fieldChanged;
        if (lg._editorShowing) {
            rowNum = lg._editRowNum;
            if (!lg.editByCell) {
                rowNum = lg._editRowNum;
                fieldName = this.getFieldName();
                colNum = lg.fields.findIndex(lg.fieldIdProperty, fieldName);

                if (!suppressHandlers) {
                    fieldChanged = (lg._editColNum != colNum);
                    // If the user has clicked in another field in the edit form,
                    // fire editField on the appropriate field
                    if (fieldChanged) {
                    // store the new edit cell
                        lg.setNewEditCell(rowNum, colNum);
                    // fire 'cellEditEnd' to save / validate before moving to the new cell
                        lg.cellEditEnd(isc.ListGrid.EDIT_FIELD_CHANGE);

                    // Note - if we could cancel the focus here, it might make sense, as the
                    // cellEditEnd callback method will re-focus in the new focus cell, but we can't
                    // cancel the focus by simply returning false from this method.
                    // Therefore allow the focus to proceed, and fall through to the super
                    // implementation of this method which will fire focus handlers, show any
                    // 'showOnFocus' icons, etc.
                    }
                }
            } else {
                colNum = lg._editColNum;
            }
        }
        return [rowNum, colNum];
    },
    _editFormItem_fireLGEditorEnter : function (rowNum, colNum) {
        var form = this.form,
            lg = form.grid;

        if (lg._editorShowing) {
            // If this is the current edit field, and hasn't yet fired its 'editorEnter' handlers
            // fire them now.
            var rowEnter = this._rowEnterOnFocus,
                cellEnter = this._cellEnterOnFocus;
            // Note: we're clearing out the flags before we fire the handlers. If the
            // handler trips a change of edit row, etc., we want editorExit to fire.
            delete this._rowEnterOnFocus;
            delete this._cellEnterOnFocus;

            
            var editVals = isc.addProperties(
                {},
                lg.getCellRecord(rowNum,colNum),
                lg._getEditValues(rowNum,colNum)
            );

            if (cellEnter) {
                var fieldName = lg.getFieldName(colNum);
                lg._handleEditorEnter(this, rowNum, colNum, editVals[fieldName]);
            }
            if (rowEnter) lg._handleRowEditorEnter(this, rowNum, editVals);

        } else {
            lg.logWarn("suppressing editorEnter handlers on focus as listGrid._editorShowing is null");
        }
    },


    // Header
    // ----------------------------------------------------------------------------------------

    //> @groupDef gridHeader
    // Properties and methods related to the ListGrid header. ListGrid headers are implemented
    // as a +link{class:Toolbar} of buttons shown at the top of the ListGrid
    // (one button per column).<br>
    // The toolbar header provides UI for interacting with the ListGrid fields directly (sorting,
    // resizing, reordering columns, etc).
    // @visibility external
    //<

    //> @attr listGrid.header (AutoChild Layout : null : R)
    // A Toolbar used to manager the headers shown for each column of the grid.
    // @group gridHeader
    // @visibility external
    //<

    //> @attr listGrid.headerContextMenu (AutoChild Canvas : null : R)
    // The context menu displayed for column headers.
    // @group gridHeader
    // @visibility external
    //<

    //> @attr listGrid.cellContextMenu (AutoChild Layout : null : R)
    // The menu displayed when a cell is right clicked on.
    // @visibility external
    //<

    //> @attr listGrid.spanContextMenu (AutoChild Layout : null : R)
    // The menu displayed when a cell is right clicked on.
    // @group gridHeader
    // @visibility external
    //<

    //> @attr listGrid.canTabToHeader (boolean : null : IR)
    // Should the header be included in the tab-order for the page? If not explicitly specified,
    // the header will be included in the tab order for the page if 
    // <smartclient>+link{isc.setScreenReaderMode,isc.setScreenReaderMode()}</smartclient> 
    // <smartgwt>
    // {@link com.smartgwt.client.util.SC#setScreenReaderMode SC.setScreenReaderMode()}
    // </smartgwt>
    // is called.
    // @group accessibility
    // @visibility external
    //<
    //canTabToHeader:null,

    //> @attr listGrid.canTabToSorter (Boolean : false : IR)
    // Should the +link{listGrid.sorterConstructor,corner sort button} be included in the 
    // tab-order for the page? 
    // @group accessibility
    // @visibility external
    //<
    canTabToSorter:false,

    //> @attr listGrid.headerHeight (number : 22 : [IRW])
    //          The height of this listGrid's header, in pixels.
    //      @setter setHeaderHeight()
    //      @visibility external
    //      @group  gridHeader, sizing
    //<
    // Note: we treat a headerHeight of zero as an equivalent of showHeader:false
    headerHeight:22,

    //> @attr listGrid.minFieldWidth (int : 15 : IRW)
    // Minimum size, in pixels, for ListGrid headers.
    // @visibility external
    //<
    minFieldWidth:15,

    //> @attr listGrid.showHeader (Boolean: true : [IRW])
    // Should we show the header for this ListGrid?
    // @group gridHeader, appearance
    // @visibility external
    //<
    showHeader:true,

    //> @attr listGrid.headerBarStyle (CSSStyleName : null : IR)
    // Set the CSS style used for the header as a whole.
    // @group   gridHeader, appearance
    // @visibility external
    //<
    //headerBarStyle:null,

    //> @attr listGrid.headerBackgroundColor (CSSColor: "#CCCCCC" : IRW)
    // BackgroundColor for the header toolbar. Typically this is set to match the color
    // of the header buttons.
    //      @group  gridHeader, appearance
    // @visibility external
    //<
    headerBackgroundColor:"#CCCCCC",
    
    // We want to support a drop shadow under the header.
    // Only supported for css-based headers as we don't want peers floating around
    // in the LG children.
    // We can't use headerDefaults directly for this as if we have frozen cols the
    // shadow should apply to the headerLayout, not the header itself.
    
    
    //> @attr listGrid.showHeaderShadow (Boolean : false : IRW)
    // Should the header show a drop-shadow?
    // Shadow will be applied to the header, or for a grid with frozen columns, the
    // header layout. 
    // <P>
    // Header shadow will only be displayed if +link{canvas.useCSSShadow,css shadows} are
    // being used.
    // @see listGrid.headerShadowVOffset
    // @see listGrid.headerShadowHOffset
    // @see listGrid.headerShadowSoftness
    // @see listGrid.headerShadowColor
    // @visibility external
    //<
    showHeaderShadow:false,

    //> @attr listGrid.headerShadowVOffset (Number : 1 : IRA)
    // If +link{listGrid.showHeaderShadow} is true, the +link{canvas.shadowVOffset} for
    // the header shadow
    // @visibility external
    //<
    headerShadowVOffset:1,

    //> @attr listGrid.headerShadowHOffset (Number : 0 : IRA)
    // If +link{listGrid.showHeaderShadow} is true, the +link{canvas.shadowHOffset} for
    // the header shadow
    // @visibility external
    //<    
    headerShadowHOffset:0,
    
    //> @attr listGrid.headerShadowSoftness (Number : 1 : IRA)
    // If +link{listGrid.showHeaderShadow} is true, the +link{canvas.shadowSoftness} for
    // the header shadow
    // @visibility external
    //<
    headerShadowSofness:1,

    //> @attr listGrid.headerShadowColor (CSSColor : null : IRA)
    // If +link{listGrid.showHeaderShadow} is true, the +link{canvas.shadowColor} for
    // the header shadow.
    // @visibility external
    //<
    // Unset by default - rely on standard skin shadow color

    headerDefaults : {

        // immediately reposition headers during drag resizing, don't delay
        instantRelayout:true,
        // when the user resizes buttons, don't try to fit them into the available space -
        // allow the user to introduce hscrolling
        enforcePolicy:false,
        
        // force createButtonsOnInit to false in case a dev sets it to true globally
        createButtonsOnInit: false,

        // when the header is clicked, have it call headerClick() on us
        itemClick : function (button, buttonNum) {
            this.Super("itemClick",arguments);
            this.grid._headerClick(buttonNum, this);
        },

        itemDoubleClick : function (button, buttonNum) {
            this.Super("itemDoubleClick", arguments);
            this.grid._headerDoubleClick(buttonNum, this);
        },

        showContextMenu : function () {
            return this.grid.headerBarContextClick(this);
        },

        // can a reorder-dragged field from revertPos be dropped at position?
        
        _canReorderDrop : function (position, revertPos) {
            var grid = this.grid,
                spanMap = grid.spanMap;
            if (!spanMap) return false;
            
            var fields = grid.fields,
                field = fields[position];
            if (!field) return false;

            // check whether field is being dropped after the last span field, or before the
            // first, depending on whether we're dragging to the right or left, respectively
            
            var dropAfter = revertPos < position;
            for (var lastSpan, span = spanMap[field.name]; span != null; 
                 lastSpan = span, span = span.parentSpan)
            {
                
                if (span.canReorder == false) return false;

                // deepest span has a field array, parent spans have span arrays
                var fields = span.fields;
                if (fields) {
                    // we're only intereested in visible fields, so exclude those hidden
                    
                    var fieldMap = grid._getFieldMap();
                    fields = fields.filter(function (id) {return fieldMap[id];});
                    if (field.name != (dropAfter ? fields.last() : fields.first())) {
                        return false;
                    }
                } else {
                    // skip spans not visible due to them containing only hidden fields
                    var spans = span.spans.filter(function (span) {return span.liveObject;});
                    if (lastSpan != (dropAfter ? spans.last() : spans.first())) {
                         return false;
                    }
                }
            }
            return true;
        },

        backgroundRepeat:isc.Canvas.NO_REPEAT,

        // don't print the header, we handle this as part of the body instead, to ensure column
        // alignment
        shouldPrint:false,

        // Override focusInNextButton() - when the user is navigating through buttons
        // with the arrow keys we want to allow them to cross from the frozen to unfrozen
        // headers and vice-versa
        _focusInNextButton : function (forward, startingIndex) {
            var movedWithinToolbar = this.Super("_focusInNextButton", arguments);
            if (!movedWithinToolbar && this.grid && this.grid.frozenFields) {
                if (forward == null) forward = true;
                return this.grid._focusInNextHeader(this, forward);
            }
            return movedWithinToolbar;
        }

    },

    //> @attr listGrid.headerButtonConstructor (Class : null : IR)
    // Widget class for this ListGrid's header buttons. If unset, constructor will be
    // picked up directly from the standard +link{class:Toolbar} button constructor.
    // @group   gridHeader, appearance
    // @visibility external
    //<

    //> @attr listGrid.headerBaseStyle (CSSStyleName : null : IR)
    // +link{Button.baseStyle} to apply to the buttons in the header, and the sorter, for
    // this ListGrid.
    // Note that, depending on the +link{listGrid.headerButtonConstructor, Class} of the header
    // buttons, you may also need to set +link{listGrid.headerTitleStyle}.
    // @group gridHeader, appearance
    // @see group:skins
    // @see clipHeaderTitles
    // @see wrapHeaderTitles
    // @visibility external
    //<

    //> @attr listGrid.headerTitleStyle (CSSStyleName : null : IR)
    // +link{StretchImgButton.titleStyle} to apply to the buttons in the header, and the sorter,
    // for this ListGrid.
    // Note that this will typically only have an effect if
    // +link{listGrid.headerButtonConstructor} is set to +link{class:StretchImgButton} or a subclass
    // thereof.
    // @group   gridHeader, appearance
    // @visibility external
    //<

    //> @attr listGrid.frozenHeaderBaseStyle (CSSStyleName : null : IR)
    // If this listGrid contains any frozen fields, this property can be used to apply a custom
    // headerBaseStyle to the frozen set of fields. If unset, the standard headerBaseStyle
    // will be used for both frozen and unfrozen cells.
    // @visibility external
    // @group gridHeader, appearance, frozenFields
    // @see listGrid.headerBaseStyle
    // @see listGridField.frozen
    //<

    //> @attr listGrid.frozenHeaderTitleStyle (CSSStyleName : null : IR)
    // If this listGrid contains any frozen fields, this property can be used to apply a custom
    // headerTitleStyle to the frozen set of fields. If unset, the standard headerTitleStyle
    // will be used for both frozen and unfrozen cells.
    // @visibility external
    // @group gridHeader, appearance, frozenFields
    // @see listGrid.headerTitleStyle
    // @see listGridField.frozen
    //<

    // Helper called from syntheticShiftFocus on header buttons. This allows us to
    // skip over the frozen / unfrozen header buttons in the page's tab order if 
    // canTabToHeader is true
    // When a button gets focus we'll remember which header it was in and then skip over the
    // other header unless a user explicitly puts focus into it via arrow-keys or clicking
    
    skipHeaderButtonFocus : function (headerButton) {
        if (headerButton.parentElement.tabWithinToolbar) return false;

        if (this.lastFocusHeader != null && this.lastFocusHeader != headerButton.parentElement) {
            return true;
        }
        return false;
    },

    headerButtonFocusChanged : function (headerButton, hasFocus) {
        if (hasFocus) this.lastFocusHeader = headerButton.parentElement;
    },

    // This method is called from header / frozenHeader.focusInNextButton() when the user
    // has hit left/right arrows to the end of the header.
    // If appropriate we'll jump focus to the first button in the next header.
    _focusInNextHeader : function (header, forward) {
        if (this.frozenFields) {
            var nextHeader = forward ? this.header : this.frozenHeader;
            if (nextHeader != header) {
                var buttons = nextHeader.getMembers(),
                    focusIndex = forward ? 0 : buttons.length-1,
                    step = forward ? 1 : -1,
                    end = forward ? -1 : buttons.length;

                while (focusIndex != end) {
                    var button = buttons[focusIndex]; 
                    if (button._canFocus()) {
                        button.focus();
                        // Returning true will indicate successful shift of focus
                        return true;
                    }
                    focusIndex += step;
                }
            }
        }
        return false;
    },

    //> @attr listGrid.headerButtonDefaults (Button Properties: {...} : IRA)
    // Defaults to apply to all header buttons. To modify this object,
    // use +link{class.changeDefaults(), ListGrid.changeDefaults()}
    // rather than replacing with an entirely new object.
    // @group   gridHeader, appearance
    // @visibility external
    //<
    headerButtonDefaults:{
        clipTitle: true,

        syntheticShiftFocus : function () {
            var grid = this.parentElement ? this.parentElement.grid : null;
            if (grid && grid.skipHeaderButtonFocus(this)) return false;
            return this.Super("syntheticShiftFocus", arguments);
        },

        focusChanged : function () {
            var grid = this.parentElement ? this.parentElement.grid : null;
            if (grid) {
                grid.headerButtonFocusChanged(this, this.hasFocus);
            }
            
            if (this.hasFocus && this.parentElement && this.parentElement._updateFocusButton) {
                this.parentElement._updateFocusButton(this)
            }
        },

        // override getCurrentCursor to show default (non pointer) for canSort:false fields
        getCurrentCursor : function () {
            var grid = this.parentElement ? this.parentElement.grid : null;
            var currentCursor = isc.Canvas.DEFAULT;
            if (grid && this.masterIndex != null) {
                var field = grid.getField(this.masterIndex),
                    canSort = grid._canSort(field) != false;
                if (canSort) currentCursor = isc.Canvas.HAND;
            } else {
                if (this.isSorterButton) {
                    if (!grid && isc.isA.ListGrid(this.parentElement)) grid = this.parentElement;
                    if (grid) {
                        var canSort = grid._canSort(grid._getSortFieldNum()) != false;
                        if (canSort) currentCursor = isc.Canvas.HAND;
                    }
                } else {
                    currentCursor = this.getClass().getPrototype().cursor;
                }
            }
            this.cursor = currentCursor;
            return this.Super("getCurrentCursor", arguments);
        },

        
        _getVPadding : function () {
            if (this._cachedVPadding != null) return this._cachedVPadding;

            // Determine the padding size from the DOM.
            var top, bottom,
            pxString = isc.px;

            // if it's drawn, examine the style of the drawn HTML element first
            if (this.isDrawn()) {
                var element = this._getCellElement();
                if (element) {
                    top    = isc.Element.getTopPaddingSize(element);
                    bottom = isc.Element.getBottomPaddingSize(element);
                }
            }

            var className = this.getStateName();
            if (className) {
                if (!isc.isA.Number(top))    top    = isc.Element._getTopPadding(className);
                if (!isc.isA.Number(bottom)) bottom = isc.Element._getBottomPadding(className);
            }

            if (!isc.isA.Number(top))    top    = 0;
            if (!isc.isA.Number(bottom)) bottom = 0;

            return this._cachedVPadding = top + bottom;
        },

        dragScrollType:"parentsOnly",
        minWidth:20,
        hoverDelay:500
    },

    //> @attr listGrid.headerButtonProperties (Button Properties: null : IRA)
    // Properties to apply to all header buttons.
    // Overrides defaults applied via  +link{ListGrid.headerButtonDefaults}.
    // @group   gridHeader, appearance
    // @visibility external
    //<

    //> @attr listGrid.clipHeaderTitles (Boolean : varies : IRA)
    // Whether the ListGrid should manage the clipping of titles of header buttons, showing
    // ellipses if the title is clipped, and potentially showing the full title
    // on +link{listGrid.showClippedHeaderTitlesOnHover,hover}.
    // <p>
    // In some cases this may be preferable to the button component's default clipping behavior
    // because if a +link{ListGrid.showSortArrow,sort arrow} or sort numeral is displayed for
    // a header, then the button's default clipping behavior may clip the sort arrow/numeral
    // whereas ListGrid-managed title clipping utilizes special HTML which keeps the sort
    // arrow/numeral visible.
    // <p>
    // This feature is automatically enabled if supported by the browser. The only supported
    // use of this attribute is to <em>disable</em> the feature by setting clipHeaderTitles
    // to false.
    // <P>
    // Note that this feature is incompatible with +link{listGridField.wrap}, and will
    // automatically be disabled for wrapping fields.
    // 
    // @see headerBaseStyle
    // @group gridHeader, appearance
    // @visibility external
    //<
    
    
    clipHeaderTitles: (!isc.Browser.isIE ||
                       (isc.Browser.version > 6 && isc.Browser.isStrict) ||
                       isc.Browser.version >= 10),

    //> @attr listGrid.wrapHeaderTitles (Boolean : null : IR)
    // If +link{listGridField.wrap} is not explicitly set, should fields wrap?  If autofitting,
    // see the docs on that property for the details of how the minimum width for a field is
    // determined.
    // 
    // @see minFieldWidth
    // @see headerBaseStyle
    // @visibility external
    //<
    

    //> @attr listGrid.rotateHeaderTitles (Boolean : null : IR)
    // Whether to rotate the field titles so they're rendered vertically from bottom to top.
    // Can be overridden for individual fields by setting +link{listGridFIeld.rotateTitle}.
    // <P>
    // Note that you can manually set the header height and field widths as you please when
    // using this feature, but it's not compatible with +link{autoFitHeaderHeights} or
    // autofitting of field widths in any +link{AutoFitWidthApproach} other than "value".
    // <P>
    // You can use +link{headerTitleVAlign} or +link{listGridField.valign} to control vertical
    // positioning of the titles, and +link{listGridField.align} to control the horizontal.
    // You may also choose between +link{clipHeaderTitles,clipping} or 
    // +link{wrapHeaderTitles,wrapping}, and set +link{showHeaderMenuButton} as you please
    // (which reserves space in each header button for the header menu button).
    // <P>
    // Note that this feature is incompatible with clipping via +link{clipHeaderTitles}:false,
    // and may not work with older browsers, particular IE versions before IE10.  The
    // "TreeFrog" and "Basic" +link{group:skins,skins} are not supported for this feature.
    //
    // @see headerTitleVAlign
    // @see listGridFIeld.valign
    // @see listGridField.rotateTitle
    // @example rotatedTitles
    // @visibility external
    //<

    //> @attr listGrid.headerTitleVAlign (VerticalAlignment : null : IR)
    // Specifies vertical alignment in the column headers: "top", "center", or "bottom".  Can 
    // be overridden for individual fields by setting +link{listGridField.valign}.
    // <p>
    // When using +link{rotateHeaderTitles,rotated titles}, this attribute defaults to "bottom"
    // if it remains unset.
    // @see listGridFIeld.valign
    // @see rotateHeaderTitles
    // @see listGridField.rotateTitle
    // @visibility external
    //<
    //headerTitleVAlign: isc.Canvas.BOTTOM,

    //> @attr listGrid.wrapHeaderSpanTitles (Boolean : null : IR)
    // If +link{headerSpan.wrap} is not explicitly set, should fields wrap?  If autofitting,
    // see the docs on that property for the details of how the minimum width for a field is
    // determined.
    // 
    // @see minFieldWidth
    // @visibility external
    //<
    

    //> @attr listGrid.sorterConstructor (Class : Button : IR)
    // Widget class for the corner sort button, if showing.  This button displays the current
    // sort direction of the primary sort field (either the only sorted field or the first in a
    // +link{listGrid.canMultiSort, multi-sort} grid) and reverses the direction of that field
    // when clicked.  For consistent appearance, this
    // is usually set to match +link{listGrid.headerButtonConstructor}
    // @group gridHeader, appearance
    // @visibility external
    //<
    sorterConstructor:isc.Button,
    

    //> @attr listGrid.sorterButtonTitle (String : "corner menu" : IR)
    // The title for the corner sort button.  The title will only
    // +link{Class.changeDefaults(), ListGrid.changeDefaults()} rather than replacing with an
    // entirely new object.
    // @group i18nMessages, gridHeader, appearance
    // @visibility external
    //<
    sorterButtonTitle: "corner menu",

    //> @attr listGrid.sorterDefaults (Object : {...} : IRA)
    // Defaults to apply to the corner sort button. To modify this object, use
    // +link{Class.changeDefaults(), ListGrid.changeDefaults()} rather than replacing with an
    // entirely new object.
    // @group gridHeader, appearance
    // @visibility external
    //<
    sorterDefaults:{
        _redrawWithParent:false,
        getTitle : function () {
            if (this.creator.loadingData && !this.creator.isEmpty()) {
                return isc.Canvas.imgHTML(isc.Canvas.loadingImageSrc);
            } else {
                return this.creator.getSortArrowImage();
            }
        },
        click : function () { return this.creator._sorterClick() },
        showContextMenu : function() { return this.creator._sorterContextClick() },
        isSorterButton: true,
        allowFilterOperators: false,
        align: "center"
    },

    //> @attr listGrid.sorterProperties (Button Properties: null : IRA)
    // Properties to apply to the sorter button. Overrides defaults applied via
    // +link{ListGrid.sorterDefaults}.
    // @group gridHeader, appearance
    // @visibility external
    //<

    // Sorting
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.sortByGroupFirst (Boolean : null : [IRW]) 
    // If set, whenever grouping is performed by an end user or by a programmatic call to 
    // +link{groupBy()}, data is implicitly sorted by all of the grouped columns, in the order 
    // they were passed to groupBy. Any user-configured sorting is applied after sorting by 
    // grouped columns.
    // <p>
    // Sorting by grouped fields will be in ascending or descending order according to whether 
    // the grid is currently sorted (by any field) in ascending or descending order, defaulting 
    // to ascending if the grid is not sorted. Implicit sorting by group can be forced to be 
    // always ascending or always descending by setting +link{groupSortDirection}.
    // <p>
    // The sorting is "implicit" in the sense that the sorting is not shown in the ListGrid 
    // headers, and not shown in the +link{multiSortDialog} if enabled.  An end user cannot 
    // currently remove the implicit sorting themselves (except by removing the grouping), 
    // though it is possible to override it by providing an explicit sort on the group's column.
    // Clicking on the grouped field's header reveals the usual sort indicators with all
    // the same semantics.
    // <p>
    // The correct way to remove implicit sorting programmatically is to call 
    // +link{setSortByGroupFirst(),setSortByGroupFirst(false)}.
    // <p>
    // Programmatic calls to +link{getSort()} will not include the implicit sort in 
    // the list of return sort specifiers, and calls to +link{setSort()} will implicitly add 
    // the sorting by grouped columns before the specified sort.
    // <p>
    // Note that directly calling ResultSet.getSort() will include the implicit sort 
    // information.
    // 
    // @group sorting, grouping
    // @see groupSortDirection
    // @see groupSortNormalizer
    // @visibility external
    //<

    //> @attr listGrid.groupSortDirection (SortDirection : null : [IRW]) 
    // When +link{sortByGroupFirst} is active, the sorting direction applied for implicit 
    // sorting by the field(s) used for grouping. Default of null means that sort direction 
    // is based on the current direction of user-configured sort, or is "ascending" if the 
    // user has not sorted the data.
    //
    // @group sorting, grouping
    // @see sortByGroupFirst
    // @see groupSortNormalizer
    // @see SortSpecifier.direction
    // @visibility external
    //<

    //> @method listGrid.groupSortNormalizer()
    // When +link{sortByGroupFirst} is active, the sorting 
    // +link{SortSpecifier.normalizer,normalizer} applied for implicit sorting by the field(s)
    // used for grouping.
    // <P>
    // No default implementation.
    //
    // @param record  (ListGridRecord)  record to normalize
    // @param fieldName    (FieldName)  name of the field on which sorting occurred
    // @param context       (ListGrid)  the grid is passed to allow property and method access
    // @return (Any)  normalized value for sorting
    // @group sorting, grouping
    // @see sortByGroupFirst
    // @see groupSortDirection
    // @see SortSpecifier.normalizer
    // @example customGroupSorting
    // @visibility external
    //<

    //> @attr listGrid.sortBinaryByFileName (boolean : true : [IRW])
    // For any fields of +link{FieldType,type "binary"}, should sorting be performed
    // against the fileName of the value for the field? For SmartClient server backed
    // dataSources, this is applied to the record automatically as described in the
    // +link{group:binaryFields} overview.
    // <P>
    // If set to false, binary fields will be sorted against the record value for the
    // field in question. Client-side sorting does not support this, so developers who
    // actually want to support a sort against the binary itself would typically set
    // +link{resultSet.useClientSorting} to false on the +link{dataProperties} block for
    // this grid.
    // <P>
    // Note that this setting will have no effect if +link{dataSourceField.sortByField} is
    // specified
    // @group sorting
    // @visibility external
    //<
    sortBinaryByFileName:true,    
    
    //> @attr listGrid.canSort (Boolean : true : [IRW])
    // Enables or disables interactive sorting behavior for this listGrid. Does not
    // affect sorting by direct calls to the +link{listGrid.sort, sort} or
    // +link{listGrid.setSort, setSort} methods.
    //
    // @group sorting
    // @visibility external
    //<
    canSort:true,

    //> @attr listGrid.canUnsort (boolean : false : [IRW])
    // When set to true, the third click on a column header removes the sort indicator
    // from the field.
    //
    // @group sorting
    // @visibility internal
    //<
    canUnsort:false,

    //> @attr listGrid.invalidateCacheOnUnsort (boolean : false : [IRW])
    // If true, and +link{listGrid.canUnsort} is also true and the grid is databound to a
    // +link{ResultSet}, then unsort causes the grid to drop the current client-side
    // data cache and refetch the current range of records from the server.
    //
    // @group sorting
    // @visibility internal
    //<
     
    invalidateCacheOnUnsort: false,

    //> @attr listGrid.selectHeaderOnSort (Boolean : true : [IRW])
    // If true, show the field-header for the sorted field (or the first field in a
    // +link{listGrid.canMultiSort, multi-sort} grid) in the selected state.
    //
    // @group sorting
    // @visibility external
    //<
    selectHeaderOnSort: true,

    //> @attr listGrid.sortFieldNum (number : null : [IRW])
    // Specifies the number of the field by which to sort this listGrid. Column numbers
    // start at 0 for the left-most column.
    // @group sorting
    // @example sort
    // @visibility external
    // @deprecated as of version 7.0 in favor of +link{listGrid.sortField}
    //<
    //sortFieldNum:null,

    //> @attr listGrid.sortField (String | int : null : IR)
    // Specifies the field by which this grid should be initially sorted. Can be set to either a
    // +link{listGridField.name,field name} or the index of the field in the fields Array.
    // <P>
    // ListGrids also support being initialized with multiple-field sort via
    // +link{listGrid.initialSort}. If initialSort is specified, it will be used in preference
    // to this property.
    // <P>
    // To sort the grid after it has been initialized, use +link{ListGrid.sort()} or
    // +link{listGrid.setSort()}. Details about the current sort of a live grid can be
    // retrieved by calling +link{listGrid.getSortField()} or +link{listGrid.getSort()}
    //
    // @group sorting
    // @example sort
    // @visibility external
    //<

    //> @attr listGrid.keyboardClickField (String | number : null : [IRW])
    // When simulating click events listGrid rows as a result of keyboard events
    // (navigating using the arrow keys, space, enter for doubleClick), which column
    // should the event be generated upon?
    // Should be set to the name or index of the desired column.
    // If null, defaults to the first column where +link{listGridField.ignoreKeyboardClicks}
    // is not false.
    // @group  events
    //<
    // If +link{listGrid.screenReaderNavigateByCell} is true, this property is updated 
    // dynamically to track which column has focus

    //> @attr listGrid.sortDirection (SortDirection : "ascending" : [IRW])
    // Sorting direction of this ListGrid. If specified when the ListGrid is initialized,
    // this property will be the default sorting direction for the +link{listGrid.sortField}.
    // May be overridden by specifying +link{ListGridField.sortDirection}.
    // <P>
    // After initialization, this property will be updated on +link{ListGrid.sort()} or
    // +link{ListGrid.setSort()} to reflect the current sort direction of the grid. When
    // this grid is sorted by multiple fields, the grid's sortDirection reflects the
    // sort direction of the primary sort field.
    // @group  sorting
    // @see type:SortDirection
    // @example sort
    // @setter sort()
    // @visibility external
    //<
    
    sortDirection: "ascending",

    //> @attr listGrid.showSortArrow (SortArrow : null : [IRW])
    // Indicates whether a sorting arrow should appear for the listGrid, and its
    // location. See +link{SortArrow} for details.
    // <P>
    // Clicking the sort arrow reverses the direction of sorting for the current sort
    // column (if any), or sorts the listGrid by its first sortable column. The arrow
    // image on the button indicates the current direction of sorting.
    // If undefined, the sort arrow will show up in the sorted field, and the
    // corner sort button will be displayed if a vertical scrollbar is being displayed
    //
    // @group sorting, appearance
    // @visibility external
    //<
    
    //showSortArrow:null,

    

    //> @attr listGrid.sortArrowMenuButtonSpaceOffset (int : 7 : [IRW])
    // When +link{leaveHeaderMenuButtonSpace} is true, configures the amount of space beyond the
    // +link{headerMenuButtonWidth} on the right side of a ListGrid header button (left for
    // +link{Page.isRTL(),RTL mode}) to reserve for the sort arrow if sorting is active for
    // that field and the arrow will be shown.  May be increased for more separation between
    // the sort arrow and the title text, at the expense of a reduced space for the title text.
    // <P>
    // This value may need to be customized in your skin or if +link{sortAscendingImage} or 
    // +link{sortDescendingImage} are changed.
    //
    // @see sortNumeralMenuButtonSpaceOffset
    // @visibility external
    //<
    sortArrowMenuButtonSpaceOffset : 7,

    //> @attr listGrid.sortNumeralMenuButtonSpaceOffset (int : 9 : [IRW])
    // When +link{leaveHeaderMenuButtonSpace} is true, configures the amount of space beyond the
    // +link{headerMenuButtonWidth} on the right side of a ListGrid header button (left for
    // +link{Page.isRTL(),RTL mode}) to reserve for the sort numeral if 
    // +link{canMultiSort,multi-sorting} is active for that field and the numeral will be shown.
    // May be increased for more separation between the title text and the sort arrow when 
    // multi-sorting.  
    // <P>
    // Note that larger values may required if 10 or more fields are sorted at once, as the
    // numeral will occupy more space.  This value may need to be customized in your skin or if
    // +link{sortAscendingImage} or +link{sortDescendingImage} are changed.
    //
    // @see sortArrowMenuButtonSpaceOffset
    // @visibility external
    //<
    sortNumeralMenuButtonSpaceOffset : 9,

    //> @attr listGrid.canPickFields (Boolean : true : [IRW])
    // Indicates whether the field picker item and submenu should be present in the header
    // context menu. This menu allows the user to hide visible fields and show hidden fields.
    // <p>
    // By default only fields explicitly included in the +link{listGrid.fields} array will
    // be available in this menu, unless +link{listGrid.canPickOmittedFields} is set to true for
    // a databound grid.
    // <p>
    // A specific field can be omitted from the column picker via +link{listGridField.canHide}.
    //
    // @visibility external
    //<
    canPickFields: true,

    //> @attr listGrid.canPickOmittedFields (Boolean : false : [IR])
    // If this grid has a specified +link{listGrid.dataSource}, and
    // +link{listGrid.useAllDataSourceFields} is false, setting this property to true
    // will cause all dataSource fields not included in the specified set of fields to
    // show up in the +link{listGrid.canPickFields,field picker menu item}.
    // <P>
    // Has no effect if +link{listGrid.fields} is unset (as in this case all dataSource fields
    // will be displayed by default), or if +link{listGrid.canPickFields} is false.
    // @visibility external
    //<
    canPickOmittedFields:false,

    // Frozen Fields (aka Frozen Columns)
    // ---------------------------------------------------------------------------------------

    //> @groupDef frozenFields
    // Frozen fields are fields that do not scroll horizontally with other fields, remaining on
    // the screen while other fields may be scrolled off.  This feature is typically used to
    // allow basic identifying information (like an "accountId") to remain on screen while the
    // user scrolls through a large number of related fields.
    // <P>
    // Fields can be programmatically frozen via setting
    // +link{listGridField.frozen,field.frozen} to true when the grid is created, or
    // dynamically frozen and unfrozen via +link{listGrid.freezeField(),freezeField()} and
    // +link{listGrid.unfreezeField,unfreezeField()}.
    // The setting +link{listGrid.canFreezeFields,canFreezeFields} enables a user interface to
    // allow end users to dynamically freeze and unfreeze fields.
    // <P>
    // The frozen fields feature is not compatible with the following features:
    // <ul>
    // <li> +link{autoFitData}:"horizontal", as well as headers that autoFit to titles
    //      (normally enabled via <code>field.overflow:"visible"</code>)
    // <li> the +link{CubeGrid} subclass of ListGrid
    // <li> nested grids
    // </ul>
    // The frozen fields feature <b>is</b> compatible with column resize and reorder, selection
    // and multi-selection, loading data on demand, inline editing, drag and drop and reorder
    // of records, the +link{TreeGrid} subclass of ListGrid, and all dynamic styling-related and
    // formatting-related features.
    // <P>
    // The +link{listGrid.frozenFieldsMaxWidth} property may be used to specify a maximum
    // size for the frozen fields. If their combined width exceeds this, a 
    // horizontal scrollbar will be displayed, allowing the user to scroll the frozen
    // fields independently of the other fields in the grid.
    // <P>
    // Troubleshooting tip: If you encounter misalignment between rows in frozen and unfrozen 
    // columns, this is likely due to one of the following causes:
    // <ul><li>Inconsistent border/padding: all cells in a row in a table must have the same
    //     top and bottom border thickness, and all cells in a column must have the same 
    //     horizontal border and padding width, or the table is invalid, 
    //     with no clear rules for rendering it.  The HTML/CSS spec doesn't say what to 
    //     do in this situation, and browser engines behave inconsistently.</li>
    // <li>For grids with +link{listGrid.fixedRecordHeights,fixedRecordHeights:true}, the cell contents,
    //     inclusive of border and padding, needs to be less than your configured 
    //     +link{listGrid.cellHeight}, or you need to set +link{listGrid.enforceVClipping} to cause us 
    //     to clip it as necessary. Breaking this rule can cause misalignment between rows in
    //     frozen and unfrozen columns as some fields have cells with taller content.
    //     (This does not apply for grids with <code>fixedRecordHeights</code> set to false).
    // </li></ul>
    //
    // @title Frozen Fields
    // @visibility external
    //<

    //> @attr listGrid.canFreezeFields (boolean : null : IRW)
    // Whether an interface should be shown to allow user is allowed to dynamically "freeze" or
    // "unfreeze" columns with respect to horizontally scrolling. If unset, this property defaults
    // to <code>true</code> unless:<ul>
    // <li>+link{listGrid.fixedRecordHeights,this.fixedRecordHeights} is <code>false</code></li>
    // <li>+link{listGrid.bodyOverflow,this.bodyOverflow} is <code>"visible"</code></li>
    // <li>+link{listGrid.autoFitData,this.autoFitData} is set to <code>"horizontal"</code> or
    // <code>"both"</code></li>
    // <li>Any field has overflow set to <code>"visible"</code></li></ul>
    // <P>
    // Note that the <code>canFreezeFields</code> setting enables or disables the user
    // interface for freezing and unfreezing fields only.  Fields can be programmatically
    // frozen via setting +link{listGridField.frozen,field.frozen} to true when the grid is
    // created, or dynamically frozen and unfrozen via +link{freezeField()} and
    // +link{unfreezeField()}.
    // <P>
    // Developers should also be aware that if the cell content for some field exceeds
    // the specified +link{cellHeight}, and +link{enforceVClipping} is not set to true, 
    // this can cause misalignment between rows in frozen and unfrozen columns. See the
    // +link{group:frozenFields,Frozen fields overview} for more on this.
    //
    //
    // @group frozenFields
    // @visibility external
    //<
    // Note that fixedColumnWidths:false will also disable canFreezeFields but this
    // is not currently public.
    
    //> @attr listGrid.frozenFieldsMaxWidth (String | Integer : null : IRW)
    // Maximum width available for any +link{group:frozenFields,frozen fields} shown 
    // in this grid. May be specified as a percentage or numeric pixel value.
    // <P>
    // If the frozen fields' combined width exceeds this value, a
    // horizontal scrollbar will be shown, allowing the frozen fields to be horizontally
    // scrolled (independently from the unfrozen fields).
    // @visibility external
    //<
    
    
    // -------------------------
    // Formula / summary fields (picked up from databoundcomponent)
    
    //> @attr listGrid.badFormulaResultValue        (String : "." : IRW)
    // @include dataBoundComponent.badFormulaResultValue
    //<
    
    //> @attr listGrid.missingSummaryFieldValue     (String : "-" : IRW)
    // @include dataBoundComponent.missingSummaryFieldValue
    //<
    
    //> @attr listGrid.missingFormulaFieldValue (String : "-" : IRW)
    // @include dataBoundComponent.missingFormulaFieldValue
    //<

    //> @attr listGrid.canAddFormulaFields (boolean : false : IRW)
    // @include dataBoundComponent.canAddFormulaFields
    // @visibility external
    //<

    //> @method listGrid.getFormulaFieldValue()
    // @include dataBoundComponent.getFormulaFieldValue()
    // @param field (ListGridField) field that has a formula
    // @param record (Record) record to use to compute formula value
    // @return (Double | String) formula result if a valid number or
    // +link{dataBoundComponent.badFormulaResultValue} if invalid
    // @visibility external
    //<

    //> @attr listGrid.canAddSummaryFields (boolean : false : IRW)
    // @include dataBoundComponent.canAddSummaryFields
    // @visibility external
    //<

    //> @method listGrid.getSummaryFieldValue()
    // @include dataBoundComponent.getSummaryFieldValue()
    // @param field (ListGridField) field that has a summary format
    // @param record (Record) record to use to compute formula value
    // @return (String) formula result
    // @visibility external
    //<


    //> @attr listGrid.canEditHilites (boolean : false : IRW)
    // @include dataBoundComponent.canEditHilites
    // @visibility external
    //<

    // Context Menus
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.showCellContextMenus (Boolean : false : [IRW])
    // Whether to show a context menu with standard items for all context clicks on rows in the
    // body.
    // @visibility external
    //<
    //showCellContextMenus:false,

    //> @attr listGrid.openRecordEditorContextMenuItemTitle (String : "Edit" : [IRW])
    // If +link{listGrid.canOpenRecordEditor} is true and +link{listGrid.showCellContextMenus}
    // is true, this property specifies the title for the context menu item shown allowing the
    // user to perform editing on a row via an embedded form.
    // @group i18nMessages
    // @visibility nextedGrid
    //<
    openRecordEditorContextMenuItemTitle:"Edit",

    //> @attr listGrid.dismissEmbeddedComponentContextMenuItemTitle (String : "Dismiss" : IRW)
    // If +link{listGrid.showCellContextMenus} is true, and we are currently showing either
    // an embedded editor (see +link{listGrid.canOpenRecordEditor}) or an embedded
    // detail grid (see +link{listGrid.canOpenRecordDetailGrid}, this property
    // specifies the title for the context menu item shown allowing the user to dismiss the
    // embedded component.
    // @group i18nMessages
    // @visibility nextedGrid
    //<
    dismissEmbeddedComponentContextMenuItemTitle:"Dismiss",

    //> @attr listGrid.deleteRecordContextMenuItemTitle (String : "Delete" : IRW)
    // If +link{listGrid.showCellContextMenus} is true, this property
    // specifies the title for the context menu item shown allowing the user to delete the
    // record on which the contextMenu was shown.
    // @group i18nMessages
    // @visibility experimental
    //<
    deleteRecordContextMenuItemTitle:"Delete",


    //> @attr listGrid.canOpenRecordDetailGrid (boolean : true : [IRW])
    // Whether context menu items will be shown for viewing records from related DataSources in
    // grids embedded in the record.
    // <P>
    // Valid only when <code>showCellContextMenus</code> is true.
    // @visibility nestedGrid
    //<
    canOpenRecordDetailGrid:true,

    //> @attr listGrid.recordDetailGridProperties (Object : null : [IR])
    // Properties for detail grids shown embedded inside rows.
    // @visibility nestedGrid
    //<

    //> @attr listGrid.canOpenRecordEditor (boolean : true : [IRW])
    // Whether a context menu item will be shown for editing records with a form embedded in
    // the record.
    // <P>
    // Valid only when <code>showCellContextMenus</code> is true.
    // @visibility nestedGrid
    //<
    canOpenRecordEditor:true,

    //> @attr listGrid.recordEditorProperties (Object : null : [IR])
    // Properties for editor forms shown embedded inside rows.
    // @see listGrid.canOpenRecordEditor
    // @visibility nestedGrid
    //<

    //> @attr listGrid.recordEditorSaveButtonTitle (String : "Save" : [IRW])
    // Title for the Save button shown in the editor form embedded inside rows if
    // +link{listGrid.canOpenRecordEditor} is true.
    // @see listGrid.canOpenRecordEditor
    // @group i18nMessages
    // @visibility nestedGrid
    //<
    recordEditorSaveButtonTitle:"Save",

    //> @attr listGrid.recordEditorCancelButtonTitle (String : "Cancel" : [IRW])
    // Title for the Cancel button shown in the editor form embedded inside rows if
    // +link{listGrid.canOpenRecordEditor} is true.
    // @see listGrid.canOpenRecordEditor
    // @group i18nMessages
    // @visibility nestedGrid
    //<
    recordEditorCancelButtonTitle:"Cancel",


    //>!BackCompat 2007.02.02
    // showCornerContextMenu was never externally documented and we have no in-code comments
    // about having ever exposed this property, so it may be safe to get rid of this
    // back-compat

    //> @attr listGrid.showCornerContextMenu (boolean : null : [IR])
    // Whether to allow a context menu on the sorter with standard items for showing and hiding
    // fields.
    // @deprecated as of 5.6 in favor of +link{attr:listGrid.showHeaderContextMenu}
    //<
    //<!BackCompat

    //> @attr listGrid.showHeaderContextMenu (Boolean : true : [IR])
    // Whether to show a context menu on the header with standard items for showing and hiding
    // fields.  Not supported for +link{cubeGrid}.
    // @group gridHeader
    // @see method:listGrid.displayHeaderContextMenu()
    // @see method:listGrid.getHeaderContextMenuItems()
    // @visibility external
    //<
    // NOTE: avoid crashing if Menu class isn't loaded by defaulting to false.
    // when we load the Menu class, we override this default.
    //showHeaderContextMenu:false,

    //> @attr listGrid.showHeaderSpanContextMenu (Boolean : true : [IR])
    // Whether to show a context menu on the header span with standard items for showing and hiding
    // fields.  Not supported for +link{cubeGrid}.
    // @group gridHeader
    // @see method:listGrid.getHeaderSpanContextMenuItems()
    // @visibility external
    //<
    // NOTE: avoid crashing if Menu class isn't loaded by defaulting to false.
    // when we load the Menu class, we override this default.
    //showHeaderSpanContextMenu:false,

    // headerMenuButton
    // ----------------------------
    //> @attr listGrid.showHeaderMenuButton (Boolean : true : [IR])
    // If set to true and +link{listGrid.showHeaderContextMenu,showHeaderContextMenu} is true, the
    // +link{listGrid.headerMenuButton} will be displayed when the user rolls
    // over the header buttons in this grid.  Not supported for +link{cubeGrid}.
    // @group headerMenuButton
    // @visibility external
    //<
    // As with showHeaderContextMenu, this default should not be set to true until we know
    // for sure that Menu has been loaded (see Menu.js)
    //showHeaderMenuButton:true,

    //> @attr listGrid.leaveHeaderMenuButtonSpace (boolean : null : [IWA])
    // If +link{listGrid.showHeaderMenuButton} is true, when auto-fitting fields to
    // the title width via +link{listGrid.autoFitFieldWidths} or +link{listGridField.autoFitWidth},
    // should the button be sized such that there is enough space for the header menu button to
    // show without covering the field title?
    // <P>
    // May be explicitly specified at the +link{listGridField.leaveHeaderMenuButtonSpace,field level}
    // or at the +link{listGrid.leaveHeaderMenuButtonSpace,grid level}. If not explicitly
    // specified space will be left for fields with
    // +link{listGridField.align} set to <code>"left"</code> or <code>"right"</code>, but not for
    // fields with align set to <code>"center"</code>.
    //
    // @see sortArrowMenuButtonSpaceOffset
    // @see sortNumeralMenuButtonSpaceOffset
    // @group headerMenuButton
    // @visibility external
    //<
    leaveHeaderMenuButtonSpace:null,

    //> @attr listGridField.leaveHeaderMenuButtonSpace (boolean : null : [IWA])
    // If +link{listGrid.showHeaderMenuButton} is true, when auto-fitting fields to
    // the title width via +link{listGrid.autoFitFieldWidths} or +link{listGridField.autoFitWidth},
    // should the button be sized such that there is enough space for the header menu button to
    // show without covering the field title?
    // <P>
    // May be explicitly specified at the +link{listGridField.leaveHeaderMenuButtonSpace,field level}
    // or at the +link{listGrid.leaveHeaderMenuButtonSpace,grid level}. If not explicitly
    // specified space will be left for fields with
    // +link{listGridField.align} set to <code>"left"</code> or <code>"right"</code>, but not for
    // fields with align set to <code>"center"</code>.
    //
    // @group headerMenuButton
    // @visibility external
    //<

    //> @attr listGrid.headerMenuButtonConstructor (ClassName : null : [IRA])
    // Constructor for the  +link{listGrid.headerMenuButton}. If unset a standard "Button" will
    // be rendered out. Note that this property may be overridden by different skins.
    // @group headerMenuButton
    // @visibility external
    //<
    //headerMenuButtonConstructor: "StretchImgButton",

    //> @attr listGrid.headerMenuButton (AutoChild StatefulCanvas : null : [RA])
    // If +link{showHeaderMenuButton} is true, when the user rolls over the header buttons in this
    // grid the headerMenuButton will be shown over the header button in question. When clicked
    // this button will display the standard header context menu (see
    // +link{listGrid.displayHeaderContextMenu}).
    // <P>
    // +link{group:headerMenuButton,Several properties} exist to customize the appearance of the
    // headerMenuButton. Also see the +link{type:AutoChild} documentation for information on how
    // to make free-form modifications to autoChild widgets
    // @group headerMenuButton
    // @visibility external
    //<

    //> @attr listGrid.headerMenuButtonIcon (URL : "[SKIN]/ListGrid/headerMenuButton_icon.gif" : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the icon shown on the
    // auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonIcon:"[SKIN]/ListGrid/headerMenuButton_icon.gif",

    //> @attr listGrid.headerMenuButtonIconWidth (number : 7 : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the width of the icon
    // shown on the auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonIconWidth:7,

    //> @attr listGrid.headerMenuButtonIconHeight (number : 7 : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the height of the icon
    // shown on the auto-generated <code>headerMenuButton</code>
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonIconHeight:7,

    //> @attr listGrid.headerMenuButtonWidth (number : 16 : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the width of the
    // auto-generated <code>headerMenuButton</code>
    // @see rotatedHeaderMenuButtonWidth
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonWidth:16,

    //> @attr listGrid.headerMenuButtonHeight (Number | String : "100%" : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the height of the
    // auto-generated <code>headerMenuButton</code>
    // @see rotatedHeaderMenuButtonHeight
    // @group headerMenuButton
    // @visibility external
    //<
    headerMenuButtonHeight:"100%",

    //> @attr listGrid.rotatedHeaderMenuButtonWidth (number : 16 : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the width of the
    // auto-generated <code>headerMenuButton</code> over a 
    // +link{listGridField.rotateTitle,rotated} header button.
    // @see headerMenuButtonWidth
    // @group headerMenuButton
    // @visibility external
    //<
    rotatedHeaderMenuButtonWidth:"100%",

    //> @attr listGrid.rotatedHeaderMenuButtonHeight (Number | String : "100%" : [IRA])
    // If +link{listGrid.showHeaderMenuButton} is true, this property governs the height of the
    // auto-generated <code>headerMenuButton</code> over a
    // +link{listGridField.rotateTitle,rotated} header button.
    // @see headerMenuButtonHeight
    // @group headerMenuButton
    // @visibility external
    //<
    rotatedHeaderMenuButtonHeight:16,

    // Drag Resize / Reorder / Drag and Drop
    // --------------------------------------------------------------------------------------------

    //> @attr listGrid.canDragRecordsOut (Boolean : false : [IRW])
    // Indicates whether records can be dragged from this listGrid and dropped elsewhere.
    // <p>
    // <strong>NOTE:</strong> If <code>canDragRecordsOut</code> is initially enabled or might be
    // dynamically enabled after the grid is created, it may be desirable to disable
    // +link{Canvas.useTouchScrolling,touch scrolling} so that touch-dragging a record starts
    // a drag operation rather than a scroll, but see the discussion of 
    // +link{listGrid.showDragHandles(), drag handles}. If 
    // +link{Canvas.disableTouchScrollingForDrag} is set to <code>true</code>, then touch
    // scrolling will be disabled automatically. However, for
    // +link{group:accessibility,accessibility} reasons, it is recommended to leave touch
    // scrolling enabled and provide an alternative set of controls that can be used to perform
    // drag and drop of records out of the grid.
    // @visibility external
    // @group  dragging
    // @see ListGridRecord.canDrag
    // @see ListGridRecord.canAcceptDrop
    // @see showDragHandles()
    // @example dragListMove
    // @example recordsAcrossWindows
    //<
    canDragRecordsOut:false,

    //> @attr listGrid.canAcceptDroppedRecords (Boolean : false : [IRW])
    // Indicates whether records can be dropped into this listGrid.
    // @visibility external
    // @group  dragging
    // @see ListGridRecord.canDrag
    // @see ListGridRecord.canAcceptDrop
    // @example dragListMove
    //<
    //canAcceptDroppedRecords:false,

    //> @attr listGrid.canReorderRecords (Boolean : false : [IRW])
    // Indicates whether records can be reordered by dragging within this <code>ListGrid</code>.
    // <p>
    // <strong>NOTE:</strong> If <code>canReorderRecords</code> is initially enabled or might be
    // +link{ListGrid.setCanReorderRecords(),dynamically enabled} after the grid is created,
    // it may be desirable to disable +link{Canvas.useTouchScrolling,touch scrolling}
    // so that touch-dragging a record starts a reorder operation rather than a scroll,
    // but see the discussion of +link{listGrid.showDragHandles(), drag handles}. If 
    // +link{Canvas.disableTouchScrollingForDrag} is set to <code>true</code>, then touch
    // scrolling will be disabled automatically. However, for +link{group:accessibility,accessibility}
    // reasons, it is recommended to leave touch scrolling enabled and provide an alternative
    // set of controls that can be used to perform drag-reordering of records.
    // @group  dragging
    // @see ListGridRecord.canDrag
    // @see ListGridRecord.canAcceptDrop
    // @see showDragHandles()
    // @example dragListMove
    // @example gridsDragReorder
    // @visibility external
    //<
    //canReorderRecords:false,

    //> @attr listGrid.canReorderFields (Boolean : true : [IRW])
    // Indicates whether fields in this listGrid can be reordered by dragging and dropping
    // header fields.  If true, can be overridden at the field level via 
    // +link{listGridField.canReorder}.
    // @group dragging
    // @example columnOrder
    // @visibility external
    //<
    canReorderFields:true,

    //> @attr listGrid.canResizeFields (Boolean : true : [IRW])
    // Indicates whether fields in this listGrid can be resized by dragging header
    // fields.
    // @visibility external
    // @group  dragging
    // @example columnSize
    //<
    canResizeFields:true,

    // for dragging records out, use the drag tracker
    dragAppearance:isc.EH.TRACKER,

    // if you set canDragResize to true on the grid show an outline rather than the tracker!
    dragResizeAppearance:isc.EH.OUTLINE,

    //> @type DragTrackerMode
    // When records are being dragged from within a ListGrid, what sort of drag-tracker
    // should be displayed?
    // @value "none" Don't display a drag tracker at all
    // @value "icon" Display an icon to represent the record(s) being dragged. Icon src is
    //              derived from +link{ListGrid.getDragTrackerIcon()}
    // @value "title" Display a title for the record being dragged. Title derived from
    //              +link{ListGrid.getDragTrackerTitle()}
    // @value "record" Display the entire record being dragged
    // @group dragTracker
    // @visibility external
    //<

    //> @attr listGrid.dragTrackerMode (DragTrackerMode : "icon" : [IRA])
    // When records are being dragged from within a ListGrid, what sort of drag-tracker
    // should be displayed?<br>
    // Note that if multiple records are being dragged the displayed tracker will be
    // based on the first selected record.
    // @group dragTracker
    // @visibility external
    //<
    dragTrackerMode:"title",
    

    //> @attr listGrid.resizeFieldsInRealTime (boolean : see below : IRWA)
    // If <code>true</code>, the grid contents are redrawn in real time as fields are resized.
    // This can be slow with a large grid and/or on some platforms. By default, this is enabled
    // in modern desktop browsers. This is automatically switched off in mobile browsers.
    //
    // @group dragging
    // @visibility external
    //<
    resizeFieldsInRealTime: ((isc.Browser.isIE && isc.Browser.isWin)
                            || (isc.Browser.isFirefox && isc.Browser.geckoVersion >= 20080529)
                            // Safari 3.0+, Google Chrome
                            || (isc.Browser.isSafari && isc.Browser.safariVersion >= 500)),

    //> @attr listGrid.dragDataAction
    // @include dataBoundComponent.dragDataAction
    //<

    // Embedded Components
    // --------------------------------------------------------------------------------------------
    //> @attr listGrid.embeddedComponentIndent (Integer : 25 : IRW)
    // This is the pixel-amount by which child components are offset within the grid-body, by 
    // default from the left, or from the right when +link{Page.isRTL, RTL} is in effect.  For
    // +link{ListGrid.canExpandRecords, expanding rows}, this attribute is overridden by 
    // +link{ListGrid.expansionIndent}.
    // <P>
    // This setting overrides the +link{ListGrid.embeddedComponentMargin, general margin} for
    // embedded-components, on the appropriate side.
    // @group expansionField
    // @visibility external
    //<
    embeddedComponentIndent: 25,

    //> @attr listGrid.embeddedComponentMargin (Integer : 0 : IRW)
    // This is the space to apply as margin around child-components embedded in this grid.  
    // This value is overridden on one side for 
    // +link{ListGrid.canExpandRecords, expansion components} by 
    // +link{ListGrid.expansionIndent, expansionIndent} and in other scenarios
    // by +link{ListGrid.embeddedComponentIndent}.
    // @group expansionField
    // @visibility external
    //<
    embeddedComponentMargin: 0,
    
    getEmbeddedComponentMargin : function () {
        // if embeddedComponentMargin is set, return it
        if (this.embeddedComponentMargin != null) return this.embeddedComponentMargin;
        // internal legacy default 
        return 0;
    },

    //> @attr listGrid.expansionIndent (Integer : null : IRW)
    // When +link{ListGrid.canExpandRecords, canExpandRecords} is true, this is the 
    // pixel-amount by which child components are offset within the grid-body, by default
    // from the left, or from the right when +link{Page.isRTL, RTL} is in effect.  If unset,
    // assumes the width of the +link{ListGrid.expansionField, expansionField}, so that child
    // components line up with the following field, according to RTL.
    // <P>
    // This setting overrides the +link{ListGrid.embeddedComponentIndent, general indent} for
    // embedded-components, on the appropriate side.
    // @group expansionField
    // @visibility external
    //<
    expansionIndent: null,

    getExpansionIndent : function () {
        // if expansionIndent is set, return it
        if (this.expansionIndent != null) return this.expansionIndent;
        // size the indent to the width of the expansionField
        var field = this.getExpansionField();
        var width = field ? this.getFieldWidth(field) : null;
        if (width != null) return width;
        // internal legacy default 
        return 25;
    },

    // Nested Master-Detail
    // --------------------------------------------------------------------------------------------
    nestedGridDefaults : {
        height:150
    },

    // Skinning
    // --------------------------------------------------------------------------------------------
    //> @attr listGrid.skinImgDir (SCImgURL : "images/ListGrid/" : IRWA)
    // Where do 'skin' images (those provided with the class) live?
    // @group appearance, images
    // @visibility external
    //<
    skinImgDir:"images/ListGrid/",

    //> @attr listGrid.sortAscendingImage (ImgProperties : {...} : IRWA)
    // Image to show when sorting ascending. See +link{class:ImgProperties} for format.
    // @group appearance
    // @see sortArrowMenuButtonSpaceOffset
    // @visibility external
    //<
    sortAscendingImage:{src:"[SKIN]sort_ascending.gif", width:7, height:7},

    //> @attr listGrid.sortDescendingImage (ImgProperties : {...} : IRWA)
    // Image to show when sorting descending. See +link{class:ImgProperties} for format.
    // @group appearance
    // @see sortArrowMenuButtonSpaceOffset
    // @visibility external
    //<
    sortDescendingImage:{src:"[SKIN]sort_descending.gif", width:7, height:7},

    //> @attr listGrid.trackerImage (ImgProperties : {...} : IRWA)
    // Default image to use for the dragTracker when things are dragged within or out of this
    // list. See +link{class:ImgProperties} for format.
    //
    // @group dragTracker
    // @see listGrid.dragTrackerMode
    // @see listGrid.getDragTrackerIcon()
    // @visibility external
    //<
    trackerImage:{src:"[SKIN]tracker.gif", width:16, height:16},

    //> @attr listGrid.booleanBaseStyle (CSSStyleName : null : IRA)
    // An optional CSS style to apply to the checkbox image. If supplied, and the checkbox is
    // enabled, the base style is suffixed with "True", "False", or "Partial" if the checkbox
    // is selected, unselected, or partially selected; if the checkbox is disabled, the suffix
    // is "TrueDisabled", "FalseDisabled", or "PartialDisabled".
    // <p>
    // <b>NOTE:</b> This attribute is not supported by +link{TreeGrid}.
    // @group imageColumns
    // @see ListGrid.printBooleanBaseStyle
    // @visibility external
    //<

    //> @attr listGrid.printBooleanBaseStyle (CSSStyleName : null : IRA)
    // If set, the +link{ListGrid.booleanBaseStyle,booleanBaseStyle} to use when +link{group:printing,printing}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanBaseStyle
    // @visibility external
    //<

    //> @attr listGrid.booleanTrueImage (SCImgURL : null : IRWA)
    // Image to display for a true value in a boolean field. The special value "blank" means
    // that no image will be shown.
    // <P>
    // To turn this off explicitly set +link{listGridField.suppressValueIcon} to true.
    // <P>
    // If this, +link{listGrid.booleanFalseImage} and +link{listGrid.booleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.checkedImage}.
    // <P>
    // +link{group:skinning,Spriting} can be used for this image, by setting this property to
    // a +link{type:SCSpriteConfig} formatted string. Alternatively developers can
    // omit this property and instead use CSS directly in the 
    // +link{ListGrid.booleanBaseStyle} property to provide a "boolean true" appearance.
    //
    // @see ListGrid.booleanFalseImage
    // @see ListGrid.booleanPartialImage
    // @see ListGrid.printBooleanTrueImage
    // @group imageColumns
    // @visibility external
    //<
    booleanTrueImage:null,

    //> @attr listGrid.booleanFalseImage (SCImgURL : null : IRWA)
    // Image to display for a false value in a boolean field. Default <code>null</code> value
    // or the special value "blank" means no image will be displayed.
    // <P>
    // To turn this off explicitly set +link{listGridField.suppressValueIcon} to true
    // <P>
    // If this, +link{listGrid.booleanTrueImage} and +link{listGrid.booleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.uncheckedImage}.
    // <P>
    // <P>
    // +link{group:skinning,Spriting} can be used for this image, by setting this property to
    // a +link{type:SCSpriteConfig} formatted string. Alternatively developers can
    // omit this property and instead use CSS directly in the 
    // +link{ListGrid.booleanBaseStyle} property to provide a "boolean false" appearance.
    //
    // @group imageColumns
    // @see ListGrid.booleanTrueImage
    // @see ListGrid.booleanPartialImage
    // @see ListGrid.printBooleanFalseImage
    // @visibility external
    //<
    booleanFalseImage:null,

    //> @attr listGrid.booleanPartialImage (SCImgURL : null : IRWA)
    // Image to display for a partially true value in a boolean field (typically selection).
    // The special value "blank" means that no image will be shown.
    // <P>
    // To turn this off explicitly set +link{listGridField.suppressValueIcon} to true.
    // <P>
    // If this, +link{listGrid.booleanTrueImage} and +link{listGrid.booleanFalseImage}
    // are unset, this will be set to the default +link{CheckboxItem.partialSelectedImage}.
    // <P>
    // +link{group:skinning,Spriting} can be used for this image, by setting this property to
    // a +link{type:SCSpriteConfig} formatted string. Alternatively developers can
    // omit this property and instead use CSS directly in the 
    // +link{ListGrid.booleanBaseStyle} property to provide a "boolean true" appearance.
    //
    // @see ListGrid.booleanTrueImage
    // @see ListGrid.booleanFalseImage
    // @see ListGrid.printBooleanPartialImage
    // @group imageColumns
    // @visibility external
    //<
    booleanPartialImage:null,

    //> @attr listGrid.printBooleanTrueImage (SCImgURL : null : IRWA)
    // If set, the +link{ListGrid.booleanTrueImage} to use when +link{group:printing,printing}.
    // <p>
    // If this, +link{listGrid.printBooleanFalseImage} and +link{listGrid.printBooleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.printCheckedImage}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanTrueImage
    // @visibility external
    //<
    printBooleanTrueImage:null,

    //> @attr listGrid.printBooleanFalseImage (SCImgURL : null : IRWA)
    // If set, the +link{ListGrid.booleanFalseImage} to use when +link{group:printing,printing}.
    // <p>
    // If this, +link{listGrid.printBooleanTrueImage} and +link{listGrid.printBooleanPartialImage}
    // are unset, this will be set to the default +link{CheckboxItem.printUncheckedImage}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanFalseImage
    // @visibility external
    //<
    printBooleanFalseImage:null,

    //> @attr listGrid.printBooleanPartialImage (SCImgURL : null : IRWA)
    // If set, the +link{ListGrid.booleanPartialImage} to use when +link{group:printing,printing}.
    // <p>
    // If this, +link{listGrid.printBooleanTrueImage} and +link{listGrid.printBooleanFalseImage}
    // are unset, this will be set to the default +link{CheckboxItem.printPartialSelectedImage}.
    // @group imageColumns
    // @group printing
    // @see ListGrid.booleanPartialImage
    // @visibility external
    //<
    printBooleanPartialImage:null,

    //> @attr listGrid.booleanImageWidth (number : 16 : IRWA)
    // Width for the +link{listGrid.booleanTrueImage}, +link{listGrid.booleanFalseImage}
    // and +link{listGrid.booleanPartialImage}.
    // Note: If +link{listGrid.booleanTrueImage} is unset, the +link{checkboxItem.checkedImage}
    // will be used to indicate a true value in a boolean field. In this case this property is
    // ignored in favor of +link{checkboxItem.valueIconWidth}.
    // @group imageColumns
    // @visibility external
    //<
    
    booleanImageWidth:16,

    //> @attr listGrid.booleanImageHeight (number : 16 : IRWA)
    // Height for the +link{listGrid.booleanTrueImage}, +link{listGrid.booleanFalseImage}
    // and +link{listGrid.booleanPartialImage}.
    // Note: If +link{listGrid.booleanTrueImage} is unset, the +link{checkboxItem.checkedImage}
    // will be used to indicate a true value in a boolean field. In this case this property is
    // ignored in favor of +link{checkboxItem.valueIconHeight}.
    // @group imageColumns
    // @visibility external
    //<
    booleanImageHeight:16,

    
    //> @attr listGrid.mozBodyOutlineColor (String : "white" : IRWA)
    // If we're in Moz Firefox 1.5 or above, and showing a header, what color should the
    // dotted focus outline show around the body. Must be a color that contrasts with the
    // header of the ListGrid.
    // @visibility internal
    //<
    mozBodyOutlineColor:"white",
    //> @attr listGrid.mozBodyNoHeaderOutlineColor (String : "red" : IRWA)
    // If we're in Moz Firefox 1.5 or above, and we're not showing a header, what color
    // should the dotted focus outline show around the body. Must be a color that contrasts
    // with the header of the ListGrid.
    // @visibility internal
    //<
    mozBodyNoHeaderOutlineColor:"red",

// -----------------------------------------------------------------------------------------
// drag handles
//

    //> @method listGrid.showDragHandles()
    // Shows an additional field near the beginning of the field list (after any
    // +link{showRowNumbers,row number} field) that can be dragged to drag the current
    // selection.  This feature is useful in +link{Browser.isTouch,touch environments} where
    // both touch scrolling and dragging are needed on the same grid, and allows scrolling to
    // be triggered on the other fields so that both operations are available.  Targeted touch
    // environments include both mobile devices, and Windows hardware that supports
    // +link{Browser.supportsDualInput,Dual Input Mode} such as Microsoft Surface.
    // <P>
    // Note that the +link{dragHandleField,drag handle field} will never be shown unless 
    // +link{canReorderRecords} or +link{canDragRecordsOut} are true.
    // <P>
    // In IE11 or Microsoft Edge, dragging a record in a grid may not be possible using a touch
    // device without enabling drag handles, or disabling native touch scrolling by setting
    // &nbsp;<code>window.isc_useNativeTouchScrolling = false</code>&nbsp; before SmartClient
    // is loaded.
    // <P>
    // <h4>Background</h4>
    // <P>
    // One alternative to adding a drag handle field would be to use long touch to start a drag
    // (with normal touch triggering scrolling).  However, this is unsupportable in IE11 or Edge
    // on Microsoft Surface (with native scrolling) because native scrolling cannot be canceled
    // on the fly using Event.preventDefault(), but instead must be disabled by applying the
    // appropriate CSS at rendering time.  (Such limitations are not present elsewhere, such as
    // on Android or IPhone browsers.)
    // <P>
    // For more details, some links are provided below.  Note that while IE10 is mentioned in
    // some of the links, the reasoning is still relevant now for IE11 and Edge as the
    // limitations remain:
    // <ul>
    // <li>+externalLink{https://quirksmode.org/mobile/default.html,Cross-browser support of touchMove}
    // <li>+externalLink{https://stackoverflow.com/questions/26218146/pointer-events-ie11-surface,preventDefault() doesn't work in IE11 on MS Surface}
    // <li>+externalLink{https://stackoverflow.com/questions/49299496/html5-pointermove-touchmove-not-working-in-microsoft-edge,preventDefault() doesn't work in Edge on MS Surface}
    // <li>+externalLink{https://web.archive.org/web/20160309214328/https://connect.microsoft.com/IE/feedback/details/767646/ms-touch-action-does-not-allow-a-way-to-programmatically-prevent-default-touch-behavior,preventDefault() failure reported to Microsoft against IE10}
    // </ul>
    // @see hideDragHandles()
    // @see dragHandleField
    // @see dragHandleIcon
    // @see dragHandleIconSize
    // @example gridsTouchDrag
    // @group dragHandleField
    // @visibility external
    //<
    showDragHandles : function() {
        this._showDragHandles = true;
        this.refreshFields();
    },

    //> @method listGrid.hideDragHandles()
    // Hides the +link{dragHandleField,drag handle field}, if currently shown.
    // @see showDragHandles()
    // @group dragHandleField
    // @visibility external
    //<
    hideDragHandles : function() {
        this._showDragHandles = false;
        this.refreshFields();
    },

    //> @attr listGrid.showInitialDragHandles (boolean : null : IRA)
    // When set to true, shows the +link{dragHandleField,drag handle field} on initial draw.
    // @see showDragHandles()
    // @see hideDragHandles()
    // @see dragHandleField
    // @group dragHandleField
    // @visibility external
    //<

    //> @attr listGrid.dragHandleFieldTitle (String : "&nbsp;" : IRWA)
    // The title to use for the +link{listGrid.dragHandleField, drag handle field}.
    // <P>
    // By default this title is not displayed in the drag column header button as the
    // autochild defaults for the field set +link{listGridField.showTitle} to
    // <code>false</code>.
    // @see showDragHandles()
    // @group dragHandleField
    // @visibility external
    //<
    dragHandleFieldTitle: isc.nbsp,

    //> @attr listGrid.dragHandleIcon (SCImgURL : "[SKIN]/actions/drag.png" : IR)
    // Default icon to show in the +link{dragHandleField,drag handle field}..
    // @see showDragHandles()
    // @group dragHandleField
    // @visibility external
    //<
    dragHandleIcon:"[SKIN]/actions/drag.png",

    //> @attr listGrid.dragHandleIconSize (Number : 16 : IRW)
    // Default width and height of +link{dragHandleIcon,drag handle icons} for this ListGrid.
    // @see showDragHandles()
    // @group dragHandleField
    // @visibility external
    //<
    dragHandleIconSize: 16,

    //> @attr listGrid.dragHandleField (AutoChild ListGridField : null : IR)
    // An automatically generated field that can be dragged to drag the current selection
    // (where otherwise the grid itself might be scrolled).  Visibility is controlled by 
    // +link{showInitialDragHandles}, +link{showDragHandles()}, and +link{hideDragHandles()}.
    // @group dragHandleField
    // @visibility external
    //<
    dragHandleFieldDefaults: {
        type:"icon",
        width:24,
        name: "_dragHandleField",
        isDragHandle: true,

        canEdit: false,
        canHide: false,
        canSort: false,
        canGroupBy: false,
        canFilter:false,
        showTitle:false,
        canExport: false,
        autoFitWidth: false,
        canAutoFitWidth: false,
        canDragResize: false,
        excludeFromState:true,
        showDefaultContextMenu: false,
        selectCellTextOnClick:false,
        ignoreKeyboardClicks:true,
        keyboardFiresRecordClick: false,
        showGroupSummary:false,
        showGridSummary:false,
        summaryValue: "&nbsp;",
        // specifically disable filterOperators for this builtin field
        allowFilterOperators: false,
        autoFreeze: true,
        // disable this from ever being assigned as the treeField
        treeField:false
    },

    //> @attr listGrid.useDragHandles (Boolean : false : [IRA])
    // Whether this grid should assume drag handles are present when deciding how to
    // handle touch interactions.  The primary use case is to set this property true if the
    // +link{listGrid.dragHandleField} autochild is not being shown, but one or more user
    // fields have been marked as +link{listGridField.isDragHandle,isDragHandle}: true.
    // <P>
    // Note that <code>useDragHandles</code> has no impact if the +link{dragHandleField,drag
    // handle field} autochild is being shown due to +link{showInitialDragHandles} or 
    // +link{showDragHandles()}.
    // @see showDragHandles()
    // @group dragHandleField
    //<

    // helper to check whether drag interaction should assume drag handles are present
    _shouldUseDragHandles : function () {
        if (this.fieldSourceGrid) return this.fieldSourceGrid._shouldUseDragHandles();
        return (this._showDragHandles || this.useDragHandles) && 
            (this.canReorderRecords || this.canDragRecordsOut);
    },

    // should the drag handle field autochild be added by setFields()
    shouldShowDragHandleField : function () {
        if (this.fieldSourceGrid) return this.fieldSourceGrid.shouldShowDragHandleField();
        return this._showDragHandles && (this.canReorderRecords || this.canDragRecordsOut);
    },

    // return the autogenerated drag handle field, if it's already been created
    getCurrentDragField : function () {
        var fields = this.completeFields || this.fields;
        if (!fields) return null;
        var dragHandleFields = fields.find(this.fieldIdProperty, "_dragHandleField");
        if (!dragHandleFields) return null;
        return isc.isAn.Array(dragHandleFields) ? dragHandleFields[0] : dragHandleFields;
    },
    
    // return desired position of drag handle field autochild; should be after row number field
    getDragFieldPosition : function () {
        if (this.fieldSourceGrid) return this.fieldSourceGrid.getDragFieldPosition();
        if (!this.shouldShowDragHandleField()) return -1;
        
        var pos = 0;
        if (this.shouldShowRowNumberField()) pos++;
        return pos;
    },

    // create the drag handle field autochild
    getDragField : function () {
        var grid = this,
        dragHandleField = {
            title: this.dragHandleFieldTitle,
            cellIcon: this.dragHandleIcon,
            iconSize: this.dragHandleIconSize,
            getAutoFreezePosition: function () {return grid.getDragFieldPosition();}
        };
        isc.addProperties(dragHandleField, this.dragHandleFieldDefaults, 
                                           this.dragHandleFieldProperties);
        return dragHandleField;
    },

    // helper to check whether event is in a drag handle field
    _shouldAllowRecordDrag : function () {
        if (!isc.Browser.isTouch || !this._shouldUseDragHandles()) {
            return true;
        }
        var body = this.body;
        if (!body || !body._usingNativeTouchScrolling()) return true;

        
        var fieldX = this.getOffsetX(isc.EH.mouseDownEvent),
            fieldNum = this.getEventColumn(fieldX),
            field = this.getField(fieldNum)
        ;
        return field && field.isDragHandle;
    },


// -----------------------------------------------------------------------------------------
// row numbers
//

    //> @attr listGrid.showRowNumbers (boolean : null : IRWA)
    // When set to true, shows an additional field at the beginning of the field-list
    // (respecting RTL) that displays the current rowNum for each record.
    // @group rowNumberField
    // @visibility external
    //<

    //> @attr listGrid.rowNumberStyle (CSSStyleName : "specialCol" : IRWA)
    // The CSS Style name for the +link{listGrid.rowNumberField}.
    // @group rowNumberField
    // @visibility external
    //<
    rowNumberStyle: "specialCol",
    
    //> @attr listGrid.applyRowNumberStyle (boolean : true : IRWA)
    // If +link{showRowNumbers} is true, should we apply the +link{rowNumberStyle} to
    // the +link{listGrid.rowNumberField}
    // @group rowNumberField
    // @visibility external
    //<
    applyRowNumberStyle:true,

    //> @attr listGrid.rowNumberStart (number : 1 : IRWA)
    // The number to start the row-count from - default value is 1.
    // @group rowNumberField
    // @visibility external
    //<
    rowNumberStart: 1,

    //> @attr listGrid.rowNumberField (AutoChild ListGridField : null : IRWA)
    // An automatically generated field that displays the current row number when
    // +link{listGrid.showRowNumbers, showRowNumbers} is true.
    // @group rowNumberField
    // @visibility external
    //<
    rowNumberFieldDefaults: {
        name: "_rowNumberField",
        excludeFromState:true,
        selectCellTextOnClick:false,
        canEdit: false,
        canFilter:false,
        canGroupBy: false,
        selectCellTextOnClick:false,
        canSort: false,
        canExport: false,
        canHide: false,
        canReorder: false,
        canDragResize: false,
        // make this special field canHilite false so we don't see it in HiliteEditors by default
        canHilite: false,
        canAutoFitWidth: false,
        showAlternateStyle: false,
        _isRowNumberField: true,
        showDefaultContextMenu: false,
        keyboardFiresRecordClick: false,
        showGroupSummary:false,
        showGridSummary:false,
        summaryValue: "&nbsp;",
        // specifically disable filterOperators for this builtin field
        allowFilterOperators: false,
        formatCellValue : function (value, record, rowNum, colNum, grid) {
            if (grid.isGrouped) {
                if (record == null || record._isGroup) return "&nbsp;";
                
                var groupedRowNum = grid.getGroupedRecordIndex(record);
                // skip any records we can't find in the group tree (EG summary rows)
                if (groupedRowNum == -1) return null;
                return (grid.rowNumberStart + groupedRowNum);
            } else {
                return this.rowNumberStart + rowNum;
            }
        },
        autoFreeze: true,
        // disable this from ever being assigned as the treeField
        treeField:false,
        // flag that means this is a special builtin field, not for formulas/export/etc
        featureField: true
    },

    // helper method to get index of the group in which a record exists
    getParentGroupIndex : function (record) {
        // bail if we're not grouped (return group 0)
        if (!this.isGrouped) return 0;

        // find out which group this record is in
        var tree = this.groupTree,
            parentNode = tree.getParent(record),
            rootChildren = tree.getChildren(tree.getParent(parentNode)),
            groupCount = 0;

        if (!isc.isA.ResultSet(rootChildren) || rootChildren.lengthIsKnown()) {
            for (var i = 0, length = rootChildren.getLength(); i < length; ++i) {
                var child = rootChildren.getCachedRow(i);
                if (child != null && child.groupValue == parentNode.groupValue) {
                    groupCount = i;
                    break;
                }
            }
        }

        return groupCount;
    },

    //> @method listGrid.getGroupedRecordIndex()
    // Returns the true row index for a grouped record excluding group and
    // summary records. Records in closed groups are included in number.
    // <p>
    // Function is not applicable for non-grouped grids and will return -1
    // if called.
    //
    // @param record (ListGridRecord) record to number
    // @return (int) row index for record or -1 for group or summary records
    // @group rowNumberField
    // @visibility external
    //<
    getGroupedRecordIndex : function (record) {
        // bail if we're not grouped
        if (!this.isGrouped) return -1;
        // find the true index of this record in a grouped grid - indexOf doesn't cater for
        // closed groups
        var tree = this.groupTree,
            
            parentNode = tree == null ? null : tree.getParent(record);

        // Checking for parentNode == null allows us to skip group-summary nodes which
        // shouldn't be counted anyway.
        if (parentNode == null) return -1;

        
        if (tree.getLevel(record) > 1) {
            var recurseState = { currentIndex: 0, parentNode: parentNode, record: record };
            this.getGroupedRecordIndexRecursive(tree.root, recurseState);
            return recurseState.currentIndex;
        }

        var rootChildren = tree.getChildren(tree.getParent(parentNode)),
            groupCount = 0,
            trueIndex = 0;

        if (!isc.isA.ResultSet(rootChildren) || rootChildren.lengthIsKnown()) {
            for (var i = 0, rootChildrenLength = rootChildren.getLength(); i < rootChildrenLength; ++i) {
                var child = rootChildren.getCachedRow(i);
                if (child != null) {
                    if (child.groupValue == parentNode.groupValue) {
                        var siblings = tree.getChildren(child);
                        if (!isc.isA.ResultSet(siblings) || siblings.lengthIsKnown()) {
                            for (var j = 0, siblingsLength = siblings.getLength(); j < siblingsLength; ++j) {
                                var sibling = siblings.getCachedRow(j);
                                if (sibling != null && this.objectsAreEqual(sibling, record)) {
                                    return trueIndex + j;
                                }
                            }
                        }
                    }
                    var prevSiblings = tree.getChildren(child);
                    if (!isc.isA.ResultSet(prevSiblings) || prevSiblings.lengthIsKnown()) {
                        var length = prevSiblings.getLength();
                        // Don't count group summary rows - these show up at the end of the
                        // group [and we support an arbitrary number of them]
                        if (this.showGroupSummary && !this.showGroupSummaryInHeader) {
                            for (var ii = length - 1; ii >=0; --ii) {
                                var prevSibling = prevSiblings.getCachedRow(ii);
                                if (prevSibling != null) {
                                    if (prevSibling[this.groupSummaryRecordProperty]) --length;
                                    else break;
                                }
                            }
                        }
                        trueIndex += length;
                    }
                }
            }
        }

        return trueIndex;
    },

    getGroupedRecordIndexRecursive : function (startNode, state) {
        var tree = this.groupTree;
        if (!startNode) startNode = tree.root;

        // iterate through all the children of the node
        var children = tree.getChildren(startNode);
        if (!children) return true;
        if (isc.isA.ResultSet(children) && !children.lengthIsKnown()) return true;

        var parentNode = state.parentNode,
            record = state.record
        ;

        // for each child
        var length = children.getLength();
        for (var i = 0; i < length; ++i) {
            var child = children.getCachedRow(i);

            if (child == null) {
                // Do nothing.
            } else if (tree.isFolder(child)) {
                if (!this.getGroupedRecordIndexRecursive(child, state)) {
                    return false;
                }
            } else {
                if (startNode.groupName == parentNode.groupName && 
                    startNode.groupValue == parentNode.groupValue &&
                    this.objectsAreEqual(child, record))
                {
                    return false;
                }
                // Don't count group summary rows
                if (!child[this.groupSummaryRecordProperty]) {
                    state.currentIndex++;
                }
            }
        }
        return true;
    },

    // helper method to compare the properties on two objects
    objectsAreEqual : function (object1, object2) {
        for (var key in object1) {
            if (object1[key] != object2[key]) return false;
        }
        return true;
    },

    _rowNumberFieldWidth: 30,
    getRowNumberField : function () {
        var grid = this,
            rnField = {
                // default the width
                width:this._rowNumberFieldWidth,
                rowNumberStart: this.rowNumberStart,
                getAutoFreezePosition: function () { return grid.getRowNumberFieldPosition() }
            }
        ;
        if (this.applyRowNumberStyle) rnField.baseStyle = this.rowNumberStyle;
        isc.addProperties(rnField, this.rowNumberFieldDefaults, this.rowNumberFieldProperties);

        rnField.title = isc.nbsp;

        return rnField;
    },

    getCurrentRowNumberField : function () {
        var fields = this.completeFields || this.fields,
            rnFields = fields.find(this.fieldIdProperty, "_rowNumberField");
        return !rnFields ? null : isc.isAn.Array(rnFields) ? rnFields[0] : rnFields;
    },

    //> @method listGrid.isRowNumberField()
    // Identifies whether the passed-in field is the specially generated
    // +link{listGrid.rowNumberField, rowNumberField} used when +link{showRowNumbers} is
    // true.  Use this method in your custom event handlers to avoid inappropriately
    // performing actions when the rowNumberField is clicked on.
    //
    // @param field (ListGridField) field to test
    // @return (Boolean) whether the provided field is the rowNumberField
    // @group rowNumberField
    // @visibility external
    //<
    isRowNumberField : function (field) {
        if (!field || !field._isRowNumberField) return false;
        else return true;
    },

    // helper function to get the rowNumber field position
    // Appears at the far left of the grid, to the left of the other special fields which are
    // - group summary title field
    // - expansion component icon field
    // - checkbox selection field
    getRowNumberFieldPosition : function () {
        if (this.fieldSourceGrid) return this.fieldSourceGrid.getRowNumberFieldPosition();
        if (!this.shouldShowRowNumberField()) return -1;
        return 0;
    },

    shouldShowRowNumberField : function () {
        // fieldSourceGrid: for cases like the summaryRow / filterEditor where we
        // share field objects across grids (and don't necessarily percolate settings like
        // 'showRowNumbers').
        return this.fieldSourceGrid ? this.fieldSourceGrid.shouldShowRowNumberField()
                                    : (this.showRowNumbers == true);
    },

    //> @attr listGrid.exportRawValues (Boolean : null : IR)
    // Dictates whether the data in this grid should be exported raw by
    // +link{listGrid.exportClientData, exportClientData()}.  If set to true,
    // data will not be processed by field-formatters during exports.
    // Decreases the time taken for large exports.  This property can also be set at the
    // +link{listGridField.exportRawValues, field level}.
    //
    // @visibility external
    //<
    
    //> @attr listGrid.exportRawNumbers (Boolean : null : IR)
    // Dictates whether numeric values should be exported as raw numbers instead of
    // formatted values when using +link{listGrid.exportClientData, exportClientData()}.
    // <P>
    // This property is only consulted if <code>exportRawValues</code> is not set to
    // true at the +link{listGrid.exportRawValues,grid} or
    // +link{listGridField.exportRawValues,field} level. That property causes all values,
    // including numeric values, to be exported unformatted.
    // <P>
    // This is useful for cases where an explicit ListGrid formatter function simply displays the number
    // as a formatted string for the user (for example "1,234"). Exporting that formatted
    // string rather than the underlying numeric value causes spreadsheet applications such as
    // Excel to lose some functionality.
    // <P>
    // If this property is not explicitly set, numeric values will be exported as raw
    // numbers for +link{DSRequest.exportAs,XLS and OOXML export} only.
    // <P>
    // May be overridden at the field level via +link{listGridField.exportRawNumbers}.
    // 
    // @visibility external
    //<

// -----------------------------------------------------------------------------------------
// RowCountDisplay / RowRangeDisplay
//

    //> @attr listGrid.rowRangeDisplay (RowRangeDisplay AutoChild : null : R)
    // +link{RowRangeDisplay} autoChild, which may be retrieved by calling +link{listGrid.getRowRangeDisplay()}.
    //
    // @visibility rowCountDisplay
    //<
    rowRangeDisplayConstructor:"RowRangeDisplay", // defined later in this file

    //> @attr listGrid.canRequestRowCount (boolean : false : IRW)
    // Depending on the setting for +link{progressiveLoading}, the exact count of available rows
    // may not be known, and <code>canRequestRowCount</code> 
    // controls whether the end user is allowed to explicitly request it for
    // display in the +link{rowRangeDisplay} label.
    // <P>
    // When this property is set to <code>true</code>, the 
    // user may request an accurate row count if one is not
    // currently known by +link{rowRangeDisplay.canRequestRowCount,clicking} 
    // the +link{listGrid.rowRangeDisplay}. To have a row count fetch operation 
    // occur automatically when progressive data is loaded instead of requiring
    // a user interaction to initiate the fetch, see +link{autoFetchRowCount}.
    // <P>
    // Note: This property also acts as a default for 
    // +link{resultSet.applyRowCountToLength}. By default, if set to true, 
    // a user may therefore click the rowRangeDisplay label to request a
    // row count query be executed on the server, and when the query is complete
    // they may scroll the listGrid body freely, retrieving records from anywhere
    // within the data set.
    // <P>
    // If +link{listGrid.applyRowCountToLength} is explicitly set it will
    // be applied to the grid's data object instead of using <code>applyRowCountToLength</code>
    // as a default. For finer grained control, a developer may set both properties
    // to false and manage behavior by explicitly calling +link{listGrid.fetchRowCount()}
    // and +link{resultSet.setFullLength(),listGrid.data.setFullLength()} from application
    // code.
    // 
    // @visibility rowCountDisplay
    //<
    canRequestRowCount:false,

    //> @attr listGrid.autoFetchRowCount (boolean : false : IRW)
    // Depending on the setting for +link{progressiveLoading}, the exact count of available rows
    // may not be available as part of the standard data fetch response - setting
    // <code>autoFetchRowCount:true</code> will cause a fetch for an accurate row count to be issued
    // as soon as data arrives (from a +link{dsResponse.progressiveLoading,progressive dataSource response} with
    // no accurate row count. This value will then be available for display in the +link{rowRangeDisplay} label.
    // <P>
    // To allow users to request an accurate row count by clicking
    // the +link{rowRangeDisplay} instead of kicking off a row count fetch automatically,
    // use +link{canRequestRowCount}.
    // <P>
    // The <code>autoFetchRowCount</code> value will be passed through to the 
    // +link{ResultSet.autoFetchRowCount,ResultSet data object}
    // which is responsible for issuing the row count fetch(es) at appropriate times.
    //
    // @visibility rowCountDisplay
    // @group rowCountDisplay
    //<

    //> @attr listGrid.applyRowCountToLength (Boolean : null : IRW)
    // This property allows developers to explicitly set +link{resultSet.applyRowCountToLength}
    // for this grid's data object.
    // <P>
    // If not explicitly specified this will be derived from +link{listGrid.canRequestRowCount}
    // @visibility rowCountDisplay
    //<

    //> @attr listGrid.blockingRowCountFetch (Boolean : null : IRW)
    // If specified, this attribute will be applied to this grid's +link{resultSet.blockingRowCountFetch,data object}
    // for dataBound grids.
    //
    // @visibility rowCountDisplay
    //<

    
    //> @method listGrid.getRowRangeDisplay()
    // This method will create and return a +link{class:RowRangeDisplay} autoChild
    // with +link{rowRangeDisplay.sourceGrid} set to this listGrid.
    // <P>
    // Note that this method will only create one rowRangeDisplay instance. Calling
    // it repeatedly will return the same canvas.
    //
    // @return (RowRangeDisplay) RowRangeDisplay component
    // @visibility rowRangeDisplay
    //<
    getRowRangeDisplay : function () {
        if (this.rowRangeDisplay == null || this.rowRangeDisplay.destroyed) {
            this.rowRangeDisplay = this.createAutoChild("rowRangeDisplay", {
                sourceGrid:this,
                canRequestRowCount:this.canRequestRowCount
            });
        }
        return this.rowRangeDisplay;
    },

    //> @type RowRangeDisplayStyle 
    // Governs how +link{listGrid.getRowRangeDisplayValue()} formats the row range
    // and row count for display
    //
    // @value "full" The +link{listGrid.fullRowRangeDisplayValue} template will be used
    //   to display both row range and row count
    // @value "brief" The +link{listGrid.briefRowRangeDisplayValue} template will be used
    //   to display both row range and row count
    // @value "countOnly" The +link{listGrid.getFormattedRowCount()} will be displayed
    //      with no other text.
    // @value "rangeOnly" The +link{listGrid.getFormattedRowRange()} will be displayed
    //      with no other text.
    // @visibility rowCountDisplay
    //<

    //> @attr listGrid.rowRangeDisplayStyle (RowRangeDisplayStyle : "full" : IRW)
    // How should the +link{getFormattedRowRange()} format the row range
    // and row count for display to the user?
    // @visibility rowCountDisplay
    //<
    rowRangeDisplayStyle:"full",

    //> @attr listGrid.fullRowRangeDisplayValue (String : "Showing ${rowRange} of ${rowCount} rows" : IRW)
    // Dynamic String specifying the format for the 
    // +link{getRowRangeDisplayValue(),row range summary value} when 
    // +link{rowRangeDisplayStyle} is set to <code>"full"</code>.
    // <P>
    // The following variables are available for evaluation within this string:
    // <ul><li><code>rowRange</code>: the +link{getFormattedRowRange(),formatted row range}</li>
    //     <li><code>rowCount</code>: the +link{getFormattedRowCount(),formatted row count}</li></ul>
    // @visibility rowCountDisplay
    // @group i18nMessages
    //<
    fullRowRangeDisplayValue:"Showing ${rowRange} of ${rowCount} rows",

    //> @attr listGrid.briefRowRangeDisplayValue (String : "${rowRange} of ${rowCount}" : IRW)
    // Dynamic String specifying the format for the 
    // +link{getRowRangeDisplayValue(),row range summary value} when 
    // +link{rowRangeDisplayStyle} is set to <code>"brief"</code>.
    // <P>
    // The following variables are available for evaluation within this string:
    // <ul><li><code>rowRange</code>: the +link{getFormattedRowRange(),formatted row range}</li>
    //     <li><code>rowCount</code>: the +link{getFormattedRowCount(),formatted row count}</li></ul>
    // @visibility rowCountDisplay
    // @group i18nMessages
    //<    
    briefRowRangeDisplayValue:"${rowRange} of ${rowCount}",

    //> @attr listGrid.emptyRowRangeDisplayValue (String : "&nbsp;" : IRW)
    // +link{getRowRangeDisplayValue(),Row range summary display value} when the grid is empty.
    // @visibility rowCountDisplay
    // @group i18nMessages
    //<    
    emptyRowRangeDisplayValue:"&nbsp;",

    //> @method listGrid.getRowRangeDisplayValue()
    // This method will return a row range summary display value containing the
    // currently visible row range and row count for the data set.
    // <P>
    // The +link{rowRangeDisplay} label autoChild shows this value as its contents.
    // <P>
    // The format of the display value is governed by the +link{rowRangeDisplayStyle}
    //
    // @return (String) formatted row range summary value
    // @visibility rowCountDisplay
    //<
    getRowRangeDisplayValue : function () {

        if (this.isEmpty()) return this.emptyRowRangeDisplayValue;

        var style = this.rowRangeDisplayStyle;
        if (style == "countOnly") {
            return this.getFormattedRowCount();
        }
        if (style == "rangeOnly") {
            return this.getFormattedRowRange();
        }

        // get the appropriate template and evaluate it
        var summaryTemplate = style == "full" ? this.fullRowRangeDisplayValue : this.briefRowRangeDisplayValue;

        return  summaryTemplate.evalDynamicString(
                    this, 
                    {rowCount:this.getFormattedRowCount(), rowRange:this.getFormattedRowRange()}
                );
    },

    // rowRangeDisplayValueChanged: Observable method fired whenever getRowRangeDisplayValue() will return
    // a new value thanks to dataChanged or scrolling

    rowRangeDisplayValueChanged : function (reason) {
//!DONTOBFUSCATE  (legal to observe and pick up params)

    },

    //> @attr listGrid.rowRangeFormat (String : "${startRow}-${endRow}" : IRW)
    // Dynamic String specifying the format for the 
    // +link{getFormattedRowRange(),visible row range}.
    // <P>
    // The following variables are available for evaluation within this string:
    // <ul><li><code>startRow</code>: first visible row in the viewport as a 
    //         +link{isc.NumberUtil.toLocalizedString(),formatted string}</li>
    //     <li><code>endRow</code>: last visible row in the viewport as a 
    //         +link{isc.NumberUtil.toLocalizedString(),formatted string}</li></ul>
    // @visibility rowCountDisplay
    // @group i18nMessages
    //<
    rowRangeFormat:"${startRow}-${endRow}",

    //> @method listGrid.getFormattedRowRange()
    // Uses the +link{rowRangeDisplayValue} to return a formatted display 
    // value showing the currently visible set of rows in the listGrid viewport.
    // <P>
    // If this listGrid has never been drawn, so has no meaningful "viewport",
    // this method will return an empty string.
    // <P>
    // See also +link{getRowRangeDisplayValue()}
    //
    // @return (String) formatted row range value
    // @visibility rowCountDisplay
    //<
    getFormattedRowRange : function () {
        if (!this.body) return "";
        var visibleRows = this.getVisibleRows();
        var startRow = isc.NumberUtil.toLocalizedString(visibleRows[0]+1),
            endRow = isc.NumberUtil.toLocalizedString(visibleRows[1]+1);

        return this.rowRangeFormat.evalDynamicString(
                    this, {startRow:startRow, endRow:endRow}
               );
    },

    childResized : function (child, deltaX, deltaY, reason) {
        // Whenever the body viewport size changes (likely due to the grid as a whole resizing, but could
        // also come from showFilterEditor, etc), refresh our visible row range if necessary
        if (child == this.body && deltaY != null && deltaY != 0 &&
            this.rowRangeDisplayStyle != "countOnly") 
        {
            this.rowRangeDisplayValueChanged("Body resized");
        }
        return this.Super("childResized", arguments);
    },

    //> @attr listGrid.unknownRowCountDisplayValue (String : "many" : IRW)
    // Value to return from +link{getFormattedRowCount()} when the row count is unknown
    // @group i18nMessages
    // @visibility rowCountDisplay
    //<
    unknownRowCountDisplayValue:"many",


    //> @attr listGrid.loadingRowCountDisplayIcon (SCImgURL : "[SKINIMG]/loading_horizontal.gif" : IRW)
    // The URL of the icon to display as a +link{getFormattedRowCount(),row count value} when
    // the row count is loading.
    //
    // @visibility rowCountDisplay
    //<
    loadingRowCountDisplayIcon: "[SKINIMG]/loading_horizontal.gif",

    //> @attr listGrid.loadingRowCountDisplayIconWidth (Number : 16 : IRW)
    // Width for the +link{loadingRowCountDisplayIcon} 
    //
    // @visibility rowCountDisplay
    //<
    loadingRowCountDisplayIconWidth: 16,

    //> @attr listGrid.loadingRowCountDisplayIcoHeight (Number : 16 : IRW)
    // Height for the +link{loadingRowCountDisplayIcon} 
    //
    // @visibility rowCountDisplay
    //<
    loadingRowCountDisplayIconHeight: 16,

    //> @attr listGrid.exactRowCountFormat (String : "${rowCount}" : IRW)
    // Format for the string returned from +link{getFormattedRowCount()} when
    // +link{getRowCountStatus(),row count status} is <code>"exact"</code>.
    // <P>
    // The variable <code>rowCount</code> is available for evaluation within
    // this string and will be set to the +link{getRowCount(),current row count} 
    // as a +link{isc.NumberUtil.toLocalizedString(),locale-formatted number}.
    // 
    // @visibility rowCountDisplay
    //<
    exactRowCountFormat:"${rowCount}",

    //> @attr listGrid.minimumRowCountFormat (String : "${rowCount}+" : IRW)
    // Format for the string returned from +link{getFormattedRowCount()} when
    // +link{getRowCountStatus(),row count status} is <code>"minimum"</code>.
    // <P>
    // The variable <code>rowCount</code> is available for evaluation within
    // this string and will be set to the +link{getRowCount(),current row count} 
    // as a +link{isc.NumberUtil.toLocalizedString(),locale-formatted number}.
    //
    // @visibility rowCountDisplay
    //<
    minimumRowCountFormat:"${rowCount}+",

    //> @attr listGrid.approximateRowCountFormat (String : "~${rowCount}" : IRW)
    // Format for the string returned from +link{getFormattedRowCount()} when
    // +link{getRowCountStatus(),row count status} is <code>"approximate"</code>.
    // <P>
    // The variable <code>rowCount</code> is available for evaluation within
    // this string and will be set to the +link{getRowCount(),current row count} 
    // as a +link{isc.NumberUtil.toLocalizedString(),locale-formatted number}.
    //
    // @visibility rowCountDisplay
    //<
    approximateRowCountFormat:"~${rowCount}",

    //> @attr listGrid.maximumRowCountFormat (String : "-${rowCount}" : IRW)
    // Format for the string returned from +link{getFormattedRowCount()} when
    // +link{getRowCountStatus(),row count status} is <code>"maximum"</code>.
    // <P>
    // The variable <code>rowCount</code> is available for evaluation within
    // this string and will be set to the +link{getRowCount(),current row count} 
    // as a +link{isc.NumberUtil.toLocalizedString(),locale-formatted number}.
    //
    // @visibility rowCountDisplay
    //<
    maximumRowCountFormat:"-${rowCount}",

    //> @attr listGrid.rangeRowCountFormat (String : "${minRowCount}-${maxRowCount}" : IRW)
    // Format for the string returned from +link{getFormattedRowCount()} when
    // +link{getRowCountStatus(),row count status} is <code>"range"</code>.
    // <P>
    // The following variables are available for evaluation within this string:
    // <ul><li><code>minRowCount</code>: the lower bound of this row count value
    //         from +link{getRowCountRange(),getRowCountRange()[0]},
    //         as a +link{isc.NumberUtil.toLocalizedString(),locale-formatted number}.</li>
    //     <li><code>minRowCount</code>: the upper bound of this row count value
    //         from +link{getRowCountRange(),getRowCountRange()[1]},
    //         as a +link{isc.NumberUtil.toLocalizedString(),locale-formatted number}.</li></ul>
    //
    // @visibility rowCountDisplay
    //<
    rangeRowCountFormat:"${minRowCount}-${maxRowCount}",

    //> @attr listGrid.rowCountDisplayPrecision (Integer : null : IRW)
    // When an exact +link{listGrid.getRowCount(),row count} is not known due
    // to progressive loading, this attribute allows the formatted row count
    // returned by +link{getFormattedRowCount()} and ultimately displayed in 
    // the +link{listGrid.rowCountDisplay,rowCountDisplay label} to be rounded to
    // a multiple of the specified value. If not explicitly set, this value
    // defaults to the +link{resultSet.resultSize,page size} for the data.
    // <P>
    // For example if the server reports a +link{dsResponse.totalRows}
    // of <code>320</code> while progressive loading is active (meaning this is not an
    // exact row count), and <code>rowCountDisplayPrecision</code> is set to
    // <code>150</code>, the formatted rowCount may display <code>300+</code>
    // <P>
    // The precision will round either up or down depending on 
    // the +link{getRowCountStatus(),row count status}.
    // <ul><li><code>rowCountStatus:"exact"</code> - this setting has no effect</li>
    //     <li><code>rowCountStatus:"minimum"</code> - the reported row count will be 
    //         rounded down to the previous multiple of this value.</li>
    //     <li><code>rowCountStatus:"maximum"</code> - the reported row count will be 
    //         rounded up to the next multiple of this value.</li>
    //     <li><code>rowCountStatus:"approximate"</code> - the reported row count will be 
    //         rounded either up or down to the nearest multiple of this value.</li>
    //     <li><code>rowCountStatus:"range"</code> - the reported minimum row count will be 
    //         rounded down to the next multiple of this value, and the reported maximum
    //         will be rounded up to the next multiple of this value.</li></ul>
    // </ul>
    // Note the formatted row count will never be rounded down to zero - if the row count
    // is less than the <code>rowCountDisplayPrecision</code>, the exact reported row count 
    // value will be displayed. This could typically only occur if <code>rowCountDisplayPrecision</code>
    // is more than the +link{resultSet.resultSize,page size} for the data.
    // <P>
    // This value may be set to <code>1</code> to effectively disable the rounding behavior
    // altogether (the row count will not be displayed exactly as reported).
    // <P>
    // Note that this is purely a formatting setting for the formatted row count string.
    // It has no impact on the behavior of the grid in terms of 
    // the reported +link{resultSet.getLength(),data length}, 
    // +link{listGrid.getTotalRows(),totalRows} or scrollable area.
    //
    // @visibility rowCountDisplay
    //<
    // rowCountDisplayPrecision:1,

    //> @method listGrid.getFormattedRowCount()
    // Returns the +link{listGrid.getRowCount(),current total row count} for
    // this grid as a formatted string. See also +link{listGrid.getRowRangeDisplayValue()}.
    // <P>
    // Note: due to +link{dataSource.progressiveLoading,progressiveLoading},
    // an exact total row count may not be available. Depending on the 
    // current +link{getRowCountStatus()rowCount status}, this method will return
    // a value in one of the following formats:
    // <ul>
    //  <li><code>"exact"</code>: The row count will be formatted using +link{exactRowCountFormat}</li>
    //  <li><code>"minimum"</code>: The row count will be formatted using +link{minimumRowCountFormat}</li>
    //  <li><code>"approximate"</code>: The row count will be formatted using +link{approximateRowCountFormat}</li>
    //  <li><code>"maximum"</code>: The row count will be formatted using +link{maximumRowCountFormat}</li>
    //  <li><code>"range"</code>: The row count range will be formatted using +link{rangeRowCountFormat}</li>
    //  <li><code>"unknown"</code>: The +link{unknownRowCountDisplayValue} will be displayed</li>
    //  <li><code>"loading"</code>: The +link{loadingRowCountDisplayIcon} will be displayed</li>
    // </ul>
    //
    // @return (String) the formatted rowCount display value
    // @visibility rowCountDisplay
    //<
    getFormattedRowCount : function () {

        var status = this.getRowCountStatus();
        if (status == "unknown") {
            return this.unknownRowCountDisplayValue;
        }
        if (status == "loading") {
            return this.imgHTML({
                src:this.loadingRowCountDisplayIcon,
                width:this.loadingRowCountDisplayIconWidth,
                height:this.loadingRowCountDisplayIconHeight
            });
        }

        // In this case we're going to use a formatted value
        if (status == "range") {
            var totalRowRange = this.getRowCountRange(),
                min = this._applyRowCountDisplayPrecision(totalRowRange[0],"minimum"),
                max = this._applyRowCountDisplayPrecision(totalRowRange[1],"maximum");
            return this.rangeRowCountFormat.evalDynamicString(
                    this, 
                    {   
                        minRowCount:isc.NumberUtil.toLocalizedString(min), 
                        maxRowCount:isc.NumberUtil.toLocalizedString(max)
                    }
            );

        } else {

            var totalRows = this._applyRowCountDisplayPrecision(this.getRowCount(), status);
            totalRows = isc.NumberUtil.toLocalizedString(totalRows);

            var format = this.exactRowCountFormat;
            switch (status) {
                case "minimum" :
                    format = this.minimumRowCountFormat;
                    break;
                case "approximate" :
                    format = this.approximateRowCountFormat;
                    break;
                case "maximum" :
                    format = this.maximumRowCountFormat;
                    break;
            }
            return format.evalDynamicString(this, {rowCount:totalRows});
        }
    },

    _applyRowCountDisplayPrecision : function (totalRows, status) {
        if (totalRows == null) return totalRows; // sanity check for bad values
        if (status == "exact") return totalRows;

        // Round the value if configured to do so:
        var precision = this.rowCountDisplayPrecision;
        // default to data page size
        if (precision == null) {
            precision = this.data ? this.data.resultSize : this.dataPageSize;
        }
        if (precision == null || precision == 1 || precision == 0) return totalRows;

        var multiple = 0;
        if (status == "approximate") {
            multiple = Math.round(totalRows/precision);
        } else if (status == "maximum") {
            multiple = Math.ceil(totalRows/precision);
        } else if (status == "minimum") {
            multiple = Math.floor(totalRows/precision);
        }
        if (multiple == 0) return totalRows;
        return (multiple*precision);
    },

    //> @method listGrid.getRowCount()
    // Retrieves the +link{resultSet.getRowCount(),row count} for the grid, which
    // may differ from the reported +link{resultSet.getLength(),data length} if 
    // +link{dataSource.progressiveLoading,progressive loading} is enabled.
    // <P>
    // See also +link{getRowCountStatus()}
    //
    // @return (integer) current row count for the grid
    // @visibility rowCountDisplay
    //<
    getRowCount : function () {
        if (this.data && this.data.getRowCount) return this.data.getRowCount();
        return this.data && this.data.getLength() || 0;
    },

    //> @method listGrid.getRowCountRange()
    // Retrieves the +link{resultSet.getRowCountRange(),row count range} for 
    // listGrids where +link{dataSource.progressiveLoading,progressive loading} is
    // active and the row count has been specified as a +link{resultSet.getRowCountStatus(),range}.
    // <P>
    // The returned value will be a two element array, containing the min and max bounds
    // for the row-count. Note that if the row count has not been recorded as a range,
    // the first element in the array will be the +link{getRowCount(),row count}, and
    // the second element will be null.
    // @return (Array of integer) minimum and maximum bounds for the row count
    // @visibility rowCountDisplay
    //<
    getRowCountRange : function () {
        if (this.data && this.data.getRowCountRange) return this.data.getRowCountRange();
        return [this.getRowCount(),null];
    },

    //> @method listGrid.getRowCountStatus()
    // This method indicates whether +link{listGrid.getRowCount()} reflects an accurate
    // row-count for this listGrid. An accurate row count may not currently be available
    // if +link{progressiveLoading} is active.
    // <P>
    // See +link{type:RowCountStatus} for further details.
    //
    // @return (RowCountStatus) Current row-count status for this grid
    // @visibility rowCountDisplay
    //<
    getRowCountStatus : function () {
        // The ResultSet deals with retrieving the fetch responses
        // and tracks the estimatedTotalRows returned by the server.
        if (this.data && this.data.getRowCountStatus != null) return this.data.getRowCountStatus();
        if (this.data && this.data.lengthIsKnown != null && !this.data.lengthIsKnown()) return "unknown";
        return "exact";
    },

    //> @method listGrid.fetchRowCount()
    // For databound grids, method will fall through to +link{resultSet.fetchRowCount()}, allowing
    // developers to request an accurate row count from the dataSource when
    // +link{dataSource.progressiveLoading,progressive loading is active}.
    //
    // @param [callback] (RowCountCallback) Callback to fire when the fetch request completes.
    //  To retrieve details of the row-count that was retrieved from the server, use
    //  the <code>getRowCount()</code> and <code>getRowCountStatus()</code> methods.
    // @param [dsRequest] (DSRequest properties) Custom properties for the row count fetch request
    //
    // @visibility rowCountDisplay
    //<
    fetchRowCount : function (callback, dsRequest) {
        if (this.data && this.data.fetchRowCount) this.data.fetchRowCount(callback, dsRequest);
    },

// -----------------------------------------------------------------------------------------
// Expando Rows
//

    //> @type ExpansionComponentPoolingMode
    // The method of pooling to employ for +link{listGrid.canExpandRecords,expansionComponents}.
    // <P>
    // @value "destroy" auto-created, built-in components are destroyed when record are
    //        +link{listGrid.collapseRecord,collapsed}.
    // @value "none" all expansion components are deparented from the grid when a record is
    //        +link{listGrid.collapseRecord,collapsed} but are not destroyed.  It is the responsibility
    //        of the developer to handle component destruction
    // @visibility external
    //<

    //> @attr listGrid.expansionComponentPoolingMode (ExpansionComponentPoolingMode : "destroy" : IRWA)
    // The method of +link{type:RecordComponentPoolingMode, component-pooling} to employ for
    // +link{canExpandRecords,expansionComponents}.
    // <P>
    // The default mode is "destroy", which means that automatically created expansionComponents
    // are destroyed when rows are collapsed.
    //
    // @visibility external
    //<
    expansionComponentPoolingMode: "destroy",

    
    destroyCustomExpansionComponents: false,

    //> @attr listGrid.canExpandRecords (Boolean : false : IRW)
    // When set to true, shows an additional field at the beginning of the field-list
    // (respecting RTL) to allow users to expand and collapse individual records.
    // See +link{listGrid.expandRecord()} and +link{listGrid.expansionMode} for details
    // on record expansion.
    // <P>
    // +link{listGrid.virtualScrolling} is automatically enabled when canExpandRecords is
    // set to true.
    // <P>
    // Note that expanded records are not currently supported in conjunction
    // with +link{listGridField.frozen,frozen fields}.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.canExpandMultipleRecords (Boolean : true : IRW)
    // When +link{listGrid.canExpandRecords} is true, this property indicates whether multiple
    // records can be expanded simultaneously.  If set to false, expanding a record will
    // automatically collapse any record which is already expanded.  The default value is
    // <code>true</code>.
    //
    // @group expansionField
    // @visibility external
    //<
    canExpandMultipleRecords: true,

    //> @attr listGrid.maxExpandedRecords (Integer : null : IRW)
    // When +link{listGrid.canExpandRecords} and +link{listGrid.canExpandMultipleRecords} are
    // both true, this property dictates the number of
    // records which can be expanded simultaneously.  If the expanded record count hits the
    // value of this property, further attempts to expand records will result in a popup
    // warning (see +link{listGrid.maxExpandedRecordsPrompt}) and expansion will be cancelled.
    // <P>
    // The default value is null, meaning there is no limit on the number of expanded records.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.maxExpandedRecordsPrompt (HTMLString : "This grid is limited to ${count} simultaneously expanded records.  Please collapse some expanded records and retry." : IR)
    // This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
    // when the message is displayed. Note that the local variable <code>count</code> will be
    // available and set to this.maxExpandedRecords. The string will be executed in the scope of the
    // ListGrid so <code>this</code> may also be used to determine other information about this grid.
    // <P>
    // Default value returns <P>
    // <code>
    // <i>This grid is limited to <code>[+link{listGrid.maxExpandedRecords}]</code> simultaneously
    // expanded records.  Please collapse some expanded records and retry.</i>
    // </code>
    // @visibility external
    // @group i18nMessages
    //<
    maxExpandedRecordsPrompt: "This grid is limited to ${count} simultaneously expanded records.  Please collapse some expanded records and retry.",

    //> @type ExpansionMode
    // When +link{ListGrid.canExpandRecords, canExpandRecords} is true, ExpansionMode
    // dictates the type of UI to be displayed in the expanded portion of the row.
    // <P>
    // There are a number of builtin ExpansionModes and you can override
    // +link{listGrid.getExpansionComponent, getExpansionComponent()} to create your own
    // expansion behaviors.
    //
    //  @value  "detailField"  Show a single field's value in an +link{class:HtmlFlow}. Field
    //      to use is +link{listGrid.detailField}.
    //  @value  "details"   Show a +link{class:DetailViewer} displaying those fields from the
    //      record which are not already displayed in the grid.
    //  @value  "related"    Show a separate +link{class:ListGrid} containing related-records.
    //      See +link{ListGridRecord.detailDS} and +link{ListGrid.recordDetailDSProperty} for
    //      more information.
    //  @value  "editor"    Show a +link{class:DynamicForm} to edit those fields from the
    //      record which are not already present in the grid.  If the record is collapsed with
    //      unsaved changes and +link{listGrid.expansionEditorShowSaveDialog} is not set, Edits
    //      will be saved automatically, or stored as +link{group:editing,editValues} if
    //      +link{listGrid.autoSaveEdits} is false.  Otherwise, a confirmation dialog is
    //      displayed.  Can optionally show a
    //      +link{listGrid.showExpansionEditorSaveButton,save button} and
    //      +link{listGrid.expansionEditorCollapseOnSave,auto-collapse} when save is pressed.
    //      If a record fails validation on save and the field in question is not visible in
    //      the grid, the record is automatically expanded and validated to show the errors.
    //  @value  "detailRelated"    Show a +link{class:DetailViewer} displaying those fields
    //      from the record not already displayed in the grid, together with a separate
    //      +link{class:ListGrid} containing related-records.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.detailField (String : null : IRW)
    // The field whose contents to show in the expanded portion of a record when
    // +link{listGrid.canExpandRecords, canExpandRecords} is <code>true</code> and
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>detailField</code>.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionMode (ExpansionMode : null : IRW)
    // The +link{ExpansionMode} for records in this grid.
    // <p>
    // If +link{ListGrid.canExpandRecords, canExpandRecords} is true but <code>expansionMode</code>
    //  is not set, it defaults to "detailRelated" if +link{listGrid.detailDS} is set, or to 
    // "details" otherwise.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionField (AutoChild ListGridField : null : IRWA)
    // The field providing the facility to expand and collapse rows.
    // @group expansionField
    // @visibility external
    //<
    expansionFieldDefaults: {
        name: "_expansionField",
        canEdit: false,
        canFilter: false,
        canGroupBy: false,
        canSort: false,
        canExport: false,
        canHide: false,
        canReorder: false,
        canDragResize: false,
        // make this special field canHilite false so we don't see it in HiliteEditors
        canHilite: false,
        _isExpansionField: true,
        showDefaultContextMenu: false,
        keyboardFiresRecordClick: false,
        cellAlign: "center",
        summaryValue: "&nbsp;",
        // specifically disable filterOperators for this builtin field
        allowFilterOperators: false,
        
        cellMouseDown : function (viewer, record, rowNum, colNum) {
            if (!viewer.canExpandRecords || record._isGroup) return;
            if (!viewer._canExpandRecord(record, viewer.getRecordIndex(record))) return;
            if (viewer.isExpanded(record)) viewer.collapseRecord(record);
            else viewer.expandRecord(record);
        },
        formatCellValue : function (value, record, rowNum, colNum, grid) {
            // This ensures that if we're looking at an edit row for a new record we
            // don't show the expansion icon
            record = grid.getCellRecord(rowNum, colNum);
            if (record == null || record._isGroup) return null;
            if (!grid._canExpandRecord(record, rowNum)) return null;
            var src = grid.isExpanded(record) ? grid.expansionFieldTrueImage : grid.expansionFieldFalseImage
            var state;
            if (grid.expansionFieldImageShowSelected && grid.isSelected(record, rowNum)) {
                state = "selected";
            }
            if (grid.expansionFieldImageShowRTL && grid.isRTL()) {
                state = state == null ? "rtl" : state + "_rtl";
            }
            if (state != null) {
                src = isc.Img.urlForState(src, null, null, null, null, state);
            }
            return grid.getValueIconHTML(src, null, this, isc.Canvas.HAND);
        },
        autoFreeze: true,
        // disable this from ever being assigned as the treeField
        treeField:false,
        // flag that means this is a special builtin field, not for formulas/export/etc
        featureField: true
    },

    // Helper method - should this grid show the special expansion field when canExpandRecords is true
    shouldShowExpansionField : function () {
        return this.fieldSourceGrid ? this.fieldSourceGrid.shouldShowExpansionField()
                                    : this.canExpandRecords;
    },

    //> @attr listGrid.expansionFieldTrueImage (SCImgURL : null :IRWA)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // determines the image to display in the expansion field for expanded rows.
    // If unset, the +link{listGrid.booleanTrueImage} will be used.
    // @see listGrid.expansionFieldFalseImage
    // @see listGrid.expansionFieldImageWidth
    // @see listGrid.expansionFieldImageHeight
    // @group expansionField
    // @visibility external
    //<
    expansionFieldTrueImage: "[SKINIMG]/ListGrid/group_opened.gif",

    //> @attr listGrid.expansionFieldFalseImage (SCImgURL : null :IRWA)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // determines the image to display in the expansion field for collapsed rows.
    // If unset, the +link{listGrid.booleanFalseImage} will be used.
    // @see listGrid.expansionFieldTrueImage
    // @see listGrid.expansionFieldImageWidth
    // @see listGrid.expansionFieldImageHeight
    // @group expansionField
    // @visibility external
    //<
    expansionFieldFalseImage: "[SKINIMG]/ListGrid/group_opening.gif",

    //> @attr listGrid.expansionFieldImageShowRTL (boolean : false : IRA)
    // If this grid is in RTL mode, should an "_rtl" suffix be added to the +link{expansionFieldTrueImage,expansionFieldTrueImage}
    // and +link{expansionFieldFalseImage,expansionFieldFalseImage} image URLs? This should only
    // be enabled if RTL media for the true and false expansion field images are available.
    // <P>
    // If both this property and +link{expansionFieldImageShowSelected} are true, and
    // the grid is in RTL mode, both suffixes will be applied to selected rows'
    // expansion field images (combined as "selected_rtl").
    //
    // @group RTL
    // @group expansionField
    // @visibility external
    //<
    expansionFieldImageShowRTL: false,

    //> @attr listGrid.expansionFieldImageShowSelected (boolean : false : IRA)
    // Should a "_selected" suffix be added to the 
    // +link{expansionFieldTrueImage,expansionFieldTrueImage}
    // and +link{expansionFieldFalseImage,expansionFieldFalseImage} image URLs for
    // selected rows?
    // <P>
    // This allows developers to provide separate expansion field media for selected
    // rows, in case the selected row style does not contrast well with the standard
    // expansion field image media.
    // <P>
    // If both this property and +link{expansionFieldImageShowRTL} are true, and
    // the grid is in RTL mode, both suffixes will be applied to selected rows'
    // expansion field image (combined as "selected_rtl")
    //
    // @group expansionField
    // @visibility external
    //<
    expansionFieldImageShowSelected: false,


    //> @attr listGrid.expansionFieldImageWidth (Integer : null : IR)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // may be set to govern the width of the expansion image displayed to indicate whether a row
    // is expanded. If unset, the expansionField image will be sized to match the
    // +link{listGrid.booleanImageWidth} for this grid.
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionFieldImageHeight (Integer : null : IR)
    // If +link{listGrid.canExpandRecords} is set to <code>true</code>, this property
    // may be set to govern the height of the expansion image displayed to indicate whether a
    // row is expanded. If unset, the expansionField image will be sized to match the
    // +link{listGrid.booleanImageHeight} for this grid.
    // @group expansionField
    // @visibility external
    //<

    //> @method listGrid.getExpansionField()
    // Returns the specially generated expansion field used when +link{canExpandRecords} is
    // true.
    // <P>
    // Called during +link{setFields()}, this method can be overridden to add advanced dynamic
    // defaults to the expansion field (call Super, modify the default field returned by Super,
    // return the modified field).  Normal customization can be handled by just setting
    // +link{AutoChild} properties, as mentioned under the docs for +link{listGrid.expansionField}.
    //
    // @return (ListGridField)
    // @group expansionField
    // @visibility external
    //<
    // the amount to add to the icon width to get the expansion field width
    expansionFieldExtraWidth: 16,
    getExpansionField : function () {
        var grid = this,
            expField = {
                excludeFromState:true,
                // default the width to the width of the icon plus an arbitrary buffer
                width: this._getExpansionFieldImageWidth() + this.expansionFieldExtraWidth,
                getAutoFreezePosition: function () { return grid.getExpansionFieldPosition() }
            }
        ;

        // if expansionFieldImageWidth/Height are set on this grid, pass them through to the field
        expField.valueIconWidth = this._getExpansionFieldImageWidth();
        expField.valueIconHeight = this._getExpansionFieldImageHeight();

        // combine the properties for the field using the autoChild pattern
        isc.addProperties(expField, this.expansionFieldDefaults, this.expansionFieldProperties);

        expField.title = isc.nbsp;

        return expField;
    },

    getCurrentExpansionField : function () {
        var fields = this.completeFields || this.fields,
            expFields = fields.find(this.fieldIdProperty, "_expansionField");
        return !expFields ? null : isc.isAn.Array(expFields) ? expFields[0] : expFields;
    },

    _getExpansionFieldImageWidth : function () {
        return this.expansionFieldImageWidth || this.booleanImageWidth ||
                (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null);
    },
    _getExpansionFieldImageHeight : function () {
        return this.expansionFieldImageHeight || this.booleanImageHeight ||
                (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconHeight") : null);
    },

    //> @method listGrid.isExpansionField()
    // Identifies whether the passed-in field is the specially generated
    // +link{listGrid.expansionField,expansionField} used when +link{canExpandRecords} is
    // true.  Use this method in your custom event handlers to avoid inappropriately
    // performing actions when the expansionField is clicked on.
    //
    // @param field (ListGridField) field to test
    // @return (Boolean) whether the provided field is the expansion field
    // @group expansionField
    // @visibility external
    //<
    isExpansionField : function (field) {
        if (!field) return false;
        var fieldObj = this.getField(field);
        if (fieldObj && fieldObj._isExpansionField) return true;
        return false;
    },

    // helper function to get the expansion field position
    // This is one of the fields that appears "stuck" to the left of the grid - these are
    // - row number field
    // - group summary title field
    // - expansion field
    // - checkbox selection field
    getExpansionFieldPosition : function () {
        if (this.fieldSourceGrid != null) return this.fieldSourceGrid.getExpansionFieldPosition();

        if (!this.shouldShowExpansionField()) return -1;
        
        var pos = 0;
        if (this.shouldShowRowNumberField())  pos++;
        if (this.shouldShowDragHandleField()) pos++;
        if (this.shouldShowCheckboxField())   pos++;
        return pos;
    },

    _canExpandRecord : function (record,rowNum) {
        if (record == null) record = this.getRecord(rowNum);
        if (record == null) return false;
        return this.canExpandRecord(record,rowNum);
    },
    //> @method listGrid.canExpandRecord()
    // Indicates whether a given record or rowNum can be expanded.  The default implementation
    // checks the value of +link{listGrid.canExpandRecords} and
    // <code>record[+link{listGrid.canExpandRecordProperty}]</code>.
    // <P>
    // Override this method for more specific control over individual record expansion.
    // <P>
    // <b>Note:</b> Rows with no underlying record in the data array - for example newly
    // added edit rows that have not yet been saved - cannot be expanded.
    //
    // @param record (ListGridRecord) record to work with
    // @param rowNum (Number) rowNum of the record to work with
    // @return (boolean) true if the record can be expanded
    // @group expansionField
    // @visibility external
    //<
    canExpandRecord : function (record, rowNum) {
        return record[this.canExpandRecordProperty] == false ? false :
            true && (this.canExpandRecords != false);
    },

    //> @method listGrid.setCanExpandRecords()
    // Setter for +link{listGrid.canExpandRecords}
    // @param canExpand (boolean) new value for listGrid.canExpandRecords.
    // @visibility external
    //<
    setCanExpandRecords : function (canExpand) {
        if (this.canExpandRecords == canExpand) return;
        if (!canExpand) {
            var data = this.data;
            if (data) {
                var expandedRows = this._getExpandedRows();
                if (expandedRows != null) {
                    for (var i = 0; i < expandedRows.length; i++) {
                        this.collapseRecord(expandedRows[i]);
                    }
                }
            }
        }
        this.canExpandRecords = canExpand;
        this.refreshFields();
    },

    //> @method listGrid.expandRecord()
    // Expands a given +link{ListGridRecord, record} by creating a subcomponent and inserting it
    // in to the record's grid-row.  A number of built-in +link{ExpansionMode, expansionModes}
    // are supported by the default implementation of
    // +link{listGrid.getExpansionComponent, getExpansionComponent()} and you can override
    // that method to provide your own expansion behavior.
    // <P>
    // Once a record has been expanded, the currently visible expansion component may be
    // retrieved via +link{getCurrentExpansionComponent()}.
    //
    // @param record (ListGridRecord) record to expand
    // @group expansionField
    // @visibility external
    //<
    _expandedRecordCount: 0,
    expandRecord : function (record, shouldRedraw) {
        if (!this.body) {
            // called before draw - add the record to an internal array, this method
            // will be called again with this record after the grid has drawn
            if (!this._recordsToExpand) this._recordsToExpand = [];
            this._recordsToExpand.add(record);
            return;
        }

        var result = false,
            component
        ;

        if (!this.isExpanded(record)) {

            // notification method / cancellation point
            
            if (this.onExpandRecord != null && !this.onExpandRecord(record)) return false;

            if (!this.canExpandMultipleRecords) {
                // can only expand one record - if one's expanded already, collapse it now
                if (this._currentExpandedRecord)
                    this.collapseRecord(this._currentExpandedRecord);
                this._currentExpandedRecord = record;
            } else if (this.maxExpandedRecords != null) {
                // limited number of expanded records allowed - if we've hit that number, show the
                // maxExpandedRecordsPrompt and return
                if (this._expandedRecordCount >= this.maxExpandedRecords) {
                    var message = this.maxExpandedRecordsPrompt.evalDynamicString(this, {
                        count: this.maxExpandedRecords
                    });
                    isc.say(message);
                    return false;
                }
            }

            // create an appropriate subcomponent and bind it
            component = this._getExpansionComponent(record);
            var extraSpaceInMargins = this.getEmbeddedComponentMargin();
            var isRTL = this.isRTL(),
                layoutProperties = {
                    layoutLeftMargin: isRTL ? extraSpaceInMargins : this.getExpansionIndent(),
                    layoutRightMargin: isRTL ? this.getExpansionIndent() : extraSpaceInMargins,
                    layoutTopMargin: (extraSpaceInMargins != 0) ? extraSpaceInMargins - 3 : 0,
                    layoutBottomMargin: extraSpaceInMargins
                }
            ;
            if (component) layoutProperties.members = [component];
            var layout = this.createAutoChild("expansionLayout", layoutProperties);
            layout.isExpansionComponent = true;
            layout.removeOnHideField = true;
            this.addEmbeddedComponent(layout, record, this.data.indexOf(record));
            this._setExpanded(record, true);
            this._setExpansionComponent(record, true);
            this._expandedRecordCount++;
            if (!this.canExpandMultipleRecords) this._currentExpandedRecord = record;
            // only return true if the record was actually expanded as a result of this call 
            result = true;
        }

        if (shouldRedraw != false) {
            this.delayCall("markForRedraw", ["Expanded Record"]);
        }

        return result;
    },
    
    //> @method listGrid.expandRecords()
    // Expands the passed list of +link{ListGridRecord, records} by creating a subcomponent for
    // each record and inserting them it in to the record's grid-row.  Calls
    // +link{listGrid.expandRecord, expandRecord} for each passed record, but only marks the
    // grid for redraw once, after all expansions are complete.
    // 
    // @param records (Array of ListGridRecord) records to expand
    // @group expansionField
    // @visibility external
    //<
    expandRecords : function (records) {
        if (!records || records.length == 0) return;
        var len = records.length;
        for (var i=0; i<len; i++) {
            var isLast = (i == len - 1);
            this.expandRecord(records[i], isLast);
        }
    },

    //> @method listGrid.collapseRecord()
    // Collapses a given +link{ListGridRecord, record} which has been previously expanded using
    // +link{listGrid.expandRecord}.
    // <P>
    // Depending on the +link{listGrid.expansionComponentPoolingMode, pooling mode},
    // this method may automatically destroy expansionComponents.  By default, components
    // created automatically by the ListGrid will be auto-destroyed.  This
    // behavior can be changed by setting a different pooling mode.
    // <P>
    // Note that components created via an override to +link{listGrid.getExpansionComponent}
    // will <b><i>not</i></b> be auto-destroyed - developers should override
    // <code>collapseRecord</code> to take care of clean-up for such components.
    //
    // @param record (ListGridRecord) record to collapse
    // @group expansionField
    // @visibility external
    //<
    collapseRecord : function (record, shouldRedraw) {
        // no passed record
        if (!record) return;

        var component = this._getEmbeddedComponents(record).find("isExpansionComponent", true);

        // bail if there's no expansion component on the passed record
        if (!component) return;

        // set this flag here because collapse can be interactive (and can be cancelled)
        this._redrawOnCollapseRecord = shouldRedraw;

        if (isc.isA.Layout(component)) {
            var member = component.getMember(0);
            if (member) {
                if (!isc.isA.DynamicForm(member)) member = member.formMember;
                if (isc.isA.DynamicForm(member) && member.valuesHaveChanged()) {
                    this.saveAndCollapseRecord(member, component, record, true, true);
                    return;
                }
            }
        }

        this._collapseRecord(record, component);
    },

    //> @method listGrid.collapseRecords()
    // Collapses the passed list of expanded +link{ListGridRecord, records}.  Calls
    // +link{listGrid.collapseRecord, collapseRecord} for each passed record, but only marks
    // the grid for redraw once, after all records have been collapsed.
    // 
    // @param records (Array of ListGridRecord) records to collapse
    // @group expansionField
    // @visibility external
    //<
    collapseRecords : function (records) {
        if (!records || records.length == 0) return;
        var len = records.length;
        for (var i=0; i<len; i++) {
            var isLast = (i == len - 1);
            this.collapseRecord(records[i], isLast);
        }
    },

    saveAndCollapseRecord : function (member, component, record, shouldShowSaveDialog, shouldCollapse) {
        if (this.autoSaveEdits == true) {
            var _this = this;

            if (this.expansionEditorShowSaveDialog && shouldShowSaveDialog) {
                isc.confirm(this.expansionEditorSaveDialogPrompt,
                    function (yes) {
                        if (yes) {
                            _this.saveExpansionDetail(member, component, record, shouldCollapse);
                        } else {
                            if (shouldCollapse) _this._collapseRecord(record, component);
                        }
                    }
                );
            } else {
                this.saveExpansionDetail(member, component, record, shouldCollapse);
            }
            return;
        } else {
            var _values = member.getChangedValues(),
                rowNum = this.getRecordIndex(record),
                _this = this
            ;

            if (this.expansionEditorShowSaveDialog && shouldShowSaveDialog) {
                isc.confirm("You have unsaved changes - do you want to save them now?",
                    function (yes) {
                        if (yes) {
                            _this._saveExpansionEditorValues(rowNum, _values);
                        }
                        if (shouldCollapse) _this._collapseRecord(record, component);
                    }
                );
                return;
            } else {
                _this._saveExpansionEditorValues(rowNum, _values);
                if (shouldCollapse) this._collapseRecord(record, component);
                return;
            }
        }
    },

    
    _saveExpansionEditorValues : function (rowNum, values) {
        for (var key in values) {
            this.setEditValue(rowNum, key, values[key]);
        }
    },

    saveExpansionDetail : function (member, component, record, shouldCollapse) {
        var _this = this;
        member.saveData(
            function (dsResponse, data, dsRequest) {
                if (data) {
                    record = data;
                    if (shouldCollapse) _this._collapseRecord(record, component);
                    else member.editRecord(record);
                }
            }, { showPrompt: true, promptStyle: "cursor" }
        );
    },

    _collapseRecord : function (record, component) {
        if (!record) return;
        component = component ||
            this._getEmbeddedComponents(record).find("isExpansionComponent", true);

        if (this.isExpanded(record)) {
            // notification method / cancellation point
            
            if (this.onCollapseRecord != null && !this.onCollapseRecord(record)) return;

            if (this._currentExpandedRecord && this._currentExpandedRecord == record)
                delete this._currentExpandedRecord;

            this.removeEmbeddedComponent(record, component ? component : this.frozenFields ? this.frozenFields.length : 0);
            this._expandedRecordCount--;
        }
        this._setExpanded(record, false);

        if (this._redrawOnCollapseRecord != false) {
            // only markForRedraw if shouldRedraw:false wasn't passed to collapseRecord
            this.markForRedraw();
        }
    },

    

    _$expandedPrefix:"_expanded_",

    //> @method listGrid.isExpanded()
    // Whether a given +link{ListGridRecord, record} is expanded or collapsed.
    //
    // @param record (ListGridRecord) record in question
    // @group expansionField
    // @return  (Boolean)           true if the node is expanded
    // @visibility external
    //<
    isExpanded : function (record) {
        return (!record ? false : !!record[this._$expandedPrefix + this.ID]);
    },

    //> @method listGrid.getExpandedRecords()
    // Returns the list of +link{ListGridRecord, records} from this ListGrid that are
    // +link{listGrid.expandRecord(),expanded}
    //
    // @group expansionField
    // @return  (Array of ListGridRecord) All expanded records in the grid
    // @visibility external
    //<
    getExpandedRecords : function () {
        return this._getExpandedRows();
    },

    _setExpanded : function (record, value) {
        record[this._$expandedPrefix + this.ID] = value;
    },
    _getExpandedRows : function () {
        return this.data.findAll(this._$expandedPrefix + this.ID, true);
    },

    _$hasExpansionComponentPrefix:"_hasExpansionComponent_",
    _hasExpansionComponent : function (record) {
        return record[this._$hasExpansionComponentPrefix + this.ID];
    },
    _setExpansionComponent : function (record, value) {
        record[this._$hasExpansionComponentPrefix + this.ID] = value;
    },

    
    _$embeddedComponentsPrefix:"_embeddedComponents_",

    _hasEmbeddedComponents : function (record) {
        if (!record) return false;
        var ids = record[this._$embeddedComponentsPrefix + this.ID];
        return (ids != null && ids.length > 0);
    },
    _getEmbeddedComponents : function (record) {
        if (!record) return [];
        // Convert array of IDs into an array of component references
        var ids = record[this._$embeddedComponentsPrefix + this.ID],
            components = []
        ;
        if (!ids) return components;
        for (var i = 0; i < ids.length; i++) {
            components[i] = isc.Canvas.getById(ids[i]);
        }
        return components;
    },
    _setEmbeddedComponents : function (record, value) {
        record[this._$embeddedComponentsPrefix + this.ID] = value;
    },

    _addEmbeddedComponent : function (record, component) {
        if(!record[this._$embeddedComponentsPrefix + this.ID]) {
            record[this._$embeddedComponentsPrefix + this.ID] = [];
        }
        if (!record[this._$embeddedComponentsPrefix + this.ID].contains(component.getID())) {
            record[this._$embeddedComponentsPrefix + this.ID].add(component.getID());
        }
    },
    _removeEmbeddedComponent : function (record, component) {

        var ids = record[this._$embeddedComponentsPrefix + this.ID];
        if (ids == null) return;
        if (ids.length == 0) {
            record[this._$embeddedComponentsPrefix + this.ID] = null;
            return;
        }
        ids.remove(component.getID());
        if (ids.length == 0) {
            record[this._$embeddedComponentsPrefix + this.ID] = null;
        }
    },

    _deleteEmbeddedComponents : function (record, value) {
        delete record[this._$embeddedComponentsPrefix + this.ID];
    },

    
    _$recordComponentsPrefix:"_recordComponents_",
    _hasRecordComponents : function (record) {
        return (record && record[this._$recordComponentsPrefix + this.ID] != null);
    },
    _getRecordComponents : function (record) {
        if (!record) return null;

        // Convert array of IDs into an array of component references
        var ids = record[this._$recordComponentsPrefix + this.ID],
            components = {}
        ;
        if (ids) {
            for (var key in ids) {
                if (ids[key].isNullMarker) {
                    components[key] = ids[key];
                } else {
                    components[key] = isc.Canvas.getById(ids[key]);
                }
            }
        }
        return components;
    },
    _addRecordComponent : function (record, fieldName, component) {
        if(!record[this._$recordComponentsPrefix + this.ID]) {
            record[this._$recordComponentsPrefix + this.ID] = {};
        }
        if (component.isNullMarker) {
            record[this._$recordComponentsPrefix + this.ID][fieldName] = component;
        } else {
            record[this._$recordComponentsPrefix + this.ID][fieldName] = component.getID();
        }
    },
    _deleteRecordComponent : function (record, fieldName) {
        var ids = record[this._$recordComponentsPrefix + this.ID];
        if (ids == null) return;
        if (isc.isAn.emptyObject(ids)) {
            record[this._$recordComponentsPrefix + this.ID] = null;
            return;
        }
        // Not per-cell - just use the special "no field" fieldName
        if (fieldName == null) fieldName = this._$noFieldString;

        delete ids[fieldName];
        if (isc.isAn.emptyObject(ids)) {
            record[this._$recordComponentsPrefix + this.ID] = null;
        }
    },

    //> @attr listGrid.expansionDetailField (MultiAutoChild HTMLFlow : null : RA)
    // Automatically generated +link{class:HTMLFlow} for displaying the contents of
    // +link{listGrid.detailField, a specified field} in a record's expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>detailField</code>.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionDetailFieldProperties</code> and
    // <code>listGrid.expansionDetailFieldDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionDetailFieldDefaults: {
        _constructor: isc.HTMLFlow,
        selectCellTextOnClick:false,
        autoDraw: false,
        width: "100%",
        height: "100%"
    },
    //> @attr listGrid.expansionDetails (MultiAutoChild DetailViewer : null : RA)
    // Automatically generated +link{class:DetailViewer} for displaying the details of a record
    // in its expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>details</code>.  Note that
    // only those fields
    // which do not already appear in the grid are displayed in the expanded section.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionDetailsProperties</code> and
    // <code>listGrid.expansionDetailsDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionDetailsDefaults: {
        _constructor: isc.DetailViewer,
        autoDraw: false,
        width: "100%"
    },
    //> @attr listGrid.expansionRelated (MultiAutoChild ListGrid : null : RA)
    // Automatically generated +link{class:ListGrid} for displaying data related to a record
    // in its expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>related</code>.
    // The +link{class:DataSource} containing the related data is provided by
    // +link{listGrid.getRelatedDataSource, getRelatedDataSource()} which, by default,
    // returns the DataSource referred to in +link{listGridRecord.detailDS}.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionRelatedProperties</code> and
    // <code>listGrid.expansionRelatedDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionRelatedDefaults: {
        _constructor: isc.ListGrid,
        autoDraw: false,
        width: "100%",
        warnOnReusedFields:false,
        autoFitData: "vertical",
        autoFitMaxRecords: 4
    },

    //> @attr listGrid.expansionEditor (MultiAutoChild DynamicForm : null : RA)
    // Automatically generated +link{class:DynamicForm} for editing the details of a record
    // in its expanded section when
    // +link{type:ExpansionMode, listGrid.expansionMode} is <code>editor</code>.  Note that only
    // those fields which do not already appear in the grid will appear in the expanded section.
    // <P>
    // According to the value of +link{showExpansionEditorSaveButton}, a save button is shown
    // beneath the editor.  You can save the values in the editor by clicking this button
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionEditorProperties</code> and
    // <code>listGrid.expansionEditorDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionEditorDefaults: {
        _constructor: "DynamicForm",
        autoDraw: false,
        numCols: 4,
        colWidths: ["*", "*", "*", "*"],
        width: "100%",
        saveOperationType: "update"
    },

    //> @attr listGrid.expansionEditorShowSaveDialog (boolean : null : IR)
    // When +link{listGrid.canExpandRecords, canExpandRecords} is true and
    // +link{listGrid.expansionMode, expansionMode} is <i>editor</i>, whether a dialog should be
    // displayed when an expanded row is collapsed while it's nested editor has changed values.
    //
    // @group expansionField
    // @visibility external
    //<
    //expansionEditorShowSaveDialog: null,

    //> @attr listGrid.expansionEditorSaveDialogPrompt (String : "You have unsaved changes - do you want to save them now?" : IR)
    // When +link{listGrid.canExpandRecords, canExpandRecords} is true and
    // +link{listGrid.expansionMode, expansionMode} is <i>editor</i>, the prompt to display
    // in a dialog when an expanded row is collapsed while it's nested editor has changed values.
    //
    // @group expansionField,i18nMessages
    // @visibility external
    //<
    expansionEditorSaveDialogPrompt: "You have unsaved changes - do you want to save them now?",

    //> @attr listGrid.expansionEditorCollapseOnSave (Boolean : true : RW)
    // When +link{expansionMode} is <i>editor</i>, should the row be collapsed following a
    // save initiated by the expansion-component's +link{expansionEditorSaveButton, save button}.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionEditorCollapseOnSave: true,

    //> @attr listGrid.showExpansionEditorSaveButton (Boolean : true : RW)
    // When +link{expansionMode} is <i>editor</i>, should a Save button be shown below the
    // the expanded editor?
    // <P>
    // Note that if an expanded-row containing an editor is collapsed while changes are
    // outstanding, changes will be either be automatically updated to the grid, or will first
    // show a confirmation dialog, according to the value of
    // +link{expansionEditorShowSaveDialog}.
    //
    // @group expansionField
    // @visibility external
    //<
    showExpansionEditorSaveButton: true,

    //> @attr listGrid.expansionEditorSaveButton (MultiAutoChild IButton : null : RA)
    // Automatically generated +link{class:IButton} for saving the values in the expanded
    // portion of a ListGrid row.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionEditorSaveButtonProperties</code> and
    // <code>listGrid.expansionEditorSaveButtonDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionEditorSaveButtonDefaults: {
        _constructor: "IButton",
        autoFit: true,
        layoutAlign: "center",
        click : function () {
            if (!this.grid || !this.form || !this.record) return;
            var grid = this.grid,
                component = grid._getEmbeddedComponents(this.record).find("isExpansionComponent", true)
            ;

            // bail if no expansion component on the record 
            if (!component) return;

            this.grid.saveAndCollapseRecord(this.form, component, this.record, false,
                this.grid.expansionEditorCollapseOnSave
            );
        }
    },

    //> @attr listGrid.expansionEditorSaveButtonTitle (String : "Save" : RWA)
    // The title for the +link{expansionEditorSaveButton}.
    //
    // @group expansionField,i18nMessages
    // @visibility external
    //<
    expansionEditorSaveButtonTitle: "Save",

    //> @attr listGrid.expansionDetailRelated (MultiAutoChild HLayout : null : RA)
    // Automatically generated +link{class:HLayout} appearing in a record's expanded section
    // when +link{type:ExpansionMode, listGrid.expansionMode} is <code>detailRelated</code>.
    // This component contains two other autoChild components,
    // a +link{class:DetailViewer} for viewing fields from the record which are not already
    // present in the grid and a separate embedded +link{class:ListGrid} for displaying other
    // data related to this record via record.detailDS.  See +link{listGrid.expansionDetails}
    // and +link{listGrid.expansionRelated} for more information.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionDetailRelatedProperties</code> and
    // <code>listGrid.expansionDetailRelatedDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionDetailRelatedDefaults: {
        _constructor: isc.HLayout,
        autoDraw: false,
        width: "100%",
        height: "100%"
    },

    //> @attr listGrid.expansionLayout (MultiAutoChild VLayout : null : RA)
    // Automatically generated +link{class:VLayout} which fills a record's expanded section
    // and contains other builtin +link{ExpansionMode, expansion-components}.  You can also
    // override +link{listGrid.getExpansionComponent, getExpansionComponent()} to provide
    // components of your own specification.
    // <P>
    // This component is an +link{type:AutoChild} and as such may be customized via
    // <code>listGrid.expansionLayoutProperties</code> and
    // <code>listGrid.expansionLayoutDefaults</code>.
    // <P>
    // Note, however, that this is a multi-instance component (potentially one per record),
    // so it is created using +link{Class.createAutoChild, createAutoChild()} not
    // +link{Class.addAutoChild, addAutoChild()}, and no default single instance is created by
    // name on the grid.
    //
    // @group expansionField
    // @visibility external
    //<
    expansionLayoutDefaults: {
        _constructor: isc.VLayout,
        autoDraw: false,
        
        height: 10,
        overflow: "visible"
    },

    //> @method listGrid.getCurrentExpansionComponent()
    // Returns the expansion component derived from +link{listGrid.getExpansionComponent()}
    // currently visible in some record, or null if the specified record is not showing
    // an expansion component.
    //
    // @param record (Integer | ListGridRecord) rowNum or record to get the expansionComponent for
    // @return (Canvas) the currently visible expansion component for the expanded row.
    // @group expansionField
    // @visibility external
    //<
    getCurrentExpansionComponent : function (record) {
        if (isc.isA.Number(record)) record = this.getRecord(record);

        // bail if no record
        if (!record) return null;

        // we actually hang 'isExpansionComponent' onto the layout containing the generated
        // expansion component so return its (only) member.
        var component = this._getEmbeddedComponents(record).find("isExpansionComponent", true);
        if (component) {
            return component.members[0];
        }
        return null;
    },

    _getExpansionComponent : function (record) {
        if (this.expansionScreen) {
            return this.getExpansionScreen(record);
        } else {
            return this.getExpansionComponent(record);
        }
    },

    //> @method listGrid.getExpansionComponent()
    // When +link{canExpandRecords} is true, gets the embedded-component to show as a given
    // record's expansionComponent.  This component is then housed in
    // +link{listGrid.expansionLayout, a VLayout} and embedded into a record's row.
    // <P>
    // By default, this method returns one of a set of built-in components, according to the
    // value of +link{type:ExpansionMode, listGrid.expansionMode}.  You can override this method
    // to return any component you wish to provide as an expansionComponent.
    // <P>
    // As long as the record is expanded, this component may be retrieved via a call to
    // +link{getCurrentExpansionComponent()}.
    // <P>
    // When an expanded record is collapsed, the component is disassociated from the record and
    // may or may not be automatically destroyed.  By default, built-in components will be
    // destroyed on unembed according to the +link{listGrid.expansionComponentPoolingMode,
    // pooling mode} being used.  Custom expansion components, created via an override of
    // getExpansionComponents(), will <b><i>not</i></b> be auto-destroyed - developers should
    // override +link{collapseRecord} to take care of clean-up for such components.
    //
    // @param record (ListGridRecord) record to get the expansionComponent for
    // @return (Canvas | Canvas Properties) the component to embed
    // @see expansionScreen
    // @group expansionField
    // @visibility external
    //<
    getExpansionComponent : function (record) {
        return this._getStockEmbeddedComponent(record, true, false, this.getRecordIndex(record), 0);
    },

    //> @attr listGridRecord.backgroundComponent (Canvas : null : IR)
    // Has no effect unless +link{listGrid.showBackgroundComponents} is <code>true</code>.
    // <P>
    // Canvas created and embedded in the body behind a given record.   When set, either as
    // a Canvas or Canvas Properties, will be constructed if necessary, combined with the
    // autoChild properties specified for +link{listGrid.backgroundComponent} and displayed
    // behind this record in the page's z-order, meaning
    // it will only be visible if the cell styling is transparent.
    // @group rowEffects
    // @visibility external
    //<

    //> @attr listGrid.expansionScreen (String : null : IR)
    // Screen to create (via +link{RPCManager.createScreen,createScreen()}) in lieu of calling
    // +link{getExpansionComponent()}.
    // <P>
    // If this grid has a +link{listGrid.dataSource,dataSource}, the created screen is
    // provided with a +link{canvas.dataContext} that includes the record being expanded.
    // Be sure the expansion screen meets these +link{canvas.autoPopulateData,requirements}
    // to utilize the <code>dataContext</code>.
    // @group expansionField
    // @visibility external
    //<

    expansionScreenPlaceholderDefaults: {
        _constructor: isc.Label,
        autoDraw: false,
        border: "1px solid red",
        contents: "expansionScreen<br>Placeholder",
        align: "center"
    },

    getExpansionScreen : function (record) {
        var ds = this.getDataSource(),
            settings = {
                suppressAutoDraw: true
            }
        ;
        if (ds) {
            settings.dataContext = {};
            settings.dataContext[ds.ID] = record;
        }
        var screen = isc.RPCManager.createScreen(this.expansionScreen, settings);
        if (!screen) {
            screen = this.createAutoChild("expansionScreenPlaceholder");
        }
        return screen;
    },

// Expando Rows - Record implementation

    //> @attr listGrid.detailDS (String : null : IRW)
    // If +link{canExpandRecords} is true and +link{type:ExpansionMode,listGrid.expansionMode}
    // is <code>"related"</code>, this property specifies the dataSource for the
    // related records grid to be shown embedded in expanded records.
    // <P>
    // This property may also be specified on a per-record basis - see
    // +link{recordDetailDSProperty}
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.recordDetailDSProperty (String : "detailDS" : IRWA)
    // The name of the ListGridRecord property that specifies the DataSource to use when
    // +link{type:ExpansionMode, listGrid.expansionMode} is "related".  The default is
    // +link{ListGridRecord.detailDS}. Note that you can set the +link{detailDS} at the
    // grid level instead if the same dataSource is to be used for all records.
    //
    // @group expansionField
    // @visibility external
    //<
    recordDetailDSProperty: "detailDS",

    //> @attr listGridRecord.detailDS (DataSource : null : IRWA)
    // The default value of +link{listGrid.recordDetailDSProperty}.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @method listGrid.getRelatedDataSource()
    // Returns the +link{class:DataSource} containing data related to the passed record.  Used
    // when +link{ListGrid.canExpandRecords} is true and +link{ExpansionMode} is "related". The
    // default implementation returns the DataSource specified in
    // +link{listGridRecord.detailDS} if set, otherwise +link{listGrid.detailDS}.
    //
    // @param   record  (ListGridRecord)    The record to get the Related dataSource for.
    // @return (DataSource) The related DataSource for the "record" param
    //
    // @visibility external
    //<
    getRelatedDataSource : function (record) {
        return isc.DS.getDataSource(record[this.recordDetailDSProperty]) ||
                    isc.DS.get(this.detailDS);
    }

    //> @attr listGrid.childExpansionMode (ExpansionMode : null : IRWA)
    // For +link{ExpansionMode, expansionModes} that show another grid or tree, what the
    // child's expansionMode should be.
    // <P>Default value <code>null</code> means no further expansion.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.expansionCanEdit (Boolean : null : IRWA)
    // For +link{ExpansionMode, expansionModes} that show another grid or tree, is that
    // component editable?
    // <P>The default value for this property is <code>false</code>.
    //
    // @group expansionField
    // @visibility external
    //<

    //> @attr listGrid.filterLocalData (boolean : null : IRA)
    // Causes filtering to be performed against the local data set, even when a
    // +link{listGrid.dataSource} is provided.
    // <p>
    // When using this mode, data must be provided to the grid via +link{listGrid.setData()},
    // and must be provided as 
    // <smartclient>a simple Array of Records</smartclient>
    // <smartgwt>a RecordList</smartgwt>.  
    // <p>
    // Note that a +link{listGrid.dataSource} must be provided for filtering to occur
    // even when filtering locally.
    // <P>
    // If this property is set to true, the supplied data is applied as the 
    // +link{resultSet.allRows, complete dataset} of a +link{class:ResultSet}, which is then 
    // filtered according to the specified criteria, and the results displayed. If false, a 
    // normal databound fetch will occur, retrieving records that match the specified criteria 
    // from this component's +link{listGrid.dataSource}.
    // <p>
    // <code>filterLocalData</code> includes both calls to +link{listGrid.fetchData()} and
    // +link{listGrid.filterData()} as well as automatic filtering when the
    // +link{listGrid.filterEditor} is enabled.
    // <p>
    // If this property is not explicitly set, default behavior will filter against the
    // dataSource unless the grid has a specified +link{DataPath, dataPath}, in which case
    // filtering will occur locally.
    // <p>
    // See also +link{listGrid.saveLocally} to cause saves to ignore the DataSource and affect
    // the local data set only.
    //
    // @visibility external
    //<

    //> @attr listGrid.recordDropAppearance (RecordDropAppearance : isc.ListGrid.BETWEEN : [IRW])
    // If +link{canAcceptDroppedRecords} is true for this listGrid, this property governs
    // whether the user can drop between, or over records within the grid.
    // This controls what +link{type:RecordDropPosition} is passed to the +link{recordDrop()}
    // event handler.
    //
    // @visibility external
    //<
    , recordDropAppearance: isc.ListGrid.BETWEEN
});



isc.ListGrid.addMethods({

// warnOnReusedFields -- will log a warning at init time if this.fields is set to an array of
// field objects which are already displayed as fields in another grid.
// Internal - we only disable this for a couple of special cases where we really do want to share
// field objects across grids, like the record editor
warnOnReusedFields:true,


init : function () {
    if (this.disableTouchScrollingForDrag &&
        (this.canDragRecordsOut || this.canDragSelect || this.canReorderRecords) &&
        this.useTouchScrolling == null)
    {
        this.logInfo("Automatically disabling touch scrolling", "scrolling");
        this.useTouchScrolling = false;
    }
    // move minHeight update from draw(), to ensure it's present before the body gets added
    if (this.minHeight == null) this.minHeight = this._getDefaultMinHeight();

    this.Super("init", arguments);
},

//> @method ListGrid.initWidget() (A)
// Initialize the canvas and call listGrid.setData().
// @param [all arguments] (Object) objects with properties to override from default
//<
initWidget : function () {
    // set a flag that prevents sortChanged() from firing during initialization
    this._initializing = true;

    // see comments above in dataFetchDelay definition 
    if (this.dataFetchDelay === 0) this.dataFetchDelay = 1;
    
    
    this.Super("initWidget", arguments);

    // allow deprecated attribute +link{selection} to access +link{selectionManager}
    if (this.selectionManager != null) this.selection = this.selectionManager;

    
    if (this.showAllRecords && this.dataFetchMode == "paged") {
        this.logWarn("dataFetchMode: 'paged' isn't supported for grids with showAllRecords: " +
                     "true");
    }

    // Disable `resizeFieldsInRealTime' in mobile browsers.
    if (isc.Browser.isMobile) this.resizeFieldsInRealTime = false;

    // call the setter on 'showRecordComponents()' - this disables the
    // drawAllMaxCells logic for the grid.
    if (this.showRecordComponents) {
        delete this.showRecordComponents;
        this.setShowRecordComponents(true);
    }

    // set the default style for the expansionDetailField to whatever the hoverStyle is - means 
    // the field-value, the HTML content, looks the same when embedded as an expansionComponent 
    // as it would if the same HTML were shown in a hover 
    
    if (!this.expansionDetailFieldDefaults.styleName) {
        this.expansionDetailFieldDefaults.styleName = this.hoverStyle;
    }

    // we want to avoid a fields array object getting re-used across multiple ListGrids.
    // This can happen if the developer does something like assigning a fields object to the
    // instance prototype.
    // To handle this we have another attribute 'defaultFields' which may be set on the instance
    // prototype and differs only from initializing with a fields block in that array will be
    // shallow cloned and assigned to this.fields rather than sharing the same object across
    // ListGrid instances
    
    if (this.fields == null && this.defaultFields != null) {
        this.fields = isc.shallowClone(this.defaultFields);
        //this.logWarn("fields picked up from this.defaultFields -- now set to:" + this.fields);
    } else if (this.warnOnReusedFields && this.fields != null) {
        if (this.fields._initializedFieldsArray) {
            this.logWarn("ListGrid initialized with this.fields attribute set to an array " +
                "which is already being displayed in another ListGrid instance. To reuse " +
                "standard field configuration across multiple ListGrids, use " +
                "listGrid.defaultFields rather than assigning directly to listGrid.fields.");

        // Also catch the case where the developer re-uses individual fields within separate
        // arrays across grids
        } else {

            var dupedFields;
            if (isc.isAn.Array(this.fields)) {
                dupedFields = this.fields.findIndex("_initializedFieldObject", true) != -1;
            } else if (isc.isAn.Object(this.fields)) {
                for (var fieldName in this.fields) {
                    var field = this.fields[fieldName];
                    if (field && field._initializedFieldObject) {
                        dupedFields = true;
                        break;
                    }
                }
            }
            if (dupedFields) {
                 this.logWarn("ListGrid initialized with this.fields attribute set to an array " +
                "containing fields which are already being displayed in another ListGrid " +
                "instance. To reuse standard field configuration across multiple ListGrids, use " +
                "listGrid.defaultFields rather than assigning directly to listGrid.fields.");
            }
        }

        // Set a flag on the array and the individual field objects - this allows us catch the case
        // where a developer reuses a standard fields array across multiple grids rather than using
        // the defaultFields attribute
        // 
        // Also use this opportunity to check for null slots in the fields array
        
        this.fields._initializedFieldsArray = true;
        if (isc.isAn.Array(this.fields)) {
            var offset = 0;
            for (var i = 0; i < this.fields.length; i++) {
                if (this.fields[i] == null) {
                    offset++;
                    this.logWarn("ListGrid initialization: Specified fields array includes null entry. Removing.");
                    continue;
                }
                if (offset > 0) {
                    this.fields[i-offset] = this.fields[i];
                }
                this.fields[i]._initializedFieldObject = true;
            }
            if (offset > 0) this.fields.length = this.fields.length - offset;
            
        } else if (isc.isAn.Object(this.fields)) {
            for (var fieldName in this.fields) {
                var field = this.fields[fieldName];
                if (field) {
                    field._initializedFieldObject = true;
                }
            }
        }
    }

    if (this.canEditNew) this.listEndEditAction = this.rowEndEditAction = "next";

    if (this.alwaysShowEditors) {
        this.editByCell = false;

        // disable selection
        
        this.selectionType = "none";
        this.selectOnEdit = false;

        if (this.canGroup != false) {
            this.logInfo("grouping functionality is not supported when alwaysShowEditors is true." +
                    " Explicitly disabling this.canGroup", "inactiveEditorHTML");
            this.canGroup = false;
        }
        if (this.modalEditing) {
            this.logInfo("modalEditing is not supported when alwaysShowEditors is true." +
                " Explicitly setting this.modalEditing to false", "inactiveEditorHTML");
            this.modalEditing = false;
        }

        // enforce editEvent:"click" - this means that if the user clicks on a cell which
        // isn't showing an inactive editor (for example where showEditorPlaceholder is true),
        // we still start editing that row/cell
        this.editEvent = "click";

        // If canEdit is unset, and we have no fields explicitly marked as canEdit:true,
        // flip the default to true.
        // This gives us the most intuitive behavior - if the developer specifies per-field
        // editability we'll respect it, otherwise we'll default to canEdit true
        if (this.canEdit == null) {
            var fields = this.getFields() || [],
                hasEditableFields = false
            ;
            for (var i = 0; i < fields.length; i++) {
                if (fields[i].canEdit == true) {
                    hasEditableFields = true;
                    break;
                }
            }

            if (!hasEditableFields) {
                this.logInfo("alwaysShowEditors has been set for this grid but canEdit is unset and " +
                  "no fields are explicitly marked as editable. Defaulting this.canEdit to true. " +
                  "Note that to avoid this override developers can explicitly specify canEdit " +
                  "at the grid or field level", "inactiveEditorHTML");
                this.canEdit = true;
            }
        }

    }

    this.updateFixedRecordHeights();

    // disable canAddFormulaField if the required component isn't present
    if (this.canAddFormulaFields && isc.FormulaBuilder == null) {
        this.logInfo("Required modules for adding formula fields not present - setting " +
                    "canAddFormulaFields to false.");
        this.canAddFormulaFields = false;
    }
    if (this.canAddSummaryFields && isc.SummaryBuilder == null) {
        this.logInfo("Required modules for adding summary fields not present - setting " +
                    "canAddSummaryFields to false.");
        this.canAddSummaryFields = false;
    }

    // default to canSelectCells mode if we're using rowSpan-sensitive styling
    if (this.useRowSpanStyling && this.canSelectCells == null) this.canSelectCells = true;

    // default cell-level roll overs to the value of canSelectCells
    if (this.useCellRollOvers == null) this.useCellRollOvers = this.canSelectCells;

    // force loading rows to contain at least &nbsp; otherwise row height may be reported as less
    // than the actual height.
    if (this.loadingMessage == null || this.loadingMessage == isc.emptyString)
        this.loadingMessage = "&nbsp;";

    // default our overflow to "visible" if autoFitData is set
    if (this.autoFitData != null) {
        this._specifiedOverflow = this.overflow;
        this.setOverflow("visible");
    }

    // default our groupStartOpen to "all" if canCollapseGroup is false
    if (this.canCollapseGroup == false) this.groupStartOpen = "all";

    // force sortDirection to a SortDirection (it could have been a boolean in the past)
    this.sortDirection = Array.shouldSortAscending(this.sortDirection) ? "ascending" : "descending";
    // store off the initial sortDirection - we'll revert to this when unsorting
    this._baseSortDirection = Array.shouldSortAscending(this.sortDirection) ? "ascending" : "descending";

    // Hilite state takes precedence over hilites because it is likely applied
    // from a user-saved location whereas hilites is the default.
    if (this.hiliteState) this.setHiliteState(this.hiliteState);

    // initialize the data object, setting it to an empty array if it hasn't been defined
    
    this.setData(this.data ? null : this.getDefaultData());

    // set up selectionType dynamic default
    this.setSelectionAppearance(this.selectionAppearance, true);

    this._setUpDragProperties();
    
    // check if grid.searchForm can be set up yet - in Reify/ComponentXML, this will be an 
    // unresolved string-ID initially, and the widget with that ID may not yet have been 
    // created
    if (this.searchForm) this.checkForSearchForm();

    // set initial visibility of drag handles used for dragging records on touch devices
    if (this.showInitialDragHandles) this._showDragHandles = this.showInitialDragHandles;

    if(!this.canResizeFields) this.canAutoFitFields=false;
    
    
    if (this.wrapHeaderTitles == null) {
        this.wrapHeaderTitles = this._getHeaderButtonAutoChildConfig("wrap") || false;
    }
    if (this.wrapHeaderSpanTitles == null) {
        this.wrapHeaderSpanTitles = this._getHeaderButtonAutoChildConfig("wrap", true) || false;
    }

    
    if (this.embeddedComponentIndentOtherMargins != null) {
        this.embeddedComponentMargin = this.embeddedComponentIndentOtherMargins;
        delete this.embeddedComponentIndentOtherMargins;
    }

    // Remember the initial groupState.
    // This allows us to avoid unnecessary calls to groupStateChanged when
    // regroup runs, but the groupBy fields are unaltered
    this.currentGroupState = this.getGroupState();

    // clear out the flag that prevents sortChanged() from firing during initialization
    delete this._initializing;
},

// Ensure that properties related to variable row heights are set correclty
// This method is lazily called on body.draw() / redraw() 

// if we have variable record heights and virtualScrolling is unset, switch it on

updateFixedRecordHeights : function () {
    
    var variableRowHeights = (this.canExpandRecords || (this.fixedRecordHeights == false));
    if (variableRowHeights != this._hasVariableRowHeights) {
        this._hasVariableRowHeights = variableRowHeights;
        if (variableRowHeights && this.virtualScrolling == null) {
            // the _specifiedFixedRecordHeights flag is used by shouldShowAllColumns - we know
            // that even though a row may exceed its cell height this isn't due to any cell's content
            // in the row, so we don't need to render out every column to get correctly sized rows.
            if (this.fixedRecordHeights) this._specifiedFixedRecordHeights = this.fixedRecordHeights;
            this.fixedRecordHeights = false;
            this.virtualScrolling = true;
        }
        if (this.body) {
            this.body.fixedRowHeights = this.fixedRecordHeights;
            this.body.virtualScrolling = this.virtualScrolling;
        }
        if (this.frozenBody) {
            this.frozenBody.fixedRowHeights = this.fixedRecordHeights;
            this.frozenBody.virtualScrolling = this.virtualScrolling;
        }
    }

},

//> @method listGrid.setFixedRecordHeights()
// Setter for +link{listGrid.fixedRecordHeights}
// @param fixedRecordHeights (boolean) New fixedRecordHeights value
// @visibility external
//<
setFixedRecordHeights : function (fixedRecordHeights) {
    this.fixedRecordHeights = fixedRecordHeights;
    this.updateFixedRecordHeights();
    if (this.isDrawn()) this.markForRedraw();
},

//> @method listGrid.setWrapCells()
// Setter for +link{listGrid.wrapCells}
// @param wrapCells (boolean) New wrapCells value
// @visibility external
//<
setWrapCells : function (wrapCells) {
    if (this.wrapCells == wrapCells) return;
    
    this.wrapCells = wrapCells;
    if (this.body) this.body.wrapCells = wrapCells;
    if (this.frozenBody) this.frozenBody.wrapCells = wrapCells;
    if (this.isDrawn()) this.markForRedraw();
},


_handleDualInputMouseMove : function (event, eventInfo) {
    if (event && event.DOMevent) {
        var domEvent = event.DOMevent,
            mouseEvent = isc.EH.isMouseEvent(domEvent.type, true, domEvent)
        ;
        if (mouseEvent) {
            isc.ListGrid.addProperties({ showRollOver: true});
            delete this._touchEnabled;
        }
    }
    return this.invokeSuper(isc.ListGrid, "handleMouseMove", event, eventInfo);
},

enableTouchSupport : function () {
    this.Super("enableTouchSupport", arguments);
    isc.ListGrid.addProperties({ showRollOver: false});
},

_getHeaderButtonAutoChildConfig : function (property, isSpan) {
    var value;

    // give the autochild properties priority, using the button properties as fallback for span
    if (isSpan) {
        value = this.headerSpanProperties ? this.headerSpanProperties[property] : null;
    }
    if (value == null) {
        value = this.headerButtonProperties ? this.headerButtonProperties[property] : null;
    }

    // bail if we've found a value
    if (value != null) return value;

    // now check the autochild defaults, using the button defaults as fallback for span
    if (isSpan) {
        value = this.headerSpanDefaults ? this.headerSpanDefaults[property] : null;
    }
    if (value == null) {
        value = this.headerButtonDefaults ? this.headerButtonDefaults[property] : null;
    }

    return value;
},

_storeDragProperties : function () {
    if (!this._initialDragProperties) {
        var iDP = this._initialDragProperties = {};
        iDP.canDrag = this.canDrag;
        iDP.canDrop = this.canDrop;
        iDP.canAcceptDrop = this.canAcceptDrop;
    }
},
_restoreDragProperties : function () {
    var iDP = this._initialDragProperties;
    if (iDP) {
        this.canDrag = iDP.canDrag;
        this.canDrop = iDP.canDrop;
        this.canAcceptDrop = iDP.canAcceptDrop;
    }
},
_setUpDragProperties : function () {
    if (!this._initialDragProperties) {
        // store the original dragProperties
        this._storeDragProperties();
    }
    // set up our specific drag-and-drop properties

    this.canDrag = !this.canDragSelectText &&
                    (this.canDrag || this.canDragRecordsOut || this.canReorderRecords ||
                    this.canDragSelect);
    this.canDrop = (this.canDrop || this.canDragRecordsOut || this.canReorderRecords);
    this.canAcceptDrop = (this.canAcceptDrop || this.canAcceptDroppedRecords ||
                    this.canReorderRecords);

},

//> @method listGrid.setCanReorderRecords()
// Setter for the +link{listGrid.canReorderRecords} attribute.
// @param canReorderRecords (boolean) new value for <code>this.canReorderRecords</code>
// @visibility external
//<
setCanReorderRecords : function (canReorderRecords) {
    if (canReorderRecords != this.canReorderRecords) {
        this.canReorderRecords = canReorderRecords;
        this._restoreDragProperties();
        this._setUpDragProperties();
        this.redraw();
    }
},

getEmptyMessage : function () {
    if (isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown()) {
        if (isc.Offline && isc.Offline.isOffline()) {
            return this.offlineMessage;
        }
        return this.loadingDataMessage == null ? "&nbsp;" :
            this.loadingDataMessage.evalDynamicString(this, {
                loadingImage: this.imgHTML(isc.Canvas.loadingImageSrc,
                                           isc.Canvas.loadingImageSize,
                                           isc.Canvas.loadingImageSize)
            });
    }
    if (this.isOffline()) {
        return this.offlineMessage;
    }
    return this.emptyMessage == null ? "&nbsp;" : this.emptyMessage.evalDynamicString(this, {
        loadingImage: this.imgHTML(isc.Canvas.loadingImageSrc,
                                   isc.Canvas.loadingImageSize,
                                   isc.Canvas.loadingImageSize)
    });
},

isEmpty : function () {
    if (!this.data) return true;

    // treat having no fields as being empty so we don't attempt to write out and manipulate
    // an empty table
    if (!this.fields || this.fields.length == 0) return true;

    
    if (isc.ResultSet && isc.isA.ResultSet(this.data)) {

        if (this.data.isPaged()) {
            if (!this.data.isEmpty()) return false;

            if (this.shouldShowNewRecordRow()) return false;

            
            var editRows = this.getAllEditRows();
            if (editRows && editRows.length > 0) {
                for (var i = 0; i < editRows.length; i++) {
                    if (editRows[i] >= 0) return false;
                }
            }
            return true;
        } else {
            // If our length is not known we must be in the process of loading, so return the
            // loading message.
            return (!this.data.lengthIsKnown() || this.getTotalRows() == 0);
        }
    } else {
        return (this.getTotalRows() == 0);
    }
},

//> @attr listGrid.preserveEditsOnSetData (boolean : null : IRWA)
// By default any edit values in an editable ListGrid are dropped when 'setData()' is called,
// as previous edits are almost certainly obsoleted by the new data-set.
// This flag allows the developer to suppress this default behavior.
// @visibility internal
// @group data
//<
// Leave this internal for now - no known use cases for it, but seems like something that
// could come up.
//preserveEditsOnSetData : null,

//> @method listGrid.setData()
// Provides a new data set to the ListGrid after the grid has been created or drawn.
// The ListGrid will redraw to show the new data automatically.
// <P>
// Note that passing null will not clear +link{data}, but will regroup it and reapply the
// current sort, highlighting, and summaries to the grid.  Size will be recalculated for fields
// marked as +link{listGridField.autoFitWidth,autofitWidth}:true and a +link{selectionManager,
// selection manager} will be created if none exists.  To clear the grid instead, pass [].
//
// @param newData (List of ListGridRecord) data to show in the list
// @group data
// @visibility external
//<

setData : function (newData, clearGroupBy) {
    // if the current data and the newData are the same, bail
    //  (this also handles the case that both are null)
    if (this.data == newData) return;

    this.dataSetChanged();

    if (!this.preserveEditsOnSetData) this.discardAllEdits();

    // drop "lastHiliteRow" -no sense in hanging onto it
    this.clearLastHilite();

    // if we are currently pointing to data, stop observing it
    if (this.data) {
        this._ignoreData(this.data);
        // if the data was autoCreated, destroy it to clean up RS<->DS links
        if (newData && this.data._autoCreated && isc.isA.Function(this.data.destroy)) {
            this.data.destroy();
        }
    }
    if (this.originalData && (newData || !this.data)) {
        this._ignoreData(this.originalData);
        if (this.originalData != newData && this.originalData._autoCreated &&
            isc.isA.Function(this.originalData.destroy))
        {
            this.originalData.destroy();
        }
        delete this.originalData;
    }

    

    // temporarily hide any overflow to avoid visual glitches if there's no data yet
    if (this.overflow != isc.Canvas.HIDDEN && 
        isc.ResultSet && isc.isA.ResultSet(newData) && !newData.lengthIsKnown())
    {
        this._suppressBodyOverflow();
    } else {
        this._restoreBodyOverflow();
    }

    // if newData was passed in, remember it
    if (newData) this.data = newData;

    // if data is not set, bail
    if (!this.data) return;

    // create a new selection if we don't have one or if we receive new data
    
    if (!this._isGrouped && !this.isGrouped && 
        (!this.selectionManager || (this.data != this.selectionManager.data))) 
    {
        this.createSelectionModel();
    }

    // observe the data so we will update automatically when it changes
    this._observeData(this.data);

    var sortFromData, sortSpecifiers;
    // if data is a resultSet, and it already has both data and sortSpecifiers, apply the
    // sortSpecifiers from the ResultSet to this grid, replacing those already on the grid
    if (isc.isA.ResultSet(this.data) && !(clearGroupBy && this.sortByGroupFirst) && 
        (sortFromData = this.data.getSort()) && this.data.lengthIsKnown())
    {
        
        sortFromData = sortFromData.filter(function (specifier) {
            return !specifier.sortedImplicitly;
        });
        sortSpecifiers = sortFromData;
    } else {
        sortSpecifiers = this.getSort();
    }
    
    
    var groupByFields = this._groupByFields || this.getGroupByFields() || isc._emptyArray;
    if (sortSpecifiers || (this.sortByGroupFirst && !groupByFields.isEmpty())) {
        if (this.fields) this.setSort(sortSpecifiers);
        else {
            // if there are no fields, run setSort() later from setFields() 
            this.initialSort = sortSpecifiers;
            this._pendingSort = true;
        }
    }

    // Call this._remapEditRows() if we're hanging onto edit values
    // as we know they're now out of date.
    
    if (this.preserveEditsOnSetData) this._remapEditRows();

    // if we can regroup, do so.
    
    this.regroup(true);

    // Don't redraw / refresh grid summary - this happens explicitly later.
    this.calculateRecordSummaries(null, null, null, true, true);

    // if this.alwaysShowEditors is set, and we have data, and we're not currently showing
    // editors, show them now.
    
    var fetching = isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown();
    if (!fetching && this._alwaysShowEditors() && !this._editorShowing) {
        this.startEditing(null,null,true,null,true);
    }

    if (this.hilites) this.applyHilites(true);

    
    if (isc.ResultSet && isc.isA.ResultSet(this.data) &&
        !(this.data.allRows && this.data.neverDropCache) &&
        this.body && this.body.overflow == "visible")
    {
        this.body.showAllRows = false;
    }

    // clear out the current expanded row count, along with the current expanded record,
    // if there is one, since the expansionComponents have been dropped, along with the
    // records they were in
    this._expandedRecordCount=0;
    if (!this.canExpandMultipleRecords && this._currentExpandedRecord)
        delete this._currentExpandedRecord;

    if (this._lastStoredSelectedState) {
        this.setSelectedState(this._lastStoredSelectedState);
        delete this._lastStoredSelectedState;
    }

    // if any fields are marked as autoFitWidth, recalculate their sizes
    
    if (this.isEmpty() && ((isc.ResultSet && isc.isA.ResultSet(this.data)) || 
                    (isc.ResultTree && isc.isA.ResultTree(this.data))) )
    {
        this._updateFieldWidthsOnDataArrived = true;
    } else {
        this.updateFieldWidthsForAutoFitValue("setData called.");
    }

    // mark us as dirty so we'll be redrawn if necessary
    this._markBodyForRedraw("setData");

    this.updateBodyCanFocusForData();
},


// Determine which field to expand when autoFitFieldWidths is true and the
// fields don't take up the full set of space available.
// If +link{listGrid.autoFitExpandField} is explicitly set use it.
// Otherwise, basically we want to find the first field that will not look odd to expand
// Implementation:
// - if a field is not of type text, ignore (don't want to expand images, dates, booleans, numbers)
// - If field has showValueIconsOnly set, ignore (even though it has text content it shouldn't
//   expand beyond the value icons width)
// - field.length:
//      - if all fields have field.length specified, expand the largest one
//      - if no fields have this property set, just expand the first text field
//      - if *some* fields have field.length set - the length may indicate a small field
//        (say 2 characters) which we don't want to expand.
//        Expand fields with no specified length in preference to those with
//        a small specified length.
autoFitExpandLengthThreshold : 10,
getAutoFitExpandField : function () {
    if (!this.autoFitFieldsFillViewport) return null;

    if (this.autoFitExpandField != null) {
        var field = this.getField(this.autoFitExpandField);
        // We don't support auto-expanding a frozen field at this time
        
        if (field != null && this.fields && this.fields.contains(field) &&
            (!this.frozenFields || !this.frozenFields.contains(field)))
        {
            return field;
        }
    }
    var fields = [], lengthFields = [];

    if (this.fields) {
        for (var i = 0; i < this.fields.length; i++) {
            var field = this.fields[i];
            if (!field.showValueIconOnly &&
               (field.type == null ||
                (isc.SimpleType.inheritsFrom(field.type, "text") && 
                 !isc.SimpleType.inheritsFrom(field.type, "image"))
               ))
            {
                if (!this._suppressedFrozenFields && field.frozen) continue;
                fields.add(field);
                
                if (field != null && field.length != null && field.maxWidth == null) {
                   lengthFields.add(field);
                }

            }
        }
    }

    if (lengthFields.length > 0) {
        lengthFields.sortByProperty("length", Array.DESCENDING);
        if (lengthFields.last().length >= this.autoFitExpandLengthThreshold ||
            lengthFields.length == fields.length)
        {
            return lengthFields[0];
        }
    }
    if (fields.length > 0) {
        
        if (fields.filter(function (field) {return field.maxWidth != null;}).length > 0) {
            fields.sortByProperty("minWidth", Array.DESCENDING, function (field) {
                return field.maxWidth || Infinity;
            });
        }
        var i = 0;
            field = fields[i]
        // Note: This conditional contains cases where we should *not* auto expand the field
        while (field != null &&
                // Respect explicitly specified pixel width
                ((field.width != null && field.width != "*") ||
                // Explicit length less than the min "expand" number of characters
                 (field.length != null &&
                    field.length < this.autoFitExpandLengthThreshold))
              )
        {
            i++;
            field = fields[i];
        }
        return field;
    }

    // Note that this could still return null - no text fields etc.
    return null;
},

// updateFieldWidthsForAutoFitValue()
// If this.autoFitWidthApproach means we size to
// column data and any fields are marked as autoFitWidth:true,
// this method will set the _fieldWidthsDirty flag on the gridRenderer, causing
// _updateFieldWidths() to be called on the next body redraw,
// Calling code should call this before causing a body redraw.
updateFieldWidthsForAutoFitValue : function (reason) {
    if (!this.body || this.body._fieldWidthsDirty) return;

    var fields = this.fields || [];
    for (var i = 0; i < fields.length; i++) {
        var shouldAutoFit = this.shouldAutoFitField(fields[i]);
        if (!shouldAutoFit) continue;
        var approach = this.getAutoFitWidthApproach(fields[i]);

        if (approach == "value" || approach == "both") {
            this.fields._appliedInitialAutoFitWidth = false;
            this.body._fieldWidthsDirty = "Updating field widths for field auto-fit" +
                                      (reason ? (":" + reason) : ".");
            break;
        }
    }
},

invalidateCache : function () {
    this.dataSetChanged();

    // make sure that header checkbox is unchecked after refreshing cache
    // (Only do this if we're not maintaining selection across filters etc)
    var selectionManager = this.selectionManager;
        trackUnloadedItems = selectionManager && 
                            selectionManager._shouldTrackUnloadedItems && 
                            selectionManager._shouldTrackUnloadedItems();

    
    if (!trackUnloadedItems && this.getCheckboxFieldPosition() != -1) {
        var defaultIsSelected = selectionManager.defaultIsSelected;
        if (defaultIsSelected) {
            this.selectAllRecords();
        } else {
            this.deselectAllRecords();
        }
        this._setCheckboxHeaderState(defaultIsSelected);
    }

    // if we have a stored drawArea, delete it now so that the
    // redraw recalculates it and reapplies recordComponents
    if (this.body && this.body._oldDrawArea) delete this.body._oldDrawArea;

    // clear metadata - last caller from dataChanged() of master grid
    if (this._isSummaryRow) delete this._masterGridDataChangedTXID;

    return this.Super("invalidateCache", arguments);
},

dataSetChanged : function () {
    
    if (this.summaryRow && this.getSummaryRowDataSource() != null) {
        this.summaryRow.setData([]);
    }

    
    delete this._virtualScrollingLocked;
},

// use this rather than field.canSort to handle canSortClientOnly fields
_canSort : function (field) {
    if (!isc.isAn.Object(field)) {
        field = this.getSpecifiedField(field);
    }
    if (field == null) return false;

    var canSort = (field.canSort == false) ? false : this.canSort == false ? false : true;
    canSort = canSort && this._canSortData(field);

    return canSort;
},

_canSortData : function (fieldName) {
    
    var field = isc.isAn.Object(fieldName) ? fieldName : this.getSpecifiedField(fieldName);
    if (field == null) return false;

    if (isc.isAn.Array(this.data)) return true;
    if (field.canSortClientOnly == true) {
        if (isc.isA.ResultSet(this.data)) {
            if (!this.data.lengthIsKnown() || !this.data.canSortOnClient()) {
                return false;
            }
        }
    }

    return true;
},

// helper to determine whether this grid can be sorted on multiple fields - returns false if
// either canMultiSort or canSort are false, or if the data itself doesn't support multiSort
_canMultiSort : function () {
    var canMultiSort = (this.canMultiSort != false) && this.canSort && this._canMultiSortData();
    return canMultiSort;
},

// helper to determine whether this grid's data supports sorting on multiple fields
_canMultiSortData : function () {
    var canMultiSort = this.canMultiSort;

    // if data doesn't support setSort (resultSet and Array do), disable multiSort
    if (!this.data.setSort) {
        canMultiSort = false;
    } else if (this.getDataSource() && canMultiSort != false) {
        canMultiSort = this.getDataSource().canMultiSort && this.canSort;
    }

    return canMultiSort;
},

// helper method to get an appropriate sortDirection for a field
_getFieldSortDirection : function (field) {
    var field = isc.isAn.Object(field) ? field : this.getSpecifiedField(field),
        direction;

    var fieldDir = field ? field.sortDirection : null;
    if (fieldDir != null) {
        direction = Array.shouldSortAscending(fieldDir) ? "ascending" : "descending";
    } else if (this.sortDirection != null) {
        direction = Array.shouldSortAscending(this.sortDirection) ? "ascending" : "descending";
    } else {
        direction = Array.shouldSortAscending(this._baseSortDirection) ? "ascending" : "descending";
    }

    return direction;
},

// Override createSelectionModel, from DataBoundComponent, to set the body's selection object
// with our selection object. Our body GridRenderer will then observe selection.setSelected.
createSelectionModel : function () {

    this.invokeSuper(isc.ListGrid, "createSelectionModel", arguments);
    
    if (isc.isA.Canvas(this.body)) {
        this.body.setSelection(this.selectionManager);
        if (this.frozenBody) {
            this.frozenBody.setSelection(this.selectionManager);
            // create separate selection objects for body/frozenBody
            this._separateDependentSelections();
        }
    }
},


selectionChange : function (record, newState) {
    if (this.body == null && this.selectionChanged != null) {
        this.selectionChanged(record, newState);
    }
},

destroySelectionModel : function () {
    if (this.body) this.body.clearSelection();
    if (this.frozenBody) this.frozenBody.clearSelection();
    return this.Super("destroySelectionModel", arguments);
},

//> @method listGrid.setSelectionType() [A]
// Changes selectionType on the fly.
// @param   selectionType (SelectionStyle)  New selection style.
// @visibility external
//<
setSelectionType : function (selectionType, ignoreCheckbox) {
    // NOTE: this is sufficient because the Selection object dynamically inspects this property
    // on it's grid
    this.selectionType = selectionType;
    if (this.body) this.body.selectionType = selectionType;
    if (this.frozenBody) this.frozenBody.selectionType = selectionType;
},

//> @method listGrid.setSelectionAppearance()
// Changes selectionAppearance on the fly.
// @param   selectionAppearance (SelectionAppearance)    new selection appearance
// @visibility external
//<
setSelectionAppearance : function (selectionAppearance, isInit) {
    if (this.selectionAppearance == selectionAppearance && !isInit) return;

    this.selectionAppearance = selectionAppearance;

    // at initialization time, if selectionType wasn't explicitly set, default selectionType to
    // "simple" for "checkbox" appearance, otherwise "multiple"
    if (isInit && this.selectionType == null && !this.canSelectCells) {
        this.selectionType = (selectionAppearance == "checkbox" ? isc.Selection.SIMPLE :
                                                                  isc.Selection.MULTIPLE);
    }

    // If this.completeFields is set (IE setFields has run already), we need to either add or
    // remove the checkboxField
    // Call setFields() with a duplicate of the current set of fields, less the
    // checkboxField (if there was one)
    // This will create a new checkboxField if necessary otherwise just clear the existing one
    if (this.completeFields != null) {
        var completeFields = [];
        for (var i = 0; i < this.completeFields.length; i++) {
            var field = this.completeFields[i];
            if (this.isCheckboxField(field)) continue;
            completeFields.add(field);
        }
        this.setFields(completeFields);
    }
},

//> @method listGrid.setBodyOverflow()  ([A])
// Update the +link{listGrid.bodyOverflow, bodyOverflow} for this listGrid.
// @param overflow (Overflow) new overflow setting for the body
// @visibility external
//<
setBodyOverflow : function (newOverflow) {
    if (this._specifiedBodyOverflow) {
        this._specifiedBodyOverflow = newOverflow;
    } else        this.bodyOverflow = newOverflow;
    if (this.body) this.body.setOverflow(this.bodyOverflow);
},

// cache current overflow, then set overflow: "hidden"
_suppressBodyOverflow : function () {
    if (this._specifiedBodyOverflow) return;
    var overflow = this.bodyOverflow;
    this.setBodyOverflow(isc.Canvas.HIDDEN);
    this._specifiedBodyOverflow = overflow;
},

// restore overflow cached by _suppressBodyOverflow()
_restoreBodyOverflow : function () {
    var overflow = this._specifiedBodyOverflow;
    if (overflow) {
        delete this._specifiedBodyOverflow;
        this.setBodyOverflow(overflow);
    }
},

//> @method listGrid.setBodyStyleName()
// Update the +link{listGrid.bodyStyleName,bodyStyleName} for this listGrid.
// @param styleName (CSSStyleName) new body style name
// @visibility external
//<
setBodyStyleName : function (styleName) {
    this.bodyStyleName = styleName;
    if (this.body && (!this.alternateBodyStyleName || !this.alternateRecordStyles)) {
        this.body.setStyleName(styleName);
    }
},

//> @method listGrid.setAlternateBodyStyleName()
// Update the +link{listGrid.alternateBodyStyleName,alternateBodyStyleName} for this listGrid.
// @param styleName (CSSStyleName) new body style name when showing alternateRecordStyles
// @visibility external
//<
setAlternateBodyStyleName : function (styleName) {
    this.alternateBodyStyleName = styleName;
    if (this.body && this.alternateRecordStyles) {
        // if passed 'null', reset to this.bodyStyleName
        this.body.setStyleName(styleName || this.bodyStyleName);
    }
},

//> @method listGrid.setAlternateRecordStyles()
// Setter for +link{listGrid.alternateRecordStyles}
// @param alternateStyles (boolean) New value for <code>this.alternateRecordStyles</code>
// @visibility external
//<
setAlternateRecordStyles : function (alternateStyles) {
    if (this.alternateRecordStyles == alternateStyles) return;
    this.alternateRecordStyles = alternateStyles;

    if (this.body && (this.alternateBodyStyleName != null)) {
        if (alternateStyles) this.body.setStyleName(this.alternateBodyStyleName);
        else this.body.setStyleName(this.bodyStyleName);
    }

},

// Override hasInherentHeight / width: If we're autoFitting to our data, advertise inherent height
// This means that a layout will not expand us to fit the available space.

hasInherentHeight : function (a,b,c,d) {
    if (this.inherentHeight != null) return this.inherentHeight;
    if (this.autoFitData == isc.Canvas.VERTICAL || this.autoFitData == isc.Canvas.BOTH) {
        return true;
    }
    return this.invokeSuper(isc.ListGrid, "hasInherentHeight", a,b,c,d);
},

hasInherentWidth : function (a,b,c,d) {
    if (this.inherentWidth != null) return this.inherentWidth;
    if (this.autoFitData == isc.Canvas.HORIZONTAL || this.autoFitData == isc.Canvas.BOTH) {
        return true;
    }
    return this.invokeSuper(isc.ListGrid, "hasInherentWidth", a,b,c,d);
},

//> @method listGrid.setAutoFitData()
// Setter for +link{listGrid.autoFitData}.
// @param autoFitData (Autofit) One of <code>"vertical"</code>, <code>"horizontal"</code>
//  or <code>"both"</code>. To disable auto fit behavior, pass in <code>null</code>.
// @group autoFitData
// @visibility external
//<
setAutoFitData : function (autoFitData) {
    this.autoFitData = autoFitData;

    if (this._autoDerivedCanFreeze && (autoFitData == "both" || autoFitData == "horizontal")) {
        delete this._autoDerivedCanFreeze;
        delete this.canFreezeFields;
    }
    if (autoFitData == null && this._specifiedOverflow) {
        this.setOverflow(this._specifiedOverflow);
    } else if (this.overflow != "visible") {
        this._specifiedOverflow = this.overflow;
        this.setOverflow("visible");
    }
    if (this.body) {
        this.body.autoFitData = this.autoFitData;
        this.body.adjustOverflow();
    }
    if (this.frozenBody) {
        this.frozenBody.autoFitData = this.autoFitData;
        this.frozenBody.adjustOverflow();
    }
},

// On dragResize, we need to turn off autoFitData behavior, as the desired size is now being explicitly
// specified rather than driven by content.
dragResizeStart : function () {
    this.resizeTo(this.getVisibleWidth(),this.getVisibleHeight());
    this.setAutoFitData("none");
    return this.Super("dragResizeStart", arguments);
},

//> @method listGrid.setAutoFitExtraRecords()
// Setter for +link{listGrid.autoFitExtraRecords}.
// @param extraRecords (Integer) Number of extra rows beyond the data-size we'll expand to
// accommodate if +link{listGrid.autoFitData,auto fit} is enabled vertically.
// @group autoFitData
// @visibility external
//<
setAutoFitExtraRecords : function (extraRecords) {
    this.autoFitExtraRecords = extraRecords;
    if (this.body) {
        this.body.autoFitExtraRecords = extraRecords;
        this.body.adjustOverflow();
    }
},


//> @method listGrid.setAutoFitMaxRecords()
// Setter for +link{listGrid.autoFitMaxRecords}.
// @param maxRecords (int) Maximum number of rows we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled vertically.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxRecords : function (maxRecords) {
    this.autoFitMaxRecords = maxRecords;
    if (this.body) {
        this.body.autoFitMaxRecords = maxRecords;
        this.body.adjustOverflow();
        if (this.frozenBody) {
            this.frozenBody.autoFitMaxRecords = maxRecords;
            this.frozenBody.redraw();
        }
    }
},

//> @method listGrid.setAutoFitMaxHeight()
// Setter for +link{listGrid.autoFitMaxHeight}.
// @param height (Integer) Maximum height in px we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled vertically.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxHeight : function (height) {
    this.autoFitMaxHeight = height;
    if (this.body) {
        this.body.adjustOverflow();
        if (this.frozenBody) this.frozenBody.redraw();
    }
},
getAutoFitMaxBodyHeight : function () {
    if (this.autoFitMaxHeight == null) return null;
    var offset = this.getVBorderPad();
    if (this.showHeader) offset += this.getHeaderHeight();
    if (this.showFilterEditor) offset += this.filterEditorHeight;
    if (this.showGridSummary) offset += this.summaryRowHeight;
    return this.autoFitMaxHeight - offset;

},

// When auto-fitting vertically, specified height for the grid acts as a minimum
getAutoFitMinBodyHeight : function () {

    var minHeight = this.getTotalMemberSpace(),
        offset = 0;
        
    
    var members = this.getGridMembers(true),
        body = this.bodyLayout || this.body;
        
    for (var i = 0; i < members.length; i++) {
        if (members[i] == body) continue;
        // skip explicitly hidden grid-components
        // (Checking visibility property rather than isVisible() to avoid confusion when
        // the grid as a whole is hidden, but drawn)
        if (members[i].visibility == isc.Canvas.HIDDEN) continue;
        offset += members[i].getVisibleHeight();
    }

    return (minHeight - offset);
},

//> @method listGrid.setAutoFitMaxColumns()
// Setter for +link{listGrid.autoFitMaxColumns}.
// @param maxColumns (int) Maximum number of fields we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled horizontally.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxColumns : function (maxColumns) {
    this.autoFitMaxColumns = maxColumns;
    if (this.body) {
        this.body.autoFitMaxColumns = maxColumns;
        this.body.adjustOverflow();
    }
},

//> @method listGrid.setAutoFitMaxWidth()
// Setter for +link{listGrid.autoFitMaxWidth}.
// @param width (Integer | String) Width we'll expand to accommodate if
// +link{listGrid.autoFitData,auto fit} is enabled horizontally.
// @group autoFitData
// @visibility external
//<
setAutoFitMaxWidth : function (width) {
    delete this._autoFitMaxPixelWidth;
    this.autoFitMaxWidth = width;
    if (this.body) {
        this.body.autoFitMaxWidth = width;
        this.body.adjustOverflow();
    }
},

// --------------------------------
// AutoFitFields

//> @method listGrid.autoFitField()
// Programmatically cause a field to auto-fit horizontally to it's contents or title.
// <P>
// Does not establish permanent auto-fitting - use +link{listGrid.setAutoFitWidth()} or
// +link{setAutoFitFieldWidths()} to do so.
// <P>
// Note that unlike the ongoing autoFit set up by +link{listGrid.autoFitFieldWidths} or
// +link{listGridField.autoFitWidth}, any specified +link{listGridField.width} will not be
// taken as a minimum width - the field may shrink below the current specified width when
// this method is run.  However, +link{listGridField.minWidth} will be respected.
// <P>
// As with +link{listGrid.autoFitFieldWidths}, the auto-fit sizing is determined via the
// +link{listGrid.autoFitWidthApproach}.
//
// @param fieldName (String)
// @return (int) new width in pixels
//
// @group autoFitFields
// @visibility external
//<
autoFitField : function (fieldName, scrollIntoView) {
    var field = this.getField(fieldName),
        fieldNum = this.getFieldNum(field);
    // avoid attempting to autofit hidden fields, or fields where
    // autoFitWidth is already set (should just happen dynamically!)
    if (field == null || fieldNum == -1) return;


    

    var widths = this.getFieldAutoFitWidths([field]);
    
    if (widths == null || widths[0] == null) return;
    
    // Set a flag noting that we're auto-fitting this field.
    // We'll use this to suppress normal reflow in reaction to the 'headerButtonResized' notification.
    // Treat this somewhat similarly to a drag-resize.
    this._autoFittingField = field;
    
    var width = widths[0];
    // resize the field (as if the user drag-resized to the auto-fit size)
    var dontStoreWidth = this.shouldAutoFitField(field);
    if (this._fieldWidths && width != this._fieldWidths[fieldNum]) {
        this.resizeField(fieldName, width, !dontStoreWidth);
    } else if (!dontStoreWidth) field.width = width;
    if (this._fieldWidths && dontStoreWidth) field._calculatedAutoFitWidth = this._fieldWidths[fieldNum];

    if (scrollIntoView) this.scrollToColumn(fieldNum, "left");

    // When a field is auto-fit, if the headerMenuButton is showing for the field, then we
    // will want to reposition the HMB if this is a touch device (on which the HMB is always
    // shown if the header is selected) or if the mouse is still within the the header button.
    // Otherwise, hide the HMB.
    if (this.headerMenuButton != null && this.headerMenuButton.masterIndex == fieldNum) {
        // getFieldHeader / getLocalFieldNum will account for frozen fields
        var header = this.getFieldHeader(fieldNum),
            headerButton = header.getMember(this.getLocalFieldNum(fieldNum));

        var EH = this.ns.EH;
        if (isc.Browser.isTouch ||
            headerButton.containsPoint(EH.getX(), EH.getY()))
        {
            // Refresh the cached scrollWidth of the header button. This is needed for the
            // case where the header button is marked for redraw, but getHeaderMenuButton()
            // needs the new scrollWidth of the just-resized header button.
            headerButton.getScrollWidth(true);

            this.getHeaderMenuButton(headerButton);

        } else {
            this.headerMenuButton.hide();
        }
    }
    
    delete this._autoFittingField;

    return width;
},

//> @method listGrid.autoFitFields()
// Perform a one-time horizontal auto-fit of the fields passed. Fields will be sized
// to match their contents or title (as specified in +link{listGrid.autoFitWidthApproach})
// Does not establish permanent auto-fitting - use +link{listGrid.setAutoFitWidth()} to do so.
// <P>
// Note that unlike the ongoing autoFit set up by +link{listGrid.autoFitFieldWidths} or
// +link{listGridField.autoFitWidth}, any specified +link{listGridField.width} will not be
// taken as a minimum width - the field(s) may shrink below the current specified width when
// this method is run.  However, +link{listGridField.minWidth} will be respected.
//    
// @param [fields] (Array of ListGridField) Array of fields to auto fit. If this parameter
//  is not passed, autoFitting will occur on all visible fields.
//
// @group autoFitFields
// @visibility external
//<
autoFitFields : function (fields) {
    // We don't support one-time autofit while undrawn.
    if (!this.isDrawn()) {
        this.logWarn("autoFitFields() called on undrawn grid. This will have no effect. " +
                     "For one-time auto-fit to drawn sizes, call this method after draw. " +
                     "To establish permanent auto-fit, use listGrid.autoFitFieldWidths instead.");
        return;
    }
    

    if (this.body) this.body._fieldWidthsDirty = true;

    this.autoSizeHeaderSpans = false;
    if (fields == null) fields = this.getAllCanAutoFitFields();
    this._autoFittingFields = true;
    var finalFields = [];
    for (var i = 0; i < fields.length; i++) {
        var field = this.getField(fields[i]);
        if (field != null) {
            delete fields[i].width;
            delete fields[i]._calculatedAutoFitWidth;
            finalFields[finalFields.length] = field;
        }
    }
    // we've removed any hidden fields here.
    fields = finalFields;

    

        
    var widths = this.getFieldAutoFitWidths(fields, this.autoFitFieldsFillViewport);
    var fieldNums = [], resizeWidths = [], storeWidths = [];
    for (var i = 0; i < fields.length; i++) {

        if (widths[i] == null) continue;
        var width = widths[i],
            field = fields[i],
            fieldNum = this.getFieldNum(fields[i]),
            fieldName = fields[i].name;
        // resize the field (as if the user drag-resized to the auto-fit size)
        var dontStoreWidth = this.shouldAutoFitField(field);
        if (this._fieldWidths && width != this._fieldWidths[fieldNum]) {

            fieldNums[fieldNums.length] = fieldNum;
            resizeWidths[resizeWidths.length] = width;
            storeWidths[storeWidths.length] = !dontStoreWidth;

        } else if (!dontStoreWidth) field.width = width;
    }
    this._resizeFields(fieldNums, resizeWidths, storeWidths);
    for (var i = 0; i < fieldNums.length; i ++) {
        if (!storeWidths[i]) {
            var fieldNum = fieldNums[i];
            this.getField(fieldNum)._calculatedAutoFitWidth = this._fieldWidths[fieldNum];
        }
    }

    this._autoFittingFields = false;

    // we suppressed placeEmbeddedComponents() during the field resizes, so
    // run it now to ensure any embedded components are correctly positioned and sized.
    if (this.frozenBody) this.frozenBody._placeEmbeddedComponents()
    if (this.body) this.body._placeEmbeddedComponents();
    // Normally we do this in resizeField() but we don't want a bunch of unnecessary
    // reflows so we delay until resize of fields is complete
    if (this.header && this.autoFitHeaderHeights) {
        this.dropCachedHeaderButtonHeights();
        this._updateHeaderHeight();
    }

    // adjust field widths, if needed, to account for the available space;
    // if drawn buttons got resized, then update the GridBody with new widths
    var fieldWidths = this.getFieldWidths("one-time horizontal auto-fit", true);
    if (fieldWidths) this.setBodyFieldWidths(fieldWidths);

    // This will adjust header heights if necessary to account for differently wrapped
    // content
    if (this.header) this.header._sizeSpans();

    // We always mark fieldWidths as dirty. If a redraw wasn't required
    // we can assume the size was unchanged. Clear this flag now or it'll have other
    // impacts such as suppressing scrolling
    if (this.body && this.body._fieldWidthsDirty && 
        !this.isDirty() && !this.body.isDirty()) 
    {
        delete this.body._fieldWidthsDirty;
    }

},

// Helper to get all (visible) fields where canAutoFitWidth != false
// these are the fields which will be resized by a call to autoFitFields with no arguments
// (and by the auto-fit-all menu option)
getAllCanAutoFitFields : function () {
    var fields = this.fields;
    if (fields == null || fields.length == 0) {
        return fields;
    }
    
    var canAutoFitFieldArray = [];
    for (var i = 0; i < fields.length; i++) {
        if (fields[i].canAutoFitWidth == false) continue;
        canAutoFitFieldArray.add(fields[i]);
    }
    return canAutoFitFieldArray;
},


shouldAutoFitField : function (field) {
    if (field.autoFitWidth != null) return field.autoFitWidth;
    return this.autoFitFieldWidths;
},

// This method is called directly as part of resizeFields() and acts as a minimum, disallowing
// resizing below the min field width.

getMinFieldWidth : function (field, ignoreFieldWidth) {
    var minWidth = this.minFieldWidth || 1;
    if (!ignoreFieldWidth) {
        
        var fieldWidth = field.width;
        if (isc.isA.Number(fieldWidth)) {
            minWidth = Math.max(minWidth, field.width);
        }
    }
    // this is also enforced by Canvas.applyStretchResizePolicy() if any of the
    // fields are operating as stretch-sized members of the header Layout
    if (field.minWidth != null) {
        minWidth = Math.max(minWidth, field.minWidth);
    }
    var fieldName = field.name;
    // If we have embeddedComponents for the field we should treat that as a minimum
    if (this.showRecordComponents && !this.clipRecordComponents &&
            (this._columnComponentsMap && this._columnComponentsMap[fieldName]))
    {
        var componentMaxWidth = this._getFieldComponentMaxWidth(fieldName);
        if (componentMaxWidth > minWidth) {
            minWidth = componentMaxWidth;
        }
    }

    return minWidth;
},
clipRecordComponents: true,

_$within:"within",
_getFieldComponentMaxWidth : function (fieldName) {
    var field = this.getField(fieldName);
    if (field == null) return 0;

    if (field._maxComponentWidth != null) return field._maxComponentWidth;

    var components = this._columnComponentsMap[fieldName];
    var maxWidth = 0;
    for (var compID in components) {
        var component = window[compID];
//         this.logWarn("For field:" + fieldName + " contemplating:" + component +
//             " which has width:" + component.getVisibleWidth());
        // skip "expand" components - these are always sized to fit the field.
        if (component && (component.embeddedPosition == this._$within) &&
            (component.getVisibleWidth() > maxWidth) )
        {
            maxWidth = component.getVisibleWidth();
        }
    }
    field._maxComponentWidth = maxWidth;
    return maxWidth;
},

// This method fires when we have embedded components which may overflow the
// specified field width horizontally, so we need to expand to fit.
_fieldComponentWidthsChanged : function (fieldName, newWidth) {
    var field = this.getField(fieldName);
    if (field) {
        // If we happen to know we just increased the size, we can update
        // the max-width without having to query sizes of all drawn components.
        // Otherwise just clear the cached value and we'll lazily recalculate.
        if (newWidth) field._maxComponentWidth = newWidth;
        else delete field._maxComponentWidth;

        // Use "fireOnPause" to actually resize the field to fit the components on a delay
        
        if (this._staleComponentWidthFields == null) {
            this._staleComponentWidthFields = {};
        }
        this._staleComponentWidthFields[fieldName] = true;
        this.fireOnPause(
            "checkFieldComponentOverflow",
            {target:this,methodName:"_checkFieldComponentOverflow"}, 0
        );
    }

},
_checkFieldComponentOverflow : function () {
    if (this.fields == null) return;

    
     
    var currentWidths = this._fieldWidths || this.getFieldWidths(),
        overflowedFields = [],
        newWidths = [],
        storeWidths = [],
        overflowed = false;
    for (var i = 0; i < this.fields.length; i++) {
        var name = this.fields[i].name;
        if (!this._staleComponentWidthFields[name]) continue;
        this._staleComponentWidthFields[name] = null;

        var minWidth = this.getMinFieldWidth(this.fields[i]);
        if (minWidth > currentWidths[i]) {
            overflowedFields.add(i);
            newWidths.add(minWidth);
            // We don't want to store any of these widths. If autoFitFieldWidths
            // is true, if the component is hidden etc we want to be able to resize
            // smaller again if _updateFieldWidthsForAutoFitValue() gets re-run.
            storeWidths.add(false);
        }
    }
    // Embedded components in some cell overflowed the available width - resize
    // the field to accommodate it.
    
    if (overflowedFields.length > 0) {
        this._resizeFields(overflowedFields, newWidths, storeWidths);
    }
},

getFieldAutoFitWidths : function (fields, fillViewport) {
    if (this.body == null || fields == null) return;
    if (!isc.isA.Array(fields)) {
        fields = [fields]
    }
    var widths = [],
        colNums = [],
        minWidths = [];

    var headers = [],
        bodyFields = [];

    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            colNum = this.getColNum(field),
            approach = this.getAutoFitWidthApproach(field, true),
            checkHeader = approach != "value",
            checkBody = approach != "title";
            
        // we'll use the colNums outside this loop when we pick up the body col widths
        colNums[i] = colNum;
        widths[i] = minWidths[i] = this.getMinFieldWidth(fields[i], true);

        if (checkHeader) {
            var header = this.getFieldHeaderButton(colNum);
            
            if (header != null) headers[i] = header;
        }

        if (checkBody) {
            bodyFields.add(field);
        }

    }
    
    if (headers.length > 0) {
        //var startTime = isc.timeStamp();
        var headerWidths = this.getAutoFitTitleWidths(headers);
        //this.logWarn("Time to get header title widths:" + (isc.timeStamp() - startTime));
        for (var i = 0; i < headerWidths.length; i++) {
        
            
            if (headerWidths[i] == null) continue;
            widths[i] = Math.max(widths[i],headerWidths[i]);
        }
    }
    // for efficiency, pass all the body fields to getAutoFitValueWidths() at once.
    
    if (bodyFields.length > 0) {
        var bodyColWidthArr = this.getAutoFitValueWidths(bodyFields);
        for (var i = 0; i < fields.length; i++) {
            if (colNums[i] != null) {
                var colNum = colNums[i],
                    bodyColWidth = bodyColWidthArr ? bodyColWidthArr[colNum] : null;
                if (bodyColWidth != null) {
                    if (widths[i] == null || bodyColWidth > widths[i]) {
                        widths[i] = bodyColWidth;
                    }
                }
            }
        }
    }
    // If passed the fillViewport flag, and there is extra space, expand the
    // appropriate field by the delta such that we do indeed fill the viewport.
    
    if (fillViewport) {
        var frozenSize = 0,
            unfrozenSize = 0,
            unfrozenSpace,
            expandField = this.getAutoFitExpandField(),
            expandFieldIndex = this.fields.indexOf(expandField),
            requiresExpansion = colNums.contains(expandFieldIndex)
        ;
        if (requiresExpansion) {

            for (var i = 0; i < this.fields.length; i++) {
                var colWidth,
                    index = colNums.indexOf(i);
                if (index >= 0) {
                    colWidth = widths[index];
                } else {
                    colWidth = this._fieldWidths[i];
                    if (colWidth == null) {
                        
                        requiresExpansion = false;
                        break;
                    }
                }
                if (this.fields[i].frozen) {
                    frozenSize += colWidth;
                } else {
                    unfrozenSize += colWidth;
                }
            }
            
            if (requiresExpansion) {
                unfrozenSpace = this.getAvailableFieldWidth(true) - frozenSize;
                requiresExpansion = unfrozenSize < unfrozenSpace;
            }
            if (requiresExpansion) {
                var index = colNums.indexOf(expandFieldIndex);
                
                widths[index] += unfrozenSpace - unfrozenSize;
            }
        }
    }
    // limit the returned widths by the maxWidth value of each field
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            maxWidth = field.maxWidth;
        if (maxWidth == null) continue;
        // don't ever lower the width below the minimum reported by getMinFieldWidth()
        if (widths[i] > maxWidth) widths[i] = Math.max(minWidths[i], maxWidth);
    }

    return widths;
},

getAutoFitTitleWidths : function (headers) {
    var testHTML = "",
        missingHeaders = {};
    for (var i = 0; i < headers.length; i ++) {
        
        if (headers[i] == null) {
            missingHeaders[i] = true;
            continue;
        }
        var header = headers[i],
            titleStyle = header.titleStyle;
        if (titleStyle == null) titleStyle = header.getStateName();
        
        
        testHTML += header._getSizeTestHTML(this.getHeaderButtonTitle(header, false));
    }
    
    if (this.logIsDebugEnabled("autoFitFieldWidths")) {
        this.logDebug("Auto Fit Title test HTML:\n" + testHTML, "autoFitFieldWidths");
    }

    if (isc.ListGrid.headerWidthsTester == null) {
        isc.ListGrid.headerWidthsTester = isc.Canvas.create({
            top:-100,
            
            width: 1,
            autoDraw:true,
            overflow:"hidden",
            contents:testHTML,
            
            ariaState: {
                hidden: true
            }
        });

    } else {
        isc.ListGrid.headerWidthsTester.setContents(testHTML);
    }
    
    
    if (!isc.ListGrid.headerWidthsTester.isDrawn()) {
        isc.ListGrid.headerWidthsTester.draw();
    }
    if (isc.ListGrid.headerWidthsTester.isDirty()) {
        isc.ListGrid.headerWidthsTester.redraw();
    }

    var handle = isc.ListGrid.headerWidthsTester.getHandle(),
        childNodes = handle.childNodes;
    var widths = [];
    for (var i = 0, j=0; i < headers.length; i ++) {
        if (missingHeaders[i]) {
            widths[i] = null;
            continue;
        }
        var titleDiv = childNodes[j];
           
        
        if (isc.Browser.isChrome || isc.Browser.isMoz || isc.Browser.isIE9) {
            var titleBCR = titleDiv.getBoundingClientRect();
            if (!isc.Browser.isIE || isc.Browser.isIE10) {
                widths[i] = Math.ceil(titleBCR.width);
            } else {
                widths[i] = (titleBCR.width + 1) << 0;
            }
        } else {
            widths[i] = Math.ceil(titleDiv.offsetWidth);
        }
        j++;
    }

    if (widths.length != headers.length) {
        this.logWarn("getAutoFitTitleWidths(): Mismatch between " +
            "headers passed in and calculated widths", "autoFitFieldWidths");
    }
    return widths;
},

//> @method listGrid.setAutoFitWidth()
// Setter for +link{listGridField.autoFitWidth}. Enables or disables dynamic autoFitWidth behavior
// on the specified field. Note if the field is currently autoFitWidth:true, and this method is
// disabling autoFit, the field will not be resized by default - if you wish to resize to an
// explicit width, use +link{listGrid.resizeField()}.
//
// @param fieldName (String) field to auto-fit
// @param autoFit (boolean) Should autoFitWidth be enabled or disabled?
// @group autoFitFields
// @visibility external
//<
setAutoFitWidth : function (fieldName, autoFit) {
    var field = this.getField(fieldName);
    if (field == null) return;
    if (field.autoFitWidth == autoFit) return;

    field.autoFitWidth = autoFit;

    if (autoFit) this.autoFitField(field);
    // If we're turning off auto-fit, don't bother to resize
},

//> @method listGrid.setAutoFitFieldWidths()
// Setter for +link{listGrid.autoFitFieldWidths}. Modifies the default auto-fit-width behavior
// for fields in this grid. Note that this may be overridden at the field level via
// +link{listGridField.autoFitWidth}.
// @param autoFit (boolean) New value for autoFitFieldWidths
// @param [dontResetWidths] (boolean) If autoFitFieldWidths was true, and is being set to false,
//  should fields be resized to their originally specified size?
//  Pass in this parameter to suppress this behavior.
// @visibility external
//<
setAutoFitFieldWidths : function (autoFit, dontResetWidths) {
    if (autoFit == this.autoFitFieldWidths) return;
    this.autoFitFieldWidths = autoFit
    if (autoFit) {
        this._updateFieldWidths("autoFitFieldWidths enabled");
    } else if (!dontResetWidths) {
        // If we're showing a header, we use it to handle converting specified
        // field widths into real sizes - running updateHeader will rebuild it and
        // perform this initial calculation for us.
        if (this.showHeader && this.headerHeight > 0) this.updateHeader();
        // Clear the flag indicating we've run through auto-fit logic and re-run
        // _updateFieldWidths() to revert the fields to specified sizes.
        this.fields._appliedInitialAutoFitWidth = false;
        this._updateFieldWidths("autoFitFieldWidths disabled");
    }
},

//> @method listGrid.setAutoFitWidthApproach()
// Setter for the +link{listGrid.autoFitWidthApproach}.
// @param approach (AutoFitWidthApproach) new AutoFitWidth approach
// @visibility external
//<
setAutoFitWidthApproach : function (approach) {
    if (this.autoFitWidthApproach == approach) return;
    this.autoFitWidthApproach = approach;

    // If we're showing a header, we use it to handle converting specified
    // field widths into real sizes - running updateHeader will rebuild it and
    // perform this initial calculation for us.
    
    if (this.showHeader && this.headerHeight > 0) this.updateHeader();
    // Clear the flag indicating we've run through auto-fit logic and re-run
    // _updateFieldWidths() to revert the fields to specified sizes.
    this.fields._appliedInitialAutoFitWidth = false;
    this._updateFieldWidths("autoFitFieldWidthApproach changed");
},

// mark the body for redraw, or if the body doesn't exist, the widget as a whole
_markBodyForRedraw : function (reason) {
    if (this.bodies) {
        this.bodies.callMethod("markForRedraw", reason);
    } else if (this.body) {
        this.markForRedraw(reason);
    }
},

redraw : function (a, b, c, d) {
    if (this.body) {
        
        if (this.body._scrollbarChangeDuringAnimation) {
            this._updateFieldWidths("scrollbar change during animation");
            delete this.body._scrollbarChangeDuringAnimation;
        }
    }

    this.invokeSuper(isc.ListGrid, "redraw", a, b, c, d);
},

//> @method listGrid._observeData() (A)
//      observe methods on the data so we redraw automatically when data changes
//      called automatically by setData
//  @param  data    (Object)        new data to be observed
//<
_observeData : function (data) {
    // redraw if the data changed
    var isRS = isc.ResultSet && isc.isA.ResultSet(data);
    if (!this.isObserving(data, "dataChanged")) {
        if (isRS) {
            this.observe(data, "dataChanged", 
                         function (operationType, originalRecord, rowNum, updateData, 
                                   filterChanged, dataFromCache) 
                         {
                             this.dataChanged(operationType, originalRecord, rowNum, updateData,
                                              filterChanged, dataFromCache);
            });
        } else if (isc.ResultTree && isc.isA.ResultTree(data)) {
            this.observe(data, "dataChanged", function (operationType) {
                // data._lastOperation set from RT.loadChildrenReply()
                this.dataChanged(operationType || data._lastOperation);
            });
        } else {
            this.observe(data, "dataChanged", function () {
                this.dataChanged();
            });
        }
    }

    if (!this.isObserving(data, "dataArrived")) {
        if (isRS) {
            this.observe(data, "dataArrived", function (startRow, endRow, dataFromCache) {
                this._dataArrived(startRow, endRow, dataFromCache);
            });
        } else if (isc.ResultTree && isc.isA.ResultTree(data)) {
            this.observe(data, "dataArrived", function (parentNode) {
                this._dataArrived(parentNode);
            });
        }
    }

    if (!this.isObserving(data, "rowCountFetchComplete") && isRS) {
        //this.logWarn("setting up obs");        
        this.observe(data, "rowCountFetchComplete", function () {
            this.rowRangeDisplayValueChanged("Row Count Fetch Complete");
        });
    }
        
    // Note - we must check for data being a tree as if it is not defined, the inherited
    // ListGrid.init() code will set it to an empty array, in which case this observation will
    // fail.
    if (isc.isA.Tree(data)) {
        // update view in response to folders opening / closing
        this.observe(data, "changeDataVisibility", function (node, newState) {
            this._folderToggleObservation(node, newState);
        });
    }
    
    
    if (this.hiddenResultSet) this.hiddenResultSet.destroy();
    if (isc.isAn.Array(data) && this.filterLocalData &&
        this.dataSource && isc.isAn.DataSource(this.dataSource)) {
        this.hiddenResultSet = isc.ResultSet.create({
            dataSource : this.dataSource,
            allRows : data
        });
    }

},
//> @method listGrid.groupTreeDataChanged()
// Callback fired from group tree +link{listGrid.groupTree} dataChanged().
// <p>
// Handles remapping edit rows and forcing a redraw if necessary.
// @group grouping
//<
// The groupTree may be a ResultTree or a Tree object.
// When a listGrid is grouped we still observe dataChanged on the underlying data object and react
// to it by updating or rebuilding the groupTree as required, and marking for redraw etc.
// Therefore if this method is fired from standard dataChanged() we typically need to take no
// action.
// Note that we explicitly disable databound cache-sync for the ResultTree and instead manage
// updating the ResultTree cache directly as part of ListGrid.dataChanged. This is appropriate since
// The ResultTree code for cache sync is organized around node ids and parent ids whereas the
// groupTree is a dynamic grouping based on records have the same values for a field.
//
// This will actually fire in response to listGrid sort or direct manipulation of the groupTree
//
// Note that this method is only fired when an existing groupTree changes - not when regroup()
// is run, creating a new groupTree.
_$dataChanged:"dataChanged",
groupTreeDataChanged : function () {
    // If the groupTree was updated from underlying data change, no need to
    // redraw etc (already handled in dataChanged())
    if (this._handlingDataChanged) return;

    if (!this._savingEdits && !this.suppressEditRowRemap) this._remapEditRows();
    var lastRow = this.getTotalRows()-1;
    if (this.body) {
        
        if (this.body.lastOverRow > lastRow) delete this.body.lastOverRow;
        if (this.body.lastMouseOverRow > lastRow) delete this.body.lastMouseOverRow;
        if (this.body._lastHiliteRow > lastRow) {
             delete this.body._lastHiliteRow;
             delete this.body._lastHiliteCol;
        }
    }
    if (this._lastRecordClicked > lastRow) delete this._lastRecordClicked;

    if (this.hilites) this.applyHilites(true);
    if (!this._suppressRedrawOnDataChanged) this.redrawForDataChanged();

},

//> @method listGrid._observeGroupData() (A)
//      observe methods on the group tree object, so that changes to the group layout
//      can be detected
//  @param  data    (Object)        new group tree to be observed
//  @visibility internal
//<
_observeGroupData : function (data) {
    // redraw if the data changed
    this.observe(data, "dataChanged", function () {
        this.groupTreeDataChanged();
    });
    this.observe(data, "changeDataVisibility", function (node, newState) {
        this._folderToggleObservation(node, newState);
    });
},

// METHODS MOVED FROM TREEGRID
// The following methods were moved from treegrid to allow the listgrid to support the tree
// as a data model for grouping. They will continue to be doc'd on treegrid for now

// Helper method - fired when folders open/close within the tree
_folderToggleObservation : function (node, newState) {
    // If we're loaded, reapply hilites, but pass in the flag to suppress marking for redraw
    // We need to do this since we won't get a dataChanged notification from the
    // children loading.
    // No need to redraw here since we will redraw (below) in response to the folder toggling.
    if (node != null && this.hilites && newState) {
        var loadState = this.data.getLoadState(node);
        if (loadState == isc.Tree.LOADED || loadState == isc.Tree.LOADED_PARTIAL_CHILDREN) {
            this.applyHilites(true);
        }
    }
    //>Animation
    // During animated folder open/close we suppress redraw in response to the folder toggling
    
    if (this._suppressFolderToggleRedraw) {
        this._remapEditRows();

        // Re run auto fit logic expand our cols to fit the revealed content
        
        this.updateFieldWidthsForAutoFitValue("Folder Toggled");

        return;
    }

    // Cut short any currently running animated folder open / close
    // Just call finishAnimation - this will no op if no animation is running
    
    if (this.body) this.body.finishRowAnimation();
    //<Animation

    // Length changes so we need to remap edit rows.
    this._remapEditRows();

    // Re run auto fit logic expand our cols to fit the revealed content
    this.updateFieldWidthsForAutoFitValue("Folder Toggled");

    // redraw to display the updated folder
    this._markBodyForRedraw('folderToggled');
},

//> @method treeGrid.toggleFolder()   ([])
// Opens the folder specified by node if it's closed, and closes it if it's open.
// TreeGrid will redraw if there's a change in the folder's open/closed state.
//
// @visibility external
// @param	node	(TreeNode | String | Integer | NodeLocator)	the node in question, or the 
//                                                              the node's ID, or a NodeLocator
//                                                              object               
//<
toggleFolder : function (node) {
    var nodeLocator;
    if (this.data.isANodeLocator(node)) {
        nodeLocator = node;
        node = node.node;
    }
    if (this.data.isOpen(nodeLocator || node)) {
        this.closeFolder(nodeLocator || node);
    } else {
        this.openFolder(nodeLocator || node);

        
        var loadState = this.data.getLoadState(node);
        if (loadState == isc.Tree.LOADING) {
            var nodeIndex = this.getRecordIndex(node);
            if (nodeIndex >= 0) this.refreshCell(nodeIndex, this._treeFieldNum);
        }

        
        if (this.frozenBody) this.frozenBody.markForRedraw();
    }
},

//> @method treeGrid.openFolder() ([A])
// Opens a folder.
// <p>
// Executed when a folder node receives a 'doubleClick' event.
// <smartclient>If you override this method, the single parameter passed will be
// a reference to the relevant folder node in the tree's data.</smartclient>
// <p>
// See the ListGrid Widget Class for inherited recordClick and recordDoubleClick events.
//
// @param   node        (TreeNode)      node to open
// @param   [path]      (String)        optional parameter containing the full path to the node.
//                                      This is essential context for a
//                                      +link{tree.multiLinkTree,multi-link tree}, but is not 
//                                      required in ordinary trees
// @see closeFolder()
// @see folderOpened()
// @see class:ListGrid
// @visibility external
//<

openFolder : function (node, path) {
    var nodeLocator;
    if (this.data.isMultiLinkTree()) {
        if (this.data.isANodeLocator(node)) {
            nodeLocator = node;
            node = nodeLocator.node;
        } else {
            nodeLocator = this.data.createNodeLocator(node, null, null, path);
        }
    }
    // CALLBACK API:  available variables:  "node"
    // Convert a string callback to a function
    if (this.folderOpened != null) {
        this.convertToMethod("folderOpened");
        if (this.folderOpened(nodeLocator || node) == false) return false;
    }

    
    if (this.animateFolders) {
        this.animateOpen(nodeLocator || node);
    } else {
        this.data.openFolder(nodeLocator || node);
    }

},

//> @method treeGrid.animateOpen()
// Animates a folder opening to display its children (which grow into view).
// Automatically triggered from <code>treeGrid.folderOpen()</code> if
// <code>this.animateFolders</code> is true.
// @group animation
// @param folder (Node) node to open
// @visibility animation_advanced
//<
animateOpen : function (folder) {

    var nodeLocator;
    if (this.data.isANodeLocator(folder)) {
        nodeLocator = folder;
        folder = folder.node;
    }

    var data = this.data;
    if (data.isOpen(nodeLocator || folder)) return;

    // Open the data, but don't redraw with the new data visible (we'll handle redrawing
    // when the animation completes).
    this._suppressFolderToggleRedraw = true;
    data.openFolder(nodeLocator || folder);
    delete this._suppressFolderToggleRedraw;

    // parent may be null if we're looking at the root node
    if (data.isMultiLinkTree()) {
        if (!nodeLocator) {
            this.logWarn("In LG.animateOpen(), we have a multiLinkTree but we were not passed a " +
                            "nodeLocator.  Assuming parent is open.")
        } else {
            var parentNodeLocator = data._getParentNodeLocator(nodeLocator);
            if (!data.isOpen(parentNodeLocator)) return;
        }
    } else {
        var parent = data.getParent(nodeLocator || folder);
        if (parent && !data.isOpen(parent)) return;
    }

    var loadState = data.getLoadState(folder);
    if (loadState != isc.Tree.LOADED && loadState != isc.Tree.LOADED_PARTIAL_CHILDREN) {
        //this.logWarn("animation for LOD folder");
        // wait for dataChanged() to fire
        this._pendingFolderAnim = nodeLocator || folder;
        return;
    }

    this._startFolderAnimation(nodeLocator || folder);
},

//> @method treeGrid.closeFolder()
// Closes a folder.
//
// @param   node        (TreeNode)      node to close
// @see openFolder()
// @see folderClosed()
// @visibility external
//<

closeFolder : function (node) {
    var nodeLocator;
    if (this.data.isANodeLocator(node)) {
        nodeLocator = node;
        node = node.node;
    }
    // CALLBACK API:  available variables:  "node"
    // Convert a string callback to a function
    if (this.folderClosed != null) {
        this.convertToMethod("folderClosed");
        if (this.folderClosed(node) == false) return false;
    }

    // cancel editing of any nodes under this one
    if (this.getEditRow() != null) {
        var editRecord = this.getRecord(this.getEditRow());
        if (this.data.isDescendantOf(editRecord, node)) this.endEditing();
    }
    // now tell the data to close the folder
    if (this.shouldAnimateFolder(nodeLocator || node))
        this.animateClose(nodeLocator || node);
    else
        this.data.closeFolder(nodeLocator || node);
},

//> @method treeGrid.animateClose()
// Animates a folder closing to hide its children (which shrink out of view).
// Automatically triggered from <code>treeGrid.folderOpen()</code> if
// <code>this.animateFolders</code> is true.
// @param folder (Node) node to open
// @group animation
// @visibility animation_advanced
//<
animateClose : function (folder) {
    var nodeLocator,
        data = this.data;
    if (this.data.isANodeLocator(folder)) {
        nodeLocator = folder;
        folder = folder.node;
    }
    if (!data.isOpen(nodeLocator || folder)) return;

    if (data.isMultiLinkTree()) {
        if (!nodeLocator) {
            this.logWarn("In LG.animateOpen(), we have a multiLinkTree but we were not passed a " +
                            "nodeLocator.  Assuming parent is open.")
        } else {
            var parentNodeLocator = data._getParentNodeLocator(nodeLocator);
            if (!data.isOpen(parentNodeLocator)) {
                return this.closeFolder(nodeLocator);
            }
        }
    } else {
        var parent = data.getParent(nodeLocator || folder);
        if (parent && !data.isOpen(parent)) {
            return this.closeFolder(folder);
        }
    }

    var data = this.data,
        folderIndex = data.indexOf(nodeLocator || folder),
        numChildren = data.getOpenList(nodeLocator || folder).getLength()-1;


    
    this.startRowAnimation( false,
                            folderIndex+1,
                            folderIndex + numChildren + 1,
                            {target:this, methodName:"redraw", args:["close folder animation complete"]},
                            this.animateFolderSpeed,
                            this.animateFolderTime,
                            this.animateFolderEffect,
                            true
                          );
    var wasSuppressed = this._suppressFolderToggleRedraw;
    this._suppressFolderToggleRedraw = true;
    this.data.closeFolder(nodeLocator || folder);
    this._suppressFolderToggleRedraw = wasSuppressed;

    if (this.body && this.body._delayedRowAnimation != null) {
        if (this.data.isMultiLinkTree() && nodeLocator) {
            this.body._openFolder = nodeLocator;
        } else {
            this.body._openFolder = folder;
        }
    }
    if (this.frozenBody && this.frozenBody._delayedRowAnimation != null) {
        if (this.data.isMultiLinkTree() && nodeLocator) {
            this.frozenBody._openFolder = nodeLocator;
        } else {
            this.frozenBody._openFolder = folder;
        }
    }

},

_startFolderAnimation : function (folder) {

    var nodeLocator;
    if (this.data.isANodeLocator(folder)) {
        nodeLocator = folder;
        folder = folder.node;
    }

    // At this point we know we have all the children for the folder loaded - verify
    // that we actually should animate the folder into view - if we have too many children
    // we may not want to -- in this case just redraw.
    if (!this.shouldAnimateFolder(nodeLocator || folder)) {
        this.markForRedraw();
        return;
    }
    var data = this.data,
        folderIndex = data.indexOf(nodeLocator || folder),
        numChildren = data.getOpenList(nodeLocator || folder).getLength()-1;

    // don't try to animate empty folders
    if (folderIndex < 0 || numChildren <= 0) return;

    this.startRowAnimation( true,
                            folderIndex+1,
                            (folderIndex + numChildren+1),
                            {target:(this.bodyLayout || this.body), methodName:"redraw", args:["open folder animation complete"]},
                            this.animateFolderSpeed,
                            this.animateFolderTime,
                            this.animateFolderEffect,
                            true
                          );
},

// Used to store open folder state in the groupTree
// (Also used by TreeGrid.getOpenState())

_addNodeToOpenState : function (tree, node, openState, isGroupTree) {
    if (!tree.isOpen(node) || !tree.isLoaded(node)) return false;
    var children = tree.getFolders(node),
        hasOpenChildren = false;
    if (children != null) {
        for (var i = 0; i < children.length; i++) {
            hasOpenChildren = this._addNodeToOpenState(tree, children[i], openState, isGroupTree)
                              || hasOpenChildren;
        }
    }
    if (isGroupTree) {
        var folderInfo = {};
        folderInfo[node.groupName] = node.groupValue;
        openState.add(folderInfo);
    } else {
        openState[openState.length] = tree.getPath(node);
    }
    return true;
},

// END METHODS MOVED FROM TREEGRID

// These parameters essentially match the 
// type, originalRecord and rowNum from ResultSet.dataChanged [not publicly exposed].

_getDataChangedRecord : function (originalRecord, rowNum, type) {
    // Sanity check - obviously this would imply we have no information at all.
    if (originalRecord == null && rowNum == null) return;
    if (type == "remove") return null;
    var currData = this.data;
    if (this.data.isGroupedOutput && this.originalData) currData = this.originalData;

    // updatedRecord does not exist (was deleted)
    var newRecord =  currData.get(rowNum);
    if (newRecord == null && originalRecord == null) return null;
    if (originalRecord != null) {
        var pks = this.dataSource != null ? this.getDataSource().getPrimaryKeyFieldNames() : [];
        var pkMismatch = newRecord == null;
        if (!pkMismatch) {
            for (var i = 0; i < pks.length; ++i) {

                if (originalRecord[pks[i]] != newRecord[pks[i]]) {
                    pkMismatch = true;
                    break;
                }
            }
        }
        
        // if primary keys differ, the record was deleted via filtering, *or*
        // the data set is sorted, such that the rowNum refers to the
        // old, not the new position.
        // See if we can find the record by PKs
        if (pkMismatch) {
            newRecord = null;
            if (type == "update") {
                rowNum = currData.indexOf(originalRecord);
                if (rowNum != -1) {
                    // Assertion - this shouldn't cause a fetch since indexOf only
                    // queries loaded rows.
                    newRecord = currData.get(rowNum);
                }
            }
        }
    }
    return newRecord;
},


dataChanged : function (type, originalRecord, rowNum, updateData, filterChanged, dataFromCache) {
    if (isc._traceMarkers) arguments.__this = this;

    // This may be a recursive call to dataChanged() from us performing a local filter on
    // our underlying ResultSet object used for filtering. This can be ignored.
    if (this._filteringLocalDataFromDataChanged) return;
    
    // set a flag so we know we're handling dataChanged
    // This prevents us from causing unnecessary additional redraws from dataChanged on the
    // groupTree if we're currently grouped by any field(s)
    this._handlingDataChanged = true;

    // operations other than fetch may mean a new summary row is required, so re-fetch
    
    if (this.summaryRow && this.getSummaryRowDataSource() != null && type != "fetch") {
        var RPCManager = isc.RPCManager,
            summaryRow = this.summaryRow,
            txID = isc.RPCManager && isc.RPCManager._currentReplyTXNum;
        if (txID == null || txID != summaryRow._masterGridDataChangedTXID) {
            summaryRow.invalidateCache();
            summaryRow._masterGridDataChangedTXID = txID;
            
            summaryRow.setCriteria(this.getSummaryRowCriteria());
        }
    }
    
    var debugLogRC = this.logIsDebugEnabled("recordComponents");

    // DataChanged fires in some cases where we don't want to reset autoFieldWidths
    // For example, scrolling through a paged resultset where the columns resizing on scroll
    // would be ugly.
    // Use ResultSet parameters to test for cases to react to:
    // - crud operations which will affect the data displayed
    // - filter changing (including invalidateCache calls)
    // Note that we have equivalent logic inline in removeData, cellChanged to handle
    // non-databound grids' data being changed through standard grid APIs
    var resetAutoFitWidths = isc.isAn.Array(this.getOriginalData()) || 
                    (filterChanged || type == "add" || type == "remove");
    if (!resetAutoFitWidths && type == "replace") {
        if (originalRecord == null || rowNum == null) resetAutoFitWidths = true;
        else {
            var updatedRecord = this.getOriginalData().get(rowNum);
            if (updatedRecord == null) resetAutoFitWidths = true;
            else {
                for (var i = 0; i < this.fields.length; i++) {
                    if (this.shouldAutoFitField(this.fields[i])) {
                        var fieldName = this.getFieldName(this.fields[i]);
                        if (updatedRecord[fieldName] != updateData[fieldName]) {
                            resetAutoFitWidths = true;
                            break;
                        }
                    }
                }
            }
        }
    }

    var updatedGroupSummaries = false;

    // if a change was made to the groupBy field of a record, regroup
    var groupByFields = (this._groupByFields || this.getGroupByFields());
    if (groupByFields != null && !this._markForRegroup) {
        var markForRegroup = false;

        // fully regroup for add/remove, or for an update where dataChanged is not passed the
        // originalRecord to figure out if the groupField was changed
        var isAdd = type == "add",
            isRemove = !isAdd && (type == "remove"),
            isUpdate = !isAdd && !isRemove && (type == "update");
        var updatedRecord;
        
        // "remove" type operation but we don't know what was removed - full regroup
        
        if (isRemove) {    
            if (originalRecord == null) markForRegroup = true;
            
        } else if (isAdd || isUpdate) {
            // "update" operation with no previous record - implies 
            // an update record now matches our criteria and previously didn't.
            // Treat as an add.
            if (originalRecord == null) isAdd = true;
            updatedRecord = this._getDataChangedRecord(originalRecord, rowNum, type);

            if (updatedRecord == null) {
                // "update" operation and we don't have the record in our
                // originalData ResultSet. Implies it was lost from cache, probably
                // due to a change which made it no longer match criteria.
                // Treat as a remove.
                if (!isAdd) {
                    isRemove = true;
                } else {
                    
                    markForRegroup = true;
                }
            } 

        // Full regroup on filterChanged
        
        } else if (type == "replace" || filterChanged || !this.groupTree) {
            markForRegroup = true;
        }

        // If we're not doing a full regroup, update the group-tree directly
        if ((isAdd || isRemove || isUpdate) && !markForRegroup) {
            var reapplyHilites = false;
            this.calculateRecordSummaries(updatedRecord, null, false, false);

            var pks = this.getDataSource().getPrimaryKeyFieldNames(),
                keyCriteria = {};
            if (this.logIsInfoEnabled("grouping")) {
                this.logInfo("dataChanged(): Attempting incremental regroup for operation type:"
                         + type + " will be treated as a[n] " + 
                            (isAdd ? "add" : isRemove ? "remove" : "update"), "grouping");
            }

            if (isAdd) {
                // Add - no existing node, so just add a node to the groupTree
                this._incrementalRegroup(updatedRecord, null);
                
            } else {
                // Remove or update
                // Finde the node within our tree which was effected
                
                // The "originalRecord" should have primary keys on it.
                // find the equivalent node in our groupTree
                for (var i = 0; i < pks.length; i++) {
                    keyCriteria[pks[i]] = (isRemove ? originalRecord[pks[i]] : updatedRecord[pks[i]]);
                }
                // NOTE: In general, we explicitly do not support composite primaryKeys with
                // Trees and TreeGrids.  However, ListGrid grouping is implemented by use of
                // a Tree - "this.data" in the below call is a Tree, not the List or ResultSet
                // holding the grid's real data.  Fortunately, Tree supports a criteria search
                // of its nodes, so we make use of that with a criteria object that happens to
                // contain only primary keys
                var nodes = this.data.findAll(keyCriteria);
                
                if (nodes != null) {
                    nodes.removeWhere("_isGroup", true);
                }

                
                if (!nodes || nodes.length != 1) {
                    
                    markForRegroup = true;
                    
                } else {

                    var node = nodes[0];

                    // remove: "incrementalRegroup" will remove the node from the group-tree
                    if (isRemove) {
                        this._incrementalRegroup(null, node);
                    } else {

                        // Update - potentially change the category of the edited record,
                        // (_incrementalRegroup) - otherwise just update it in situ.
                        var fieldNames = this._getFieldNamesToUpdateForGrouped();

                        var node = nodes[0];
                        for (var i = 0; i < groupByFields.length; i++) {
                            var undef, fieldName = groupByFields[i];

                            var field = this.getUnderlyingField(fieldName),
                                newValue = this._getGroupValue(updatedRecord[fieldName],
                                                               updatedRecord, field, fieldName),
                                oldValue = this._getGroupValue(originalRecord[fieldName],
                                                               originalRecord, field, fieldName)
                            ;
                            if (newValue != oldValue) {
                                this._remapEditRows();
                                
                                this._incrementalRegroup(updatedRecord, node, updateData);
                                updatedGroupSummaries = true;
                                this._ignoreRegroup = true;
                                break;
                            }
                        }

                        // apply all modified fields to the node.
                        
                        if (node != updatedRecord) {
                            for (var i = 0; i < fieldNames.length; i++) {
                                node[fieldNames[i]] = updatedRecord[fieldNames[i]];
                            }
                            node["_cache_" + this.ID] = updatedRecord["_cache_" + this.ID];
                        }
                        // Clear any record components on this record so they will
                        // be recreated during redraw
                        node[this._$recordComponentsPrefix + this.ID] = null;
                        // Hilites need to be re-applied as well
                        reapplyHilites = true;
                        // refresh the group(s) that contain the updated record
                        if (!updatedGroupSummaries) {
                            updatedGroupSummaries = true;
                            this.refreshGroupSummary(node);
                        }
                        
                        // Refresh the sort on the groupTree if we have one.
                        // This ensures a change to the sort field will cause the
                        // record to jump into its new position.
                        var currentSort = this.data.getSort();
                        if (currentSort != null) {
                            this.data.setSort(currentSort);
                        }
                    }
                }
            }
            if (reapplyHilites && this.hilites) this.applyHilites(true);
        }
        if (markForRegroup) {
            this._setMarkForRegroup(true, false, false, false, true, groupByFields);
        }
    }
    
    var sortSpecifiers = this._sortSpecifiers;
    if (sortSpecifiers != null && sortSpecifiers.length > 0) {
        var origData = this.getOriginalData();
        if (isc.isA.ResultSet(origData) &&
            ((origData.shouldUpdatePartialCache() && !origData.allMatchingRowsCached()) ||
             !origData.canSortOnClient()) &&
            (type == "replace" || type == "update" || type == "add"))
        {
            if (originalRecord == null || rowNum == null) {
                this.unsort();
            } else {
                var updatedRecord = this._getDataChangedRecord(originalRecord, rowNum, type);
                if (updatedRecord == null) {
                    this.unsort();
                } else {
                    this._unsortOnChange(updatedRecord, originalRecord);
                }
            }

        } else {
            if (this.filterLocalData && !this.data._resorting && this.data.resort) {
                this.data.resort();
            }
        }
    }

    if (this.filterLocalData) {
        var baseData = this.getOriginalData();
        if (baseData.filterLocalData) {
            this._filteringLocalDataFromDataChanged = true;
            baseData.filterLocalData();
            delete this._filteringLocalDataFromDataChanged;
        }
    }

    
    if (this._markForRegroup && (!this.isGrouped || !this._savingEdits) &&
        // Skip attempting to regroup / reset selection if our resultSet is in mid-fetch
        (!isc.isA.ResultSet(this.data) || this.data.lengthIsKnown()))
    {
        this._lastStoredSelectedState = this.getSelectedState(true);
        this.regroup();
    
    
    } else if (this._asyncRegroupInProgress && !this._groupByDataChanged) {
        var baton = this._asyncRegroupBaton,
            fields;
        if (baton) {
            fields = baton.groupByFields || baton.groupByField;
        } else {
            fields = this.groupByFields || this._groupByFields;
        }
        
        if (this.logIsInfoEnabled("grouping")) {
            this.logInfo("dataChanged() occurred while asynchronous regrouping in progress. " +
                         "Restarting grouping with fields:" + fields, "grouping");
        }
        // no need to clear the timer for the asynch-regroup that's currently in progress - that's
        // already handled by 'groupBy'
        this.groupBy(fields);
    }

    //>Animation
    // Call finishRowAnimation - will kill any show/hide row animations.
    // These animations assume the data remains constant for the duration
    // of the animation.
    // (No-ops if appropriate)
    if (this.body) this.body.finishRowAnimation();
    //<Animation

    // Call _remapEditRows() to ensure that editValues are associated with the (possibly
    // modified) rowNumbers using pointers between record primary key and edit values
    
    if (!this._savingEdits) {
        if (!this.suppressEditRowRemap) this._remapEditRows();
        // If we're actually showing the editor and the current edit-row has changed
        // roll the new values into the edit form for any unedited fields
        if (this._editorShowing) {
            var editForm = this.getEditForm(),
                editRowNum = this.getEditRow(),
                record = this.getRecord(editRowNum),
                showInEditor = {};
            
            // Clean off any tree metadata, etc
            if (isc.isA.Tree(this.data)) {
                record = this.data.getCleanNodeData(record, false);
            }            

            if (editForm && record != null) {
                for (var fieldName in record) {
                    // If we have an edit value, don't allow the new
                    // record value to override it
                    if (this._getEditValue(editRowNum, fieldName, true) != null) continue;
                    // If we have a live edit item, and it has a modified value
                    // (IE the user has changed it, or app code has called setValue()
                    // diretly on the form), skip that too.
                    
                    var item = editForm.getItem(fieldName),
                        currentVal = item ? item.getValue() : null;
                    if (item && 
                        !item.compareValues(currentVal, record[fieldName]) &&
                        !item.compareValues(item._getOldValue(), currentVal)) 
                    {
                        continue;
                    }

                    showInEditor[fieldName] = record[fieldName];
                }
                // no need to call 'setEditValue()' - displaynewEditValues already
                // handles picking up the display value from the record value.
                
                this._displayNewEditValues(editRowNum, this.getEditCol(), showInEditor);
                var oldVals = editForm._oldValues;
                // We didn't use 'setValues()' but we need to remember these
                // particular field values so if this method runs again we don't
                // treat these values as user-edited.
                // use DBC._duplicateValues to ensure we duplicate dates, objects, handle 
                // GWT objects, etc (we used to use clone(), but it fails in the presence
                // of pointer loops, which can happen with the records in grouped lists)
                var dup = {};
                isc.DynamicForm._duplicateValues(editForm, showInEditor, dup);
                for (var fieldName in showInEditor) {
                    oldVals[fieldName] = dup[fieldName];
                }
                
            }
        }
    }

    // if the originalRecord has components, we want to refresh the record's components later
    var originalRecordHasComponents = this._hasRecordComponents(originalRecord);
    
    // re-associate embeddedComponents with records which were not previously present in the
    // cache but are now - set grid._shouldRetainEmbeddedComponents to false to have components
    // removed when their associated records are no longer in the cache.
    if (!isc.isA.ResultSet(this.data) || this.data.lengthIsKnown()) {
        // remap embedded components
        this._remapEmbeddedComponents();
    }

    // if this.alwaysShowEditors is set, and we have data, and we're not currently showing
    // editors, show them now.
    // This handles us getting new data (from a fetch for example)
    if (this._alwaysShowEditors() && !this._editorShowing) {
        this.startEditing(null,null,true,null,true);
    }

    
    var lastRow = this.getTotalRows()-1;
    if (this.body) {
        if (this.body.lastOverRow > lastRow) delete this.body.lastOverRow;
        if (this.body.lastMouseOverRow > lastRow) delete this.body.lastMouseOverRow;
        if (this.body._lastHiliteRow > lastRow) {
            delete this.body._lastHiliteRow;
            delete this.body._lastHiliteCol;
        }
    }
    if (this._lastRecordClicked > lastRow) delete this._lastRecordClicked;

    
    var changedRecords = null;
    if (type != "update" && type != "remove") {
        changedRecords = this._getDataChangedRecord(originalRecord, rowNum, type);
    }

    if (updatedGroupSummaries) {
        
        if (this.summaryRow && this.showGridSummary) this.summaryRow._recalculateSummaries();
    } else {
        this.calculateRecordSummaries(changedRecords, null, null, true, true, type == "remove",
                                      type != null && type != "fetch" && type != "update");
    }

    if (this.hilites) this.applyHilites(true);
    
    //this.logWarn("_suppressRedrawOnDataChanged is " + this._suppressRedrawOnDataChanged);
    if (!this._suppressRedrawOnDataChanged) {
        // recalculate autoFitWidth field widths to fit the new data
        if (resetAutoFitWidths) this.updateFieldWidthsForAutoFitValue(this._$dataChanged);

        
        var mustRedraw = true;
        if (!this.forceRedrawOnDataChanged &&
            type == "update" && originalRecord != null) {
            var currentRowNum = this.data.indexOf(originalRecord);
            
            
            if (currentRowNum != null && currentRowNum != -1 && currentRowNum == rowNum) {
                if (debugLogRC) {
                    this.logDebug("dataChanged running refreshRow(" + currentRowNum + ")", 
                        "recordComponents");
                }
                this.refreshRow(currentRowNum, originalRecordHasComponents);
                mustRedraw = false;
            }
        }
        if (mustRedraw) this.redrawForDataChanged();
    } else {
        if (originalRecordHasComponents) this.updateRecordComponents();
    }

    this.rowRangeDisplayValueChanged("source grid dataChanged");

    // In screenreader mode allow our aria-state to update to reflect the new data length if necessary
    if (isc.Canvas.ariaEnabled() && this.updateAriaForDataChanged) {
        this.updateAriaForDataChanged();
    }    

    // Note - a regroup may require a re-selection of the prior-to-regroup selection
    // range.
    // We rely on code in the _regroupFinish flow to handle resetting selection

    // clear the _handlingDataChanged flag
    delete this._handlingDataChanged;

    this.updateBodyCanFocusForData();
    
    this._updateRowCountsInRuleScope();
    if (filterChanged) this._provideCriteriaToRuleContext();
},

// forceRedrawOnDataChanged - flag to disable targetted row refresh if we got 
// "dataChanged" for a single updated record. 

forceRedrawOnDataChanged:false,


_setMarkForRegroup : function (
        markForRegroup,
        calledFromGroupBy, calledFromRegroup, calledFromClearGroupBy, calledFromDataChanged,
        fields, groupByFields)
{
    
    var markForRegroup0 = this._markForRegroup;
    if (calledFromGroupBy) {
        
        this._groupByCompleteFieldsBeforeRegroup = fields;
        this._isGrouped = true;
        this._groupByFields = groupByFields;
    } else if (calledFromRegroup) {
        if (markForRegroup0 && !markForRegroup) {
            
            this._groupByCompleteFieldsAfterRegroup = this._groupByCompleteFieldsBeforeRegroup;
            delete this._groupByCompleteFieldsBeforeRegroup;
            delete this._isGrouped;
            delete this._groupByFields;
        }
    } else if (calledFromClearGroupBy) {
        

        // clean up temporary grouping state
        
        delete this._isGrouped;
        delete this._groupByFields;

        delete this._groupByCompleteFieldsBeforeRegroup;
        delete this._groupByCompleteFieldsAfterRegroup;
    }
    

    
    this._markForRegroup = markForRegroup;
},

redrawForDataChanged : function () {
    if (this.frozenBody) this.frozenBody._suppressRecordComponentsUpdate = true;
    this._markBodyForRedraw(this._$dataChanged);
},
    

// Ensure that when body redraw runs, we do a full field-widths refresh, including
// calculating auto-fit size
_forceUpdateFieldWidths : function (reason) {
    if (this.body && this.fields) {
        this.body._fieldWidthsDirty = reason == null ? true : reason;
        // Ensure we actually calculate new field widths based on data values.
        delete this.fields._appliedInitialAutoFitWidth;
    }


},

// wrap the call out to the dataArrived override point and handle sorter according to
// canSortClientOnly value and current data-state
_$new_data: "New dataset loaded",
_dataArrived : function (startRow, endRow) {
    var sortField = this._getSortFieldNum();
    
    
    if (this._updateFieldWidthsOnDataArrived || startRow == 0) {
        this._updateFieldWidthsOnDataArrived = false;
        if (this.body && this.body.isDrawn()) this._forceUpdateFieldWidths(this._$new_data);
    }
    if (sortField != null && sortField != -1) {
        var fieldNum = this.getFieldNum(sortField),
            field = this.getField(fieldNum)
        ;

        if (field && field.canSortClientOnly && !this._canSortData(field)) {
            this._setSortFieldNum(null);

            // tell that toolbar button to unselect / get rid of sort arrow
            if (sortField != null && this.header && isc.isA.Toolbar(this.header)) {
                this.header.deselectButton(sortField);
                var button = this.header.getButton(sortField);
                if (button) button.setTitle(this.getHeaderButtonTitle(button));
            }

            // Get rid of the sort arrow in the sorter
            if (this.sorter && this.sorter.setTitle) this.sorter.setTitle(this.sorter.getTitle());
        }
    }

    if (!(this.canSelectAll == false) && this.getCurrentCheckboxField()) {
        var cbPos = this.getCheckboxFieldPosition(),
            field = this.getField(cbPos);
        // if we are showing a checkbox select-all header, and we don't have
        // a full cache, disable the checkbox header and show a hover prompt
        if (isc.ResultSet && isc.isA.ResultSet(this.data)
            && !this.data.allMatchingRowsCached())
        {
            var props = {
                disabled: true,
                showHover: true,
                prompt: this.selectionManager.selectionRangeNotLoadedMessage,
                title: (this.selectionType == "single") ? isc.nbsp :
                        this._getCheckboxValueIconHTML(false, false, true, true, field)
            }
        // if we now have a full cache, enable the checkbox selectAll header
        } else {
            var props = {
                disabled: false,
                showHover: false,
                prompt: null,
                title: (this.selectionType == "single") ? isc.nbsp :
                        this._getCheckboxValueIconHTML(false, false, true, false, field)
            }
        }
        // if checkbox was disabled but is now being enabled, update it
        var updateCheckbox = field && field.disabled && !props.disabled;
        this.setFieldProperties(cbPos, props);
        if (updateCheckbox) this.updateCheckboxHeaderState();
    }

    
    if (isc.screenReader && this.body != null) {
        if (isc.isA.Tree(this.data)) {
            // in this case we're passed a single param, the parent node.
            var node = startRow;
            if (this.data.isOpen(node) && this.data.hasChildren(node)) {
                var children = this.data.getChildren(node);
                if (children && !children.isEmpty()) node = children.first();
            }
            var rowNum = this.data.indexOf(node);
            // If we don't currently have focus, just remember the native focus row - this means
            // if we're showing a modal prompt / redrawing we should refocus on the right native
            // element...
            var colNum = this._getKeyboardClickNum(),
                body = this.getFieldBody(colNum),
                localCol = this.getLocalFieldNum(colNum);
            body._putNativeFocusInRow(rowNum, localCol, !this.hasFocus);
        }
    }

    // we only want to run auto-sizing code if the data has already arrived
    if (this._autoSizeOnDataArrived) {
        this._headerDoubleClick(this._autoSizeHeaderFieldNum, this._autoSizeHeader);
        this._autoSizeHeaderFieldNum = null;
        this._autoSizeHeader = null;
        this._autoSizeOnDataArrived = false;
    }

    this._restoreBodyOverflow();
    
    
    if (!this._handlingDataChanged) {
        this._markBodyForRedraw();
    }
    
    this._fromDataArrived = true;
    this.dataArrived(startRow, endRow);
    delete this._fromDataArrived;
    
    this.updateBodyCanFocusForData();
    
    if (this.data) {
        if (isc.isA.ResultSet(this.data)) {
            if (this.data._initialDataLoading) {
                if (this._provideDataLoadingToRuleContext) {
                    this._provideDataLoadingToRuleContext();
                }
                delete this.data._initialDataLoading;
            }
        } else if (isc.isA.ResultTree(this.data)) {
            this._provideDataLoadingToRuleContext();
        }
    }

},
    
updateBodyCanFocusForData : function () {
    if (this.body && !this.canFocusInEmptyGrid) {
        var isEmpty = this.isEmpty();
        if (isEmpty != this._wasEmptyForCanFocus) {
            this.body._updateCanFocus();
            if (this.frozenBody != null) this.frozenBody._updateCanFocus();
            // Call updateCanFocus on the grid too, in case any callers call
            // 'getTabIndex' or 'canFocus' on the grid directly
            this._updateCanFocus();
            this._wasEmptyForCanFocus = isEmpty;
        }
    }
},


// doc'd in registerStringMethods block
dataArrived : function (startRow, endRow) {},

//> @method listGrid._ignoreData() (A)
//      stop observing methods on data when it goes out of scope
//      called automatically by setData
//  @param  data    (Object)        old data to be ignored
//<
_ignoreData : function (data, destroying) {
    //>Animation
    // Call finishRowAnimation - will kill any show/hide row animations
    // These animations assume the data remains constant for the duration
    // of the animation.
    // (No-ops if appropriate)
    if (this.body) this.body.finishRowAnimation();
    //<Animation

    if (isc.isA.Tree(this.data)) this.ignore(data, "changeDataVisibility");

    this.ignore(data, "dataChanged");

    if (this.isObserving(data, "dataArrived")) {
        this.ignore(data, "dataArrived");
    }


    // If we're destroying, no need to call deslectAll, as we'll continue to
    // destroySelectionModel() anyway, and calling deselectAll can cause
    // selectionChanged notifications to fire which is likely to lead to 
    // application level crashes since the grid is in an invalid state
    if (!destroying && this.selectionManager) {
        var currentSelection = this.selectionManager.getSelection();
        this.selectionManager.deselectAll()
        if (currentSelection && currentSelection.length > 0) {
            this.fireSelectionUpdated();
        }
    }
    // NOTE: we don't ignore this.selectionManager.setSelected because
    //          we're re-using the same selection object
    
},

// Helper called from setFields() before deriveVisibleFields to apply default 
// "showIf" function if appropriate.
applyDefaultShowIf : function (completeFields) {
    if (completeFields == null) return;
    for (var i = 0; i < completeFields.length; i++) {

        var field = completeFields[i];

        // If field is marked as initially hidden, use showIf:"false"
        
        if (field.hidden && field.showIf == null) field.showIf = "false";

        // if field.showIf is set at this stage, it takes precedence over 
        // hideOnTablet / hideOnPhone - otherwise set up a showIf to read those properties
        // if necessary.
        if (field.showIf == null && 
            ((isc.Browser.isTablet && field.hideOnTablet != null) || 
                (isc.Browser.isHandset && field.hideOnPhone != null)))
        {
            field.showIf = this._getFieldShowOnMobileFunction();
        }
    }
},
    

//> @method listGrid.applyFieldDefaults()
//      @group  data
//         Derive default field sizes and formatters where possible, based on schema information.
//<
_generatedFieldNameCount:0,
applyFieldDefaults : function (fields) {
    if (fields == null) return;
    
    var thisID = this.getID();

    // apply ListGrid-specific defaults, like using toShortDate() for Date fields
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];

        if (field == null) continue;

        // the default title rotation from the grid can be overridden on a per-field basis
        var rotateTitle = field.rotateTitle = field.rotateTitle || 
                this.rotateHeaderTitles && field.rotateTitle != false;

        
        if (field.componentID == null) field.componentID = thisID;

        // In general we can support un-named fields in dataBoundComponents if there is a dataPath
        if (!this.allowNamelessFields && field[this.fieldIdProperty] == null) {
            if (field.dataPath == null) {
                this.logWarn("unable to process field with no name / dataPath:" +
                             this.echo(field));
                continue;
            }
            // apply an arbitrary name - this gives us a straightforward way to map the
            // field object any generated editor item, etc.
            
            field[this.fieldIdProperty] = "field" + this._generatedFieldNameCount++;
        }
        // default the alignment of each field to left if not specified
        // In RTL mode default to right alignment (so text flows from start of value
        // outward as you'd expect). This means setting the property to "left" if
        // reverseRTLAlign is set, otherwise to "right".
        var defaultAlign = (this.isRTL() && !this.reverseRTLAlign) ? isc.Canvas.RIGHT
                                                                   : isc.Canvas.LEFT;

        // "type" is used for align and default formatting. If we have a display field
        // we're pulling display-values from, use the type specified there rather than
        // on the underlying data values the display values represent.
        var type = this.getFieldDisplayType(field);
        var baseType = (type != null ? isc.SimpleType.getBaseType(type) : null);
        

        // note: needs to be first, as "image" type technically inherits from text
        if (isc.SimpleType.inheritsFrom(type, "image")) {
            field._typeFormatter = this._formatImageCellValue;

        // Attempt to size columns to fit their content
        } else if (baseType == this._$text) {

            // use minimal space for small text fields with no value map
            
            if (field.width == null && field.length != null) {
                if (field.length < 15 && !field.valueMap) {
                    // set default width, taking into account grid and field minimums
                    field.width = Math.max(field.length * 7, this.minFieldWidth || 1,
                                           field.minWidth || 1);
                }
            }

        } else if (baseType == "integer" || baseType == "float") {
            // align numbers right by default to line up decimal places
            // Exception: If there's a valueMap attached we don't want to right-align
            // (Example - mapping error codes to display strings).
            
            var hasObjValueMap = field.valueMap != null && !isc.isAn.Array(field.valueMap),
                reverseAlign = (this.isRTL() && !this.reverseRTLAlign);
            defaultAlign = hasObjValueMap ?
                            (reverseAlign ? isc.Canvas.RIGHT : isc.Canvas.LEFT) :
                            (reverseAlign ? isc.Canvas.LEFT : isc.Canvas.RIGHT);
            field._typeFormatter = this._formatNumberCellValue;

        // by default size date columns fields to match the default shortDate format applied
        // to date fields
        
        } else if (baseType == "date" || baseType == "datetime") {
            if (field.width == null && field.autoFitWidth == null && 
                this.autoFitDateFields != "none") 
            {
                field.autoFitWidth = true;
                field.autoFitWidthApproach = this.autoFitDateFields;
            }
            // right alignment lines up years if day/month values are numeric and not padded
            defaultAlign = (this.isRTL() && !this.reverseRTLAlign)  ? isc.Canvas.LEFT
                                                                    : isc.Canvas.RIGHT;
            field._typeFormatter = this._formatDateCellValue;

        // by default size time columns fields to match the default format applied to time
        // fields
        } else if (baseType == "time") {
            if (field.width == null && field.autoFitWidth == null &&
                this.autoFitTimeFields != "none") 
            {
                field.autoFitWidth = true;
                field.autoFitWidthApproach = this.autoFitTimeFields;
            }
            field._typeFormatter = this._formatTimeCellValue;
            defaultAlign = (this.isRTL() && !this.reverseRTLAlign)  ? isc.Canvas.LEFT
                                                                    : isc.Canvas.RIGHT;

        } else if (type == "binary" || type == "blob" || type == "upload" || type == "imageFile") {
            field._typeFormatter = this._formatBinaryCellValue;
        } else if (type == "link") {
            field._typeFormatter = this._formatLinkCellValue;
        } else if (type == "icon") {
            // check autoFitIconFields -- if set, set min width to accommodate the
            // icons and set autoFitWidth:true / autoFitWidthApproach such that
            // it'll expand to accommodate the title if appropriate
            if (field.width == null && field.autoFitWidth == null) {
                if (this.autoFitIconFields != "none") {
                    field.autoFitWidth = true;
                    field.autoFitWidthApproach =
                        (this.autoFitIconFields == "title" && !rotateTitle) ? "both" : "value";
                }
            }
            field.align = field.align || "center";

            // install a formatter that will put button.icon into the cell
            field._typeFormatter = this._formatIconCellValue;

            // default title so that icon appears alone (otherwise would default to field name
            // if title was unset)
            field.title = field.title || isc.nbsp;

        // turn on 'canToggle' for all boolean fields.
        // If 'canEdit' is also set to true these fields will be editable via a single
        // click
        } else if (type == "boolean" || type== "checkbox") {
            if (field.canToggle == null) field.canToggle = true;
        }

        // For boolean fields we show checkbox images by default
        // this is handled via the valueIcon system - see getValueIcon(), getValueIconWidth() and
        // showValueIconOnly()
        

        // If formatCellValue was passed to us as a string, convert it to a method
        if (field.formatCellValue != null && !isc.isA.Function(field.formatCellValue))
            isc.Func.replaceWithMethod(field, "formatCellValue", "value,record,rowNum,colNum,grid");

        if (this.showValueIconOnly(field)) {
            defaultAlign = isc.Canvas.CENTER;

            
            field.iconSpacing = 0;

            // apply the "icon" field logic to fields that show valueIcons -
            // respect autoFitIconFields here too
            if (field.width == null && field.autoFitWidth == null) {
                if (this.autoFitIconFields != "none") {
                    field.autoFitWidth = true;
                    field.autoFitWidthApproach =
                        (this.autoFitIconFields == "title" && !rotateTitle) ? "both" : "value";
                }
            }
        } else if (field.icon != null && field.showTitle == false) {
            
            field.iconSpacing = 0;
        }

        // configure alignment for rotated header button titles
        if (rotateTitle) {
            
            if (!field.align) {
                field.align = isc.Canvas.CENTER;
                // pass through the default field alignment to the cells
                if (!field.cellAlign) field.cellAlign = defaultAlign;
            }
        }

        // default the vertical alignment of fields to headerTitleVAlign - see jsdoc on
        // ListGrid.headerTitleVAlign for behavior
        if (!field.valign) {
            if (this.headerTitleVAlign != null) field.valign = this.headerTitleVAlign;
            else if (rotateTitle) field.valign = "bottom";
        }

        // TODO: numeric quantities with range validators could be given specific sizes
        if (!field.align) field.align = defaultAlign;

        // For fields marked as multiple:true, set the "validateEachItem" flag.
        // This ensures that when validators run in an editable grid we will
        // validate each selected value
        if (field.multiple && field.validateEachItem == null) field.validateEachItem = true;

        //>EditMode
        
        if (field.recordClick) {
            // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value,rawValue"
            // Convert a string callback to a function
            isc.Func.replaceWithMethod(field, "recordClick",
                                             "viewer,record,recordNum,field,fieldNum,value,rawValue");
        }
        //<EditMode
    }
},

// If this field has a specified display field, pick up the underlying display field object
// (from the optionDataSource if appropriate, otherwise from the grid itself, or the
// underlying DS the grid is bound to).
getDisplayField : function (field) {
    var displayField = field.displayField;
    if (displayField != null) {
        var ods = field.optionDataSource ? isc.DataSource.get(field.optionDataSource) : null;
        if (ods != null) displayField = ods.getField(displayField);
        else {
            displayField = this.getField(displayField);
            if (displayField == null && this.dataSource != null) {
                displayField = this.getDataSource().getField(field.displayField);
            }
        }
    }
    return displayField;
},

// Returns the specified type of the field's displayField, if there is one, otherwise of the
// field itself.
getFieldDisplayType : function (field) {
    var displayField = this.getDisplayField(field),
        type;
    if (displayField != null) type = displayField.type;
    if (type == null) type = field.type;
    return type;
},

// Helper method called on boolean fields to determine whether we should use the
// booleanTrueImage/booleanFalseImage and related settings, or fall back to the general
// valueIcons system, which may show a combination of text and icons
_$boolean:"boolean",
_formatBooleanFieldAsImages : function (field) {
    // If booleanTrue/FalseImage have been set null, always back off to showing text / valueIcons
    if (this.booleanTrueImage == null && this.booleanFalseImage == null) return false;

    var type = this.getFieldDisplayType(field),
        baseType = (type != null ? isc.SimpleType.getBaseType(type) : null);
    if (baseType != this._$boolean) return false;

    // read as: user has not tried to set valueIcon-specific flags.
    // Also note: it's commonly necessary to set a valueMap with a boolean field in order to
    // allow stored values like YES/NO/null to be mapped to boolean true/false, so a valueMap
    // doesn't indicate an intent to use valueIcons.  If you have a valueMap and there are more
    // values than true/false/unset, you shouldn't declare the field boolean, it should be
    // enum.
    return (!field.suppressValueIcon && field.showValueIconOnly == null &&
             field.valueIcons == null && field.formatCellValue == null);
},


//> @method listGrid.setFieldProperties()
// Dynamically set properties for a particular field. This method will update the fields
// header-button without having to explicitly reset the fields in the grid.  <smartgwt>
// The passed-in +link{ListGridField} should contain just the minimal properties you want to
// change; do not take the original ListGridField, modify it, and just pass that to this
// function.</smartgwt>
// <P> 
// NOTE: Where explicit setters exist for field properties (such as
// +link{resizeField()}, +link{setFieldTitle()}, +link{setFieldIcon()}, etc.) these should be
// used instead.
//
// @param   fieldNum (number | String) name of the field, or index.
// @param   properties (ListGridField Properties) properties to apply to the header
// @visibility external
//<
// NOTE: little testing has been done on which properties can actually be set this way
setFieldProperties : function (fieldNum, properties) {
    var field, allFields = this.getAllFields();
    var origField = fieldNum;
    if (isc.isA.Number(fieldNum)) {
        // if an index was passed, use the visible fields
        field = this.getField(fieldNum);
    } else {
        // if a key was passed, use the complete fields to handle hidden columns
        var globalFieldNum = isc.Class.getArrayItemIndex(
                                fieldNum, allFields, this.fieldIdProperty);
        field = allFields[globalFieldNum];
        // map back to the fieldNum within this.fields (not within this.completeFields)
        fieldNum = this.getFieldNum(field);
    }
    if (!field) return;
    
    // If we find "operator" among the properties, consider it a special case and handle it
    // with setFieldProperty()
    for (var propName in properties) {
        if (propName == "operator") {
            this.setFieldProperty(field, propName, properties[propName]);
            // Remove "operator" from the properties list, so it is not handled twice
            delete properties[propName];
        }
    }
    
    isc.addProperties(field, properties);

    if (this.header != null && this.header.isDrawn()) {
        // getFieldHeader / getLocalFieldNum will account for frozen fields
        var header = this.getFieldHeader(fieldNum),
            headerButton = header.getMember(this.getLocalFieldNum(fieldNum));
        if (headerButton) headerButton.setProperties(properties);
    }
},

//> @method listGrid.setFieldMinWidth()
// Updates +link{listGridField.minWidth} for the specified field and redraws the associated
// column if required.
//
// @param fieldNum (int | String) name of the field, or index.
// @param width (Number)
// @see listGridField.minWidth
// @visibility external
//<
setFieldMinWidth : function (fieldNum, width) {
    this.setFieldProperties(fieldNum, {minWidth: width});
    var body = this.fieldIsFrozen(fieldNum) ? this.frozenBody : this.body;
    if (body) body._fieldWidthsDirty = true;
},

//> @method listGrid.setFieldMaxWidth()
// Updates +link{listGridField.maxWidth} for the specified field and redraws the associated
// column if required.
//
// @param fieldNum (int | String) name of the field, or index.
// @param width (Number)
// @see listGridField.maxWidth
// @visibility external
//<
setFieldMaxWidth : function (fieldNum, width) {
    this.setFieldProperties(fieldNum, {maxWidth: width});
    var body = this.fieldIsFrozen(fieldNum) ? this.frozenBody : this.body;
    if (body) body._fieldWidthsDirty = true;
},

//> @method listGrid.setMinFieldWidth()
// Updates +link{listGrid.minFieldWidth} and redraws any columns as needed.
//
// @param width (int)
// @see listGrid.minFieldWidth
// @visibility external
//<
setMinFieldWidth : function (width) {
    this.minFieldWidth = width;
    if (this.body)             this.body._fieldWidthsDirty = true;
    if (this.frozenBody) this.frozenBody._fieldWidthsDirty = true;

},

//> @method listGrid.setFieldTitle()
// Change the title of a field after the grid is created.
//
// @param fieldNum (int | String) name of the field, or index.
// @param title (String) new title
// @visibility external
//<
setFieldTitle : function (fieldNum, title) {
    this.setFieldProperties(fieldNum, {title:title});
},

//> @method listGrid.setFieldHeaderBaseStyle()
// Update the +link{listGridField.headerBaseStyle} for a field within the grid at runtime.
// @param name (String) name of the field.
// @param newStyle (CSSStyleName) new baseStyle for the field header
// @visibility external
//<
setFieldHeaderBaseStyle : function (name, baseStyle) {
    var field = this.getField(name);
    if (field == null) {
        this.logWarn("setFieldHeaderBaseStyle() unable to find field:" + name);
        return;
    }
    field.headerBaseStyle = baseStyle;
    var button = this.getFieldHeaderButton(this.getFieldNum(field));
    if (button != null) {

        // Treat being passed null as an attempt to revert to default base style.
        if (baseStyle == null) {
            var buttonProperties = this.getHeaderButtonProperties();
            if (field.frozen && buttonProperties.frozenBaseStyle) {
                baseStyle = buttonProperties.frozenBaseStyle;
            } else if (buttonProperties.baseStyle) {
                baseStyle = buttonProperties.baseStyle;
            }
        }
        if (baseStyle == null) {
            baseStyle = button.getClass().getPrototype().baseStyle;
        }
        button.setBaseStyle(baseStyle);
    }
},

//> @method listGrid.setFieldHeaderTitleStyle()
// Update the +link{listGridField.headerTitleStyle} for a field within the grid at runtime.
// @param name (String) name of the field.
// @param newStyle (CSSStyleName) new titleTyle for the field header
// @visibility external
//<
setFieldHeaderTitleStyle : function (name, titleStyle) {
    var field = this.getField(name);
    if (field == null) {
        this.logWarn("setFieldHeaderTitleStyle() unable to find field:" + name);
        return;
    }
    field.headerTitleStyle = titleStyle;
    var button = this.getFieldHeaderButton(this.getFieldNum(field));
    if (button != null) {
        if (titleStyle == null) {

            var buttonProperties = this.getHeaderButtonProperties();
            if (field.frozen && buttonProperties.frozenTitleStyle) {
                titleStyle = buttonProperties.frozenTitleStyle;
            } else if (buttonProperties.titleStyle) {
                titleStyle = buttonProperties.titleStyle;
            }
        }
        if (titleStyle == null) {
            titleStyle = button.getClass().getPrototype().titleStyle;
        }
        button.setTitleStyle(titleStyle);
    }
},

//> @method listGrid.setFieldIcon()
// Change the +link{listGridField.icon} for a field after the grid is created
// @param fieldName (String) field to update
// @param icon (SCImgURL) icon for the field
// @visibility external
//<
setFieldIcon : function (fieldName, icon) {
    var field = this.getField(fieldName);
    this.setFieldProperties(fieldName, {icon:icon});
    if (field && field.type == "icon" && field.cellIcon == null) {
        delete field._iconHTML
        this.body.markForRedraw("Field icon changed");
    }
},

//> @method listGrid.setFieldCellIcon()
// Change the +link{listGridField.cellIcon} for a field after the grid is created
// @param fieldName (String) field to update
// @param cellIcon (SCImgURL) new cellIcon for the field
// @visibility external
//<
setFieldCellIcon : function (fieldName, icon) {
    this.setFieldProperties(fieldName, {cellIcon:icon});
    var field = this.getField(fieldName);
    if (field && field.type == "icon") {
        delete field._iconHTML
        this.body.markForRedraw("Field cell icon changed");
    }
},


// AutoComplete
// --------------------------------------------------------------------------------------------

//> @method listGrid.setAutoComplete()
// Change the autoCompletion mode for the grid as a whole.
//
// @param   newSetting (AutoComplete)  new setting
// @group autoComplete
// @visibility autoComplete
//<

setAutoComplete : function (newSetting) {
    this.autoComplete = newSetting;
},

//> @method listGrid.setFieldAutoComplete()
// Change the autoCompletion mode for an individual field.
//
// @param   newSetting (AutoComplete)  new setting
// @group autoComplete
// @visibility autoComplete
//<

setFieldAutoComplete : function (field, newSetting) {
    field = this.getField(field);
    if (field) field.autoComplete = newSetting;
},

// --------------------------------------------------------------------------------------------

//> @method listGrid.showFields()
// Force an array of fields to be shown. This method does not add new fields to the grid,
// it simply changes field visibility. If a field.showIf expression exists, it will be
// destroyed.
// <P>
// Note: for showing multiple fields it is more efficient to call this method than to call
// +link{showField()} repeatedly.
//
// @param   field           (Array of String | Array of ListGridField)  Fields to show.
// @param   [suppressRelayout] (boolean) If passed, don't resize non-explicitly sized columns
//                                       to fill the available space.
// @visibility external
// @example columnOrder
//<
// Actually this is a synonym for showField() - separated for ease of documentation
showFields : function (fields, suppressRelayout) {
    return this.showField(fields,suppressRelayout);
},

//> @method listGrid.showField()
// Force a field to be shown. This method does not add new fields to the grid,
// it simply changes field visibility. If a field.showIf expression exists, it will be
// destroyed.
// <P>
// Note: for showing multiple fields it is more efficient to call +link{showFields()} than
// to call this method repeatedly.
//
// @param field (String | ListGridField) field to show
// @param [suppressRelayout] (boolean) If passed, don't resize non-explicitly sized columns
//                                       to fill the available space.
// @visibility external
// @example columnOrder
//<
showField : function (fields, suppressRelayout) {

    arguments.__this = this;

    // if setFields() hasn't been run, run it now, then call ourselves again
    if (this.completeFields == null) {
        this.setFields(this.completeFields || this.fields);
        return this.showField(fields, suppressRelayout);
    }

    if (!isc.isAn.Array(fields)) {
        fields = [fields];
    }

    var noFields = true,
        allVisible = true;

    var mustSetFields = this.frozenFields || this._suppressedFrozenFields;

    for (var i = 0; i < fields.length; i++) {
        
        var field = fields[i],
            fieldObj = field;
        if (!this._processingVisibilityRule) {
            this._removeFieldVisibleWhen(field);
        }

        // Use getSpecifiedField() to retrieve the fieldObject from the fields / completeFields
        // array.
        // Note that this returns null for an invalid field object / ID
        fieldObj = this.getSpecifiedField(fieldObj);

        if (fieldObj == null) {
            fields[i] = null;
            this.logWarn("showField(): unable to find field object for field: " + field
                         + ". Taking no action. Call setFields() to add new fields.")
            continue;
        }

        noFields = false;

        // Update initialization property to match new field state
        fieldObj.hidden = false;

        // Set hideOnPhone/hideOnTablet to null - we're explicitly overriding these
        fieldObj.hideOnPhone = fieldObj.hideOnTablet = null;

        // -- We always want to clear out any showIf property on the field, as even if the field is
        //    currently being shown, we want the field to continue to be shown from this point on
        //    regardless of any conditions in a showIf property
        
        if (fieldObj.detail) {
            fieldObj.showIf = "true";
        } else {
            if (fieldObj.showIf != null) fieldObj.showIf = null;
        }

        // need to call setFields if the field is frozen or if it was already visible at a 
        // different masterIndex
        if (fieldObj.frozen) mustSetFields = true;

        // if this field is in a headerSpan, we need to call setFields() to rebuild it
        if (this.spanMap && this.spanMap[fieldObj.name] != null) mustSetFields = true;

        if (mustSetFields) continue;

        // If this.fields contains the object, we can assume it's already visible if we're drawn
        // and will show up when we get drawn otherwise.
        if (this.fields.contains(fieldObj)) {
            fields[i] = null;
            continue;
        }

        // At this point we know we have at least one field that needs to be added
        // to the fields array (was previously hidden)
        allVisible = false;
        // hang onto the "live" fieldObj in the array
        fields[i] = fieldObj;
    }

    
    if (mustSetFields) {
        // don't call bindToDataSource() since that will disturb any manual field ordering
        this._suppressBindToDS = true;
        this.setFields(this.completeFields);
        delete this._suppressBindToDS;

        if (this.selectHeaderOnSort && this._sortSpecifiers) this.selectSortFieldHeaderButton();
        this.handleFieldStateChanged();
        return;
    }

    if (noFields || allVisible) return;

    // update this.fields
    this.deriveVisibleFields();

    // Empty slots may be present due to already visible fields
    fields.removeEmpty();

    var shownFieldNums = [],
        foundFields = 0;

    // Determine the position of the newly shown fields in our fields array.
    for (var i = 0; i < this.fields.length; i++) {
        var index = fields.indexOf(this.fields[i]);
        if (index != -1) {
            shownFieldNums[index] = i;

            foundFields++;
            // stop when we've figured out the position of all fields passed in.
            if (foundFields == fields.length) break;
        }
    }

    var header = this.header;
    // Update any UI to display the new field, if necessary
    

    // create the header button for the new column
    if (header != null) {
        if (!suppressRelayout) this.header.hPolicy = "fill";
        // undocumented feature - addButtons handles being passed an array of field indices
        // as well as an array of buttons
        
        this._suppressAutoFitToTitle = true;
        this.header.addButtons(fields.duplicate(), shownFieldNums);
        delete this._suppressAutoFitToTitle;
    }

    // tell the body about the new field
    if (this.body) {

        // If we're showing an editor in the new field we need to
        // - create the form items for it and slot it into the edit form
        // - shift the colNum on other items, and the _editColNum of the grid as a whole.
        if (this._editorShowing) {

            var editRowNum = this.getEditRow(),
                record = this.getRecord(editRowNum),

                
                editedRecord = this.getEditedRecord(editRowNum),

                adjustedEditColNum = false,
                items = this.getEditForm().items,
                liveItemIndex = items.length-1,
                liveItem = items[liveItemIndex],
                itemColNum = liveItem.colNum;

            // sort the shownFieldNums
            // this allows us to update the live edit item colNum values easily.
            // Note that it means the shownFieldNums will no longer match up to the fields
            // entries in the shown fields array.
            shownFieldNums.sort();

            for (var i = shownFieldNums.length-1; i >= 0; i--) {
                var offset = i+1,
                    fieldNum = shownFieldNums[i],
                    threshold = (fieldNum - i);

                if (!adjustedEditColNum && this._editColNum >= fieldNum) {
                    this._editColNum += offset;
                }

                // Update the edit form
                var fieldObj = this.fields[fieldNum],
                    width = this.getEditFormItemFieldWidths(record)[fieldNum],
                    item;

                while (liveItem != null && itemColNum >= threshold) {
                    liveItem.colNum += offset;

                    liveItemIndex --;
                    liveItem = (liveItemIndex >= 0) ? items[liveItemIndex] : null;
                    itemColNum = (liveItem != null) ? liveItem.colNum : null;
                }

                // at this point we've updated any items with a colNum >= ours
                // Create an item for the newly shown field and slot it into the edit form
                //
                // liveItemIndex will now be set to the slot before the one we're interested in
                // (index of the item that previously matched our colNum, minus 1)
                //
                // Note if we're editing by cell this won't apply since if we're showing an editor
                // the field its showing on must already be visible.
                var drawnRange = this.body.getDrawArea();
                if (!this.editByCell && fieldNum >= drawnRange[2] && fieldNum <= drawnRange[3]) {
                    item = this.getEditItem(fieldObj, record, editedRecord, editRowNum, fieldNum, width);
                }
                if (item != null) {
                    this._editRowForm.addItems([item], liveItemIndex+1);
                }
            }
        }

        this.body.fields = this.normalFields || this.fields;
        this.setBodyFieldWidths(this.getFieldWidths());

        this._remapEmbeddedComponentColumns(this.body);

    }

    // If we're auto-fitting vertically, allow the header to shrink or grow vertically
    // as appropriate
    
    if (this.header && this.autoFitHeaderHeights) {
        this.dropCachedHeaderButtonHeights();
        this._updateHeaderHeight();
    }


    // reset the sortFieldNum - we may have added or repositioned the primary sort field
    if (this.sortField != null) {
        this.sortFieldNum = null;
        this.sortFieldNum = this._getSortFieldNum();
        if (this.selectHeaderOnSort) this.selectSortFieldHeaderButton();
    }

    // If we have a filterEditor showing, update its fields too
    if (this.filterEditor != null) {
        this.filterEditor.showField(fields, suppressRelayout);
        if (this.allowFilterOperators) {
            for (var i = 0; i < fields.length; i++) {
                var filterForm = this.filterEditor.getEditForm(),
                    filterFormItem = filterForm && filterForm.getItem(fields[i].name)
                ;
                if (filterFormItem) {
                    var operator = this.getFieldSearchOperator(fields[i]);
                    this.updateOperatorIcon(fields[i], filterFormItem, operator);
                }
            }
        }
    }

    // update recordSummaries as well as grid/group ones
    this.recalculateSummaries(null, fields);
    if (this.summaryRow != null && this.showGridSummary) {
        this.summaryRow.showField(fields, suppressRelayout);
    }

    // reapply hilites - we don't store hilite information on hidden fields so if
    // hidden fields are displayed we'll need to reapply.
    if (this.hilites) this.applyHilites(true);

    // do an instant redraw rather than markForRedraw() because we have to avoid dropping values
    var gridBody = this.body;
    if (gridBody && gridBody.isDrawn()) gridBody.redraw("show field");
    this.markForRedraw("showField");

    this.handleFieldStateChanged();
    this._clearFieldDependencyTable();
    
},

// field.showIf function to return hideOnTablet etc if appropriate
_getFieldShowOnMobileFunction : function () {

    if (this._showOnMobileFunction == null) {
        this._showOnMobileFunction = function (list, field, fieldNum) {
            if (isc.Browser.isTablet && field.hideOnTablet != null) {
                return !field.hideOnTablet;
            }
            if (isc.Browser.isHandset && field.hideOnPhone != null) {
                return !field.hideOnPhone;
            }
        };
        this._showOnMobileFunction._isShowOnMobileFunction = true;
    }    
    return this._showOnMobileFunction;
},

//> @attr listGridField.hideOnPhone (Boolean : null : IRW)
// Set this property to true to suppress showing this field on mobile phones 
// (handset-sized devices). To update this property at runtime use 
// +link{listGrid.setHideOnPhone()}
// <P>
// Note that if +link{listGridField.hidden} is set, or an explicit +link{listGridField.showIf} 
// function exists that will take precedence over this setting. 
// Similarly, an explicit call to +link{listGrid.showField()} or
// +link{listGrid.hideField()} will clear this setting.
// <P>
// See also the related property +link{listGridField.hideOnTablet}.
//
// @group appearance
// @visibility external
//<

//> @method listGrid.setHideOnPhone()
// Updates the +link{listGridField.hideOnPhone} attribute at runtime.
// @param field (ListGridField | String) field or field name to update
// @param hideOnPhone (Boolean) new setting for hideOnPhone property
// @visibility external
//<
setHideOnPhone : function (field, hideOnPhone) {
    var field = this.getFieldByName(field); // resolve number/name to a field object
    if (field == null) return;
    if (field.hideOnPhone === hideOnPhone) {
        return;
    }
    field.hideOnPhone = hideOnPhone;

    // Don't override explicit showIf function
    if (field.showIf == null) {
        field.showIf = this._getFieldShowOnMobileFunction();
    }
    this.refreshFields();

},

//> @attr listGridField.hideOnTablet (Boolean : null : IRW)
// Set this property to true to suppress showing this field on tablets 
// (tablet-sized devices). To update this property at runtime use 
// +link{listGrid.setHideOnTablet()}
// <P>
// Note that if +link{listGridField.hidden} is set, or an explicit +link{listGridField.showIf} 
// function exists that will take precedence over this setting. 
// Similarly, an explicit call to +link{listGrid.showField()} or
// +link{listGrid.hideField()} will clear this setting.
// <P>
// See also the related property +link{listGridField.hideOnPhone}.
//
// @group appearance
// @visibility external
//<

//> @method listGrid.setHideOnTablet()
// Updates the +link{listGridField.hideOnTablet} attribute at runtime.
// @param field (ListGridField | String) field or field name to update
// @param hideOnTablet (Boolean) new setting for hideOnTablet property
// @visibility external
//<
setHideOnTablet : function (field, hideOnTablet) {
    var field = this.getFieldByName(field); // resolve number/name to a field object
    if (field == null) return;
    if (field.hideOnTablet === hideOnTablet) {
        return;
    }
    field.hideOnTablet = hideOnTablet;

    // Don't override explicit showIf function
    if (field.showIf == null) {
        field.showIf = this._getFieldShowOnMobileFunction();
    }
    this.refreshFields();
},

selectSortFieldHeaderButton : function () {
    // reselect the sortField
    var sort = this.getSort();
    if (sort && sort.length > 0) {
        var fieldNum = this.getFieldNum(sort[0].property);
        if (fieldNum>=0) {
            // select the appropriate button
            var sortHeader = this.getFieldHeader(fieldNum),
                sortButton = this.getFieldHeaderButton(fieldNum)
            ;

            if (sortButton) {
                sortHeader.selectButton(sortButton);
                if (isc.Browser.isTouch && this.shouldShowHeaderMenuButton(sortButton, true)) {
                    this._showHeaderMenuButton(sortButton);
                }
            }
        }
    }
},

//> @method listGrid.hideFields()
// Force an array of fields to be hidden.
// <P>
// NOTE: If a field.showIf expression exists, it will be destroyed.
// <P>
// When hiding multiple fields, this method should be called rather than
// calling +link{listGrid.hideField()} repeatedly for each field to hide.
//
// @param fields (Array of String | Array of ListGridField) fields to hide
// @param [suppressRelayout] (boolean) if passed, don't relayout non-explicit sized fields
//                                      to fit the available space
// @visibility external
//<
hideFields : function (fields, suppressRelayout) {
    return this.hideField(fields, suppressRelayout);
},

//> @attr listGrid.discardEditsOnHideField (boolean : true : IRW)
// If a user is editing a +link{listGrid.canEdit,canEdit:true} listGrid, and they hide
// a field while the editor is showing, should we discard any edits in the edit row for
// the field being hidden?
// <P>
// Default behavior is to discard the edits - set this flag to false to preserve edits
// @visibility external
//<
// The intention here is to avoid confusion. If the user is editing a field in an
// auto-save-edits:true grid, it is rare for there to be pending editor values outside the
// edit-form. Most commonly this will occur only for validation failure.
// In this case, if the edits a field and hides it and then a save fails due to a validation
// failure on the hidden field, there's no user-visible feedback indicating what happened.
// Developers who choose to do so can set this flag to false and handle this case via 
// validation failure handling code at the grid level of course.
// We also disable this for the filterEditor where we want to retain filter criteria which
// are not reflected in the visible set of fields.
discardEditsOnHideField:true,

//> @method listGrid.hideField()
// Force a field to be hidden.<br><br>
//
// NOTE: If a field.showIf expression exists, it will be destroyed.
// <P>
// Note also that if multiple fields are to be hidden it is more efficient to call
// +link{hideFields()} passing in the array of fields to hide rather than to call this method
// repeatedly.  In particular, this will ensure +link{recalculateSummaries()} is only run once.
//
// @param field (String | ListGridField) field to hide
// @param [suppressRelayout] (boolean) if passed, don't relayout non-explicit sized fields
//                                      to fit the available space
// @visibility external
// @example columnOrder
//<
hideField : function (fields, suppressRelayout) {
    arguments.__this = this;

    // if setFields() hasn't been run, run it now, then call ourselves again
    if (this.completeFields == null) {
        this.setFields(this.completeFields || this.fields);
        return this.hideField(fields, suppressRelayout);
    }

    var noFields = true,
        allHidden = true;

    if (!isc.isAn.Array(fields)) {
        fields = [fields];
    }
    // we shuffle some stored colNums around on edit items - store out the index of each field
    // being hidden in an array to make this easier.
    var hiddenFieldNums = [];

    if (fields.length == this.getFields().length) {
        // can't hide the last bunch of fields
        this.logWarn("Attempt to hide all fields in one call - disallowed.");
        return;
    }

    

    var mustSetFields = this.frozenFields;
    // If we're showing an editor we need to make certain changes to get rid of the
    // form item, etc.
    var editorShowing = this._editorShowing,
        editRow = editorShowing ? this.getEditRow() : null,
        editCol = editorShowing ? this.getEditCol() : null,
        hidEditCell = false;
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            fieldObj = field;

        // Use getSpecifiedField() to pick up the field object from the completeFields array
        // (or if setFields has never been called, from the fields array).
        // Note - if we're passed an invalid field object, this method returns null.
        fieldObj = this.getSpecifiedField(fieldObj);
        if (fieldObj == null) {
            this.logWarn("hideField(): unable to find field object for field: " + field
                         + ". Taking no action. To add this field use the setFields() method.");
            fields[i] = null;
            continue;
        }

        noFields = false;
        if (!this._processingVisibilityRule) {
            this._removeFieldVisibleWhen(field);
        }

        // Set hideOnPhone/hideOnTablet to null - we're explicitly overriding these
        
        fieldObj.hideOnPhone = fieldObj.hideOnTablet = null;

        // -- Set showIf to always evaluate to false.
        fieldObj.showIf = this._$false;
        // If the field is not currently present in this.fields, we can safely assume it's already
        // hidden. No need to proceed in this case
        if (!this.fields.contains(fieldObj)) {
            fields[i] = null;
            continue;
        }
        allHidden = false;

        // Update initialization property to match new field state
        fieldObj.hidden = true;

        // If we're going to call setFields, we're done - we'll just call that
        // method outside this for-loop to update the completeFields array, edit values, etc.
        if (mustSetFields) continue;

        var fieldNum = this.fields.indexOf(fieldObj),
            fieldName = this.getFieldName(fieldNum);

        hiddenFieldNums.add(fieldNum);

        if (editorShowing) {
            if (editCol == fieldNum) hidEditCell = true;

            // If the user has modified the edit value and not yet stored the change
            // (IE it isn't yet part of our 'pending edit values' for the row), discard
            // the unsaved edits.
            
            // By default we're going to clear the edit value from the cell being hidden
            // pass the additional 3rd parameter to avoid re-displaying the record's value
            // in the (about to be cleared) cell.
            var focusItem = this.getEditFormItem(fieldName);
            // (Item may not exist due to incremental rendering, non editable fields, editByCell)
            if (focusItem && focusItem.hasFocus) focusItem.blurItem();
            
            if (this.discardEditsOnHideField) {
                this.clearEditValue(editRow, fieldNum, true);
            }
        }
    }
    // If we were passed an empty array, or an array containing already hidden fields
    // we can bail here.
    if (noFields || allHidden) return;

    
    if (mustSetFields) {

        // don't call bindToDataSource() since that will disturb any manual field ordering
        this._suppressBindToDS = true;
        this.setFields(this.completeFields);
        delete this._suppressBindToDS;

        if (this.selectHeaderOnSort && this._sortSpecifiers) this.selectSortFieldHeaderButton();
        this.handleFieldStateChanged();
        return;
    }

    fields.removeEmpty();
    if (editorShowing) {
        if (hidEditCell) {
            // If we're editing by cell, and hiding the current edit cell just kill the edit.
            if (this.editByCell) {
                this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                editorShowing = false;
            } else {
                // If possible we want to shift edit focus to an adjacent field
                // findNextEditCell() is unaware of the cells we've just hidden so
                // reimplement the relevant part of this method to find the next editable and
                // still visible field. Check for closest field to the left first, then to the right
                var newEditCol = editCol-1,
                    foundEditCol = false;
                while (newEditCol >= 0) {
                    if (!hiddenFieldNums.contains(newEditCol) &&
                        this.canEditCell(editRow, newEditCol) &&
                        this._canFocusInEditor(editRow, newEditCol))
                    {
                        foundEditCol = true;
                        break;
                    }
                    newEditCol--;
                }
                if (!foundEditCol) {
                    newEditCol = editCol +1;
                    while (newEditCol < this.fields.length) {
                        if (!hiddenFieldNums.contains(newEditCol) &&
                            this.canEditCell(editRow, newEditCol) &&
                            this._canFocusInEditor(editRow, newEditCol))
                        {
                            foundEditCol = true;
                            break;
                        }
                        newEditCol++;
                    }
                }

                // If we don't have any other editable cells in the row, just cancel the edit
                if (!foundEditCol) {
                    this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                    editorShowing = false;
                } else {
                    // focus in the adjacent field.
                    
                    this._startEditing(editRow, newEditCol,
                                            !this.getEditForm().hasFocus);
                }
            }
        }
    }
    // update this.fields
    this.deriveVisibleFields();
    // destroy the header button
    var header = this.header;
    if (header != null) {
        // Setting the hPolicy to "fill" will cause the header to relay it's buttons out to
        // fill the available space.
        if (!suppressRelayout) this.header.hPolicy = "fill";
        var buttons = [];
        for (var i = 0; i < hiddenFieldNums.length; i++) {
            var fieldNum = hiddenFieldNums[i];

            var button = this.header.getButton(fieldNum);
            buttons[buttons.length] = button;
            if (this.headerMenuButton && this.headerMenuButton.masterElement == button) {
                this.headerMenuButton.depeer();
            }
        }
        // removeButtons actually effects the display passed in, so duplicate it
        this.header.removeButtons(buttons.duplicate());
        buttons.callMethod("destroy");

        // If we're auto-fitting vertically, allow the header to shrink or grow vertically
        // as appropriate
        if (this.autoFitHeaderHeights) {
            this.dropCachedHeaderButtonHeights();
            this._updateHeaderHeight();
        }
    }
    // If we're currently showing any edit form items for subsequent columns,
    // we must decrement their 'colNum' properties.
    // do this *before* we redraw the body, as the body redraw relies on these values being
    // accurate to create new items for fields that get shifted into view.
    // Also update the _editColNum if necessary.

    
    var itemsToClear = [];
    if (editorShowing) {
        hiddenFieldNums.sort();

        var form = this._editRowForm,
            items = form.getItems(),

            itemIndex = items.length-1,
            item = items[itemIndex],
            itemColNum = item.colNum,

            adjustedEditColNum = false;

        for (var i = hiddenFieldNums.length-1; i >= 0; i--) {

            var offset = i+1,
                threshold = hiddenFieldNums[i];

            if (!adjustedEditColNum && this._editColNum > threshold) {
                this._editColNum -= offset;
                adjustedEditColNum = true;
            }

            while (item != null && itemColNum >= threshold) {
                if (itemColNum == threshold) itemsToClear.add(item);
                else item.colNum -= offset;

                itemIndex --;
                item = (itemIndex >= 0) ? items[itemIndex] : null;
                itemColNum = (item != null) ? item.colNum : null;
            }
        }
    }
    // tell the body about the removed fields
    if (this.body) {
        this.body.fields = this.normalFields || this.fields;
        this.setBodyFieldWidths(this.getFieldWidths());

        this._remapEmbeddedComponentColumns(this.body);
    }

    if (editorShowing && itemsToClear.length > 0) {
        // If we're currently showing an edit form item for this field, remove it now (already
        // been cleared from the DOM), and had the edit values cleared.
        for (var i = 0; i < itemsToClear.length; i++) {
            // Hide the actual item if there is one.
            var item = itemsToClear[i];
            // Note that we may already have updated the items as part of redraw so
            // don't attempt to remove an already destroyed item from the form
            if (item.destroyed) continue;
            this._editRowForm.removeItems([item]);
        }
    }
    // reset the sortFieldNum - we may have removed or repositioned the primary sort field
    if (this.sortField != null) {
        this.sortFieldNum = null;
        this.sortFieldNum = this._getSortFieldNum();
        if (this.selectHeaderOnSort && this.header) this.selectSortFieldHeaderButton();
    }

    // If we have a filterEditor showing, update its fields too
    if (this.filterEditor != null) this.filterEditor.hideField(fields, suppressRelayout);

    // update recordSummaries as well as grid/group ones
    this.recalculateSummaries();
    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow.hideField(fields, suppressRelayout);
    }

    // do an instant redraw rather than markForRedraw() because we have to avoid dropping values
    var gridBody = this.body;    
    if (gridBody && gridBody.isDrawn()) gridBody.redraw("hide field");

    
    //this._remapEmbeddedComponents();
    this.handleFieldStateChanged();
    this._clearFieldDependencyTable();
},

//> @method listGrid.fieldIsVisible()
// Check whether a field is currently visible
//
// @param   field (String | ListGridField)  field to be checked
// @return (boolean) true if the field is currently visible, false otherwise.
// @visibility external
//<
fieldIsVisible : function (field, optimize) {
    var fieldObj = field;
    // If passed a field ID, look for it in the completeFields array rather than the fieldsArray
    // as it is may be defined, but not visible
    if (!isc.isAn.Object(fieldObj)) fieldObj = this.getSpecifiedField(field);

    // avoid a linear lookup across visible fields
    if (optimize) {
        if      (fieldObj.showIf == "false") return false;
        else if (fieldObj.showIf ==  null)   return true;
    }

    return this.fields.contains(fieldObj);
},

// ----------------------------------------------------------------------------

//> @method listGrid.processVisibilityRule()
// Process a "visibility" type rule for this ListGrid.
// <P>
// Overridden to handle showing and hiding fields if +link{rule.targetObjectType} is
// set to "ListGridField" in order to support ListGridField.visibleWhen.
//
// @param result (boolean) the result of evaluating criteria in the ruleScope for this rule
// @param rule (Rule) the rule to process
// @return (boolean) Returns true if the rule changed the visibility of the target object
// @visibility internal
//<
processVisibilityRule : function (result, rule) {

    result = !!result;
    if (rule.targetObjectType == "ListGridField") {
        var wasVisible = this.fieldIsVisible(rule.fieldName);
        if (wasVisible != result) {

            this._processingVisibilityRule = true;

            if (result) this.showField(rule.fieldName);
            else this.hideField(rule.fieldName);

            delete this._processingVisibilityRule;

            return true;
        
        // unchanged - nothing to do here
        } else {
            return false;
        }
    }
    // If we didn't handle this with custom logic, invoke Super
    return this.Super("processVisibilityRule", arguments);
},

//> @method listGrid.processEnableRule()
// Process an "enable" type rule for this ListGrid.
// <P>
// Overridden to handle enabling fields if +link{rule.targetObjectType} is
// set to "ListGridField" in order to support ListGridField.enableWhen.
//
// @param result (boolean) the result of evaluating criteria in the ruleScope for this rule
// @param rule (Rule) the rule to process
// @return (boolean) Returns true if the rule changed the visibility of the target object
// @visibility internal
//<
processEnableRule : function (result, rule) {
    var disable = !result
    if (rule.targetObjectType == "ListGridField") {

        this._processingVisibilityRule = true;

        var field = this.getSpecifiedField(rule.fieldName),
            wasDisabled = field && field.disabled;
        if (field && (wasDisabled != disable)) {
            field.disabled = disable;
            var header = this.getFieldHeaderButton(rule.fieldName);
            if (header) {
                header.setDisabled(disable);
            }
            return true;
    
        // unchanged - nothing to do here
        } else {
            return false;
        }
    }
    // If we didn't handle this with custom logic, invoke Super
    return this.Super("processEnableRule", arguments);
},


_setupFieldWhenRules : function () {
    var rulesEngine = this.getRulesEngine(),
        fields = this.completeFields,
        ruleScope = this.getRuleScope();

    if (!rulesEngine || !fields) return;

    var addedRule;

    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];

        // A canvas inherits ruleScope from its parent but in the case of a ListGridField
        // it's not a Canvas and therefore would require an explicit ruleScope setting
        // just like any other non-Canvas instance. To make this process easier,
        // a ruleScope is pushed into the LGF. Note that this isn't necessary for
        // *When rules or for normal ruleContext updates but is useful for setting a
        // dynamicProperty on a grid field or for handling events in a workflow.
        if (ruleScope && !field.ruleScope) field.ruleScope = ruleScope;

        if (!field._createdWhenRule) {
            if (field.visibleWhen) {
                rulesEngine.addRule(
                    this._createWhenRule("visibility", field.visibleWhen,
                        {targetObjectType:"ListGridField", fieldName:field.name})
                );
                addedRule = true;
            }
            if (field.enableWhen) {
                rulesEngine.addRule(
                    this._createWhenRule("enable", field.enableWhen,
                        {targetObjectType:"ListGridField", fieldName:field.name})
                );
                addedRule = true;
            }
            if (field.readOnlyWhen) {
                rulesEngine.addRule(
                    this._createWhenRule("readOnly", field.readOnlyWhen,
                        {targetObjectType:"ListGridField", fieldName:field.name})
                );
                addedRule = true;
            }

            field._createdWhenRule = true;
        }
    }

    if (addedRule && !rulesEngine.members.contains(this)) rulesEngine.addMember(this);
},

_removeFieldWhenRules : function (field) {
    var field = this.getSpecifiedField(field);
    if (field && field._createdWhenRule) {
        if (field.visibleWhen) this._removeWhenRule("visibility", {fieldName:field.name});
        if (field.enableWhen) this._removeWhenRule("enable", {fieldName:field.name});
        delete field._createdWhenRule;
    }
},


_removeFieldVisibleWhen : function (field) {
    var field = this.getSpecifiedField(field);
    if (field && field.visibleWhen) {
        if (field._createdWhenRule) {
            this._removeWhenRule("visibility", {fieldName:field.name});
        }
        delete field.visibleWhen;
    }
},

// ----------------------------------------------------------------------------
// panelHeader related methods

showActionInPanel : function (action) {
    // specifically add the "editNew" action, which is not added by default
    if (action.name == "editNew") return true;
    return this.Super("showActionInPanel", arguments);
},

//> @method listGrid.getTitleField()
// @include dataBoundComponent.getTitleField()
//<

//> @method listGrid.setFields()  ([A])
// Sets the fields array and/or field widths to newFields and sizes, respectively.
// <p>
// If newFields is specified, it is assumed that the new fields may have nothing in common with
// the old fields, and the component is substantially rebuilt.  Furthermore, it's invalid to
// modify any of the existing +link{ListGridField}s after they've been passed to this function.
// Consider the following methods for more efficient, more incremental changes:
// +link{resizeField()}, +link{reorderField()}, +link{showField()}, +link{hideField()}, or
// +link{setFieldProperties()}.
// <p>
// Two specific values of newFields have explicit meanings:
// <ul>
// <li>null - a newFields value of <code>null</code> indicates there are no field overrides.
//            All current fields are removed and, if the grid is bound to a 
//            +link{dataSource}, the "default binding" is used. (see 
//            +link{dataBoundComponent.fields}).</li>
// <li>empty array <smartclient>([])</smartclient> - providing an empty array for the
//            newFields indicates that no fields are desired even if a dataSource is
//            provided.</li>
// </ul>
//
// @visibility external
//
// @param   [newFields]     (Array of ListGridField)    array of fields to draw
//<
_$setFields:"set fields",
setFields : function (newFields) {

    if (isc._traceMarkers) arguments.__this = this;
    var recalculateSummaries = false;
    // If called with new fields (more than just an update of existing field state), reset
    // the flag indicating that we've used specified width as a minimum for autoFitWidth fields
    //
    // Also drop any old ...when rules from fields being removed
    if (newFields != null && this.fields != null &&
        this.fields != newFields && this.completeFields != newFields)
    {
        delete this.fields._appliedInitialAutoFitWidth;
        var oldFields = this.completeFields || this.fields;
        for (var i = 0; i < oldFields.length; i++) {
            if (!newFields || !newFields.contains(oldFields[i])) {
                this._removeFieldWhenRules(oldFields[i]);
            }
        }
    }
    // Iterate through supplied fields:
    // - warn and remove any null slots
    // - Check for any userFormulae / summary fields - we may have to "recalculateSummaries"
    if (isc.isAn.Array(newFields)) {
        var offset = 0;
        for (var i = 0; i < newFields.length; i++) {
            // If we hit a null slot, shunt subsequent fields earlier in the list so they fill
            // the slot.
            if (newFields[i] == null) {
                this.logWarn("listGrid.setFields : null entry in new fields array - removing the entry");
                offset += 1;
                continue;
            }
            if (offset > 0) newFields[i-offset] = newFields[i];
            
            if (newFields[i] && (newFields[i].userFormula || newFields[i][this._$summary])) {
                recalculateSummaries = true;
            }
        }
        if (offset > 0) newFields.length = newFields.length - offset;
    }

    if (!newFields && isc.DataSource && 
        isc.isA.DataSource(this.getDataSource()) && !this.getDataSource().hasFields())
    {
        this.logWarn("ListGrid.setFields() : neither this ListGrid nor its dataSource have fields");
    }
    // set boolean images to default checkboxItem images if unset
    if (!this.booleanFalseImage && !this.booleanTrueImage && !this.booleanPartialImage) {
        this.booleanTrueImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("checkedImage") : null;
        this.booleanFalseImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("uncheckedImage") : null;
        this.booleanPartialImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("partialSelectedImage") : null;
        // set imageWidth from checkboxItem.valueIconWidth to avoid images having different sizes
        // when editing and not editing
        
        this.booleanImageWidth = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null;
        this.booleanImageHeight = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("valueIconHeight") : null;

    }
    if (!this.printBooleanFalseImage && !this.printBooleanTrueImage && !this.printBooleanPartialImage) {
        this.printBooleanTrueImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("printCheckedImage") : null;
        this.printBooleanFalseImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("printUncheckedImage") : null;
        this.printBooleanPartialImage = isc.CheckboxItem ?
                        isc.CheckboxItem.getInstanceProperty("printPartialSelectedImage") : null;
    }

    // if there is a sortFieldNum set, get a pointer to that field
    // we'll check later to reset the sort if we need to
    var sortFieldNum = this._getSortFieldNum(),
        oldSortField = (sortFieldNum != null && this.fields
                        ? this.fields[sortFieldNum] : null);

    // Interaction of setFields() with editing:
    // - If we have editValues for any row(s) [Pending unsaved edits], it is possible that
    //   some of the fields for which we have edit values will go away - in this case we need
    //   to drop those edit values, and any validation errors for those fields.
    // - If we are currently showing an editor for some row, we may also need to update the
    //   fields in the edit form.
    // * We'll drop the removed fields' edit values silently, [log at info level only] - this
    //   is expected / acceptable behavior when fields are removed.
    var editorShowing = this._editorShowing,
        editRowNum = this.getEditRow(),
        editColNum = this.getEditCol(),
        editForm = this._editRowForm,
        oldEditFieldName = this.fields ? this.getEditFieldName() : null
    ;

    // listGrid.completeFields and listGrid.fields are set to arrays which contain pointers
    // to the same set of "field" objects.
    // - Any fields with a showIf property that evaluates to false will be removed from
    //   this.fields, making it an array of only the list of *visible* fields.
    // - on a reorder or similar manipulation of the set of fields, you should manipulate
    //   this.completeFields and pass the result to setFields().  Otherwise, you will lose any
    //   fields that aren't visible at the time.
    

    

    // on the first setFields() ever, create a new array for the visible fields
    if (this.completeFields == null) {
        this.fields = [];
        
    // Also if passed this.fields, duplicate the array before potentially storing it
    // as this.completeFields so we don't end up with both references pointing to the 
    // same object.
    } else if (newFields === this.fields) {
        newFields = newFields.duplicate();
    }

    // bind the passed-in fields to the DataSource and store
    // canPickOmittedFields - if true we'll pick up all dataSource fields but have them
    // marked as showIf:false if useAllDataSourceFields is false
    
    if (!this._suppressBindToDS) {
        this.completeFields = this.bindToDataSource(newFields, this.canPickOmittedFields);
    }
    if (this.completeFields == null) this.completeFields = [];

    // rowNumberField displaying the current rowNum of each record
    if (this.shouldShowRowNumberField()) {
        var rnField = this.getCurrentRowNumberField(),
            rnPos = this.getRowNumberFieldPosition(),
            shouldAdd = !rnField
        ;

        // Exception: If the completeFields passed in (the new fields) contains the
        // special field already, no need to add it.
        
        if (shouldAdd &&
            newFields && newFields.find(this.fieldIdProperty, "_rowNumberField") != null)
        {
            shouldAdd = false;
        }

        if (shouldAdd) rnField = this.getRowNumberField();

        if (shouldAdd) this.completeFields.addAt(rnField, rnPos);
        else this.completeFields.slideList([rnField], rnPos);
    } else {
        var rnField = this.getCurrentRowNumberField();
        if (rnField) this.completeFields.remove(rnField);
    }

    // dragHandleField for forcing a drag over a scroll
    if (this.shouldShowDragHandleField()) {
        var dragHandleField = this.getCurrentDragField(),
            shouldAdd = !dragHandleField
        ;
        if (shouldAdd && newFields && newFields.find(this.fieldIdProperty, "_dragHandleField"))
        {
            shouldAdd = false;
        }
        if (shouldAdd) dragHandleField = this.getDragField();

        // avoid adding the drag handle field at position 1 when there's nothing at position 0
        var dragPos = this.getDragFieldPosition();
        if (dragPos > this.completeFields.length) dragPos = this.completeFields.length;

        if (shouldAdd) this.completeFields.addAt(dragHandleField, dragPos);
        else this.completeFields.slideList([dragHandleField], dragPos);
    } else {
        var dragHandleField = this.getCurrentDragField();
        if (dragHandleField) this.completeFields.remove(dragHandleField);
    }
    
    // checkboxField for selection
    if (this.shouldShowCheckboxField()) {
        var cbField = this.getCurrentCheckboxField(),
            cbPos = this.getCheckboxFieldPosition(),
            shouldAdd = !cbField
        ;
        if (shouldAdd && newFields && newFields.find(this.fieldIdProperty, "_checkboxField")) {
            shouldAdd = false;
        }

        if (shouldAdd) cbField = this.getCheckboxField();
        // make checkboxField frozen if we have any other frozen fields - note autoFreeze: true does this now

        // avoid adding the checkbox field at position 1 when there's nothing at position 0
        // (eg, when showingGroupTitleColumn() returns true, but groupBy() hasn't yet been called)
        if (cbPos > this.completeFields.length) cbPos = this.completeFields.length;

        if (shouldAdd) this.completeFields.addAt(cbField, cbPos);
        else this.completeFields.slideList([cbField], cbPos);
    } else {
        var cbField = this.getCurrentCheckboxField();
        if (cbField) this.completeFields.remove(cbField);
    }

    // expansionField for expanding a row
    if (this.shouldShowExpansionField()) {
        var expField = this.getCurrentExpansionField(),
            expPos = this.getExpansionFieldPosition(),
            shouldAdd = !expField
        ;
        if (shouldAdd) expField = this.getExpansionField();
        // make expansionField frozen if we have any frozen fields - note autoFreeze: true does this now

        if (shouldAdd) this.completeFields.addAt(expField, expPos);
        else this.completeFields.slideList([expField], expPos);
    } else {
        var expField = this.getCurrentExpansionField();
        if (expField) this.completeFields.remove(expField);
    }

    // Add / update the removeField if this.canRemoveRecords is true
    if (this.shouldShowRemoveField()) {
        var removeFieldNum = this.completeFields.findIndex("isRemoveField", true),
            removeField = (removeFieldNum >= 0) ? this.completeFields[removeFieldNum]
                                                : {excludeFromState:true, isRemoveField:true};
        if (removeFieldNum == -1 && newFields) {
            removeFieldNum = newFields.findIndex("isRemoveField", true);
        }
        // If we created the removeField and there was no explicit removeField specification,
        // always show the removeField at the end.
        if (removeFieldNum == -1) removeField._showAtEnd = true;


        if (!removeField._removeFieldInitialized) {

            isc.addProperties(removeField, this.removeFieldDefaults, this.removeFieldProperties);
            if (removeField.name == null) removeField.name = "_removeField";
            if (removeField.title == null) removeField.title = this.removeFieldTitle;

            // show removeIcon / unremoveIcon by default.
            // if cellIcon or formatCellValue are explicitly specified on the field
            // don't override those.
            if (removeField.cellIcon == null && removeField.formatCellValue == null) {
                removeField.formatCellValue = function (value, record, rowNum, colNum, grid) {
                    // If this record is explicitly marked to not allow removal show no icon
                    if (grid.recordCanRemoveProperty && record && record[grid.recordCanRemoveProperty] === false) return "&nbsp;";

                    if (!this.removeIconHTML) {
                        this.removeIconHTML = isc.Canvas.imgHTML({
                            src: grid.removeIcon,
                            width: grid.removeIconSize,
                            height: grid.removeIconSize,
                            extraCSSText: "cursor:" + isc.Canvas.POINTER_OR_HAND
                        });
                        this.unremoveIconHTML = isc.Canvas.imgHTML({
                            src: grid.unremoveIcon,
                            width: grid.removeIconSize,
                            height: grid.removeIconSize,
                            extraCSSText: "cursor:" + isc.Canvas.POINTER_OR_HAND
                        });
                    }
                    if (grid.recordMarkedAsRemoved(rowNum)) {
                        return this.unremoveIconHTML;
                    } else {
                        return this.removeIconHTML;
                    }
                };
                // Store out the iconSize - this makes autoFit more efficient
                removeField.iconSize = this.removeIconSize;
            }
            if (removeFieldNum == -1) {             
                this.completeFields.add(removeField);
            }

            removeField._removeFieldInitialized = true;
        } else if (removeField._showAtEnd && removeFieldNum >= 0 && removeFieldNum < this.completeFields.length-1) {
            // removeField already exists but it is no longer at the end of the row.
            // this happens when loading an editable listgrid in VB with defined fields
            // because addField() is called for each field rather than setting them all at once.
            this.completeFields.removeAt(removeFieldNum);
            this.completeFields.add(removeField);
        }
    } else {
        var removeFieldNum = this.completeFields.findIndex("isRemoveField", true);
        if (removeFieldNum >=0) {
            this.completeFields.removeAt(removeFieldNum);
        }
    }

    // If we have headerSpans ensure the order of fields works with the set of spans
    if (this.headerSpans) {

        // header spans can span fields that aren't next to each other in the fields array.
        // If this happens we'll need to render them next to each other for the spans to work of course
        this.reorderFieldsForHeaderSpans();

        this.spanMap = this.buildSpanMap();
    }

    // set field state if necessary
    var fieldStateAlreadySet = false;
    if (this.fieldState != null) {
        this.setFieldState();
        fieldStateAlreadySet = true;
    } else {
        
        this._refreshCompleteFieldsMaps();
    }

    // set group state if necessary
    var groupStateAlreadySet = false;
    if (this.groupState != null) {
        this.setGroupState(this.groupState);
        groupStateAlreadySet = true;
    }

    this._setupFieldWhenRules();

    this.applyDefaultShowIf(this.completeFields);

    // determine which fields should be shown, and add them to the visible fields array
    // (this.fields)
    // Need to derive the visible fields array before calling applyFieldDefaults() because
    // some field defaults depend on whether a field is the last visible non-frozen field.
    // (Note that we already applied defaults that effect visibility in 'applyDefaultShowIf()' above)
    this.deriveVisibleFields();

    // apply various type-based defaults
    this.applyFieldDefaults(this.completeFields);

    this._clearFieldDependencyTable();

    // sets things up to look up display maps when LG is drawn
    
    if (isc.DataSource) this._setOptionDataSources();

    // warn about all fields being hidden.  Note it's valid to have no fields if you've created
    // a grid that will be bound to a DataSource or provided fields later.
    if (this.fields.length == 0 && this.completeFields.length > 0) {
        this.logWarn("All specified fields for this component are hidden. Note that fields " +
                     "may be hidden via 'showIf' or 'detail' attribute values. " +
                     "In order to display data this grid must have some visible fields.");
    }

    // wipe out the cached fieldWidths, if any
    this._fieldWidths = null;

    var newEditColNum, editFieldStillPresent, hadFocus;
    
    if (editorShowing) {
        // make sure we get the latest value of the field being edited
        // (Not relevant if we're not drawn since the user can't have updated)
        this.storeUpdatedEditorValue();

        // assume we should continue editing at the field with the same id
        newEditColNum = this.fields.findIndex(this.fieldIdProperty, oldEditFieldName);
        if (newEditColNum != -1 && !this.canEditCell(editRowNum, newEditColNum))
            newEditColNum = -1;

        // if the field with same id isn't editable, find the next editable cell
        if (newEditColNum == -1) {
            var newEditCell;
            // extra param to suppress checking past this row
            if (!this.editByCell) newEditCell = this.findNextEditCell(editRowNum, 0, 1,
                                                                      true,true, false, true);
            if (newEditCell != null && newEditCell[0] == editRowNum) {
                newEditColNum = newEditCell[1];
            }

            // Kill the edit if we're editing by cell, or can't find another editable field
            // in the edit row.
            if (newEditColNum == -1) {
                this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                editorShowing = false;
            }
        } else {
            // field with the same name present and editable: blur and refocus after redraw
            var item = editForm.getItem(oldEditFieldName);
            if (item) {
                hadFocus = item.hasFocus;
                if (hadFocus) editForm._blurFocusItemWithoutHandler();
            }
            editFieldStillPresent = true;
        }

        // Hide the editor if still editing.
        // Note that this will fire a blur handler unless we have already blurred without
        // the handler
        
        if (editorShowing) this.hideInlineEditor(false, true);
    }

    var autoCanFreeze = (this.canFreezeFields == null || this._autoDerivedCanFreeze) &&
                        this.fixedRecordHeights != false && this.fixedFieldWidths != false &&
                        this.autoFitData != "horizontal" && this.autoFitData != "both" &&
                        this.bodyOverflow != "visible";
    if (autoCanFreeze) {
        if (this.completeFields.getProperty("overflow").contains("visible")) autoCanFreeze = false;
    }
    if (autoCanFreeze) {
        this._autoDerivedCanFreeze = true;
        this.canFreezeFields = true;
    } else if (this._autoDerivedCanFreeze) {
        delete this._autoDerivedCanFreeze;
        this.canFreezeFields = null;
    }
    // if we're working with a cellSelection, it needs to know how many columns are visible
    if (this.canSelectCells && this.selectionManager) this.selectionManager.numCols = this.fields.length;

    // if we are showing the header, rebuild it with the new set of fields
    var showingHeader = this.showHeader && this.headerHeight > 0 && this.header != null;
    if (showingHeader) {
        // this method will actually update the header to match this.fields
        this.updateHeader();
    }

    
    var sortStateAlreadySet = false;

    if (this._pendingSort) {
        
        delete this._pendingSort;
        this.setSort(this.getSort());
        sortStateAlreadySet = true;
    } else if (this.sortState != null) {
        // sortState 
        this.setSortState(this.sortState);
        sortStateAlreadySet = true;
    } else {
        // if we've already been sorted and we *can* sort, resort now
        var sortFieldNum = this._getSortFieldNum();
        if (sortFieldNum != null && this._canSortData(sortFieldNum)) {
            
            this.setSort(this.getSort());
        }
    }


    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow.setFields(this.completeFields.duplicate());
    }

    
    this.updateFieldDependencies();

    // If we added formula / summary fields, run the "recalculateSummaries" method to
    // apply calculated values to the records if necessary.
    this.calculateRecordSummaries(null, null, true, true, false, !recalculateSummaries);
    this.updateBody();

    // If we have a filterEditor, update its fields
    
    if (this.filterEditor) {
         // update the ds on the filterEditor (and the edit-form) - we need a ds to support some
        // expression-parsing features, like "matches other field" detecting fields by title as
        // well as name
        this.filterEditor.updateDataSource(this.getDataSource());
        var completeFields = this.completeFields || [];
        this.filterEditor.setFields(completeFields.duplicate());
    }

    // if we've rebuilt the header, this will place it and draw it.
    // this will also determine new field widths for the new fields (whether from the header or
    // otherwise)
    this.layoutChildren(this._$setFields);

    // sync scroll position of new header with current body scroll position
    if (showingHeader && this.body != null) {
        this.syncHeaderScrolling(this.body.getScrollLeft());
        if (this.frozenFields != null) {
            this.syncHeaderScrolling(this.frozenBody.getScrollLeft(), null, true);
        }
    }

    // Now the fields have been set, update the edit values field:
    // Update our editValues, and validation errors to account for any fields that have
    // gone from the list.
    if (this._editSessions != null) {
        var fieldsDropped = {};

        for (var i in this._editSessions) {
            if (this._editSessions[i] == null) continue;
            var vals = this._editSessions[i]._editValues,
                // We want to hang onto primary key values, even if they're not shown in the
                // ListGrid
                pks = (this.dataSource != null
                    ? this.getDataSource().getPrimaryKeyFieldNames()
                    : [])
            ;

            for (var currentFieldName in vals) {
                
                if (!this.fields.containsProperty(this.fieldIdProperty, currentFieldName) &&
                    !pks.contains(currentFieldName)) {
                    // track which fields were dropped so we can inform the user / developer
                    fieldsDropped[currentFieldName] = true;
                    // clearEditValue will clear the editValue and any validation errors for
                    // the field
                    // Pass the additional 3rd parameter to avoid refreshing the updated cells
                    
                    this.clearEditValue(vals, currentFieldName, true);
                }
            }
        }

        fieldsDropped = isc.getKeys(fieldsDropped);
        if (fieldsDropped.length > 0) {
            this.logInfo("'setFields()' removed the following fields which had pending edit " +
                         "values for some row[s]: '" + fieldsDropped.join("', '") + "'.\n" +
                         "Edit values for these fields have been dropped.", "gridEdit");
        }
    }

    // re-show the editor, with the new set of fields
    if (editorShowing) {
        // if the previous edit field is still showing, just re-show the editor
        // and focus silently if appropriate.
        if (editFieldStillPresent) {
            // 2nd and 3rd parameters are both false - even though this field may be in a
            // new position, it's the same logical field, so we don't want to fire
            // editorEnter()
            this.showInlineEditor(editRowNum, newEditColNum, false, false, true);
            if (hadFocus) editForm._focusInItemWithoutHandler(newEditFieldName);
        } else {
            // If we've killed the previous edit field, but still want to be editing, use
            // _startEditing() to start editing the new cell to ensure editValues get set up
            // if necessary
            this._startEditing(editRowNum, newEditColNum, !hadFocus);
        }

        // Refocus without firing the handler if the old edit field is still around and had
        // focus before the setFields.
        if (hadFocus) {
            var newEditFieldName = this.getEditFieldName();
            if (newEditFieldName == oldEditFieldName) {
                editForm._focusInItemWithoutHandler(newEditFieldName);
            } else {
                editForm.focusInItem(newEditFieldName);
            }
        }
    }

    // Re-run the logic to apply hilites (that method stores information on record and
    // field objects).
    
    if (this.hilites != null) this.applyHilites();

    // Remember the fieldState when setFields is first called.
    // If "setFieldState()" is called with a partial fieldState that doesn't include all fields,
    // behavior varies based on dbc.sparseFieldState:
    // - if true we assume any fields not explicitly included in the fieldState should be hidden
    // - if false we'll reapply the default field state for any fields that are not explicitly 
    //   listed in the new state.
    // That is implemented in DBC.setFieldState
    // _suppressStoreFieldState flag used to ensure 'setFieldState()' doesn't also remember
    // that field state as the default
    
    if (!this._suppressStoreFieldState) this.defaultFieldState = this.getFieldState();

    if (this._scrollCell) this._delayedScrollToCell();
    
    // Set view state if necessary
    if (this.viewState) {
        var viewState = this.viewState;
        // Only do this the very first time through
        this.viewState = null;

        if (fieldStateAlreadySet) {
            // Don't overwrite fieldState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.field;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        if (sortStateAlreadySet) {
            // Don't overwrite sortState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.sort;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        if (this.hiliteState) {
            // Don't overwrite hiliteState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.hilite;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        if (groupStateAlreadySet) {
            // Don't overwrite groupState set earlier
            var state = this.evalViewState(viewState, "viewState");
            if (state) {
                delete state.group;
            }
            viewState = "(" + isc.Comm.serialize(state,false) + ")";
        }
        this.setViewState(viewState);
    }
    this.restorePersistedViewState();


},


_refreshCompleteFieldsMaps : function () {
    var fieldNames = this._completeFieldNamesMap = {},
        dataPaths  = this._completeDataPathsMap  = {},
        fieldIdProperty = this.fieldIdProperty,
        completeFields = this.completeFields;
    for (var i = 0; i < completeFields.length; i++) {
        var field = completeFields[i];
        if (field.dataPath) dataPaths[field.dataPath] = field;
        fieldNames[field[fieldIdProperty]] = field;
    }
},

// fields to copy from the update to updated record in dataChanged() for grouped grid
_getFieldNamesToUpdateForGrouped : function () {
    var ds = this.getDataSource(),
        fieldNames = ds.getFieldNames();
    // client-only DataSource responses will preserve all updated grid fields, so handle that
    
    if (ds.clientOnly || this.updateExtraFields) {
        var dsFieldMap = ds.getFields(),
            allFields = this.getAllFields();
        for (var i = 0; i < allFields.length; i++) {
            var fieldName = allFields[i].name;
            // skip adding duplicate field already in DS
            if (!dsFieldMap.hasOwnProperty(fieldName)) {
                fieldNames.add(fieldName);
            }
        }
    // by default, "real" server DataSources will drop fields not in the DS; skip them
    
    } else {
        fieldNames.addList(this.getCacheableFields().getProperty("name"));
    }
    return fieldNames;
},
    
_delayedScrollToCell : function () {
    if (this._scrollCell != null) {
        var isAnArray = isc.isAn.Array(this._scrollCell),
            scrollRowNum =  isAnArray ? this._scrollCell[0] : this._scrollCell,
            scrollColNum = isAnArray ? this._scrollCell[1] || 0 : 0,
            xPosition = isAnArray ? this._scrollCell[2] : null,
            yPosition = isAnArray ? this._scrollCell[3] : null
        ;
        delete this._scrollCell;
        this.scrollToCell(scrollRowNum, scrollColNum, xPosition, yPosition);

        
        var body = this.body;
        if (body && !body.isDirty() && body._needAxisRedraw() && body.virtualScrolling) {
            this._markBodyForRedraw("redraw for scroll");
        }        
    }
},

// override add/removeField to account for us having 'this.completeFields' which
// dataBoundComponent doesn't expect
addField : function (field, index) {
    return this.Super("addField", [field, index, this.completeFields], arguments);
},
removeField : function (field) {
    return this.Super("removeField", [field, this.completeFields], arguments);
},

// Helper method - should this grid show the special checkbox field for
// selectionAppearance:"checkbox". TreeGrid's show the checkbox in the
// special tree field so we don't show this field.
_$checkbox:"checkbox",
shouldShowCheckboxField : function () {
    if (this.fieldSourceGrid) return this.fieldSourceGrid.shouldShowCheckboxField();
    return (this.selectionAppearance == this._$checkbox &&
        this.selectionType != this._$none &&
        !isc.isA.TreeGrid(this));
},

//> @method listGrid.focusInFilterEditor()
// If the filter editor (+link{listGrid.showFilterEditor}) is visible for this grid,
// this method will explicitly put focus into the specified field in the filter editor.
// @group filterEditor
// @visibility external
// @param [fieldName] (String) Name of the field to put focus into. If unspecified focus will go
//                             to the first field in the editor
//<
focusInFilterEditor : function (fieldName) {
    if (this.filterEditor == null) return;
    var fieldNum = fieldName != null ? this.getColNum(fieldName) : null;
    this.filterEditor.startEditing(0, fieldNum);
},

//> @method listGrid.filterByEditor()
// If the filter editor (+link{listGrid.showFilterEditor}) is visible for this grid,
// this method will perform a filter based on the current values in the editor.
// @group filterEditor
// @visibility external
//<
filterByEditor : function () {
    if (this.filterEditor != null) this.filterEditor.performAction();
},


// Override bindToDataSource. Unlike other data-bound widgets if this.showDetailFields is true
// we want to default our detailFields to be hidden (but accessible via the headerContextMenu)
// Note: We do this at init (setFields) time by setting the showIf property on the field,
// rather than overriding fieldShouldBeVisible() to return false for detail fields, so that
// when showField() is called on the field, that method can return true and allow the field
// to show.
bindToDataSource : function (fields, componentIsDetail, a,b,c,d) {
    var numericFieldName = false;

    var completeFields = this.invokeSuper(isc.ListGrid, "bindToDataSource",
                                          fields, componentIsDetail, a,b,c,d);
    
    if (completeFields != null) {
        for (var i = 0; i < completeFields.length; i++) {
            var field = completeFields[i];

            if (field.showIf == null && field.hidden == null && field.detail == true) {
                field.hidden = true;
            }
            if (this.showDetailFields) {
                
                if (this._isNumberOrArrayProp(field.name)) {
                    numericFieldName = true;
                }
                if (this._isFieldObject(field)) {
                    field._isFieldObject = true;
                }
            }
            
            var validators = this.getFieldEditorValidators(field);
            if (validators) field.validators = (field.validators || []).addList(validators);
        }
    }
    this._noNumericFields = !numericFieldName;
    return completeFields;
},

// should we apply the "_isFieldObject" marker to this field object?
// this is used by the column picker submenu to identify "true fields" as opposed to auto-generated 
// columns such as the removeField

_isFieldObject : function (field) {
    if (field == null) return false;
    return (!field.isRemoveField && !field._isRowNumberField && 
            !field._isExpansionField && !field._isCheckboxField);
    
},

// Check whether a field name is a number
// *and* whether it's some property present on the fields array such as "size", etc
_$emptyArr:[],
_isNumberOrArrayProp : function (name) {
    if (this._$emptyArr[name] != null) return true;
    if (isc.isA.Number(parseInt(name)) &&
        parseInt(name).toString() == name) return true;
    return false;
},

// Field State
// --------------------------------------------------------------------------------------------
// The fieldState is an object capturing presentation information about the fields -
// expected to be used as a way for developers to save the current presentation (EG in cookies)
// and re-load that presentation when the page is reloaded.
// fieldState is an opaque format.



//> @type ListGridFieldState
// An object containing the stored presentation information for the fields of a listGrid.
// Information contained in a <code>ListGridFieldState</code> object includes the
// visibility and widths of the listGrid's fields.<br>
// Note that this object is a JavaScript string, and may be stored (for example) as a blob
// on the server for state persistence across sessions.
//
// @baseType String
// @group viewState
// @visibility external
//<

//> @attr listGrid.fieldState (ListGridFieldState : null : IRW)
// Initial +link{ListGridFieldState, field state} for the grid.
// <p>
// +link{viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>fieldState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>fieldState</code> has priority for
// field state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getFieldState,getFieldState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//> @method listGrid.getFieldState()
// Returns a snapshot of the current presentation of this listGrid's fields as
// a +link{type:ListGridFieldState} object.
// <P>
// This object can later be passed to +link{listGrid.setFieldState()} to reset this grid's
// fields to the current state.
// <P>
// Note that the information stored includes the current width and visibility of each of this
// grid's fields, as well as any +link{listGrid.canAddFormulaFields,formula} or
// +link{listGrid.canAddSummaryFields,summary fields} added by the user.
// <P>
// The optional <code>sparse</code> parameter governs whether the returned field state
// should omit state information for hidden fields. If this parameter is not passed
// explicitly, field state will be sparse if +link{dataBoundComponent.sparseFieldState}
// is true.<br>
// When applying sparse field state to a component via +link{setFieldState()}, any 
// explicitly defined fields on the component that were not captured in the stored
// state object will be hidden.
//
// @param [sparse] (Boolean) If true, field state will be ommitted for hidden fields.
// @group viewState
// @see listGrid.setFieldState();
// @visibility external
// @return (ListGridFieldState) current state of this grid's fields.
//<
// LG.getFieldState() moved up to DBC

//> @method listGrid.setFieldState()
// Sets some presentation properties (visibility, width, userFormula and userSummary) of the
// listGrid fields based on the +link{type:ListGridFieldState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to +link{listGrid.getFieldState()}.
// <P>
// The optional <code>isSparse</code> parameter may be passed to indicate
// whether the fieldState object is "sparse" - whether it includes explicit
// state information for hidden fields. In this case any fields defined on the component
// not explicitly included in the fieldState object will be hidden.<br>
// If <code>isSparse</code> is not explicitly passed as a parameter, 
// sparseness will be assumed if +link{dataBoundComponent.sparseFieldState}
// is true.
//
// @group viewState
// @param fieldState (ListGridFieldState) state to apply to the listGrid's fields.
// @param [isSparse] (Boolean) If true, the fieldState passed in is assumed to be "sparse". 
//  Any fields defined on this component without explicit field state values will be
//  hidden.
// @visibility external
// @see listGrid.getFieldState()
//<
setFieldState : function (fieldState, isSparse) {

    if (isSparse == null) isSparse = this.sparseFieldState;

    //!OBFUSCATEOK
    if (this.completeFields == null) this.setFields(this.fields);

    // For a grid initialized with this.fieldState(), we will run setFieldState with no params
    // from within our initial setFields().
    
    if (fieldState == null && this.fieldState != null) {
        if (isc.isA.String(this.fieldState)) {
            fieldState = this.evalViewState(this.fieldState, "fieldState");
        } else {
            fieldState = this.fieldState;
        }
        this.completeFields = this._setFieldState(fieldState, null, isSparse);

        // fieldState is init-only property, so null after use
        this.fieldState = null;

    } else {
        fieldState = this.evalViewState(fieldState, "fieldState");
        if (fieldState) {
            this.completeFields = this._setFieldState(fieldState, null, isSparse);
            this.refreshFields();
        }
    }

    this._refreshCompleteFieldsMaps();
},


handleFieldStateChanged : function (preserveSelection) {
    // ignoreStateChangeHandlers is set in setViewState(), eg, and is used to prevent
    // the various public state-changed notifications from firing during internal work
    if (!this.ignoreStateChangeHandlers) this.fieldStateChanged();
    this.handleViewStateChanged();
    if (this.canSelectCells && !preserveSelection) {
        this.selectionManager.deselectAll();
        if (this.fields && this.fields.length != this.selectionManager.numCols) {
            this.selectionManager.numCols = this.fields.length;
        }
    }
    if (isc.Canvas.ariaEnabled && this.updateAriaForFieldsChanged) {
        this.updateAriaForFieldsChanged();
    }
},

// fieldStateChanged implemented in DBC

// Override setHilites to fire the viewStateChanged notification
setHilites : function () {
    this.Super("setHilites", arguments);
    this.handleViewStateChanged();
},

// Override _handleHilitesChanged to fire the hilitesChanged notification.
_handleHilitesChanged : function (hilites) {
    this.Super("_handleHilitesChanged", arguments);
    if (isc.isA.Function(this.hilitesChanged)) this.hilitesChanged();
},

// Override redrawHilites to redraw the body rather than the entire grid.
redrawHilites : function () {
    this._markBodyForRedraw("redrawHilites");
},


// ---------------------------------------------------------------------------------------

//> @type SelectionAppearance
// How data selection should be presented to the user.
// @value "rowStyle" selected rows should be shown with different appearance - see
//                   +link{ListGrid.getCellStyle()} and optionally
//                   +link{ListGrid.selectionCanvas}.
// @value "checkbox" an extra, non-data column should be automatically added to the ListGrid,
//                   showing checkboxes that can be toggled to select rows.
//                   See +link{listGrid.getCheckboxField()}.
// @visibility external
//<

// defaults for checkbox field
checkboxFieldDefaults: {
    name: "_checkboxField",
    excludeFromState:true,
    selectCellTextOnClick:false,
    canEdit: false,
    shouldPrint:false,
    // Note we could probably allow filtering by this field for client-side grids - which would
    // allow you to view all selected / unselected rows easily, (nice feature) but it wouldn't
    // work for databound grids
    canFilter:false,
    canGroupBy: false,
    canSort: false,
    canExport: false,
    canHide: false,
    canReorder: false,
    canDragResize: false,
    // make this special field canHilite false so we don't see it in HiliteEditors by default
    canHilite: false,
    _isCheckboxField: true,
    type:"boolean",
    showDefaultContextMenu: false,
    hoverHTML: "return null;", // suppress hover at row level, only hovering for header
    autoFreeze: true,
    showGridSummary: false,
    showGroupSummary: false,
    summaryValue: "&nbsp;",
    // specifically disable filterOperators for this builtin field
    allowFilterOperators: false,
    // disable this from ever being assigned as the treeField
    treeField:false,
    title: isc.nbsp,
    // flag that means this is a special builtin field, not for formulas/export/etc
    featureField: true
},

//> @method listGrid.getCheckboxField()
// Returns the specially generated checkbox field used when +link{selectionAppearance} is
// "checkbox".
// <P>
// Called during +link{setFields()}, this method can be overridden to add advanced dynamic
// defaults to the checkbox field (call Super, modify the default field returned by Super,
// return the modified field).  Normal customization can be handled by just setting
// +link{AutoChild} properties, as mentioned under the docs for +link{listGrid.checkboxField}.
//
// @return (ListGridField)
// @group checkboxField
// @visibility external
//<
getCheckboxField : function () {
    var grid = this,
        cbField = {
        // default the width to the width of the icon plus an arbitrary buffer
            width:this.checkboxFieldHSpace + this._getCheckboxFieldImageWidth(),
            getAutoFreezePosition: function () { return grid.getCheckboxFieldPosition() }
        }
    ;
    isc.addProperties(cbField, this.checkboxFieldDefaults, this.checkboxFieldProperties);

    cbField.title = (this.canSelectAll == false || this.selectionType == "single" ? isc.nbsp :
        this._getCheckboxValueIconHTML(false, false, true, false, cbField));

    return cbField;
},

//> @attr listGrid.checkboxFieldHSpace (int : 15 : IR)
// How much horizontal space should the +link{getCheckboxField(),checkbox field} leave
// around the checkbox icon when +link{listGrid.selectionAppearance} is set to
// <code>"checkbox"</code>?
// <P>
// The automatically generated checkbox field will be sized to the width of the
// checkbox icon (specified via +link{listGrid.checkboxFieldImageWidth} or
// +link{listGrid.booleanImageWidth}) plus this value.
// @group checkboxField
// @visibility external
//<
checkboxFieldHSpace:15,

getCurrentCheckboxField : function () {
    var fields = this.completeFields || this.fields;
    if (!fields) return null;
    var cbFields = fields.find(this.fieldIdProperty, "_checkboxField");
    return !cbFields ? null : isc.isAn.Array(cbFields) ? cbFields[0] : cbFields;
},

_getCheckboxFieldImageWidth : function () {
    return this.checkboxFieldImageWidth || this.booleanImageWidth ||
            (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null);
},
_getCheckboxFieldImageHeight : function () {
    return this.checkboxFieldImageHeight || this.booleanImageHeight ||
            (isc.CheckboxItem ? isc.CheckboxItem.getInstanceProperty("valueIconWidth") : null);
},

//> @method listGrid.isCheckboxField()
// Identifies whether the passed-in field is the specially generated
// +link{listGrid.checkboxField,checkboxField} used when +link{selectionAppearance} is
// "checkbox".  Use this method in your custom event handlers to avoid inappropriately
// performing actions when the checkboxField is clicked on.
//
// @param field (ListGridField) field to test
// @return (Boolean) whether the provided field is the checkbox field
// @group checkboxField
// @visibility external
//<
isCheckboxField : function (field) {
    if (!field || !field._isCheckboxField) return false;
    else return true;
},

// helper function to get the checkbox field position
// This is a special field which appears "stuck to" the left edge of the grid.
// We have a few other special fields:
// - rowNumbers column
// - groupTitle column when showing group summaries in header
// - record expansion icon column
getCheckboxFieldPosition : function () {
    if (this.fieldSourceGrid) return this.fieldSourceGrid.getCheckboxFieldPosition();
    if (this.selectionAppearance != "checkbox" || isc.isA.TreeGrid(this)) return -1;
    
    var pos = 0;
    if (this.shouldShowRowNumberField())  pos++;
    if (this.shouldShowDragHandleField()) pos++;
    return pos;
},


//>
// @attr listGrid.saveDefaultSearch (boolean : true : IR)
// - saves the name of the default search to localStorage, under the key "sc_defaultSearch:" + minimal
//   locator
// - see SavedSearches "Default Searches" for why this is stored separately from the search itself
// - if there is no saved default search, but there is a +link{SavedSearchesdefaultField}, the first
//   user-specfic search marked default will be used, otherwise the first admn search marked default
// - if autoFetchData is enabled, the autoFetch will be postponed as needed until a default search can be
//   looked up and applied.  If anything fails in the default search lookup, an autoFetch will still be
//   performed (without any saved search information)
//<
saveDefaultSearch: true,

//> @type ListGridSelectedState
// An object containing the stored selection information for a listGrid.
// Note that this object is not intended to be interrogated directly, but may be stored
// (for example) as a blob on the server for state persistence across sessions.
//
// @baseType String
// @group viewState
// @visibility external
//<
// ListGridSelectedState object is implemented as an array of primaryKeys indicating the
// selected set of records.

//> @attr listGrid.selectedState (ListGridSelectedState: null : IRW)
// Returns a snapshot of the current selection within this listGrid as
// a +link{type:ListGridSelectedState} object.<br>
// This object can be passed to +link{listGrid.setSelectedState()} to reset this grid's selection
// the current state (assuming the same data is present in the grid).<br>
// @group viewState
// @visibility external
//<

//> @method listGrid.getSelectedState()
// For components bound to a +link{listGrid.dataSource, dataSource} with records identified by 
// unique +link{DataSourceField.primaryKey, primaryKeys}, this method returns a snapshot of 
// the component's current selection, as a +link{type:ListGridSelectedState} object.<br>
// This object can be passed to +link{listGrid.setSelectedState()} to reset this grid's current
// selection state (assuming the same data is present in the grid).<br>
// Selected state is not supported if the component has no dataSource, or the dataSource has no
// primaryKey fields.
// @group viewState
// @see listGrid.setSelectedState();
// @visibility external
// @return (ListGridSelectedState) current state of this grid's selection
//<
getSelectedState : function (supressWarnings, returnObject) {
    if (!this.selectionManager) return null;
    if (!this.dataSource ||
        isc.isAn.emptyObject(this.getDataSource().getPrimaryKeyFields()))
    {
        if (!supressWarnings) {
            
            this.logWarn("can't getSelectedState without a DataSource " +
                         "with a primary key field set");
        }
        return null;
    }

    var selectedState = [];
    if (this.canSelectCells) {
        var selection = this.selectionManager.getSelectedCells();

        // store primary keys and cell-range.  Works only with a DataSource
        for (var i = 0; i < selection.length; i++) {
            var cell = selection[i],
                PKs = this.getPrimaryKeys(cell[0],cell[1]),
                entry = null
            ;

            for (var k=0; k<selectedState.length; k++) {
                if (this.objectsAreEqual(PKs, selectedState[k].PKs)) {
                    entry = selectedState[k];
                    break;
                }
            }
            if (!entry) {
                selectedState.add({ PKs: PKs, cells: [] });
                entry = selectedState[selectedState.length-1];
            }
            // If we're not using cellRecords (cellRecordMode is "row"),
            // remember the fields so we can re-select the appropriate cells within
            // the row
            if (this.selectionManager.cellRecordMode == "row") {
                entry.cells.add(this.getFieldName(cell[1]))
            }
        }
    } else {
        
        var selection = this.getSelection();

        // store primary keys only.  Works only with a DataSource
        var selectionLength = selection.length;
        for (var i = 0; i < selectionLength; ++i) {
            selectedState[i] = this.getPrimaryKeys(selection[i]);
        }
    }

    // returnObject is undocumented and passed when called from getViewState() - return the 
    // object to avoid double escaping
    if (returnObject) return selectedState;

    return isc.Comm.serialize(selectedState,false);
},


//> @method listGrid.getCellSelection()
// When +link{canSelectCells} is active, returns the +link{CellSelection} object that tracks
// and manages the current selection.  Returns null if +link{canSelectCells} is false.
// @return (CellSelection) current cellSelection
// @visibility external
//<
getCellSelection : function () {
    if (!this.canSelectCells) return null;
    return this.getSelectionObject();
},

//> @method listGrid.setSelectedState()
// Reset this grid's selection to match the +link{type:ListGridSelectedState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getSelectedState()}.
//
// @group viewState
// @param selectedState (ListGridSelectedState) Object describing the desired selection state of
//                                              the grid
// @see listGrid.getSelectedState()
// @visibility external
//<
setSelectedState : function (selectedState, forceRuleScopeUpdate) {    
    // If we have no selectionManager, or no data, or we're not associated with
    // a data-source, setSelectedState is invalid

    if (!this.dataSource ||
        isc.isAn.emptyObject(this.getDataSource().getPrimaryKeyFields()))
    {
        return;
    }

    var selection = this.selectionManager;
    if (selection == null) {
        return; 
    }

    var data = this.originalData || this.data;

    // ignore calls at an invalid time (data still loading or cache just invalidated)
    if (isc.ResultSet && isc.isA.ResultSet(data) && !data.lengthIsKnown()) return;


    selectedState = this.evalViewState(selectedState, "selectedState")

    var anySelected = this.anySelected();

    // If the new state is empty, simply deselect all
    if (!selectedState || selectedState.length == 0) {
        // Nothing to do if we currently have no selection
        if (anySelected) {
            selection.deselectAll();
            this.fireSelectionUpdated();
        } else if (forceRuleScopeUpdate) {
            this._updateRuleScope();
        }
        return;
    }
    

    var usingCellRecords = false;

    if (this.canSelectCells) {
        // We expect to have recorded PKs and cells [separate objects]
        if (!selectedState[0].PKs) {
            if (anySelected) {
                if (this.selectionManager) this.selectionManager.deselectAll();
                this.fireSelectionUpdated();
            }
            this.logWarn("setSelectedState(): Format of selected state is inapplicable to a " +
                "ListGrid with canSelectCells: true.");
            return;
        }

        // One record per row - pick up the column from the state object
        if (selection.cellRecordMode != "cell") {
            if (selectedState[0].cells == null) {
                this.logWarn("setSelectedState(): selected state is lacking column coordinates. " +
                    "First column will be marked as selected for each row");
            }
        } else {
            usingCellRecords = true;
        }
    // canSelectCells:false - don't expect the "PKs" sub object we remember for
    // cell-selections
    } else if (selectedState[0].PKs) {
        this.logWarn("Cannot restore CellSelection state to a " +
        "ListGrid with canSelectCells: false.");
        if (anySelected) {
            if (this.selectionManager) this.selectionManager.deselectAll();
            this.fireSelectionUpdated();
        }
        return;
    }

    var currentSelection = selection.getSelection(),
        records = [],
        
        hasChanges = currentSelection.length != selectedState.length;

    for (var i = 0; i < selectedState.length; i++) {
        var item = selectedState[i];
        // Invalid entry?
        if (!isc.isAn.Object(item)) continue;

        // resultSet.indexOf() looks up by matching PK values
        var PKs = this.canSelectCells ? item.PKs : item,
            index = data.findByKeys(PKs, this.getDataSource());
        
        // record may have been removed
        if (index == -1) {
            hasChanges = true;
        } else {
            // Move from primary keys to actual record object in data
            var record = data.get(index);

            // cell records: index of record in data set is unrelated to row/col coords
            if (usingCellRecords) {

                // If the record isn't currently selected, this state will change selection
                if (!hasChanges) hasChanges = currentSelection.find(PKs) == null;
                var cell = this.getCellCoordinates(record);
                if (cell == null || cell[0] == -1) {
                    hasChanges = true;
                } else {
                    records.add(cell);
                }

            } else {
                // canSelect cells: The entry may contain several columns that are 
                // selected for some row.
                // We'll reformat this into multiple cell coord identifiers (2 element array)
                // in the "records" array
                if (this.canSelectCells) {
                    // item.cells contains the field(s) that are selected for this record
                    
                    var cells = [];
                    // Convert from field name to colNum
                    for (var k = 0; k < item.cells.length; k++) {
                        var colNum = this.getColNum(item.cells[k]);
                        if (colNum == -1) {
                            hasChanges = true;
                        } else {
                            cells.add(colNum)
                        }
                    }
                    // To determine whether selection changed, loop through all the fields 
                    // comparing current selected state with new selected state
                    if (cells.length > 0) {
                        var record = data.get(index);
                        for (var colNum=0; colNum<this.fields.length; colNum++) {
                            var shouldSelectIndex = cells.contains(colNum);
                            if (!hasChanges) {
                                
                                var isSelected = selection.cellIsSelected(record,colNum);
                                if (shouldSelectIndex != isSelected) hasChanges = true;
                            }
                            if (shouldSelectIndex) {
                                records.add([index, colNum]);
                            }
                        }
                    }
                } else {
                    var record = data.get(index);
                    hasChanges = hasChanges || !currentSelection.contains(record);
                    records.add(data.get(index));
                }
            }
        }
    }
    if (hasChanges) {
        selection.deselectAll();

        if (this.canSelectCells) {
            this.selectionManager.selectCellList(records);
        } else {
            this.selectionManager.selectList(records);
        }
        this.fireSelectionUpdated();
    } else if (forceRuleScopeUpdate) {
        this._updateRuleScope();
    }
},

//> @type ListGridSortState
// An object containing the stored sort information for a listGrid.
// Note that this object is not intended to be interrogated directly, but may be stored
// (for example) as a blob on the server for state persistence across sessions.
//
// @baseType String
// @group viewState
// @visibility external
//<
// ListGridSortState object is implemented as a simple JS object containing fieldName and sortDir
// attributes - also now supports the multiSorting subsystem by storing the grid's list of
// sortSpecifiers

//> @attr listGrid.sortState (ListGridSortState: null : IRW)
// Initial sort state for the grid.
// <P>
// +link{listGrid.viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>sortState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>sortState</code> has priority for
// sort state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getSortState,getSortState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//> @method listGrid.getSortState()
// Returns a snapshot of the current sort state within this listGrid as
// a +link{type:ListGridSortState} object.<br>
// This object can be passed to +link{listGrid.setSortState()} to reset this grid's sort to
// the current state (assuming the same fields are present in the grid).<br>
// @group viewState
// @see listGrid.setSortState();
// @visibility external
// @return (ListGridSortState) current sort state for the grid.
//<
getSortState : function (returnObject) {

    if (this.logIsDebugEnabled("sorting")) {
        this.logInfo("\n"+
            "grid.sortFieldNum is: "+this.sortFieldNum+"\n"+
            "grid.sortField is: "+this.sortField+"\n"+
            "grid.getField(grid.sortFieldNum) is:\n"+
                isc.echoAll(this.getField(this.sortFieldNum))+"\n"+
            "-----------------------------------------\n"+
            "grid._getSortFieldNum() is: "+this._getSortFieldNum()+"\n"+
            "grid.getField(grid._getSortFieldNum()) is:\n"+
                isc.echoAll(this.getField(this._getSortFieldNum()))+"\n"+
            "", "sorting"
        )
    }

    var sortFieldNum = this._getSortFieldNum();

    if (sortFieldNum != null || (this._sortSpecifiers && this._sortSpecifiers.length > 0)) {
        var sortField = (sortFieldNum != null ? this.getField(sortFieldNum) : null),
            sortFieldName = sortField != null ? this.getFieldName(sortField) : null,
            sortDir = this._getFieldSortDirection(sortField),
            sortState = {}
        ;
        if (this._sortSpecifiers) {
            var specifiers = isc.shallowClone(this._sortSpecifiers);
            // remove some props added during sorting - keeps the output neat and they'll be
            // re-applied on setSort()
            specifiers.clearProperty("primarySort");
            specifiers.clearProperty("sortIndex");
            specifiers.clearProperty("normalizer");
            specifiers.clearProperty("context");
            specifiers.clearProperty("_comparator");
            sortState.sortSpecifiers = specifiers;
        } else {
            sortState.fieldName = sortFieldName;
            sortState.sortDir = sortDir;
        }
        
        // returnObject is undocumented and passed when called from getViewState() - return the 
        // object to avoid double escaping
        if (returnObject) return sortState;

        // eval() of a string containing object literal text will js error - enclose in "(" ... ")" to
        // avoid this.
        return "(" + isc.Comm.serialize(sortState,false) + ")";
    }
    // return an empty array, which we can detect as non-null and write out a token
    if (returnObject) return [];
},


//> @method listGrid.setSortState()
// Reset this grid's sort state (sort field and direction or list of
// +link{sortSpecifier}s) to match the
// +link{type:ListGridSortState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getSortState()}.
//
// @param sortState (ListGridSortState) Object describing the desired sort state for the grid.
// @group viewState
// @see listGrid.getSortState()
// @visibility external
//<
setSortState : function (state) {
    state = this.evalViewState(state, "sortState")
    if (!state) {
        if (this.getSort()) this.clearSort();
        return;
    }

    if (state.sortSpecifiers) {
        // all non-legacy state - single specifier or multisort
        this.setSort(isc.shallowClone(state.sortSpecifiers));
    } else if (state.fieldName == null) {
        // no specifiers and no fieldName - never happens - clear the sort
        this.clearSort();
    } else {
        // will only get here now if the user has legacy state or creates their own state
        // object which doesn't include sortSpecifiers - a sortSpecifier will be created
        // anyway and further calls to getSortState() will include it
        var fieldNum = this.getFieldNum(state.fieldName)
        if (fieldNum != -1) this.sort(fieldNum, state.sortDir);
    }
},

//> @type ListGridViewState
// An object containing the "view state" information for a listGrid.
// <P>
// This object contains state information reflecting the following states in the grid:
// <ul>
// <li>+link{type:ListGridFieldState,field state}</li>
// <li>+link{type:ListGridSortState,sort state}</li>
// <li>+link{type:ListGridSelectedState,selected state}</li>
// <li>+link{type:ListGridGroupState,group state}</li>
// <li>+link{type:ListGridUserCriteriaState,criteria state}</li>
// <li>hilite state</li>
// <li>filterEditor visibility state</li>
// </ul>
// Note that this object is a JavaScript string, and may be stored (for example) as a blob
// on the server for state persistence across sessions.
//
// @baseType String
// @group viewState
// @visibility external
//<
// ListGridViewState object is implemented as a simple JS object containing the following
// fields:
// - selected [a ListGridSelectedState object]
// - field [a ListGridFieldState object]
// - sort [a ListGridSortState object]
// - group [a ListGridGroupState object]
// - hilite [a string]
// - filterEditor visibility [a boolean/string]
// - userCriteria [a ListGridUserCriteriaState object]

//> @attr listGrid.saveCriteriaInViewState (Boolean : true : IRW)
// Should the current +link{listGrid.getFilterEditorCriteria, filter-criteria} be included 
// along with other details when saving this grid's +link{listGrid.viewState, view-state}?
// <P>
// If true, the current criteria will be saved when calling +link{getViewState()} and will
// be applied to the grid via a filter when calling +link{setViewState()}.
// <P>
// Notes
// <ul>
// <li>If this grid has never actually fetched data, criteria will not be included
// <li>If this flag is set to <code>false</code>, +link{setViewState()} will not
//      modify the grid's filter even if criteria were included when viewState was stored.</li>
// </ul>
//
// @group viewState
// @see ListGrid.getUserCriteriaState()
// @see ListGrid.setUserCriteriaState()
// @visibility external
//<
saveCriteriaInViewState: true,

//> @attr listGrid.minimalViewState (Boolean : false : IRW)
// When true, causes a call to +link{ListGrid.getViewState, getViewState()} to return  
// minimal configuration, especially changes made by the user.  This mode has numerous
// limitations, particularly if you have a number of saved <code>viewState</code>s
// for the same runtime grid-instance.
// <P>
// When set to false, the default, <code>getViewState</code> returns more complete 
// configuration, necessary to reproduce the current view.  Such viewState will always 
// include information about +link{listGrid.getUserCriteriaState, filter-criteria}, 
// +link{listGrid.getSortState, sort} and +link{listGrid.getGroupState, group} -state 
// - if the grid is unfiltered, unsorted or ungrouped, 
// special tokens are included, which ensure the grid is returned to the same state
// later, when the viewState is reloaded.
// @group viewState
// @see ListGrid.getViewState()
// @see ListGrid.setViewState()
// @visibility internal
//<
//minimalViewState: null,

//> @method listGrid.getViewState()
// Returns a snapshot of the current view state of this ListGrid.<br>
// This includes the field, sort, hilite, group, and selected state of the grid, its criteria
// and, when canShowFIlterEditor is true, whether the filter-editor is visible, returned as a 
// string representation of a +link{type:ListGridViewState} object.<br>
// This string can be stored over page-reloads (for example, in +link{Offline.put,browser local storage} or
// as field value in a record stored to a +link{DataSource}) and then reapplied to the grid
// via +link{listGrid.setViewState()} later to reset the grid to 
// to the current state (assuming the same data / fields are present).
// <P>
// To detect when view state changes, developers may use the +link{listGrid.viewStateChanged(),
// viewStateChanged event}.
// <P>
// Note that the +link{autoPersistViewState} feature will automatically persist the view state
// to Offline storage and reapply when the grid is reloaded, without the need to invoke this
// method explicitly.
//
// @group viewState
// @see type:ListGridViewState
// @see listGrid.setViewState();
// @visibility external
// @return (ListGridViewState) current view state for the grid.
//<
// The undocumented 'returnObject' parameter is for internal use only - it allows 
// overrides to this method to call Super and then add to / manipulate the object before
// serializing and returning it.
getViewState : function (returnObject) {

    
    var state = { },
        selected = this.getSelectedState(true, true),
        field = this.getFieldStateAsObject(),
        sort = this.getSortState(true),
        hilite = this.getHiliteStateAsObject(true),
        group = this.getGroupState(true),
        saveUserCriteria = this.saveCriteriaInViewState && this.hasFilteredData(),
        userCriteria =  saveUserCriteria  && this.getUserCriteriaState(true),
        filterEditor = this._canShowFilterEditor(),
        attrCount = 0
    ;

    if (selected && selected != "") { attrCount++; state.selected = selected; }
    if (field && field != "") { attrCount++; state.field = field; }

    // if !minimalViewState, always write sort - [No Sorting] will call clearSort() on reload
    if (!sort || isc.isAn.emptyArray(sort)) sort = "[No Sorting]";
    if (sort != "[No Sorting]" || !this.minimalViewState) {
        attrCount++; 
        state.sort = sort;
    }
    // if !minimalViewState, always write hilite - [No Hilites] will clear hilites on reload
    if (!hilite || hilite == "") hilite = "[No Hilites]";
    if (hilite != "[No Hilites]" || !this.minimalViewState) {
        attrCount++; 
        state.hilite = hilite; 
    }

    // if !minimalViewState, always write group - [No Grouping] will clear grouping on reload
    if (!group || group == "") group = "[No Grouping]";
    if (group != "[No Grouping]" || !this.minimalViewState) {
        attrCount++; 
        state.group = group; 
    }

    // filterEditor-visibility and criteria
    if (filterEditor != null) { attrCount++; state.showFilterEditor = !!this.showFilterEditor; }
    if (saveUserCriteria) {
        // always write criteria - [No Criteria] will clear existing criteria on reload
        if (!userCriteria || isc.isAn.emptyObject(userCriteria)) userCriteria = "[No Criteria]";
        state.userCriteria = userCriteria;
    }

    if (attrCount > 0) {
        // Available so TG can call Super() and get an object back
        if (returnObject) return state;
        return "(" + isc.Comm.serialize(state,false) + ")";
    }
},

// Is this grid showing a data set derived from a run through fetchData, filterEditor submit, etc?
// Used to determine whether we should save criteria in view state / enable saving searches, etc.
hasFilteredData : function () {
    var data = this.getOriginalData();
    // componentId is set up by DBC.createDataModel
    return data != null && ((isc.ResultSet && isc.isA.ResultSet(data)) ||
                            (isc.ResultTree && isc.isA.ResultTree(data)) ) && (data.componentId == this.ID);
},

//> @type ListGridUserCriteriaState
// An object containing the stored criteria as applied by the user.  Does not include criteria
// applied in other ways.
//
// @baseType String
// @group viewState
// @visibility external
//<

//> @attr listGrid.userCriteriaState (ListGridUserCriteriaState: null : IRW)
// Initial user-criteria state for the grid.
// <P>
// +link{listGrid.viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>userCriteriaState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>userCriteriaState</code> has priority for
// user-criteria state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getGroupState,getUserCriteriaState}.
// </smartclient>
//
// @group viewState
// @visibility internal
//<

//> @method listGrid.getUserCriteriaState()
// Returns a snapshot of the current user-provided criteria for this ListGrid.
// <P>
// This object can be passed to +link{listGrid.setUserCriteriaState()} to reset this grid's 
// user-criteria to the current state.
// @group viewState
// @see type:ListGridUserCriteriaState
// @see listGrid.setUserCriteriaState();
// @visibility external
// @return (ListGridUserCriteriaState) current criteria state for the grid.
//<
getUserCriteriaState : function (returnObject) {
    var filterEditorCriteria = this.getFilterEditorCriteria(),
        filterWindowCriteria = this.getFilterWindowCriteria();

    if (isc.isAn.emptyObject(filterEditorCriteria)) filterEditorCriteria = null;
    if (isc.isAn.emptyObject(filterWindowCriteria)) filterWindowCriteria = null;
    
    if (filterWindowCriteria == null && filterEditorCriteria == null) return "";

    // state-shorthand - remove the operator from any criterions that use "equals", to reduce
    // clutter - it gets reintroduced by expandEqualsCriteria() when the state is reapplied
    if (filterEditorCriteria) isc.DataSource.collapseEqualsCriteria(filterEditorCriteria);
    if (filterWindowCriteria) isc.DataSource.collapseEqualsCriteria(filterWindowCriteria);

    var result;
    if (filterWindowCriteria != null) {
        var composite = {
            composite:true,
            filterWindowCriteria:filterWindowCriteria
        };
        if (filterEditorCriteria != null) {
            composite.filterEditorCriteria = filterEditorCriteria;
        }
        result = composite;
    } else {
        result = filterEditorCriteria;
    }

    // returnObject is undocumented and passed when called from getViewState() - return the 
    // object to avoid double escaping
    if (returnObject) return result;

    // eval() of a string containing object literal text will js error - enclose in "(" ... ")" 
    // to avoid this.
    return "(" + isc.Comm.serialize(result,false) + ")";
},

//> @method listGrid.setUserCriteriaState()
// Reset this grid's user-criteria to match the +link{type:ListGridUserCriteriaState} object 
// passed in.
// <P>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getUserCriteriaState()}.
// @group viewState
// @param userCriteriaState (ListGridUserCriteriaState) Object describing the desired criteria
// @see listGrid.getUserCriteriaState()
// @visibility external
//<
setUserCriteriaState : function (state) {

    var criteria = state;

    if (criteria) {
        if (isc.isA.String(criteria)) {
            criteria = this.evalViewState(criteria, "userCriteriaState")
        }
    } else {
        criteria = null;
    }
    // Note: If there were no filterWindowCriteria we record a simple
    // criterion object.
    // Otherwise we record an object of the format
    // { composite:true, filterWindowCriteria:<...>, filterEditorCriteria:<...> }
    // Handle being passed either format
    if (criteria && criteria.composite) {
        var filterWindowCriteria = criteria.filterWindowCriteria,
            filterEditorCriteria = criteria.filterEditorCriteria;

        // reinstate operator: "equals" to any criterions that have a value but no operator
        if (filterEditorCriteria) isc.DataSource.expandEqualsCriteria(filterEditorCriteria);
        if (filterWindowCriteria) isc.DataSource.expandEqualsCriteria(filterWindowCriteria);

        // don't invoke setFilterWindowCriteria() as that would cause a fetch - wait for
        // filterEditorSubmit
        this.filterWindowCriteria = filterWindowCriteria;
        criteria = filterEditorCriteria;
    } else {
        // Clear any current advanced FWC
        this.filterWindowCriteria = null;
    }
    this._showFilterWindowCriteriaIndicator();
    this.setFilterEditorCriteria(criteria);
    this.handleFilterEditorSubmit(criteria);
},


//> @type ListGridGroupState
// An object containing the stored grouping information for a listGrid.
// Note that this object is not intended to be interrogated directly, but may be stored
// (for example) as a blob on the server for state persistence across sessions.
//
// @baseType String
// @group viewState
// @visibility external
//<
// ListGridGroupState object is implemented as a serialized array of objects specifying
// fieldName, groupingMode, granularity.
// We also support a simple comma separated string (the older format) for backcompat

//> @attr listGrid.groupState (ListGridGroupState: null : IRW)
// Initial group state for the grid.
// <P>
// +link{listGrid.viewState} can be used to initialize all view properties of the grid.
// When doing so, <code>groupState</code> is not needed because <code>viewState</code>
// includes it as well. If both are provided, <code>groupState</code> has priority for
// group state.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getGroupState,getGroupState}.
// </smartclient>
//
// @group viewState
// @visibility external
//<

//> @method listGrid.getGroupState()
// Returns a snapshot of the current grouping state of this ListGrid.<br>
// This object can be passed to +link{listGrid.setGroupState()} to reset this grid's grouping
// to the current state (assuming the same data / fields are present in the grid).<br>
// @group viewState
// @see type:ListGridGroupState
// @see listGrid.setGroupState();
// @visibility external
// @return (ListGridGroupState) current view state for the grid.
//<
getGroupState : function (returnObject) {
    var i, field, states, groupFields = this.getGroupByFields();
    if (groupFields == null) {
       return "";
    } else {
        states = [];
        for (i = 0; i < groupFields.length; i++) {
            var allFields = this.completeFields || this.fields || [];
            field = allFields.find("name", groupFields[i]);
            if (field) {
                var state = { fieldName: groupFields[i] };
                if (field.groupingMode != null) state.groupingMode = field.groupingMode;
                if (field.groupGranularity != null) state.groupGranularity = field.groupGranularity;
                if (field.groupPrecision != null) state.groupPrecision = field.groupPrecision;
                states.add(state);
            }
        }
    }

    // returnObject is undocumented and passed when called from getViewState() - return the 
    // object to avoid double escaping
    if (returnObject) return states;

    // eval() of a string containing object literal text will js error - enclose in "(" ... ")" to
    // avoid this.
    return "(" + isc.Comm.serialize(states,false) + ")";

},

//> @method listGrid.setGroupState()
// Reset this grid's grouping to match the +link{type:ListGridGroupState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getGroupState()}.
//
// @group viewState
// @param groupState (ListGridGroupState) Object describing the desired grouping state of
//                                              the grid
// @see listGrid.getGroupState()
// @visibility external
//<
setGroupState : function (state) {
    var groupSpec = [];

    if (state) {
        if (isc.isA.String(state)) {
            if (!state.startsWith("(")) {
                // Backcompat - handle the state being stored as a comma separated string of fieldNames
                // in this case, split the string and make an array of objects with a fieldName
                state = state.split(",");
                for (var i=0; i<state.length; i++) {
                    state[i] = { fieldName: state[i] };
                }
            } else {
                state = this.evalViewState(state, "groupState")
            }
        }
        
        for (var i = 0; i < state.length; i++) {
            var item = state[i]
            
            var spec = this.makeGroupSpecifier(item.property || item.fieldName, 
                        item.grouping || item.groupingMode,
                        item.granularity || item.groupGranularity, 
                        item.precision || item.groupPrecision);
            if (spec) groupSpec.add(spec);
        }
    } else {
        groupSpec = null;
    }
    this.setGroupSpecifiers(groupSpec);
},

//> @attr listGrid.viewState (ListGridViewState : null : IRW)
// Initial view state may be provided for the listGrid at init time.
// To set view state at runtime, use +link{setViewState()}.<br>
// See +link{ListGridViewState} for details of what is included in the viewState for
// a ListGrid by default.
// <P>
// View state is a composite object containing various more granular states such as 
// +link{fieldState,fieldState}, +link{saveCriteriaInViewState,current filter criteria}, etc.
// As such it is not necessary to specificify fieldState, etc. in addition to 
// viewState at init time, but if both are provided the specific states 
// (<code>fieldState</code>, etc) will have priority.
// <smartclient>
// <P>
// To retrieve current state call +link{ListGrid.getViewState,getViewState}.
// </smartclient>
// <P>
// <b>Note:</b> For +externalLink{http://www.smartclient.com/product,SmartClient Pro users}, 
// the +link{SavedSearches,Saved Search subsystem} provides a sophisticated, out of the box
// set of capabilities and user-interface components for users to store and apply multiple
// named views or "saved searches". See +link{canSaveSearches} for how to enable menu options
// to save searches in grids. Note that each saved search includes
// the +link{listGrid.savedSearchStoredState,full view state} for the grid by default.
//
// @group viewState
// @visibility external
//<

//> @method listGrid.setViewState()
// Reset this grid's view state to match the +link{type:ListGridViewState} object passed in.<br>
// Used to restore previous state retrieved from the grid by a call to
// +link{listGrid.getViewState()}.
//
// @param viewState (ListGridViewState) Object describing the desired view state for the grid
// @group viewState
// @see listGrid.getViewState()
// @visibility external
//<
setViewState : function (state) {
    state = this.evalViewState(state, "viewState")
    if (!state) return;
    
    var fetchValueMap = this._fetchValueMap;

    // use ignoreStateChangeHandlers to prevent the various public state-changed notifications from firing
    var ignoreStateChangeHandlers = this.ignoreStateChangeHandlers;
    this.ignoreStateChangeHandlers = true;

    // Order is somewhat important - for example show fields before potentially sorting
    // by them, etc
    if (state.field) this.setFieldState(state.field);

    
    if (state.group) {
        // [No Grouping] is used to restore a grid to an ungrouped state, when 
        // minimalViewState is false
        if (state.group == "[No Grouping]") this.clearGroupBy();
        else this.setGroupState(state.group);
    }

    if (state.sort) {
        // [No Sorting] is used to restore a grid to an unsorted state, when 
        // minimalViewState is false
        if (state.sort == "[No Sorting]") {
            // if there's a sort in place right now, invalidateCache on unsort to force a 
            // visible reordering back to DB default
            var invalidateCacheOnUnsort = this.invalidateCacheOnUnsort;
            var currentSort = this.getSort();
            var hadSort = (currentSort != null && currentSort.length > 0)
            if (hadSort) this.invalidateCacheOnUnsort = true;
            this.setSortState(null);
            if (hadSort) this.invalidateCacheOnUnsort = invalidateCacheOnUnsort;
        } else this.setSortState(state.sort);
    }

    if (state.hilite) {
        // [No Hilites] is used to restore a grid to an un-hilited state, when 
        // minimalViewState is false
        if (state.hilite == "[No Hilites]") this.setHiliteState(null);
        else this.setHiliteState(state.hilite);
    }

    if (state.selected && state.selected != "") this.setSelectedState(state.selected);

    if (state.showFilterEditor != null && state.showFilterEditor != this.showFilterEditor) {
        this.setShowFilterEditor(!!state.showFilterEditor);
    }
    if (this.saveCriteriaInViewState && state.userCriteria && this.getDataSource()) {
        // [No Criteria] is used to restore a grid to an unfiltered state
        if (state.userCriteria == "[No Criteria]") {
            // Don't call 'setFilterWindowCriteria()' - we don't want to fetch until filterEditorSubmit below
            this.filterWindowCriteria = null; 
            this._showFilterWindowCriteriaIndicator();
            this.clearFilterValues();
            this.handleFilterEditorSubmit({});
        } else {
            this.setUserCriteriaState(state.userCriteria);
        }
    }

    if (fetchValueMap && !this.isDrawn()) {
        
        this._fetchValueMap = true;
    }

    this.ignoreStateChangeHandlers = ignoreStateChangeHandlers;
},

// Group state changed. Fire both "groupStateChanged" and "viewStateChanged".
// These methods documented under stringMethods section.
handleGroupStateChanged : function () {
    // We call this method blindly from regroupFinished which may be due to
    // a true change of group state [group by new field, etc], or may be a simple
    // regroup to accommodate new data, etc.
    // Avoid calling the public notification if the groupState hasn't actually been
    // updated.
    
    
    var groupStateString = this.getGroupState();
    if (this.currentGroupState == groupStateString) return;
    this.currentGroupState = groupStateString;

    if (!this.getDataSource() && !this._lastStoredSelectedState) {
        
        // clear any selection when grouping changes
        this.deselectAllRecords();
        // clear the "select all" header rcheckbox if it's visible
        var cbField = this.getCurrentCheckboxField();
        if (cbField && this.selectionType != "single" && this.canSelectAll != false) {
            this._setCheckboxHeaderState(false);
        }
    }

    // ignoreStateChangeHandlers is set in setViewState(), eg, and is used to prevent
    // the various public state-changed notifications from firing during internal work
    if (!this.ignoreStateChangeHandlers) this.groupStateChanged();
    this.handleViewStateChanged();
    this._provideIsGroupedToRuleContext();
},
groupStateChanged : function () {},

// Fire the viewStateChanged notification. This is documented in registerStringMethods()

handleViewStateChanged : function () {
    // clear the flag that indicates whether a given field has menuItems to show - will be
    // cached again on next headerButton mouseOver
    if (this.fields) this.fields.clearProperty("hasMenuItems");

    // auto-save state, if configured, before notifying observers
    this.persistViewState();
    if (!this.ignoreStateChangeHandlers) {
        this.fireOnPause("viewStateChangeNotification", {
            target:this, methodName:"viewStateChanged"
        }, 0);
    }
},

//> @type   ListGridViewStatePart
// @value  "all"            All parts of the view state
// @value  "group"          Group state
// @value  "field"          Field state
// @value  "selected"       Selected state
// @value  "sort"           Sort state
// @value  "hilite"         Hilite state
// @value  "userCriteria"   Criteria state
//
// @visibility external
// @group viewState
//<


//> @attr listGrid.autoPersistViewState (Array of ListGridViewStatePart : null : IRW)
// Setting this property to a non-null value will enable automatic saving of 
// +link{listGrid.getViewState(),view state} to offline storage. This saved view state will then
// be restored automatically when the user visits the page again.
// <P>
// <i><b>Note:</b> +externalLink{http://www.smartclient.com/product,SmartClient Pro users}, 
// may also be interested in the +link{listGrid.canSaveSearches} feature. This uses the
// +link{SavedSearches,Saved Search subsystem} to allow users to explicitly store and apply
// multiple named views or "saved searches". Each saved search includes
// the +link{listGrid.savedSearchStoredState,full view state} for the grid by default.</i>
// <P>
// <code>autoPersistViewState</code> may be set to a list of 
// +link{type:ListGridViewState,view state} +link{ListGridViewStatePart,parts} that
// should be automatically persisted into offline storage when changed.
// <P>
// This feature saves the derived state whenever the grid's view state
// changes due to user interaction (see +link{listGrid.viewStateChanged()}), and
// restores the saved state from offline storage when the grid is drawn.
// <P>
// The state is saved to offline storage using the grid's +link{type:AutoTestLocator,locator}
// as the key. See Locator setails below.
// <P>
// Note that <code>autoPersistViewState</code> should only be set on specific listGrid instances,
// and never as a default value for the class by changing the ListGrid defaults. Enabling this
// feature as a default would be an invalid usage as it would apply to listgrids
// (and subclasses of ListGrid) created and re-used internally by framework features as well
// as those explicitly created by application code.
// <P>
// The current saved value can be retrieved or cleared by calling
// +link{getSavedViewState} or +link{clearSavedViewState} respectively.
// <P>
// <b>Locator details</b>
// <P>
// The grid must have a stable locator so that previous state can be
// retrieved during initial draw and saved back into the same place. 
// If the grid has an explicit +link{ID} the locator will always be stable. Setting an
// explicit ID on a known parent of the grid can also lead to a stable ID as described in
// the +link{group:usingSelenium,Best Practices section of Using Selenium Scripts}.
// <P>
// For purposes of this feature the top-level parent of the grid must have an explicit ID.
// <P>
// Additional details on locators and their use can be found in +link{autoTest} and
// +link{type:LocatorStrategy}.
//
// @see listGrid.getSavedViewState
// @see listGrid.clearSavedViewState
// @group viewState
// @visibility external
//<

//> @method listGrid.clearSavedViewState
// Clear this grid's auto-saved +link{type:ListGridViewState,view state} as described in
// +link{autoPersistViewState}.
//
// @see listGrid.autoPersistViewState
// @see listGrid.getSavedViewState
// @group viewState
// @visibility external
//<
clearSavedViewState : function () {
    var locator = this._getAutoPersistLocator();
    if (locator) isc.Offline.remove(locator);
},

//> @method listGrid.getSavedViewState
// Returns the +link{type:ListGridViewState,view state} for this ListGrid as last saved by the
// +link{autoPersistViewState} setting.
//
// @return (ListGridViewState) last auto-saved view state for the grid.
// @see listGrid.autoPersistViewState
// @see listGrid.clearSavedViewState
// @group viewState
// @visibility external
//<
getSavedViewState : function () {
    var locator = this._getAutoPersistLocator();
    if (locator) return isc.Offline.get(locator);
},

persistViewState : function () {
    if (this.autoPersistViewState && !this._disablePersistViewState) {
        var locator = this._getAutoPersistLocator();
        if (locator) {
            if (!this._restoredViewState && isc.Offline.get(locator)) {
                // There is a persisted viewState that has yet to be applied.
                // Don't save a new viewState until then.
                return;
            }

            // get overall viewState with getViewState in "object" mode
            var rawViewState = this.getViewState(true),
                viewState = {}
            ;

            // pull desired parts into the viewState to save
            if (!isc.isAn.Array(this.autoPersistViewState)) {
                this.autoPersistViewState = [this.autoPersistViewState];
            }
            for (var i = 0; i < this.autoPersistViewState.length; i++) {
                var part = this.autoPersistViewState[i];
                if (part == "all") {
                    viewState = rawViewState;
                    break;
                }
                viewState[part] = rawViewState[part];
            }

            if (!isc.isAn.emptyObject(viewState)) {
                // save viewState to Offline storage serialized
                isc.Offline.put(locator, "(" + isc.Comm.serialize(viewState,false) + ")");
            }
        }
    }
},

// If viewState is auto-persisted, pull the last saved state
// and apply it now overwriting any coded values. Only do this
// the first time the grid is drawn.
restorePersistedViewState : function () {
    if (this.autoPersistViewState && !this._disablePersistViewState && !this._restoredViewState) {
        this._restoredViewState = true;
        var locator = this._getAutoPersistLocator();
        if (locator) {
            var viewState = isc.Offline.get(locator);
            if (viewState) this.setViewState(viewState);
        }
    }
},

_getAutoPersistLocator : function () {
    var locator;
    if (this.autoPersistViewState && !this._disablePersistViewState) {
        if (!this._persistLocator) {
            var locatorDetails = isc.AutoTest.getLocatorWithIndicators(this);
            if (locatorDetails && locatorDetails.containsGlobalId) {
                this.logWarn("autoPersistViewState is enabled but locator has an auto-generated global ID. State will not be saved. locator=" + locatorDetails.locator);
                // Only one attempt to get a stable locator is attempted and a message
                // generated.
                this._disablePersistViewState = true;
                return;
            }
            this._persistLocator = locatorDetails.locator;
        }
        locator = this._persistLocator;
    }
    return locator;
},

getViewStateChangedFunction : function () {
    if (this._viewStateChangedFunction == null) {
        var grid = this;
        this._viewStateChangedFunction = function () {
            if (grid.destroyed) return;
            grid.viewStateChanged();
        };
    }
    return this._viewStateChangedFunction;
},
viewStateChanged : function() {
},

//> @method listGrid.setDataSource()
// @include dataBoundComponent.setDataSource()
// @visibility external
//<
// Override setDataSource() - we need to reset the stored filter criteria in case we are
// showing the filterEditor.
setDataSource : function (dataSource, fields) {
    // If we have a specified groupByField, ungroup when changing from one DataSource to another.
    // *Don't ungroup if we didn't have a dataSource before this method ran - this is likely to
    // happen on init when a developer can validly set groupBy before setting dataSource.
    
    var currentDS = this.getDataSource();
    if (currentDS != null && currentDS != dataSource && currentDS.ID != dataSource) {
        this.ungroup();
    }

    // discard edits as they don't apply to the new DataSource records
    
    
    this.discardAllEdits();
    // The edit row form has fields as defined in the previous datasource. Drop the form
    // so it will be recreated on the next edit attempt.
    if (this._editorShowing) this.hideInlineEditor();
    if (this._editRowForm) {
        this._editRowForm.destroy();
        delete this._editRowForm;
    }

    this.Super("setDataSource", arguments);
    this.clearFilterValues();

},


// determine which fields should be shown, and add them to the visible fields array.
// (Used as an internal helper - developers should call 'refreshFields' instead)
deriveVisibleFields : function () {
    // NOTE: we use setArray() so that this.fields remains the same array instance.
    this.fields.setArray(this.getVisibleFields(this.completeFields));
    delete this.fields._appliedInitialAutoFitWidth

    this.deriveFrozenFields();
    this.refreshMasterIndex();
},


//> @method ListGrid.refreshFields
// Re-evaluates +link{ListGridField.showIf} for each field, dynamically showing and
// hiding the appropriate set of fields
// @visibility external
//<
refreshFields : function () {
    // nothing to do if external code calls this method before setFields/draw
    if (!this.completeFields) return;
    // Just fall through to 'setFields()' for now
    
    this._suppressStoreFieldState = true;
    this._suppressBindToDS = true;
    this.setFields(this.completeFields);
    delete this._suppressBindToDS;
    delete this._suppressStoreFieldState;
    
    if (this.showFilterEditor && this.allowFilterOperators && this.filterEditor) {
        // reapply operatorIcons 
        this.filterEditor.updateFilterOperators();
    }
},

//> @method ListGrid.getCurrentFieldWidths()
// Returns an array of widths of the visible fields in this <code>ListGrid</code>, in px.  This
// method is implemented by calling +link{ListGrid.getFieldWidth(),getFieldWidth()} for each field.
// If field widths cannot be determined, the returned array will contain nulls.
// @return (Array of Integer) field widths in px
// @visibility external
//<
getCurrentFieldWidths : function() {
    var widths = [];
    for (var i = 0; i < this.fields.length; i++) {
        widths[i] = this.getFieldWidth(i);
    }
    return widths;
},


getFieldWidths : function (reason, retNullIfNoResize) {
    // o appropriate time to get field widths:
    // LG w/ header:
    // - initially: right after we draw the header
    // - after setFields() header rebuilt: right after we rebuild the header
    // LG w/o header:
    // - initially: anytime before the body is drawn
    // - after setFields(): anytime before the body is redrawn

    var sizes = this._getCalculatedFieldWidths();
    // When autoFitFieldWidths is true, we may need to tweak these values to either
    // fill the available space, or clip certain fields if we're overflowing the
    // available space.
    // On drag-resize we set autoFitWidth to false on the field being dragged.
    // However we also want to suppress other fields' resizing (expanding to fill viewport
    // etc/ clipping to avoid h-scrollbars) or we'll get strange interactions with drag
    // similar to the problems if you re-evaluated "*" widths during drag
    if (this.autoFitFieldWidths && !this._calculatingAutoFitFieldWidths
        && !this._dragResizingField )
    {
        this._calculatingAutoFitFieldWidths = true;
        var unfrozenWidths = sizes.duplicate(),
            frozenWidths = null;

        if (this.frozenFields != null) {
            var left = this.freezeStart();
            if (left) {
                frozenWidths = unfrozenWidths.slice(0, this.frozenFields.length);
                unfrozenWidths = unfrozenWidths.slice(this.frozenFields.length);
            } else {
                frozenWidths = unfrozenWidths.slice(-this.frozenFields.length);
                unfrozenWidths = unfrozenWidths.slice(0, -this.frozenFields.length);
            }
        }
        
        var availableSpace = this.getAvailableFieldWidth(true),
            totalSize = unfrozenWidths.sum();

        var unfrozenSpace = availableSpace;
        if (frozenWidths != null) unfrozenSpace -= frozenWidths.sum();

        

        // Case 1: the fields don't fill the available space.
        // Expand the autoFitExpandField to fill the available space in the body.
        // Note: We don't auto-expand frozen fields - that would require resizing the
        // frozen body as well. The getAutoFitExpandField() method already handles not
        // returning frozen fields.
        // NOTE: If we're fitting to data, but data is currently loading, don't expand a field
        // now - wait until we redraw with loaded data. Otherwise we don't really know the
        // rendered sizes of all fields, so we won't know how much to expand the expansion field
        // by. Then when data arrives and the other fields all resize, we end up rendering the
        // expansion field potentially too wide since the other fields may now overflow available
        // space.
        
        var validData = true;
        if (this.autoFitWidthApproach != "title") {
            var dA = this.getDrawArea();
            // drawArea may be null if the body hasn't yet been created.
            if (!this.data || dA == null || Array.isLoading(this.data.get(dA[0]))) {
                validData = false;
            }
        }

        
        if (totalSize < unfrozenSpace && validData) {
            var expandField = this.getAutoFitExpandField();
            if (expandField) {
                // we want to update the sizes array (includes both frozen and
                // unfrozen fields) so get the global fieldNum for the expand field
                // and update that value.
                var expandFieldNum = this.getFieldNum(expandField);

                // limit growth of "expand field" to maxWidth
                var maxWidth = expandField.maxWidth || Infinity,
                    oldWidth = sizes[expandFieldNum],
                    newWidth = oldWidth + unfrozenSpace - totalSize;
                sizes[expandFieldNum] = newWidth  > maxWidth ? maxWidth : newWidth;

                // If we're showing a header for the field we have to resize
                // the button too so it stays in sync with the sizes array we
                // return (which will be applied to the body)
                var button = this.getFieldHeaderButton(expandFieldNum);
                if (button && button.isDrawn()) {
                    button.setWidth(sizes[expandFieldNum]);
                    retNullIfNoResize = false;
                }
            }
        // case 2: the auto-fit fields are overflowing the available space, clip them
        // if appropriate.
        // Note: we don't clip frozen fields - that would require resizing the actual bodies.
        } else if (totalSize > unfrozenSpace && this.autoFitClipFields != null) {
            // If any autoFitFields are marked as clippable, and we're now overflowing
            // horizontally, we want to re-run stretchResize logic ignoring
            // calculated autoFit for those fields -- just let them take up the available
            // space.
            // If we're not showing a header this is easy
            // If we are (and autoFitWidthApproach includes the header title), we need to
            // have the header re-run it's logic so it takes account of other (non clippable)
            // fields' title-widths
            // This means reset it's policy to fill, resize our fields to "*", then reflow,
            // reset the policy back to whatever it was before (probably "none")
            var policy;
            var clipFields = this.autoFitClipFields;
            for (var i = 0; i < clipFields.length; i++) {
                var field = this.getField(clipFields[i]),
                    fieldNum = this.getFieldNum(field);
                if (field == null || fieldNum < 0) continue;

                // Don't attempt to clip frozen fields since that would require resizing
                // the frozen body.
                if (!this._suppressedFrozenFields && field.frozen) {
                    this.logInfo("auto-fitting field:" + field.name +
                        " is present in the autoFitClipFields array for this grid, but is" +
                        " currently frozen. This is not supported - the field will not be clipped.",
                        "frozenFields");
                    continue;
                }


                // deleting the calculated autoFitWidth ensures that when
                // _getCalcualtedFieldWidths runs stretchResizePolicy will simply resize
                // the row to fit if possible, or if a header is showing, the header reflow
                //.will achieve the same result.
                delete field._calculatedAutoFitWidth;
                var header = this.getFieldHeader(fieldNum);
                if (header && header.isDrawn()) {
                    button = header.getMember(this.getLocalFieldNum(fieldNum));
                    
                    button.setWidth(field.width || field.minWidth || "*");
                    
                    button.setOverflow("hidden");
                }
            }
            if (this.header && this.header.isDrawn()) {
                var reflowReason = this._$gettingFieldWidths;
                if (reason != null) reflowReason += reason;
                 policy = this.header.hPolicy;
                 this.header.hPolicy = "fill";
                this.header.reflowNow(reflowReason);
                this.header.hPolicy = policy;
                if (this.frozenHeader) {
                    this.frozenHeader.hPolicy = "fill";
                    this.frozenHeader.reflowNow(reflowReason);
                    this.frozenHeader.hPolicy = policy;
                }
                retNullIfNoResize = false;
            }
//            this.logWarn("after reflow..." + this.header.getMemberSizes());

            // rerun the method to get the stretch-resize calculated widths
            // (will run the appropriate logic based on whether or not we're showing
            // headers
            sizes = this._getCalculatedFieldWidths();
        }
        this._calculatingAutoFitFieldWidths = false;
    }

//     this.logWarn("getFieldWidths() ultimately gave sizes:" + sizes);

    return retNullIfNoResize ? null : sizes;

},
_$gettingFieldWidths:"Getting listGrid fieldWidths. ",

// helper for getFieldWidths() - returns the stretch-resize calculated widths
// (based on the header if appropriate).
_getCalculatedFieldWidths : function () {


    

    var header = this.header;
    if (isc.isA.Layout(header) && header.isDrawn()) {
        
//        this.logWarn("using header-based field widths");
        
        // Handle the case where the header has been resized but the buttons are pending
        // a reflow
        
        if (header._layoutIsDirty) {
            header.reflowNow();
        }
        
        // Force an immediate redraw of any dirty buttons.
        // This is required to ensure sizes are correct -- if redrawOnResize is true for
        // the button or label with overflow:"visible", and setWidth() is called on it
        // the redraw isn't immediate - we need to force a redraw now if it hasn't occurred
        // so getVisibleWidth() returns the new size.
        // derive field widths from header sizes
        var buttons = header.members;
        var sizes = [];
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].isDirty()) buttons[i].redraw();
            if (buttons[i].label != null && buttons[i].label.isDirty()) buttons[i].label.redraw();
            sizes[i] = buttons[i].getVisibleWidth();
        }
        

        if (sizes.length > 0) {
            if (this.allowMismatchedHeaderBodyBorder) {
                
                var leftHeaderBorder = header.getLeftBorderSize() + header.getLeftMargin(),
                    rightHeaderBorder = header.getRightBorderSize() + header.getRightMargin();
                if (leftHeaderBorder != 0) {
                    sizes[0] += leftHeaderBorder;
                }
            }

            var totalSize = sizes.sum(),
                availableSpace = header.getInnerWidth();

            if (this.allowMismatchedHeaderBodyBorder) {
                var overflowAmount = totalSize - availableSpace;
                if (overflowAmount > 0) {
                    sizes[sizes.length-1] += Math.min(overflowAmount, rightHeaderBorder);
                }
            }
        }
        if (this.frozenFields) {
            var frozenWidths = this.frozenHeader.getMemberSizes();
            sizes.addListAt(frozenWidths, this.freezeStart() ? 0 : sizes.length);
        }


    } else {
//         this.logWarn("using stretchResize-based field widths");
        var sizes = this.getStretchResizeWidths();

    }
    return sizes;

},

// convenience method to redirect instance calls to implementation at class level
applyStretchResizePolicy : function (sizes, totalSize, minSize, modifyInPlace, callerMinSizes) {
    var thisClass = this.getClass(),
        policy = this.useOriginalStretchResizePolicy ? thisClass.applyStretchResizePolicy :
                                                    thisClass.applyNewStretchResizePolicy;
        return policy.call(thisClass, sizes, totalSize, minSize, modifyInPlace, this,
                           callerMinSizes);
},

getStretchResizeWidths : function () {
    var fields = this.fields;
    if (fields == null) return [];

    var useOriginal  = this.useOriginalStretchResizePolicy,
        ignoreLimits = this.ignoreStretchResizeMemberSizeLimits || useOriginal;

    var widths = fields.getProperty("width"),
        autoFitWidths = fields.getProperty("_calculatedAutoFitWidth"),
        hasDynamicDefaults = [];

    for (var i = 0; i < widths.length; i++) {
        
        if (autoFitWidths[i] != null) {
            // LGF.width acts as an additional minimum under the new policy
            if (!ignoreLimits && autoFitWidths[i] < fields[i].width) {
                autoFitWidths[i] = fields[i].width;
            }
            
            if (isc.isA.String(widths[i])) {
                hasDynamicDefaults.add(i);
            } else {
                if (widths[i] == null || widths[i] < autoFitWidths[i]) {
                    widths[i] = autoFitWidths[i];
                }
                // constrain numerical width of LGF with LGF.maxWidth/LGF.minWidth
                if (!ignoreLimits) {
                    var maxWidth = fields[i].maxWidth,
                        minWidth = fields[i].minWidth;
                    if (maxWidth != null && widths[i] > maxWidth) widths[i] = maxWidth;
                    if (minWidth != null && widths[i] < minWidth) widths[i] = minWidth;
                    // in addition to the field-specific limits, apply common minimum
                    if (widths[i] < this.minFieldWidth) widths[i] = this.minFieldWidth;
                }
            }
        }
    }

    // apply the stretch-resize policy to properly size any flexible-size LGF
    var innerWidth = this.innerWidth != null ? this.innerWidth : this.getAvailableFieldWidth(),
        calculatedWidths = this.applyStretchResizePolicy(widths, innerWidth, this.minFieldWidth,
                                                         false, autoFitWidths);

    
    if (useOriginal && hasDynamicDefaults.length > 0) {
        var fieldOverflowed = false;
        for (var i = 0; i < hasDynamicDefaults.length; i++) {
            var j = hasDynamicDefaults[i];
            if (calculatedWidths[j] < autoFitWidths[j]) {
                fieldOverflowed = true;
                widths[j] = autoFitWidths[j];
            }
        }
        if (fieldOverflowed) {
            calculatedWidths = this.applyStretchResizePolicy(
                widths,
                innerWidth,
                this.minFieldWidth
            );
        }
    }

    return calculatedWidths;
},

getAvailableFieldWidth : function (specifiedWidth) {
    
    if (specifiedWidth == null) {
        specifiedWidth = this.autoFitData != "both" && this.autoFitData != "horizontal";
    }

    var width = (!specifiedWidth
                    ? this.getVisibleWidth() : this.getWidth());
    
    return this._getInnerSpaceFromWidth(width);
},
_getInnerSpaceFromWidth : function (width) {
    width -= this.getHMarginBorderPad();
    // leave a gap for the scrollbar if vertical scrolling is on or if we're configured to
    // always leave a gap
    var leaveGap = this._shouldLeaveScrollbarGap();

    if (leaveGap) {
        width -= this.body ? this.body.getScrollbarSize() : this.getScrollbarSize();
    }
    return Math.max(1, width);
},



//> @method ListGrid.getFieldWidth()
// Returns a numeric value for the width of some field within this <code>ListGrid</code>.
// @param fieldNum (int | FieldName) Index or name of the field for which the width is to be
//                                   determined.
// @return (Integer) width of the field in px, or <code>null</code> if the width can't be
//                   determined.
// @visibility external
//<
getFieldWidth : function (fieldNum) {
    fieldNum = this.getFieldNum(fieldNum);
    if (fieldNum == -1 || !this.fields || fieldNum >= this.fields.length) return null;
    var width;
    if (this.body != null) width = this.getColumnWidth(fieldNum);
    if (width == null || isNaN(width)) width = this.getFieldWidths()[fieldNum];
    return width;
},

//> @attr listGrid.exportHiddenFieldWidth (int : 100 : IRW)
// Width to size non-visible fields (which may be specified with
// +link{dataBoundComponent.exportFields,exportFields} or +link{dsRequest.exportFields}) during
// +link{exportData()} or +link{exportClientData}, if they have no defined numeric
// +link{listGridField.width,width}.
// @see group:exportFormatting
// @see listGrid.exportFieldWidths
// @visibility external
//<
exportHiddenFieldWidth : 100,

_adjustFieldSizesForBodyStyling : function (sizes, vertical) {
    if (vertical == null) vertical = false;

    if (sizes == null || sizes.length == 0) return sizes;

    
    if (!this.body) {    
        
        return sizes;
    }

    // Adjust sizes of first and last field to account for styling on the body.
    
    sizes[sizes.length -1] =
        this._adjustLastFieldForBodyStyling(sizes[sizes.length-1], sizes.sum(), vertical);
    sizes[0] = this._adjustFirstFieldForBodyStyling(sizes[0], vertical);

    return sizes;
},

_adjustFirstFieldForBodyStyling : function (size, vertical) {
    if (!this.body) return size;

    // always knock the left (or top) border off the first field, otherwise everything starts
    // shifted too far right (or down)
    var bodyStartAdjust = (vertical ? this.body.getTopBorderSize() + this.body.getTopMargin()
                                    : this.body.getLeftBorderSize() + this.body.getLeftMargin());
    if (bodyStartAdjust != 0) size -= bodyStartAdjust;
    
    return Math.max(0, size);
},

_adjustLastFieldForBodyStyling : function (size, totalFieldsWidth, vertical) {
    if (!this.body) return size;

    // Figure out whether all the sizes will expand as far or further than the bottom or right
    // edge. If so we want to knock off the end border from the last col or row.
    var bodyEndAdjust = (vertical ? this.body.getBottomBorderSize() + this.body.getBottomMargin()
                                  : this.body.getRightBorderSize() + this.body.getRightMargin());

    if (bodyEndAdjust != 0) {
        
        var overflowAmount = totalFieldsWidth -
            (vertical ? this.body.getInnerHeight() : this.body.getInnerWidth());
            
        if (overflowAmount > 0) {
            size -= Math.min(overflowAmount, bodyEndAdjust);
        }
    }
    return Math.max(size,1);
},

setBodyFieldWidths : function (sizes) {

    var setBodyColWidths = false,
        setFrozenBodyColWidths = false;

    // set the _fieldWidths array to the list passed in
    this._fieldWidths = sizes;
    // adjust the first / last column width for any left/right border or margin on the body.
    
    var origSizes = sizes;
    if (this.allowMismatchedHeaderBodyBorder) {
        if (isc.isAn.Array(sizes)) {
            sizes = this._adjustFieldSizesForBodyStyling(sizes.duplicate());
        }
    }

    // if we have frozenFields, separate out the sizes for those columns
    var frozenFields = this.frozenFields;
    
    if (frozenFields && this.frozenBody) {
        var frozenWidths = this.getFrozenSlots(sizes);
        sizes = this.getUnfrozenSlots(sizes);
        var changed = this.frozenBody.setColumnWidths(frozenWidths);
        if (changed) setFrozenBodyColWidths = true;

        var freezeWidth = frozenWidths.sum();
        var max = this._getFrozenFieldsMaxWidth();
        if (max != null && freezeWidth > max) 
        {        
            freezeWidth = max
        }
        
        // this will automatically cause the main body to size to fill remaining space
        this.frozenBody.setWidth(freezeWidth);
        
        this.frozenBody.updateUserSize(freezeWidth, this._$width);
        if (this.frozenHeader) this.frozenHeader.setWidth(freezeWidth);
    }

    // give the GridRenderer new fieldWidths
    // will mark the body for redraw.
    if (this.body != null) {
        var changed = this.body.setColumnWidths(sizes);
        if (changed) setBodyColWidths = true;   
    }
    // If we're showing the edit form, update the widths of the form items
    
    if (this._editorShowing) {
        var items = this._editRowForm.getItems(),
            record = this.getRecord(this.getEditRow()),

            // This method gives the widths of form items for every column - since
            // we only create a subset of form items, we won't use every one.
            
            completeFormFieldWidths = this.getEditFormItemFieldWidths(record);

        for (var i = 0; i < items.length; i++) {
            var colNum = items[i].colNum;

            if (items[i].width != completeFormFieldWidths[colNum])
                items[i].setWidth(completeFormFieldWidths[colNum]);
        }
    }
    
    // If we have variable row heights and frozen fields, a col resize
    // may cause rows to change heights due to wrapped content
    // Ensure we refresh both bodies to keep row heights in synch.
    if (frozenFields && setBodyColWidths != setFrozenBodyColWidths &&
        !this.fixedRecordHeights &&
        this.matchFrozenRowHeightsApproach == "rowHeightSpacerHTML") 
    {
        if (!setFrozenBodyColWidths) {
            this.frozenBody.markForRedraw("Row resizes due to field width change");
        } else {
            this.body.markForRedraw("Row resizes due to field width change");
        }
    }
},

//> @method listGrid.setFrozenFieldsMaxWidth ()
// Setter for the +link{frozenFieldsMaxWidth} attribute
// @param width (String | Integer) new maximum width for frozen fields
// @visibility external
//<
setFrozenFieldsMaxWidth : function (width) {
    delete this._specifiedFFW;
    this.frozenFieldsMaxWidth = width;
    
    if (this.frozenFields != null) {
        this._updateFieldWidths("frozenFieldsMaxWidth changed");
    }
},

_getFrozenFieldsMaxWidth : function () {
    if (this.fieldSourceGrid) return this.fieldSourceGrid._getFrozenFieldsMaxWidth();
    
    var FFW = this._specifiedFFW || this.frozenFieldsMaxWidth;
    if (isc.isA.String(FFW)) {
        this._specifiedFFW = FFW;    
        if (FFW == "*") {
            FFW = this.getInnerContentWidth();
        } else if (FFW.endsWith("%")) {
            var max = this.getInnerContentWidth(),
                percentVal = parseInt(FFW); // No need to trim the "%", parseInt handles this
            FFW = Math.floor((max * percentVal) / 100);
        }
        
    }
    return FFW;
},


//> @type ListGridComponent
// Standard component-type displayed within a ListGrid, as contained by +link{listGrid.gridComponents}.
// @group appearance
// @value "filterEditor" The standard filter-component displayed when +link{listGrid.showFilterEditor}
//   is true
// @value "header" The header-component displayed when +link{listGrid.showHeader} is true.
// @value "body" The body component for the grid.
// @value "summaryRow" The summary-row component displayed when +link{listGrid.showGridSummary} is
//   true.
// @visibility external
//<

//> @attr listGrid.gridComponents (Array of ListGridComponent | Array of Any : (see below) : IR)
// Array of components that make up this grid. This array controls which standard and/or custom
// parts will be displayed within this ListGrid.
// <P>
// ListGrid is a subclass of +link{VLayout} and consists of a number of member components. The
// standard set of members are automatically generated by the grid, and include (for example)
// the header (a Toolbar of buttons for each field) and the body
// (a GridRenderer displaying the actual data contained in the grid).<br>
// The default value of <code>gridComponents</code> is an Array of +link{ListGridComponent}s listing
// the standard components in their default order:
// <smartclient>
// <pre>
//    gridComponents : ["filterEditor", "header",
//                      "body", "summaryRow"]
// </pre>
// </smartclient>
// <smartgwt>
// <pre>
//    [ListGridComponent.FILTER_EDITOR, ListGridComponent.HEADER, ListGridComponent.BODY,
//     ListGridComponent.SUMMARY_ROW]
// </pre>
// </smartgwt>
//
// You can override <code>gridComponents</code> to change the order of standard components.
// You can also omit standard components this way, although it more efficient to
// use the related "show" property if available (eg +link{showFilterEditor}). Note that
// this array must contain an entry for the <code>"body"</code> - listGrids with no body showing
// are unsupported.<br>
// <i>Advanced note:</i> The live components generated for each of these standard
// +link{ListGridComponent} types may differ across different listGrids. For example if this
// grid has any +link{listGridField.frozen,frozen fields}, the "body" entry will actually
// be created as an HLayout containing two GridRenderers (one for frozen fields,
// and one for unfrozen fields). This is really an implementation detail - the "body" entry
// in the gridComponents array simply specifies where the UI for the body should render within
// the ListGrid layout.
// <P>
// By embedding a Canvas directly in this list you can add arbitrary additional components to the
// listGrid as members, and have them be displayed alongside the standard automatically generated
// parts of the ListGrid.
// <P>
// Note that having added controls to gridComponents, you can still call APIs directly on
// those controls to change their appearance, and you can also show() and hide() them if
// they should not be shown in some circumstances.
// <P>
// Tip: custom controls need to set layoutAlign:"center" to appear vertically centered.
// <P>
// See +externalLink{https://smartclient.com/smartgwt/showcase/#grid_appearance_custom_toolbar,this example}
// of subclassing ListGrid and using gridComponents to add a tool bar with standard functions that 
// you want throughout your application.
//
// @visibility external
//<

gridComponents:[
    "filterEditor",
    "header",
    "body",
    "summaryRow"
],

getGridMembers : function (forAutoFitData) {
    var gridComponents = this.gridComponents,
        members = [],
        bodyShown,
        headerShown;

    for (var i = 0; i < gridComponents.length; i++) {
        var component = gridComponents[i],
            liveComponent = null;

        // allow arbitrary canvii to be shoehorned into the grid.
        if (isc.isA.Canvas(component)) {
            liveComponent = component;

        } else if (isc.isA.String(component)) {

            if (!this.shouldShowGridComponent(component)) continue;

            // This isn't quite as simple as auto-children -- for example if we have
            // frozen fields we use a Layout to show the 2 bodies - otherwise we simply
            // add the body directly to ourselves as a child.
            switch (component) {
                case "filterEditor" :
                    if (this.filterEditor == null) this.makeFilterEditor();
                    liveComponent = this.filterEditor;
                    break;

                case "header" :
                    headerShown = true;
                    if (this.header == null) {
                        this.makeHeader();
                    }
                    liveComponent = this.headerLayout || this.header;
                    break;

                case "body" :
                    bodyShown = true;
                    
                    this.createBodies();
                    liveComponent = this.bodyLayout || this.body;
                    break;

                case "summaryRow" :
                    liveComponent = this.getSummaryRow(forAutoFitData);
                    break;

//                 default :
//                     this.logWarn("getGridComponents() - Hit default - unrecognized component " + component);
            }
        }
        // Handle being passed anything you could pass to "addChild" (EG "autoChild:foo") by
        // explicitly calling 'createCanvas'.
        if (component != null && liveComponent == null) {
            liveComponent = this.createCanvas(component);
        }
        members.add(liveComponent);
    }
    
    // If we're showing a header and a body, ensure the header is higher in the
    // page's z-index. this allows it to show a visible drop-shadow.
    if (headerShown && bodyShown) {
        var header = this.headerLayout || this.header,
            body = this.bodyLayout || this.body;
        header.moveAbove(body);
    }
    
    if (!bodyShown) {
        this.logWarn("ListGrid specified with gridComponents:" + gridComponents +
            ".  This does not include a \"body\" entry. ListGrids with no body are unsupported," +
            " displaying the body as the last member in the grid.");
        members[members.length] = this.createBodies();
    }
    return members;
},

showComponentPropertyMap:{
    header:"showHeader",
    filterEditor:"showFilterEditor",
    summaryRow:"showGridSummary"
},
_$body:"body", _$header:"header",
shouldShowGridComponent : function (component) {
    if (component == this._$body) return true;
    if (component == this._$header && this.headerHeight == 0) {
        return false;
    }

    var componentName = component;
    if (componentName.startsWith(this._$autoChildPrefix)) {
        // remove the "autoChild:" prefix, so the property-name is properly formed below
        componentName = componentName.substring(this._$autoChildPrefix.length);
    }

    var property = this.showComponentPropertyMap[componentName];
    if (property == null) {
        this.showComponentPropertyMap[componentName] = property =
                "show" + componentName.substring(0,1).toUpperCase() + componentName.substring(1);
    }
    return this[property];
},

// createChildren - builds (or retrieves) our standard set of grid components and adds them
// to self as members
// Called from prepareToDraw, also from other cases where we need to refresh UI (EG showing/hiding
// filterEditor)

createChildren : function () {
    
    this.updateGridComponents();

    
    if (isc.Browser.isMoz && isc.Browser.geckoVersion >= 20051111) {
        if (this.header) {
            this.body.mozOutlineOffset = "0px";
            if (this.body.mozOutlineColor == null)
                this.body.mozOutlineColor = this.mozBodyOutlineColor;
        } else {
            if (this.body.mozOutlineColor == null)
                this.body.mozOutlineColor = this.mozBodyNoHeaderOutlineColor;
            this.body.mozOutlineOffset = "-1px";
        }
    }

    
    this._originalUseNativeTabIndex = this._useNativeTabIndex;
    this._useNativeTabIndex = false;
},

// actually creates the standard 'gridComponent' widgets and adds them as members.
// If components are already created they're just retrieved (not clobbered)
// If components are already members, the Layout 'setMembers' code should no-op.

updateGridComponents : function () {

    // Catch showHeader:true + no header in grid components (ditto filterEditor, summaryRow)
    for (var componentName in this.showComponentPropertyMap) {
        var propName = this.showComponentPropertyMap[componentName];
        if (this[propName] && !this.gridComponents.contains(componentName)) {
            this.logWarn("Missing grid component:" + propName + " set to true, but "
                 + componentName + " not included in gridComponents. Setting " + propName + " to false.");
            this[propName] = false;
        }
    }    
    this.setMembers(this.getGridMembers());
},

// layoutChildren at the Layout level handles positioning and sizing members.
// We have to do a certain amount of tweaking to this, mainly to ensure we calculate field
// widths correctly, and, if we have frozen fields, assign sizes to the frozen header and body
// correctly.

layoutChildren : function (reason, deltaX, deltaY) {
    var mustUpdateUI = (this.getDrawnState() != isc.Canvas.UNDRAWN) || (reason == this._$initial_draw);
    if (!mustUpdateUI) {
        
       return isc.VLayout._instancePrototype.layoutChildren.call(this,reason,deltaX,deltaY);
    }
    
    // When drawing both bodies we can clear the cell value cache now rather than having
    // each body do it as it gets draw()n
    // This has the advantage that if we render out row-height spacer HTML from the
    // unfrozen body while drawing the frozen body, we can reuse the calculated cell values
    var clearedCellValueCache = false;
    if (this.body != null && this.frozenBody != null && 
        !this.isDrawn() && reason == this._$initial_draw) 
    {
        this.body._clearCellValueCache();
        this.frozenBody._clearCellValueCache();
        this.body._clearedCellValueCacheInDrawThread = true;
        this.body._clearedCellValueCacheInDrawThread = true;
        
        clearedCellValueCache = true;
    }

    // If we've created our children, go ahead and call updateFieldWidths() to figure out
    // column sizes, and perform various member-management tasks.
    
    if (this.body != null) {
        // Note - If the grid as a whole was resized, our fields will potentially reflow. This could
        // change the required header heights in autoFitHeaderHeights mode, requiring
        // us to resize the header bar.
        // We already run the _updateHeaderHeight logic within updateFieldWidths so no
        // need to explicitly do that again here.
        
        if (reason != this._$resized || deltaX != 0 && this._shouldUpdateFieldWidths(deltaX)) {
            this._updateFieldWidths(reason, deltaX, deltaY);
        }
    }

    
    isc.VLayout._instancePrototype.layoutChildren.call(this,reason,deltaX,deltaY);
    
    if (clearedCellValueCache) {
        delete this.body._clearedCellValueCacheInDrawThread;
        delete this.frozenBody._clearedCellValueCacheInDrawThread;
    }

    if (this.body != null) {
        // Every time we layout children (may be due to body resize or body scroll change), if
        // we're showing the frozen body, ensure it's the correct (explicit) height
        if (this.frozenBody) {
            var adjustForHScroll = this.shrinkForFreeze && this.body.hscrollOn;
            var height = this.bodyLayout.getInnerHeight();
            if (adjustForHScroll) height -= this.body.getScrollbarSize();
            this.frozenBody.setHeight(height);
            if (this.frozenBody._needRowRedraw()) this.frozenBody.markForRedraw("height changed");
            // this will avoid the layout from scrapping this specified height on resize etc
            this.frozenBody.updateUserSize(height, this._$height);
        }
    }
    
},


_shouldUpdateFieldWidths : function (deltaX) {
    if (!this.isDrawn() || !this.header || !isc.isA.Number(deltaX) || 
        this.overflow != isc.Canvas.VISIBLE && this.overflow != isc.Canvas.CLIP_V)
    {
        return true;
    }

    var widthOverflow = this.header.getWidth() - this.getWidth();
    return widthOverflow <= 0 || widthOverflow + deltaX <= 0;
},

// ---------------------------------------------------------
// ListGrid Tab Order Management:
//
// Layouts override getChildTabPosition to order children in member order first, then
// non member children.
// They also have an updateMemberTabPosition method called from various appropriate
// points (addMember / reorderMembers etc) which essentially takes the calculated
// childTabPosition and applies it in the TabIndexManager.
//
// For ListGrids, the only change we need to make here is to shove the sorter
// (a non-member child) after the header in the page's tab order.
// 
// Note that special handling is also required for grid editing.
// We add the edit-form under the ListGrid body, so it is in the logically correct place,
// but we also intercept Tab keypress events in order to handle
// - moving within items
// - moving between items/editing new fields
// - completing the edit and moving on.

getChildTabPosition : function (child, returnNulls) {
    var position = this.Super("getChildTabPosition", arguments);
    
    var header = this.headerLayout || this.header,
        sorter = this.sorter;
    if (header == null || sorter == null) {
        return position;
    }
    var headerIndex = this.members.indexOf(header);
    // slot the sorter after the header in the tab-order
    if (child == sorter) {
        return headerIndex+1;
    }
    
    // If we were asked to return null, just return null. These guys will slot in 
    // in the "normal" order
    if (position == null) {
        return null;        
    }
    
    // Shift any subsequent members, or any non-member children forward by one to
    // account for the sorter being shifted up in the tab order.
    
    var memberIndex = this.members.indexOf(child);
    if (memberIndex == null || memberIndex == -1 || memberIndex > headerIndex) {
        position += 1;
    }
    return position;
},

// Override shouldAlterBreadth
// If we are autoFitData:"horizontal" or "both", we expand the body to fit the available
// space (relying on the fact that the grid is overflow:'visible' to show it).
// Avoid attempting to have the standard layout logic size the grid body when we're in
// this mode

shouldAlterBreadth : function (member) {
    if ((member == this.body || member == this.bodyLayout) && this.body._hAutoFit) return false;
    return this.Super("shouldAlterBreadth", arguments);
},

_updateHeaderWidth : function (fieldWidths, headerWidth, headerLayout) {

    

    // if autoFitMaxColumns is set, then limit the sum to the initially visible
    // columns; this prevents an infinite resizing loop where we try to resize
    // larger and other logic forces us back to a narrower width
    var maxColumns = this.autoFitMaxColumns;
    if (maxColumns != null) {
        if (this.frozenFields == null || this.freezeStart()) {
            fieldWidths = fieldWidths.slice(0, maxColumns);
        } else {
            var nFrozenFields = this.frozenFields.length;
            if (maxColumns < nFrozenFields) {
                fieldWidths = fieldWidths.slice(-nFrozenFields, -nFrozenFields + maxColumns);
            } else {
                var unfrozenFields = fieldWidths.slice(0, maxColumns - nFrozenFields);
                fieldWidths = fieldWidths.slice(-nFrozenFields);
                fieldWidths.addList(unfrozenFields);
            }
        }
    }
    var sum = fieldWidths.sum();

    // if autoFitMaxWidth is set, clip the sum based on its value
    var maxWidth = this.getAutoFitMaxWidth();
    if (maxWidth != null) {
        maxWidth = this._getInnerSpaceFromWidth(maxWidth);
    }
    if (maxWidth != null && sum > maxWidth) {
        sum = maxWidth;
    }

    // if width has increased, update header width or resize header layout
    if (sum > headerWidth) {
        if (headerLayout) headerLayout.resizeTo(sum);
        else headerWidth = sum;
    }

    return headerWidth;
},


_updateFieldWidths : function (reason, mustRefresh,c) {


    // don't do anything until we've created our children (eg resized before draw())
    // Safe to bail here - we'll always get a notification on initial-draw
    if (this.body == null) return;

    // Its unnecessary to run this if we're in the middle of a drag-resize and
    // can lead to some bad interactions between the desired sizing of fields from the
    // drag and auto-fit sizing.
    if (this._dragResizingField) return;

    var isInitialDraw = (reason == this._$initial_draw);
    if (!isInitialDraw && this.getDrawnState() == isc.Canvas.UNDRAWN) {
        return;
    }
        
    // don't allow this method to fire recursively
    
    
    if (this._updatingFieldWidths) {
        if (mustRefresh) this._mustRefreshFieldWidths = true;
        return;
    } else {
        this._mustRefreshFieldWidths = false;
    }

    // getFieldWidths() will actually resize fields in order to handle the special cases
    // where we have autoFitWidths enabled plus expansion of an autoFitField to fill space
    // or clipping to avoid introducing hscrollbars.
    // Avoid running this method in response to a header-resized event from that resize
    
    if (this._calculatingAutoFitFieldWidths) {
        return;
    }
    // Similarly if an explicit autoFit (due to the user hitting the 'autoFitAllColumns'
    // menu item, don't react to things like the header width changing - we'll explicitly
    // size correctly as we go...
    
    if (this._autoFittingFields) {
        return;
    }
    
    this._updatingFieldWidths = true;
    

    // wipe out fieldWidths on resize so they'll be recalculated.
    
    var previousFieldWidths = this._fieldWidths;
    this._fieldWidths = null;

    // If any fields has autoFitWidth set to true, calculate the auto-fit size for the
    // column apply it to the field
    // Note that we only care about the cases where we're fitting to the body content - if
    // we're fitting to the header this is handled by simply setting overflow to "visible"
    // on the header button.

    
    if (this.fields && !this.skipAutoFitWidths) {
        // The _appliedInitialAutoFitWidth flag allows us to avoid resizing
        // cols to fit content when this is not required. Should be cleared out
        // lazily by cases where we know content has changed and we should
        // reflow to accommodate it.
        if (!this.fields._appliedInitialAutoFitWidth) {
            var autoFitFieldWidths = this.getAutoFitValueWidths(null, true);
            
            if (autoFitFieldWidths == null) {
                this.fields.setProperty("_calculatedAutoFitWidth", null);
            } else {
            
                // Temp disable instantRelayout. Changing widths on the buttons will cause a
                // reflow on the layout as a whole, but we don't want to reflow instantly 
                // for every button as that'll cause layoutChildren and potentially resize
                // and redraw every button [each time through this loop!]
                var header = this.header,
                    frozenHeader = this.frozenHeader,
                    headerInstantRelayout = header && header.instantRelayout,
                    fHeaderInstantRelayout = frozenHeader && frozenHeader.instantRelayout;
                if (header) header.instantRelayout = false;
                if (frozenHeader) frozenHeader.instantRelayout = false;

            
                for (var i = 0; i < this.fields.length; i++) {
                    var field = this.fields[i];
                    if (autoFitFieldWidths[i] == null) {
                        field._calculatedAutoFitWidth = null;
                        continue;
                    }
                    var maxWidth = field.maxWidth || Infinity,
                        minWidth = this.getMinFieldWidth(field),
                        autoFitWidth = Math.min(autoFitFieldWidths[i], maxWidth);
                    var headerButton = this.getFieldHeaderButton(i);
                    if (headerButton == null) {
                        
                        if (header && minWidth > autoFitWidth) {
                            field._calculatedMinWidth = minWidth;
                        }
                    } else {
                        var isBoth = this.getAutoFitWidthApproach(field) == "both",
                            originalOverflow = headerButton.overflow,
                            overflowNotVisible = isBoth && (originalOverflow != "visible");
                        if (isBoth && overflowNotVisible) {
                            headerButton.setOverflow("visible");
                        }

                        if (minWidth < autoFitWidth) {
                            // update the header if there is one
                            // Note: If autoFitWidthApproach is "both", the header title can
                            // still overflow this new specified size (giving us the desired
                            // behavior of fitting to the larger of the 2 drawn sizes)
                            headerButton.setWidth(autoFitWidth);                            
                        } else {
                            headerButton.setWidth(minWidth);
                        }
                        
                        
                        if (headerButton.isDirty()) headerButton.redraw();
                        if (headerButton.label && headerButton.label.isDirty()) {
                            headerButton.label.redraw();
                        }
                        // If the autoFitWidth approach is "both" the header button
                        // may render wider than the specified width (overflow:"visible")
                        // In this case
                        // - we want the calculated autoFitWidth to be wider
                        // - we need to apply that wider size actually to the header button
                        //   (specified size is used directly in calculations
                        //   such as getFieldWidths()
                        if (isBoth) {
                            var headerDrawnWidth = headerButton.getVisibleWidth(),
                                expectedWidth = Math.max(minWidth, autoFitWidth);
                            if (headerDrawnWidth > expectedWidth) {
                                autoFitWidth = Math.min(headerDrawnWidth, maxWidth);
                                headerButton.setWidth(autoFitWidth);
                            }
                            
                            if (overflowNotVisible) {
                                headerButton.setOverflow(originalOverflow);
                            }
                        }
                    
                    }

                    field._calculatedAutoFitWidth = autoFitWidth;
                    var headerButton = this.getFieldHeaderButton(i);
                    if (headerButton != null) {

                        if (minWidth < autoFitWidth) {
                            // update the header if there is one
                            // Note: If autoFitWidthApproach is "both", the header title can
                            // still overflow this new specified size (giving us the desired
                            // behavior of fitting to the larger of the 2 drawn sizes)
                            headerButton.setWidth(autoFitWidth);
                        } else {
                            headerButton.setWidth(minWidth);
                        }
                    }

                }
                
                // Reset instantRelayout now.
                
                if (header) {
                    header.instantRelayout = headerInstantRelayout;
                    if (header._layoutIsDirty) header._reflowNow();
                }
                if (frozenHeader) {
                    frozenHeader.instantRelayout = fHeaderInstantRelayout;
                    if (frozenHeader._layoutIsDirty) frozenHeader._reflowNow();
                }

                // Hang a flag on the array to avoid re-calculating the width every time we
                // run stretchResizePolicy, etc
                this.fields._appliedInitialAutoFitWidth = true;

                // Remember how big the grid as a whole is - if it resizes we may need to
                // resize the field that expands to fill available space.
                this._initialAutoFitGridWidth = this.getWidth();

            }

        } else if (this._initialAutoFitGridWidth != this.getWidth()) {
            var expandField = this.getAutoFitExpandField();
            if (expandField) {
                var expandFieldNum = this.getFieldNum(expandField);

                delete expandField._calculatedAutoFitWidth;

                // Pick up the autoFitValueWidth for the field in question
                
                var autoFitFieldWidths = this.getAutoFitValueWidths(null, true);
                if (autoFitFieldWidths) {
                    var autoFitValueWidth = autoFitFieldWidths[expandFieldNum];
                    if (isc.isA.Number(autoFitValueWidth)) {

                        var maxWidth = expandField.maxWidth || Infinity,
                            minWidth = this.getMinFieldWidth(expandField);

                        expandField._calculatedAutoFitWidth = 
                            Math.min(autoFitValueWidth, maxWidth);

                        // Note: If autoFitWidthApproach is "both", the header title can
                        // still overflow this new specified size (giving us the desired
                        // behavior of fitting to the larger of the 2 drawn sizes)
                        var headerButton = this.getFieldHeaderButton(expandFieldNum);
                        if (headerButton != null) {
                            headerButton.setWidth(Math.max(minWidth, autoFitValueWidth));
                        }
                        this._initialAutoFitGridWidth = this.getWidth();
                    }
                }
            }
        }
    }

    
    var innerWidth = this.getAvailableFieldWidth(true),
        innerWidthChanged = (innerWidth != this.innerWidth);
    this.innerWidth = innerWidth;

    //   this.logWarn("total columns width: " + innerWidth +
    //                (this.body ? ", vscrollon: " + this.body.vscrollOn : ""));

    var header = this.header,
        headerHeight = (this.showHeader ? this.getHeaderHeight() : 0);
    if (header != null) {
        
        // place the header
        // in RTL, sorter is on left
        var left = (this.isRTL() && this._showSortButton() ? this._getSorterWidth() : 0);

        
        header.hPolicy = "fill";
        if (this.frozenHeader) this.frozenHeader.hPolicy = "fill";
        var autoFitHorizontal = this.autoFitData == "horizontal" || this.autoFitData == "both",
            headerWidth = this.innerWidth,
            fieldWidths;

        if (!this.leaveScrollbarGap && header.isDrawn() &&
            headerWidth != header.getWidth() && reason == "body scroll changed") {
            
            //this.logWarn("header changing size" + this.getStackTrace());
            if (this._settingBodyFieldWidths || !this.resizeFieldsForScrollbar) {
                header.hPolicy = "none";
            }
        }
        var headerLayout = this.headerLayout || header;
        
        headerLayout.resizeTo(headerWidth, headerHeight);
        
        headerLayout.updateUserSize(headerHeight, this._$height);

        
        if (autoFitHorizontal && !this._dragResizingField) {
            fieldWidths = this.getFieldWidths(reason + " [sizing horizontal auto-fit header]");
            this._updateHeaderWidth(fieldWidths, headerWidth, headerLayout);
        }

        // if we're in the middle of the initial drawing process, draw the header now so we can
        // get fieldWidths from it to give to the body before it draws.  Also draw the header
        // if we're completely drawn and it's undrawn because it was just recreated.
        
        if (!header.isDrawn() && (isInitialDraw || this.isDrawn())) {
            if (!this.frozenFields) {
                if (isInitialDraw) this._moveOffscreen(header);
                header.draw();
            } else {
                // running getFieldWidths before the header is drawn
                // to determine how much space will be required for the frozen header
                // (see _getCalculatedFieldWidths for explanation)
                if (fieldWidths == null) {
                    fieldWidths = this.getFieldWidths(reason + " [sizing frozen fields]");
                }
                var frozenWidths = this.getFrozenSlots(fieldWidths);
                var frozenWidth = frozenWidths.sum();
                this.frozenHeader.setWidth(frozenWidth);
                
                this.frozenHeader.updateUserSize(frozenWidth, this._$width);
                if (isInitialDraw) this._moveOffscreen(this.headerLayout);
                this.headerLayout.draw()
            }
        }

        if (header.isDrawn()) header.hPolicy = "none";
        if (this.frozenHeader && this.frozenHeader.isDrawn()) this.frozenHeader.hPolicy = "none";

        // ensure the sorter is showing in the right place and visible / hidden as appropriate
        
        if (this.sorter) {
            this.updateSorter();
        }

        if (this.autoFitHeaderHeights) {
            var headerHeight = this.getHeaderHeight();
            this.dropCachedHeaderButtonHeights();

            var newHeaderHeight = this.getHeaderHeight(),
                headerLayout = this.headerLayout || this.header;

            // only do a full update if the header height has changed
            if (headerHeight             != newHeaderHeight || 
                headerLayout.getHeight() != newHeaderHeight)
            {
                headerLayout.setHeight(newHeaderHeight);
                this._updateHeaderHeight();
            } else {
                if (this.headerSpans) {
                    // update spans on both standard and frozen headers
                    this.header._adjustSpans(true);
                    if (this.frozenHeader) this.frozenHeader._adjustSpans(true);
                }
            }
        }

    }

    // if we haven't figure out field widths, this is the time to get them, since the header
    // has been drawn if we have one, and the body is yet to be drawn.
    // NOTE: if we are clear()d and then redrawn, and we have a header, we don't want to get
    // sizes from the header while it's undrawn, as it will not run the layout policy while
    // undrawn.
    if ((!this._fieldWidths || innerWidthChanged) &&
        ((header && header.isDrawn()) || headerHeight == 0))
    {
        
        var originalPolicy;
        if (header && header.hPolicy &&
            (reason == this._$new_data || reason == this._$initial_draw))
        {
            originalPolicy = header.hPolicy;
            header.hPolicy = "fill";
        }

        var fieldWidths = this.getFieldWidths(reason);
        this.setBodyFieldWidths(fieldWidths);

        // update the filter editor field widths too [only need to worry about the body]
        if (this.filterEditor && this.filterEditor.body != null) {
            this.filterEditor.setBodyFieldWidths(this.filterEditor.getFieldWidths(reason));
        }

        // update the summaryRow (if visible)
        if (this.summaryRow && this.showGridSummary && this.summaryRow.body != null) {
            this.summaryRow.setBodyFieldWidths(fieldWidths.duplicate());
        }

        if (this.logIsDebugEnabled("layout")) {
            this.logDebug("new field widths: " + this._fieldWidths, "layout");
        }
        
        if (originalPolicy) header.hPolicy = originalPolicy;
    }

    // Normally we can rely on the standard layout behavior to size the filter editor.
    // however, if autoFitData is horizontal our content can exceed our specified size, and
    // the layout doesn't automatically handle expanding content to fit an overflowed breadth
    // Therefore in this case explicitly match the filter editor to the body width
    if (autoFitHorizontal && this.filterEditor) {
        this.filterEditor.setWidth(this.body.getVisibleWidth());
    }

    
    this._updatingFieldWidths = false;
    
    if (this.headerSpans != null && this.autoSizeHeaderSpans) {
        var changed = false;
        
        if (this._mustRefreshFieldWidths) {
            changed = true;
        } else if (this._fieldWidths != null && previousFieldWidths != null) {
            if (previousFieldWidths.length != this._fieldWidths.length) {
                changed = true;
            } else {
                for (var i = 0 ; i < previousFieldWidths.length; i++) {
                    if (previousFieldWidths[i] != this._fieldWidths[i]) {
                        changed = true;
                        break;
                    }
                }
            }
        }
        if (changed) {
            if (this._rerunningUpdateFieldWidths) {
                
            } else {
                this.logDebug("Re-running update field widths to account for header span auto-size");
                this._rerunningUpdateFieldWidths = true;
                var rerunReason = "Ensure header span and field sizes sync";
                if (reason != null) rerunReason += " [from " + reason + "]";
                this._updateFieldWidths(rerunReason);

            }
            this._rerunningUpdateFieldWidths = false;
        }
    }
},

//> @attr listGrid.autoFitHeaderHeights (boolean : null : IR)
// If this property is set to true, header buttons for either +link{listGrid.fields,fields} or
// +link{listGrid.headerSpans,header spans} will automatically expand to accommodate their
// titles vertically.  This means if you have a "tall" title - typically a long string where
// +link{listGridField.wrap} is set to true such that you end up with several lines of text -
// the button will render large enough to accommodate it.  If necessary this will cause the
// header for the grid as a whole to expand beyond the specified +link{listGrid.headerHeight}.
// <P>
// Note that you need not set +link{headerSpan.height} or +link{headerSpanHeight} if you set
// this property, but if you do, they will be used as minimum values.
//
// @visibility external
//<



// get the "expected" height for field or span header-buttons based on
// this.headerHeight, span.height, etc.
getHeaderButtonDefaultHeight : function (span, recalculate) {
    if (recalculate || span._defaultHeight == null) {
        this.calculateDefaultSpanHeights();
    }
    return span._defaultHeight;
},

// Perform a one-time iteration through all header buttons determining
// "expected" heights based on header height etc, and cache these values.
calculateDefaultSpanHeights : function () {

    if (this.headerSpans == null) {
        // Shouldn't be called if headerSpans is null
        return;
    }

    if (this.headerSpans != null) {

        var fields = this.getFields(),
            fieldNames = fields.getProperty("name");
        for (var i = 0; i < this.headerSpans.length; i++) {
            var availableSpace = this.headerHeight,
                span = this.headerSpans[i];

            this._calculateDefaultSpanHeight(span, availableSpace, fieldNames);
        }
        for (var i = 0; i < fields.length; i++) {
            if (this.spanMap[fields[i].name] == null) {
                fields[i]._defaultHeight = this.headerHeight;
            }
        }
    }
},

// helper for calculateDefaultSpanHeights()
_calculateDefaultSpanHeight : function (span, availableSpace, fieldNames, isField) {
    if (!isField) {
        // Skip anything that isn't visible
        if (!this._headerSpanVisible(fieldNames, span)) return;

        var defaultHeight;
        if (span._spanAutoSizeHeight !== true) {
            defaultHeight = span.height || this.headerSpanHeight;
        }
        if (defaultHeight == null) {
            var spanDepth = this.getNestedSpanDepth(span);
            // add one to account for field at the bottom
            spanDepth += 1;
            defaultHeight = Math.floor(availableSpace / spanDepth);
        }
        span._defaultHeight = defaultHeight;
        availableSpace -= defaultHeight;

        if (span.spans) {
            for (var i = 0; i < span.spans.length; i++) {
                this._calculateDefaultSpanHeight(span.spans[i], availableSpace, fieldNames);
            }
        } else {
            for (var i = 0; i < span.fields.length; i++) {
                // skip hidden / missing fields
                var field = this.getField(span.fields[i]);
                if (field) {
                    this._calculateDefaultSpanHeight(field, availableSpace, fieldNames,
                        true);
                }
            }
        }
    } else {
        // not visible? Just bail
        if (!fieldNames.contains(span.name)) return;

        span._defaultHeight = availableSpace;
    }
},

_getHeaderButtonWrap : function (config, isSpan) {
    if (config.wrap != null) return config.wrap;
    return isSpan ? this.wrapHeaderSpanTitles : this.wrapHeaderTitles;
},

getHeaderButtonMinHeight : function (field, recalculate) {
    if (!recalculate && field._calculatedMinHeight != null) {
        return field._calculatedMinHeight;
    }
    return this.getHeaderButtonMinHeights([field], recalculate)[0];
},

// Use an offscreen tester to figure out how much space is required for
// a field, or span header button based on its specified title.
// Caches the value for re-use
getHeaderButtonMinHeights :function (fields, recalculate) {
    var mustCalculate = [];
    var heights = [];
    var testHTML = "";
    for (var i = 0; i < fields.length; i++) {
        var width, isSpan, field = fields[i];
        if (!recalculate && field._calculatedMinHeight != null) {
            heights[i] = field._calculatedMinHeight;
        } else {
            isSpan = !this.fields.contains(field);

            if (isSpan) {
                var spannedFields = this.getSpannedFields(field);
                //this.logWarn("fields:" + spannedFields);

                width = 0;
                for (var ii = 0; ii < spannedFields.length; ii++) {
                    var spannedField = this.getField(spannedFields[ii]);
                    if (spannedField == null) {
                        continue;
                    }
                    width += this.getFieldWidth(spannedFields[ii]);
                }

            } else {
                width = this.getFieldWidth(field);
            }

            // XXX This basically matches framework behavior if we
            // don't see a useful numerical width. May want to revisit.
            if (isNaN(width)) {
                heights[i] = 1;
            } else {
                
                var baseStyle = field.headerBaseStyle,
                    buttonProperties = this.getHeaderButtonProperties();
                if (baseStyle == null) {
                    if (field.frozen && buttonProperties.frozenBaseStyle) {
                        baseStyle = buttonProperties.frozenBaseStyle;
                    } else if (buttonProperties.baseStyle) {
                        baseStyle = buttonProperties.baseStyle;
                    }
                }
                var titleStyle = field.headerTitleStyle;
                if (titleStyle == null) {
                    if (field.frozen && buttonProperties.frozenTitleStyle) {
                        titleStyle = buttonProperties.frozenTitleStyle;
                    } else if (buttonProperties.titleStyle) {
                        titleStyle = buttonProperties.titleStyle;
                    }
                }

                if (baseStyle == null || titleStyle == null) {
                    var buttonConstructor = this.headerButtonConstructor ||
                                this.header ? this.header.buttonConstructor
                                            : isc.Toolbar.getPrototype().buttonConstructor;
                    if (isc.isA.String(buttonConstructor)) {
                        buttonConstructor = isc[buttonConstructor];
                    }
                    if (baseStyle == null)  {
                        baseStyle = buttonConstructor.getPrototype().baseStyle;
                    }
                    if (titleStyle == null) {
                        titleStyle = buttonConstructor.getPrototype().titleStyle;
                    }
                }

                var title = isSpan ? field.headerTitle || field.title
                                 : this.getHeaderButtonTitle(field);
                var oldConfig = field._calculatedHeightConfig;

                if (oldConfig &&
                    oldConfig.baseStyle == baseStyle &&
                    oldConfig.titleStyle == titleStyle &&
                    oldConfig.width == width &&
                    oldConfig.wrap == field.wrap &&
                    oldConfig.title == title)
                {
                    field._calculatedMinHeight = oldConfig.height;
                    heights[i] = oldConfig.height;
                }
            }
        }
        if (heights[i] != null) continue;

        // available width must account for any padding due to +link{leaveHeaderMenuButtonSpace}
        if (this._shouldPadHeaderButton(field, width)) {
            width = Math.max(1, width - this._getHeaderButtonPadding(field));
        }

        // At this point we want to actually measure the
        // height (and cache the result).

        var config = {};
        config.width = width;
        config.baseStyle = baseStyle;
        config.titleStyle = titleStyle;
        config.wrap = field.wrap;
        config.title = title

        mustCalculate.add({
            index:i,
            config:config
        });

        if (isSpan == null) isSpan = !this.fields.contains(field);
        var buttonWrap = this._getHeaderButtonWrap(config, isSpan);

        
        testHTML += "<div style='position:absolute;width:" + width + "px;'><div class=" +
            (config.titleStyle || config.baseStyle) +
            (buttonWrap ? ">" : " style='white-space:nowrap;'>") +
            title + "</div></div>"
    }
    if (mustCalculate.length == 0) return heights;

    
    if (isc.ListGrid.headerHeightTester == null) {
        isc.ListGrid.headerHeightTester = isc.Canvas.create({
            overflow:"hidden",
            top:-1000,
            autoDraw:true,
            contents:testHTML
        });
    } else {
        isc.ListGrid.headerHeightTester.setContents(testHTML);
    }
    // immediate redraw (setContents does a delayed redraw)
    if (isc.ListGrid.headerHeightTester.isDirty()) isc.ListGrid.headerHeightTester.redraw();

    var handle = isc.ListGrid.headerHeightTester.getHandle(),

    childNodes = handle.childNodes;
    if (childNodes.length != mustCalculate.length) {
        
    }
    for (var i = 0; i < childNodes.length; i++) {
        var div = childNodes[i];

        var config = mustCalculate[i].config,
            index = mustCalculate[i].index,
            field = fields[index];

        config.height = div.offsetHeight;
        field._calculatedHeightConfig = config;
        field._calculatedMinHeight = config.height;

        heights[index] = config.height;
    }
    return heights;
},

// Drops the cached expected (default) and min-heights for all fields / header spans
dropCachedHeaderButtonHeights : function () {
    for (var i = 0; i < this.fields.length; i++) {
        this.fields[i]._defaultHeight = null;
        this.fields[i]._calculatedMinHeight = null;
        if (this.spanMap) {
            var span = this.spanMap[this.fields[i].name];
            while (span != null) {
                span._defaultHeight = null;
                span._calculatedMinHeight = null;
                span = span.parentSpan;
            }
        }
    }
},

// getHeaderHeight() - if autoFitting headers vertically, this method will calculate
// the required height for the header-bar as a whole and return it
// (Otherwise returns specified header height).
getHeaderHeight : function () {
    if (this.headerHeight == 0 || !this.showHeader) return 0;
    if (!this.autoFitHeaderHeights) return this.headerHeight;

    var minHeight = 0;
    if (this.headerSpans == null) {
        minHeight = this.headerHeight;
        var fields = this.getFields();

        var fieldHeights = this.getHeaderButtonMinHeights(fields);
        minHeight = Math.max(minHeight, fieldHeights.max());

    } else {

        var fields = this.getFields(),
            fieldColHeight = 0;

        // We've found that redraws are a significant bottleneck and that
        // redrawing the offscreen header height tester for every field and every
        // span is expensive.
        // Cut this down by passing all fields into getMinHeights... then all
        // spans (two redraws total rather than one per button)
        var fieldMinHeights = this.getHeaderButtonMinHeights(fields),
            spans = [];

        for (var i = 0; i < fields.length; i++) {
            if (this.spanMap[fields[i].name]) {
                var span = this.spanMap[fields[i].name];
                while (span) {
                    if (!spans.contains(span)) {
                        spans.add(span);
                    }
                    span = span.parentSpan;
                }
            }
        }

        
        var spanMinHeights = this.getHeaderButtonMinHeights(spans);
        for (var i = 0; i < fields.length; i++) {
            fieldColHeight = Math.max(
                                this.getHeaderButtonDefaultHeight(fields[i]),
                                this.getHeaderButtonMinHeight(fields[i])
                             );
            if (this.spanMap[fields[i].name]) {
                var span = this.spanMap[fields[i].name];
                while (span) {

                    fieldColHeight +=  Math.max(
                                        this.getHeaderButtonDefaultHeight(span),
                                        this.getHeaderButtonMinHeight(span)
                                       );
                    span = span.parentSpan;
                }
            }

            minHeight = Math.max(minHeight, fieldColHeight);
        }

    }
    return Math.max(minHeight, this.headerHeight);
},

// getAutoFitValueWidths: Calculates the auto-size width based on rendered field values
// Returns a sparse array of field sizes indexed by fieldNum in this.fields.
// By default expects no params and returns only auto-size width of the fields marked with
// autoFitWidth:true.
// If fields are passed in directly we'll calculate sizes for those fields only (regardless of
// any per-field autoFitWidth settings)
getAutoFitValueWidths : function (fields, checkApproach) {
    if (this.data == null) return;
    if (isc.isA.ResultSet(this.data)) {
        var drawArea = this.body.getDrawArea();
        if (!this.data.rangeIsLoaded(drawArea[0], drawArea[1])) {
            // If we're autofitting all fields, and data is loading, mark for resize
            // again - will occur on redraw from dataChanged/dataArrived
            if (fields == null) {
                this.updateFieldWidthsForAutoFitValue("Delayed resize pending data load");
            }
            return;
        }
    } else if (isc.isA.ResultTree(this.data)) {
        var data = this.data,
            root = data.getRoot();
        
        if (!root || 
            (data.getLoadState(root) != isc.Tree.LOADED && 
             data.getLoadState(root) != isc.Tree.LOADED_PARTIAL_CHILDREN))
        {
            this.updateFieldWidthsForAutoFitValue("Delayed resize pending tree data load");
            return;
        }
    }

    var noAutoFit = (fields == null);
    if (fields == null) {
        fields = [];
        for (var i = 0; i < this.fields.length; i++) {
            var field = this.fields[i];
            
            if (this.shouldAutoFitField(field)) {
                // checkApproach - if passed don't collect valueWidths unless the field's
                // autoFitWidthApproach is 'value' or 'both'
                if (!checkApproach || this.getAutoFitWidthApproach(field) != "title") {
                    fields.add(field);
                    noAutoFit = false;
                }
            }
        }
    }
    if (noAutoFit) return [];
    
    // widths will be a sparse array containing just the calculated field widths
    var widths = [],
        checkAutoFitWidths = false,
        frozenAutoFitFields = [], frozenAutoFitColNums = [],
        autoFitFields = [], autoFitColNums = [];
    for (var i = 0; i < this.fields.length; i++) {
        if (fields.contains(this.fields[i])) {
            var field = this.fields[i];
            // call getDefaultFieldWidth per field with the special flag to
            // suppress checking autoFitWidths
            // If we get back any nulls (indicating we hit this) pass these to
            // the getColumnAutoSize() method directly.
            // It's more efficient to pass a number of cols to that method
            // at once, but we also want a custom "getDefaultFieldWidth" implementation
            // to behave as expected so it's a viable override point for customizing this
            // behavior.
            var defaultWidth = this.getDefaultFieldWidth(this.fields[i], true);
            if (defaultWidth == null) {
                checkAutoFitWidths = true;
                if (field.frozen) {
                    frozenAutoFitFields.add(this.getLocalFieldNum(i));
                    frozenAutoFitColNums.add(i);
                } else {
                    
                    autoFitFields.add(this.getLocalFieldNum(i));
                    autoFitColNums.add(i);
                }
            } else {
                widths[i] = defaultWidth;
            }
        }
    }
    if (checkAutoFitWidths) {

        if (frozenAutoFitFields.length > 0) {
            var bodyWidths = this._getBodyColumnAutoSize(true, frozenAutoFitFields);
            if (bodyWidths != null) {
                for (var i = 0; i < bodyWidths.length; i++) {
                    widths[frozenAutoFitColNums[i]] = bodyWidths[i];
                }
            }
        }

        if (autoFitFields.length > 0) {
            var bodyWidths = this._getBodyColumnAutoSize(false, autoFitFields);
            if (bodyWidths != null) {
                for (var i = 0; i < bodyWidths.length; i++) {
                    widths[autoFitColNums[i]] = bodyWidths[i];
                }
            }
        }
    }
    return widths;
},

// Helper to call gridRenderer logic to get auto-fit widths for a number of fields.
_getBodyColumnAutoSize : function (frozen, localFieldNums) {
    var body = frozen ? this.frozenBody : this.body;
    if (body == null) return null;
    var bodyWidths = body.getColumnAutoSize(localFieldNums);
    
    if (this.includeGridSummaryInAutoFitWidth &&
        this.showGridSummary && this.summaryRow != null)
    {
        var summaryBody = (frozen ? this.summaryRow.frozenBody : this.summaryRow.body);
        if (summaryBody != null) {
            var summaryWidths = summaryBody.getColumnAutoSize(localFieldNums);
            if (summaryWidths != null) {
                if (bodyWidths == null) bodyWidths = [];
                for (var i = 0; i < summaryWidths.length; i ++) {
                    if (bodyWidths[i] == null ||
                        summaryWidths[i] > bodyWidths[i]) bodyWidths[i] = summaryWidths[i];
                }
            }
        }
    }
    // In setBodyFieldWidths, we automatically adjust body col sizes (shrink them)
    // to avoid the body styling from impacting the overall width of the body - required
    // to support mismatched header/border styling.
    // Preemptively expand the calculated "auto fit" width so doing this won't eat into
    // that space
    if (this.allowMismatchedHeaderBodyBorder && bodyWidths != null) {
        var body = frozen ? this.frozenBody : this.body,
            firstIndex = localFieldNums.indexOf(0),
            lastIndex = localFieldNums.indexOf(
                            (frozen ? this.frozenFields.length : this.fields.length)-1);
        if (firstIndex != -1) {
            bodyWidths[firstIndex] =  bodyWidths[firstIndex] +
                                        body.getLeftBorderSize() + body.getLeftMargin();
        }
        if (lastIndex != -1) {
            bodyWidths[lastIndex] =  bodyWidths[lastIndex] +
                                        body.getRightBorderSize() + body.getRightMargin();
        }
    }
    return bodyWidths;
},

//> @attr listGrid.iconPadding (Integer : 2 : IR)
// When using +link{autoFitFieldWidths}, padding in pixels left on each side of fields that
// show images.
// @visibility external
//<

//> @method listGrid.getDefaultFieldWidth()
// Method to calculate and return the default width of a field. This method is called
// to calculate the size of each field's content as part of the
// +link{listGrid.autoFitFieldWidths,field auto fit} behavior. Note that this method
// returns a size for <i>content</i>, so will not be consulted if
// +link{listGridField.autoFitWidthApproach,autoFitWidthApproach} is set 
// to <code>"title"</code>.
// <P>
// If +link{listGridField.defaultWidth} is specified, this will be returned.
// <P>
// Otherwise, the default implementation varies by +link{ListGridFieldType,field type}.
// For fields of type <code>"icon"</code>, or fields which show only a
// +link{ListGridField.valueIcons,valueIcon} as a value, and for boolean fields which
// show a checkbox value, the width will be calculated based on the icon size and
// +link{listGrid.iconPadding}.
// For other fields the +link{getFieldContentWidth()} method will be used to calculate
// a width based on the rendered width of content. Note that for
// <code>"image"</code> type fields, this method will rely on the +link{listGridField.imageWidth}
// being specified.
// <P>
// Note that this width is the default width of "content" - it does not take into account
// the rendered size of the field title.
//
// @param field (ListGridField) Field for which the size should be determined
// @return (int) default size required for the field's content.
//
// @visibility external
//<

iconPadding:2,
lastFieldMaxExpandWidth:80,
getDefaultFieldWidth : function (field, suppressAutoFitWidths) {

    // If an explicit, static 'defaultWidth' was specified on the field, respect it.
    if (field.defaultWidth != null) return field.defaultWidth;

    // special cases where we can avoid writing out and measuring content
    var baseType = field.type == null ? null :
                    isc.SimpleType.getBaseType(field.type) || field.type
    ;

    
    if (baseType == "date" || baseType == "datetime") {
        var canEdit = (this.canEdit == true  && field.canEdit != false) ||
                      (this.canEdit != false && field.canEdit == true),
            isDateTime = isc.SimpleType.inheritsFrom(field.type, "datetime")
        ;
        if (canEdit) {
            if (isDateTime) {
                if (this.defaultEditableDateTimeFieldWidth != null) {
                    return this.defaultEditableDateTimeFieldWidth;               
                }                 
            } else {
                if (this.defaultEditableDateFieldWidth != null) {
                    return this.defaultEditableDateFieldWidth;               
                }
            }
        } else {
            if (isDateTime) {
                if (this.defaultDateTimeFieldWidth != null) {
                    return this.defaultDateTimeFieldWidth;
                }
            } else {
                if (this.defaultDateFieldWidth != null) {
                    return this.defaultDateFieldWidth;
                }                
            }
        }
    }
    if (baseType == "time") {
        if (this.defaultTimeFieldWidth != null) {
            return this.defaultTimeFieldWidth;
        }
    }

    var width;

    // special cases where we can avoid writing out and measuring content
    if (baseType == "icon" && (field.iconWidth != null || field.iconSize != null)) {
        width =  (field.iconWidth || field.iconSize) + 2*this.cellPadding + 2*this.iconPadding;
        
    } else if (this.showValueIconOnly(field)) {
        width = this.getValueIconWidth(field) + 2 * this.cellPadding +
                    this.getValueIconRightPadding(field) + this.getValueIconLeftPadding(field);
        // add the padding from the cell-style - it can be scaled by density
        width += isc.Element._getHPadding(this.baseStyle);
        
    } else {
        width = suppressAutoFitWidths ? null : this.getFieldContentWidth(field);
    }
    
    
    if (isc.isA.Number(width) && this.showFilterEditor && !this.leaveScrollbarGap &&
        this.fields != null && field === this.fields.last())
    {
        var sorterWidth = this._getSorterWidth(),
            minWidth = Math.min(width + sorterWidth, this.lastFieldMaxExpandWidth);
        if (width < minWidth) width = minWidth
    }

    return width;
},

//> @method listGrid.getFieldContentWidth()
// Returns the pixel width of the content of a visible field in this grid.
// @param field (ListGridField) field to test
// @return (Integer) drawn width of this fields content
// @visibility external
//<
getFieldContentWidth : function (field) {

    var width,
        fieldNum = this.getFieldNum(field),
        localFieldNum = this.getLocalFieldNum(fieldNum);
    var widths = this._getBodyColumnAutoSize(field.frozen, [localFieldNum]);
    width = widths ? widths[0] : null;
    if (width == null) width = field.width;
    return width;
},

getAutoFitWidthApproach : function (field) {
    if (field.autoFitWidthApproach != null) return field.autoFitWidthApproach;
    return this.autoFitWidthApproach;
},

draw : function (a,b,c,d) {

    if (isc._traceMarkers) arguments.__this = this;
    if (!this.readyToDraw()) return this;

    // default minHeight if not set from which LG autochildren are being shown
    if (this.minHeight == null) this.minHeight = this._getDefaultMinHeight();

    // set a flag that prevents sortChanged() from firing during initial draw
    this._firstDraw = true;

    // create children and set up fields if not already set up
    this.prepareForDraw();

    // call the superclass draw routine to do the actual drawing
    this.invokeSuper(isc.ListGrid, "draw", a,b,c,d);

    
    if (this.completeFields) {
        this._setupFieldWhenRules();
    }


    // clear the flag that prevents sortChanged() from firing during initial draw
    delete this._firstDraw;

    // get the actual rendered sizes of the columns
    this.body.getColumnSizes();

    
    for (var i = 0; i < this.bodies.length; i++) {
        var body = this.bodies[i];
        if (body._embeddedComponents) this.markForRedraw();
    }

    // if the sortFieldNum is specified, tell the header about it
    var sortFieldNum = this._getSortFieldNum();
    if (this.header && sortFieldNum != null && this.selectHeaderOnSort) {
        this.selectSortFieldHeaderButton();
    }

    // scroll the header along with the list (necessary for textDirection == RTL)
    this._syncBodyScrollForDraw(this.body.getScrollLeft(), this.body.getScrollTop());

    
    if (this.sorter) this.updateSorter();

    // If we have embedded components ensure that our initial auto-fit widths take
    // their size into account.
    if (this.body._embeddedComponents ||
        (this.frozenBody && this.frozenBody._embeddedComponents))
    {
        this.updateFieldWidthsForAutoFitValue("Initial draw with embeddedComponents");
    }
    
    this._wasEmptyForCanFocus = this.isEmpty();

    
    if (isc.Browser.isIE && this.header && this.headerSpans && this.autoFitWidthApproach == "both") {
        this.header.layoutChildren();
    }

    // Register for ruleContextChanged events so dynamic criteria can be re-evaluated
    if (!isc.isA.PickListMenu || !isc.isA.PickListMenu(this)) {
        this._observeRuleContextChanged();
    }        

    return this;
},

// Ensure on initial draw that the header scroll position matches body scroll position
_syncBodyScrollForDraw : function () {
    this.bodyScrolled(this.body.getScrollLeft(), this.body.getScrollTop());
},

// should we show inactive editors for every record - returns true if we have any data and
// alwaysShowEditors is true at the grid or field level [can check specific fields]
_alwaysShowEditors : function (field, ignoreTotalRows) {
    // ignoreTotalRows -- useful to test whether we would ever show editors in every cell
    // as opposed to whether we currently do.

    // if we have no data don't show any edit cells
    if (!ignoreTotalRows && this.getTotalRows() == 0) return false;

    if (this.alwaysShowEditors) return true;
    var fields = field ? [field] : this.fields;
    if (fields) {
        for (var i = 0; i < fields.length; i++) {
            if (fields[i].alwaysShowEditors) {
                return true;
            }
        }
    }
    return false;
},

prepareForDraw : function () {
    

    var pendingGroup = this.groupByField && !this.isGrouped;

    
    if (this.data) {
        this.data._deferCacheInvalidation = pendingGroup;
    }

    // call setFields() for the first time, if it hasn't already been done
    if (this.completeFields == null) this.setFields(this.fields);

    if (this.data) {
        delete this.data._deferCacheInvalidation;
    }

    // if alwaysShowEditors is true, ensure we are editing
    if (this.getEditRow() == null) {
        var forceEditing = this._alwaysShowEditors();
        if (forceEditing) this.startEditing(null,null,true,null,true);
    }

    

    // if grid is not grouped, and a grouping is already set, apply it with groupBy
    if (pendingGroup) {
            var fields = this.getGroupByFields();
            this.groupByField = null;

        // if we have no fields don't call groupBy yet - should occur on setFields
        //if (this.fields != null)
            this.groupBy(fields);
        }

    // create the header and body.
    this.createChildren();
},



//> @method listGrid.getGroupByFields()
// Get the current grouping of this listGrid as an array of fieldNames.
// <P>
// This method returns an array containing the names of the field(s) by which this
// grid is grouped (either from +link{listGrid.groupByField} having been explicitly set or
// from a call to +link{listGrid.groupBy()}). If this grid is not currently grouped, this method
// will return null.
// @return (Array of String) Current grouping for this grid. If grouped by a single field an array
//  with a single element will be returned.
// @visibility external
//<

getGroupByFields : function () {
    var fields = this.groupByField;
    if (fields != null && !isc.isAn.Array(fields)) {
        fields = [fields];
    }
    return fields;
},

//> @method listGrid.openGroup()
// Opens the node represented by the "record" parameter, if it is a folder and is not already
// open.  This method only applies to +link{ListGrid.groupBy,grouped} ListGrids.
// @param record (Record) node to open
// @return (boolean) true if the node was opened, false if it was not (either because it is not
//                   a folder, or because it was already open)
// @visibility external
//<
openGroup : function (record) {
    if (isc.isA.Tree(this.data) && record.isFolder) {
        if (!this.data.isOpen(record)) {
            this.openFolder(record);
            return true;
        }
    }
    return false;
},

//> @method listGrid.closeGroup()
// Closes the node represented by the "record" parameter, if it is a folder and is not already
// closed.  This method only applies to +link{ListGrid.groupBy,grouped} ListGrids.
// @param record (Record) node to close
// @return (boolean) true if the node was closed, false if it was not (either because it is not
//                   a folder, or because it was already closed)
// @visibility external
//<
closeGroup : function (record) {
    if (isc.isA.Tree(this.data) && record.isFolder) {
        if (this.data.isOpen(record)) {
            this.closeFolder(record);
            return true;
        }
    }
    return false;
},


prepareForDestroy : function (indirectDestroy) {
    if (this._dragLine) {
        this._dragLine.destroy();
        this._dragLine = null;
    }
    if (this._cornerMenu) this._cornerMenu.destroy();
    if (this.spanContextMenu) this.spanContextMenu.destroy();
    if (this.cellContextMenu) this.cellContextMenu.destroy();
    if (this._editRowForm) {
        this._editRowForm.destroy();
        delete this._editRowForm;
        delete this._editorShowing;
    }
    
    // ignore methods on the searchForm and set it to null
    if (this.searchForm) this.setSearchForm(null); 

    if (this.data){
        // if the data was autoCreated, destroy it to clean up RS<->DS links
        if (this.data._autoCreated && isc.isA.Function(this.data.destroy)) {
            this.data.destroy();
        } else {
            // ignore so we don't leak memory from the observation references
            this._ignoreData(this.data, true);
            delete this.data;
        }
    }
    // If we are grouped our ResultSet may be stored under this.originalData
    // Clean this up too (otherwise we can end up with the DataSource attempting to
    // notify a destroyed ListGrid via it's orphaned resultSet)
    if (this.originalData){
        if (this.originalData._autoCreated && isc.isA.Function(this.originalData.destroy)) {
            this.originalData.destroy();
        } else {
            this._ignoreData(this.originalData, true);
            delete this.originalData;
        }
    }

    if (this.selectionManager) {
        this.destroySelectionModel();
    }
    if (this.selectionCanvas) this.selectionCanvas.destroy();
    if (this.selectionUnderCanvas) this.selectionUnderCanvas.destroy();
    if (this.currentRollOverCanvas) this.currentRollOverCanvas.destroy();
    if (this.currentRollUnderCanvas) this.currentRollUnderCanvas.destroy();

    this._dropODSData();

    // RecordComponents:
    // - if pooling mode is recycled, destroy any created recordComponents sitting in our pool.
    // - if pooling mode is data, destroy any created recordComponents that got scrolled out
    //   of view and never destroyed.
    
    var recordComponents = this.getRecordComponentPool();
    if (recordComponents) {
        for (var i = 0; i < recordComponents.length; i++) {
            var comp = recordComponents[i];
            if (comp && comp.destroy && !comp.destroyed) {
                if (!comp.dontAutoDestroy) comp.destroy();
                else comp.deparent();
            }
        }
    }
    if (this._orphanedRecordComponents != null) {
        for (var ID in this._orphanedRecordComponents) {
            var comp = this._orphanedRecordComponents[ID];
            if (!comp || comp.destroyed || comp.destroying
                || comp._pendingDestroy)
            {
                continue;
            }
            if (!comp.dontAutoDestroy) comp.destroy();
            else comp.deparent();
        }
    }
    
    // Remove the hiddenResultSet used to notify on changes when data is provided as Array
    if (this.hiddenResultSet) this.hiddenResultSet.destroy();

    

    this.Super("prepareForDestroy", arguments);
},

//> @method listGrid.redrawHeader()
// Redraw just the +link{listGrid.header,grid header} 
//
// @param   rightNow (boolean) If true, redraw the grid header with a direct inline call
//          to its redraw() method.  Otherwise, 
//          +link{canvas.markForRedraw,mark the header for redraw}
// @visibility external
//<
redrawHeader : function(rightNow) {
    var headerLayout = this.headerLayout || this.header;
    if (headerLayout) {
        if (rightNow) {
            headerLayout.redraw(this.ID + ": redrawHeader()");
        } else {
            headerLayout.markForRedraw(this.ID + ": redrawHeader()");
        }
    }
},

//> @method listGrid.getBaseStyle()
// Return the base styleName for this cell.  Has the following implementation by default:
// <ul>
// <li>If +link{listGrid.editFailedBaseStyle, this.editFailedBaseStyle} is defined, and the
//     cell is displaying a validation error return this value.</li>
// <li>If +link{listGrid.editPendingBaseStyle, this.editFailedPendingStyle} is defined, and
//     the cell is displaying an edit value that has not yet been saved (see
//     +link{ListGrid.autoSaveEdits}) return this value.</li>
// <li>Otherwise return +link{ListGrid.recordBaseStyleProperty, record[listGrid.recordBaseStyleProperty]},
//     if defined, otherwise +link{ListGridField.baseStyle, field.baseStyle}.</li>
// </ul>
// If no custom style is found for the cell as described above, the default baseStyle will be
// returned. If +link{listGrid.baseStyle} is specified this will be used. Otherwise for
// grids showing fixed height rows which match +link{listGrid.normalCellHeight}
// +link{listGrid.normalBaseStyle} will be used. For grids with variable, or modified
// cell heights, +link{listGrid.tallBaseStyle} will be used.
// <P>
// Note also that
// enabling +link{listGrid.fastCellUpdates} will cause the <code>tallBaseStyle</code> to be
// used rather than +link{listGrid.normalBaseStyle}.
// <P>
// As noted under +link{listGrid.enforceVClipping}, cell content which renders taller than the
// available space within a cell may cause rows to expand even if +link{listGrid.fixedRecordHeights} 
// is true. This can lead to misaligned rows when frozen columns are used.
// Developers should be aware that changing cell styling such that there is increased
// borders or padding will reduce the available space for content within the specified cell height,
// making this scenario more common. To fix this, specify a larger cellHeight, or set
// enforceVClipping to true.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param   record (ListGridRecord) Record associated with this cell. May be <code>null</code>
//                                  for a new edit row at the end of this grid's data set.
// @param   rowNum  (number)    row number for the cell
// @param   colNum  (number)    column number of the cell
// @return  (CSSStyleName)  CSS class for this cell
// @visibility external
// @see getCellStyle()
// @example replaceStyle
//<
getBaseStyle : function (record, rowNum, colNum) {

    
    if (this.canEdit == true && !this.isPrinting) {
        if (this.editFailedBaseStyle && this.cellHasErrors(rowNum, colNum))
            return this.editFailedBaseStyle;

        if (this.editPendingBaseStyle && this._cellHasChanges(rowNum, colNum, false, true))
            return this.editPendingBaseStyle;
    }

    if (this.originBaseStyle && this.selectionManager._isCellSelectionOrigin(rowNum, colNum)) {
        return this.originBaseStyle;
    }

    if (record && this.recordBaseStyleProperty && record[this.recordBaseStyleProperty])
        return record[this.recordBaseStyleProperty];

    var field = this.getField(colNum);
    if (field && field.baseStyle) return field.baseStyle;

    if (field && field.type == "summary" && this.recordSummaryBaseStyle)
        return this.recordSummaryBaseStyle;

    if (field && field.frozen && !this._suppressedFrozenFields && this.frozenBaseStyle) {
        return this.frozenBaseStyle;
    }

    if (this.isPrinting && (this.printBaseStyle != null)) return this.printBaseStyle;

    var baseStyle = this.baseStyle,
        typeBaseStyle = "regular";
    if (baseStyle == null) {
        if (this.cellHeight != this.normalCellHeight ||
            
            this.fastCellUpdates ||
            this.allowRowSpanning ||
            !this.shouldFixRowHeight(record, rowNum) ||
            
            (record != null && this._hasEmbeddedComponents(record)))
        {
            baseStyle = this.tallBaseStyle;
            typeBaseStyle = "tall";
        } else {
            baseStyle = this.normalBaseStyle;
            typeBaseStyle = "normal";
        }
    }
    return baseStyle;
},

//> @method listGrid.getCellCSSText()
// @include gridRenderer.getCellCSSText()
// @example addStyle
//<
getCellCSSText : function (record, rowNum, colNum) {
    var field = this.getField(colNum),
        cssText;

    // per-record cssText
    if (record) {
        
        if (this.fieldSourceGrid == null && field != null && this.showValueIconOnly(field)) {
            
            if (!record._isGroup || this.canCollapseGroup ||
                !this._shouldUseGroupNodeHTML(this.getFieldBody(colNum), colNum,
                                              this._isGroupTitleField(field)))
            {
                cssText = "line-height:0px;";
            }
        }

        var recordCSSText = record[this.recordCSSTextProperty];
        if (recordCSSText != null) {
            return cssText != null ? cssText + recordCSSText : recordCSSText;
        }
    }

    var removedCSSText = this.removedCSSText;
    if (this.recordMarkedAsRemoved(rowNum) && removedCSSText) {
        cssText = cssText != null ? cssText + removedCSSText : removedCSSText;
    } else {

        if (this.hasBeenEdited(rowNum)) {
            var editCSSText;
            if (this.editFailedBaseStyle == null && (editCSSText = this.editFailedCSSText) &&
                this.cellHasErrors(rowNum, colNum))
            {
                cssText = cssText != null ? cssText + editCSSText : editCSSText;
            } else if (this.editPendingBaseStyle == null && (editCSSText = this.editPendingCSSText) &&
                this._cellHasChanges(rowNum, colNum, false, true))
            {
                cssText = cssText != null ? cssText + editCSSText : editCSSText;
            }
        }
    }

    
    if (!this.body._drawRecordAsSingleCell(rowNum, record)) {
        cssText = this.getRecordHiliteCSSText(record, cssText, this.getField(colNum), true);
    }
    if (cssText && !cssText.endsWith(isc.semi)) cssText += isc.semi;
    return cssText;

},

//> @method listGrid.getRawCellValue()
//      @group  data
//          return the raw data for one particular cell in the list
//
//      @param  record      (Object)    a record in the data
//      @param  recordNum   (number)    number of that record (in case it's important for the output)
//      @param  fieldNum    (number)    number of the field to display
//
//      @return (String)    raw value for this cell
//<

getRawCellValue : function (record, recordNum, fieldNum, isFieldName) {
    return this._getRawCellValue(
        this.emptyCellValue, this.groupSummaryRecordProperty, this.gridSummaryRecordProperty,
        null, null, this.data, this.applyFormulaAfterSummary, null, null, null, null,
        record, recordNum, fieldNum, isFieldName);
},
_getRawCellValue : function (
    emptyCellValue, groupSummaryRecordProperty, gridSummaryRecordProperty,
    fieldsHaveUserFormulas, fieldsHaveUserSummaries, data, applyFormulaAfterSummary,
    fieldHasUserFormula, fieldUserFormula, fieldHasUserSummary, fieldUserSummary,
    record, recordNum, fieldNum, isFieldName)
{
    // If `getRawCellValue()` is overridden in a subclass then use that.
    if (this.getRawCellValue != isc.ListGrid.getInstanceProperty("getRawCellValue")) {
        return this.getRawCellValue(record, recordNum, fieldNum, isFieldName);
    }

    var field,
        fieldName,
        dataPath;

    if (isFieldName) {
        fieldName = fieldNum
        // when fieldName specified, search completeFields if available
        field = this.completeFields ? isc.Class.getArrayItem(fieldName, this.completeFields, this.fieldIdProperty) : this.getField(fieldName);
    } else {
        field = this.fields[fieldNum];
        fieldName = field ? field[this.fieldIdProperty] : fieldName;
    }
    if (fieldHasUserFormula == null) {
        fieldHasUserFormula = (field && field.userFormula != null);
    }
    if (fieldHasUserFormula && fieldUserFormula == null) {
        fieldUserFormula = field.userFormula;
    }
    if (fieldHasUserSummary == null) {
        fieldHasUserSummary = (field && field.userSummary != null);
    }
    if (fieldHasUserSummary && fieldUserSummary == null) {
        fieldUserSummary = field.userSummary;
    }
    
    dataPath = field ? this.getTrimmedFieldDataPath(field) : null;

    if (fieldName == null && dataPath == null) return emptyCellValue;
    // Note even if fieldName is set, field is not guaranteed to be present - this could
    // be a displayField which is being rendered in a different field's cell

    var editValue, value, undef;
    
    if (this._editRowMap != null && this._editRowMap[recordNum] != null) {
        editValue = this._getEditValue(recordNum, fieldNum);
    }

    if (editValue !== undef) {
        // This ensures that the value for the cell as it is currently stored for local editing
        // is displayed, rather than the saved value of the cell.
        
        return editValue;
    // record can be null if there's no record for this cell
    } else if (record == null) {
        return emptyCellValue;

    // show the result of getRecordSummary for summary fields
    
    } else if (field && field.type == this._$summary) {
        value = record[this._getRecordSummaryAttributeProperty(field)];

    // Default - just look at the record.
    } else {

        // let the dataset return a value if it supports doing so
        
        if (data.getFieldValue && field) {
            value = data.getFieldValue(record, dataPath, field, this, "getRawValue");

        } else if (record.ownerDocument && field) {
            // if working with XML, fetch values via XPath selectors if so configured.  (Needed
            // for viewing XML elements when not dataBound, but could be moved to be a built-in
            // feature of both List and native Array)
            
            value = isc.xml.getFieldValue(record, fieldName, field);
        } else {
            // If this is a group header or group summary node, no need to worry about
            // dataPaths/complex types. Just rely on the record[fieldName] check below.
            
            if (!record._isGroup && !record[this.groupSummaryRecordProperty]) {
                value = isc.Canvas._getFieldValue(dataPath, field, record, this, true, "getRawValue");
            }
            if (value == null) value = record[fieldName];
        }
    }

    // if the field has a 'getRawCellValue' attribute
    
    if (field && field.getRawCellValue) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "getRawCellValue", "viewer,record,recordNum,field,fieldNum,value");

        // call it as a function (returns string | null)
        value = field.getRawCellValue(this, record, recordNum, field, fieldNum, value);
    }

    // handle user-formula and user-summary fields
    
    if (field) {

        if (this._shouldApplyUserFormulaAfterSummary(
                applyFormulaAfterSummary, fieldHasUserFormula, field) &&
            this._shouldShowUserFormula(
                groupSummaryRecordProperty, applyFormulaAfterSummary, field, record))
        {
            var currentUserFormula = field.userFormula;
            field.userFormula = fieldUserFormula;
            value = this.getFormulaFieldValue(field, record);
            field.userFormula = currentUserFormula;
        }
        // note: actual value computed later (after formatters have been applied
        // to raw value) - see getSummaryFieldValue() call in getFormattedCellValue
        if (fieldHasUserSummary) {
            var currentUserSummary = field.userSummary;
            field.userSummary = fieldUserSummary;
            this.getSummaryFunction(field);
            field.userSummary = currentUserSummary;
        }
    }
    return value;
},

// shouldShowRecordSummary - returns true if this is a summary field unless
// this is a summary row and there's an explicit summaryFunction (which takes precedence over
// any record summary function).

_$summary:"summary",
shouldShowRecordSummary : function (field, record) {
    return this._shouldShowRecordSummary(
        this.groupSummaryRecordProperty, this.gridSummaryRecordProperty, field, record);
},
_shouldShowRecordSummary : function (
    groupSummaryRecordProperty, gridSummaryRecordProperty, field, record)
{
    if (field && field.type == this._$summary) {
        if (record[groupSummaryRecordProperty]) {
            return (field.summaryFunction == null && field.getGroupSummary == null);
        
        } else if (record[gridSummaryRecordProperty]) {
            return (field.summaryFunction == null && field.getGridSummary == null);
        }
        return true;
    }
    return false;
},

// shouldShowUserFormula - As with record summaries, if you have a formula field
// you likely do not want the field-level record-formula to show in a summary row
// - instead the grid or group summary should be displayed as the field value.
shouldShowUserFormula : function (field, record) {
    return this._shouldShowUserFormula(
        this.groupSummaryRecordProperty, this.applyFormulaAfterSummary, field, record);
},
_shouldShowUserFormula : function (
    groupSummaryRecordProperty, applyFormulaAfterSummary, field, record)
{
    var isSummary = this._isSummaryRow ||
                     (record && record[groupSummaryRecordProperty]);
    if (isSummary && !this.__applyFieldFormulaAfterSummary(applyFormulaAfterSummary, field)) {
        return false;
    }
    return true;
},

//> @attr listGrid.applyFormulaAfterSummary (Boolean : false : IRW)
// If +link{listGridField.userFormula} is set for some field, and this grid is showing
// +link{listGrid.showGroupSummary,group summaries} or a
// +link{listGrid.showGridSummary,grid summary}, this property determines what field value
// should be present in those summary rows. Should the field apply the user-formula to the
// calculated summary row, or should it apply a standard grid or group summary to the
// user-formula values displayed in the grid?
// <P>
// May be overridden at the field level via +link{listGridField.applyAfterSummary}
// @visibility external
//<

applyFormulaAfterSummary:false,




//> @attr listGrid.skipHiddenUserSummaryFields (boolean : null : IRW)
// Controls whether hidden fields are included when user formulas are calculated
// for fields where +link{listGridField.applyAfterSummary} is false (also
// controls "record summary" fields - where the field type is "summary").
//<
//> @attr listGrid.skipHiddenGridSummaryFields (boolean : null : IRW)
// Controls whether calculation of grid summaries does anything for
// hidden fields.  If this property is true, grid summaries will only
// be calculated for visible fields.
//<
//> @attr listGrid.skipHiddenGroupSummaryFields (boolean : null : IRW)
// Controls whether calculation of group summaries does anything for
// hidden fields.  If this property is true, group summaries will only
// be calculated for visible fields.
//<

//> @attr listGrid.refreshDependentFieldsForSummaries (Boolean : true : IRW)
// When summaries are refreshed, and a list of fields is passed to limit what's refreshed,
// should the dependent fields automatically be added to ensure they're included?
//<
refreshDependentFieldsForSummaries: true,

// If we have a formulaField, how should the cell value in a summary row be calculated?
// if applyFormulaAfterSummary is true we'll calculate summary row values and apply
// the field-formula to that calculated row. Otherwise we will display "normal" summary
// values for the field in the row (for example summing all the calculated values in the
// formula field).
_applyFieldFormulaAfterSummary : function (field) {
    return this.__applyFieldFormulaAfterSummary(this.applyFormulaAfterSummary, field);
},
__applyFieldFormulaAfterSummary : function (applyFormulaAfterSummary, field) {
    var applyAfterSummary = field && field.applyAfterSummary;
    if (applyAfterSummary == null) applyAfterSummary = applyFormulaAfterSummary;
    if (applyAfterSummary == null) applyAfterSummary = false;
    //this.logWarn("For field:" + field.name + ", applyFormulaAfterSummary:" + applyAfterSummary);
    return applyAfterSummary;
},

_getCheckboxValueIconHTML : function (isSel, isPartial, canSelect, disabled, field) {
    var icon,
        iconStyle;
    if (!canSelect) {
        // record cannot be selected but we want the space allocated for the checkbox anyway.
        icon = isc.Canvas._$blank;
    } else {
        var isPrinting = this.isPrinting;

        // checked if selected, otherwise unchecked
        var booleanBaseStyle = (isPrinting
                                ? this.printBooleanBaseStyle || this.booleanBaseStyle
                                : this.booleanBaseStyle);
        if (isSel) {
            if (isPartial) {
                icon = (isPrinting
                        ? this.printCheckboxFieldPartialImage || this.checkboxFieldPartialImage ||
                          this.printBooleanPartialImage || this.booleanPartialImage
                        : this.checkboxFieldPartialImage || this.booleanPartialImage);
                iconStyle = booleanBaseStyle == null ? null : booleanBaseStyle + "Partial";
            } else {
                icon = (isPrinting
                        ? this.printCheckboxFieldTrueImage || this.checkboxFieldTrueImage ||
                          this.printBooleanTrueImage || this.booleanTrueImage
                        : this.checkboxFieldTrueImage || this.booleanTrueImage);
                iconStyle = booleanBaseStyle == null ? null : booleanBaseStyle + "True";
            }
        } else {
            icon = (isPrinting
                    ? this.printCheckboxFieldFalseImage || this.checkboxFieldFalseImage ||
                      this.printBooleanFalseImage || this.booleanFalseImage
                    : this.checkboxFieldFalseImage || this.booleanFalseImage);
            iconStyle = booleanBaseStyle == null ? null : booleanBaseStyle + "False";
        }
        if (icon == null) icon = isc.Canvas._$blank;
    }
    // if the record is disabled, make the checkbox image disabled as well
    if (disabled) {
        var spriteConfig = isc.Canvas._getSpriteConfig(icon);
        if (spriteConfig != null) {
            if (spriteConfig.src != null && spriteConfig.src != isc.Canvas._$blank) {
                spriteConfig.src = isc.Img.urlForState(spriteConfig.src, false, false, isc.StatefulCanvas.STATE_DISABLED);
            }
            if (spriteConfig.cssClass != null) {
                spriteConfig.cssClass += isc.StatefulCanvas.STATE_DISABLED;
            }
        } else {
            if (icon != isc.Canvas._$blank) icon = isc.Img.urlForState(icon, false, false, isc.StatefulCanvas.STATE_DISABLED);
        }
        if (iconStyle != null) iconStyle += isc.StatefulCanvas.STATE_DISABLED;
    }

    return this.getValueIconHTML(icon, iconStyle, field);
},

//> @method listGrid.getCellValue()   ([A])
//          Obtains the display value for a specific cell according to the given input
//          parameters.<br>
//          To format the value displayed in the cell, make use of the
//          +link{listGrid.formatCellValue(),formatting} methods rather than 
//          overriding this method directly.
//      @visibility external
//      @group  data
//
//      @param  record      (Object)    the current record object
//      @param  recordNum   (number)    number of the record in the current set of displayed
//                                      record (e.g. 0 for the first displayed record)
//      @param  fieldNum    (number)    number of the field in the listGrid.fields array
//
//      @see    method:ListGrid.formatCellValue
//      @return (String)    display value for this cell
//<
_$HR:"<HR>",
getCellValue : function (record, recordNum, fieldNum, gridBody) {
    if (gridBody == null) gridBody = this.getFieldBody(fieldNum);

    // If we're handed an empty record, we may be looking at a new edit row - if so get
    // the edit values instead
    if (record == null) {
        if (this._isNewRecordRow(recordNum)) {
            return this.getNewRecordRowCellValue();
        }
        record = this._getEditValues(recordNum, fieldNum);
    } else {

        // Special cases:
        // if it's a separator row, return a horizontal rule
        
        if (record[this.isSeparatorProperty]) return this._$HR;

        // group controller node - write out the groupNodeHTML
        if (record._isGroup && fieldNum != null) {

            var currentField = this.fields[fieldNum],
                isGroupTitleField = this._isGroupTitleField(currentField)
            ;
            if (this.showGroupSummaryInHeader && this.showGroupSummary && 
                currentField.name == record.groupName) 
            {
                
                var summaries = record._groupSummaryData && record._groupSummaryData[0];
                if ((!summaries || !summaries[currentField.name]) && !isGroupTitleField) {
                
                    return isc.nbsp;
                }
            }

            // If we're showing multiple fields and we're not showing a summary in the
            // header, explicitly empty all fields except the groupTitleField
            var isCheckboxField = this.isCheckboxField(this.getField(fieldNum));
            var isRowNumberField = this.isRowNumberField(this.getField(fieldNum));

            if (this._shouldUseGroupNodeHTML(gridBody, fieldNum, isGroupTitleField)) {
                return this.getGroupNodeHTML(record, gridBody);

            } else if (isCheckboxField ? !this.canSelectGroups :
                        (isRowNumberField || !this.showGroupSummaryInHeader))
            {
                return isc.nbsp;
            }
        }
    }

    // get the actual data record
    var field = this.fields[fieldNum],
        value = null;

    // if field is null, we've shrunk the number of columns, so forget it
    if (field == null) return isc.emptyString;

    // if this is a summary row and the field has a summaryValue specified, return that - all
    // the special fields (rowNumber, checkbox, expansion, remove) set this value to "&nbsp;"
    if (this._isSummaryRow && field.summaryValue) {
        return field.summaryValue;
    }
    // If this is the checkboxField, write out the checkbox HTML
    
    if (this.isCheckboxField(field)) {
        var isCellSelection = this.selectionManager.isA("CellSelection"),
            isSelected;
        if (isCellSelection) isSelected = !!this.selectionManager.isSelected(record, fieldNum);
        else isSelected = !!this.selectionManager.isSelected(record, recordNum);
        return this._getCheckboxValueIconHTML(isSelected,
                   this.showPartialSelection && 
                   !!this.selectionManager.isPartiallySelected(record, recordNum),
                   this.body.canSelectRecord(record),
                   record && record[this.recordEnabledProperty] == false, field);
    }

    // Determine whether we should be showing JUST a valueIcon
    // Do this before we figure out other HTML to avoid calculating stuff we're not going to
    // actually use.
    var icon,
        iconStyle,
        iconOnly = this.showValueIconOnly(field),
        isEditCell;
    if (record != null) {
        
        if (record[this.singleCellValueProperty] != null) {
            return record[this.singleCellValueProperty];
        }

        if (Array.isLoading(record)) {
            
            if (!isc.Browser.isSafari || fieldNum == 0) {
                return this.loadingMessage;
            }
            return isc.nbsp;
        }

        // If we are currently editing there are three possibilities for what we should write
        // out for each cell:
        // - This cell is being edited -- write out the edit form's element HTML
        // - This cell has pending edit values, but is not currently being edited.
        //   (this can happen if we're editing another cell in this row, or if an edit was not
        //   successfully saved for this cell) -- display the edit values.
        // - This cell should display the value for the record (default behavior)
        // We catch the first case here, and write out the edit-form item into the cell if
        // appropriate.
        // The other two cases will be handled by 'getRawCellValue()', which will check for
        // the presence of editValues on a cell.
        

        // if rowSpanning is enabled, and the user starts editing a row that
        // is spanned by some cell, behavior is governed by rowSpanEditMode:
        // - if rowSpanEditMode is "first", canEditCell will return false for the
        //   logical cell so we won't show an editor in the cell.
        // - otherwise, we show an editor in the cell and populate it with values
        //   based on the edit row.
        //   This means the value displayed in the editor will come from the
        //   edit-row, whereas the value displayed while not in edit mode comes from
        //   the first spanned record (by default).
        //   In this case the edit-value displayed may be different to the static
        //   value displayed in the spanning cell.
        //   The developer might use this mode if they have some advanced behavior like
        //   custom formatters that render a value for every spanned record, etc
        var editRowNum = this._editRowNum,
            editStartRow = editRowNum;
        if (editStartRow != null && this.allowRowSpanning) {
            editStartRow = this.getCellStartRow(editStartRow, fieldNum);
        }
        isEditCell = (this._editorShowing && editStartRow == recordNum &&
                      (!this.editByCell || this._editColNum == fieldNum) &&
                      
                      this._shouldShowEditCell(editRowNum,fieldNum));
        if (isEditCell) {
            var editRecord = record;
            if (editRowNum != recordNum) {
                editRecord = this.getCellRecord(editRowNum, fieldNum);
            }
            // Avoid writing out live form items if we're just getting HTML for the
            // GR auto-sizer canvas.
            
            if (gridBody._gettingAutoSizeHTML || this._gettingRowHeightSpacerHTML) {
                value =this.getInactiveEditorCellValue(editRecord, editRowNum, fieldNum, true);
            } else {
                value = this.getEditItemCellValue(editRecord, editRowNum, fieldNum);
            }
        // Checking for this._editorShowing would mean that when changing edit cell,
        // hideInlineEditor would render the row with no inactive editors, and they
        // wouldn't get shown again on showEditForm for the new cell without another
        // row-refresh
        } else if (this._showInactiveEditor(fieldNum) && this.canEditCell(recordNum,fieldNum)) {

            value = this.getInactiveEditorCellValue(record, recordNum, fieldNum);
            // set isEditCell -- this will suppress the standard 'valueIcon' stuff
            isEditCell = true;
        } else {
            // get the value according to the field specification
            var field = this.fields[fieldNum],
                displayFieldValue,
                pickUpDisplayFieldValue,
                undef;
            // If a displayField was specified on the field, and no separate optionDataSource,
            // we should display the value for the record from the displayField rather than the
            // data field.
            if (field.displayField != null) {
                pickUpDisplayFieldValue = !field.valueMap &&
                                          !field.getCellValue &&
                                          // this method actually checks for field.valueMap
                                          // being non null
                                          this._useDisplayFieldValue(field) &&
                                          // Do not pick up the display value if it is undefined
                                          // on the record, unless there is a current edited value 
                                          // for the field (because getRawCellValue() returns the
                                          // correct edited value in that case)
                                          (record[field.displayField] !== undef ||
                                           this._getEditValue(recordNum, field.displayField) != undef);

                if (pickUpDisplayFieldValue) {
                    var displayField = field.displayField;
                    displayFieldValue = this.getRawCellValue(record, recordNum, displayField, true);
                }
                // Note: we still need to proceed through the rest of the logic, since the
                // underlying data value drives the valueIcon
            }
            value = this.getRawCellValue(record, recordNum, fieldNum);
            
            // if the field has a 'getCellValue' attribute
            // NOTE: this is deprecated - overriding 'getCellValue()' at the Grid level is very
            // advanced, so for simple formatting (which is likely to be done at either the Field
            // or Grid level) we provide 'formatCellValue()' methods instead.)
            // Leave this code in place for Back-compat only.

            //>!BackCompat 2005.1.12
            if (field.getCellValue) {
                // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value"
                // Convert a string callback to a function
                isc.Func.replaceWithMethod(field, "getCellValue",
                                                 "viewer,record,recordNum,field,fieldNum,value");
                value = field.getCellValue(this, record, recordNum, field, fieldNum, value);
            }
            //<!BackCompat
            
            icon = this.getValueIcon(field, value, record, recordNum);
            iconStyle = this.getValueIconStyle(field, value, record, recordNum);
            
            // if we're ONLY showing an icon we don't really need to figure out the text from
            // the valueMap.
            if (!iconOnly) {

                // if the field has an 'valueMap' parameter, treat the value as a key in the map
                var valueMap = field.valueMap;
                if (valueMap) {
                    value = this.resolveValueMap(value, field.valueMap);
                }
            }

            if (pickUpDisplayFieldValue) value = displayFieldValue;
        }
    }

    if (!isEditCell) {
        // If this is a summary row, avoid calling formatCellValue at all if we're not showing
        // a summary for the field.
        if (record &&
            ((record[this.groupSummaryRecordProperty] && !this.shouldShowGroupSummary(field)) ||
             (this._isSummaryRow &&
                ((record[this.gridSummaryRecordProperty] && !this.shouldShowGridSummary(field))
                 || (field.showGridSummary == false))
             )
            )
           )
        {
            value = this.emptyCellValue;
        } else {

            // If this cell isn't showing an editor we may need to write out an icon
            
            var iconHTML = null;

            // only show an icon in group-rows if the field is showGroupSummary: true
            if (icon != null && (!record._isGroup || field.showGroupSummary)) {
                iconHTML = this.getValueIconHTML(icon, iconStyle, field, 
                        this.getValueIconCursor(field, record, value));
            }

            if (iconOnly) {
                // If there's no icon write out the empty cell value. This avoids us having
                // un-styled cells.
                if (!iconHTML || isc.isAn.emptyString(iconHTML)) iconHTML = this.emptyCellValue;
                value = iconHTML;

            } else {

                // apply hilites to capture htmlBefore/after
                var hilites = this.getFieldHilites(record, field);
                // Note hilites can == 0, so if(hilites) doesn't work

                var hiliteAfterFormat = field.hiliteHTMLAfterFormat;
                if (hiliteAfterFormat == null) hiliteAfterFormat = this.hiliteHTMLAfterFormat;
                if (hiliteAfterFormat == null) hiliteAfterFormat = true;


                if (hiliteAfterFormat) {
                    value = this._formatCellValue(value, record, field, recordNum, fieldNum);
                    // Note that hilites can == 0, so if (hilites) doesn't work
                    if (hilites != null) value = this.applyHiliteHTML(hilites, value);
                } else { 
                    if (hilites != null) value = this.applyHiliteHTML(hilites, value);
                    value = this._formatCellValue(value, record, field, recordNum, fieldNum);
                }

                if (iconHTML) {
                    if (field.valueIconOrientation != isc.Canvas.RIGHT)
                        value = iconHTML + value;
                    else
                        value = value + iconHTML;
                }
            }

            // Only show error icon HTML if we're not showing an editor for the cell - otherwise
            // we'd get doubled error icons.
            
            if (this.canEdit != false && this.showErrorIcons && this.cellHasErrors(recordNum, fieldNum)) {
                value = this.getErrorIconHTML(record, recordNum, fieldNum) + value;
            }

            // Add the hiliteIcons last
            var field = this.fields[fieldNum];
            var hilites = this.getFieldHilites(record, field);
            // Note that hilites can == 0, so if(hilites) won't work
            if (hilites != null) {
                if (!record || (record && !record.isGroupSummary) ||
                    (this.showHilitesInGroupSummary && field.showHilitesInGroupSummary != false))
                {
                    value = this.applyHiliteIcon(hilites, field, value);
                }
            }
        }
    }
    // if current field is the groupTitleField, add indentation to the cell value
    var gtf = this.isGrouped ? this.getGroupTitleField() : null;
    if (gtf && this.fields[fieldNum].name == gtf) {
        var groupIndent =
            isc.Canvas.spacerHTML(this.groupIndentSize + this.groupLeadingIndent, 1);
        value = groupIndent + value;
    }
    return value;
},

//> @method listGrid.cellValueIsClipped()
// @include gridRenderer.cellValueIsClipped()
//<
cellValueIsClipped : function (rowNum, colNum) {
    var body = this.getFieldBody(colNum);
    colNum = this.getLocalFieldNum(colNum);
    return body.cellValueIsClipped(rowNum, colNum);
},

resolveValueMap : function (value, valueMap) {
    // NOTE: this can be really expensive, since we may eval the function that
    // returns the value map for each record!!!
    if (isc.isA.String(valueMap)) valueMap = this.getGlobalReference(valueMap);
    // NOTE: don't look up displayed values in Array valueMaps, which just list legal
    // values, and don't provide stored->displayed value mappings.
    if (!isc.isAn.Array(valueMap)) {
        if (isc.isAn.Array(value)) {
            var displayValue = [];
            for (var i = 0; i < value.length; i++) {
                var dataVal = isc.getValueForKey(value[i], valueMap, value[i]);
                displayValue[displayValue.length] = dataVal;
            }
            value = displayValue;
        } else {
            value = isc.getValueForKey(value, valueMap);
        }
    }
    return value;
},

// Formula/summary -related overrides from DBC
getTitleFieldValue : function (record) {
    var titleField = this.getDataSource().getTitleField(),
        title = this.getCellValue(record, this.getRecordIndex(record),
            this.getFieldNum(titleField), this.body
    );

    if (!title || title == "") {
        title = this.getRawCellValue(record, this.getRecordIndex(record), titleField, true);
    }
    return title;
},

getRawValue : function (record, fieldName) {
    var recordIndex = this.getRecordIndex(record);
    
    return this.getRawCellValue(record, recordIndex, fieldName, true);
},

getFormattedValue : function (record, fieldName, value, alwaysFormatValue, forExport) {
    var recordIndex = this.getRecordIndex(record),
        field = this.getSpecifiedField(fieldName),
        fieldNum = this.getFieldNum(fieldName);

    if (this.fieldIsVisible(field) && value == null) {
        return this.getCellValue(record, recordIndex, fieldNum, this.body);
    }
    if (value == null) value = this.getRawValue(record, fieldName);
    // if the field has an 'valueMap' parameter, treat the value as a key in the map
    var valueMap = field ? field.valueMap : null;
    if (valueMap) {
        // NOTE: this can be really expensive, since we may eval the function that
        // returns the value map for each record!!!
        if (isc.isA.String(valueMap)) valueMap = this.getGlobalReference(valueMap);
        // NOTE: don't look up displayed values in Array valueMaps, which just list legal
        // values, and don't provide stored->displayed value mappings.
        if (!isc.isAn.Array(valueMap)) {
            if (isc.isAn.Array(value)) {
                var displayValue = [];
                for (var i = 0; i < value.length; i++) {
                    var dataVal = isc.getValueForKey(value[i], valueMap, value[i]);
                    displayValue[displayValue.length] = dataVal;
                }
                value = displayValue;
            } else {
                value = isc.getValueForKey(value, valueMap);
            }
        }
    }
    var ret = this._formatCellValue(value, record, field, recordIndex, fieldNum, 
                                    alwaysFormatValue, forExport);
    return ret;
},


// get the width of the specified field or null
getSpecifiedFieldWidth : function (fieldName) {

    var field = this.getField(fieldName);
    if (field == null) {
        // field may just be hidden - if so check for an explicit width on the
        // field object in our completeFields array and return that
        if (isc.isAn.Object(fieldName)) fieldName = fieldName[this.fieldIdProperty];
        field = this.getSpecifiedField(fieldName);
    }
    if (field == null) return;

    var fieldName = field[this.fieldIdProperty],
        members = this.header ? this.header.members : null,
        frozenMembers = this.frozenFields && this.frozenHeader ? this.frozenHeader.members : null,
        width;

    if (members || frozenMembers) {
        var member;
        
        if (members) member = members.find(this.fieldIdProperty, fieldName);
        if (!member && frozenMembers) {
            member = frozenMembers.find(this.fieldIdProperty, fieldName);
        }
        if (member) {
            // if there's a _userWidth and it's a number, a user resized it, so we want it in
            // the state 
            if (member._userWidth && isc.isA.Number(member._userWidth))
                width = member._userWidth;

        // If we don't have a member for the field, look at the specified width and
        // use it if possible.
        // This can happen if a field is currently hidden
        } else {
            if (field.width != null && isc.isA.Number(field.width)) {
                width = field.width;
            }
        }
    }
    return width;
},

//> @attr listGrid.iconCursor (Cursor : isc.Canvas.POINTER : IRW)
// Default cursor to display when the user rolls over icons within cells of an
// +link{listGridField.type,type:icon} field.
// <P>
// May be overridden by +link{listGridField.iconCursor}.
// <P>
// Note: Unlike the field-level +link{listGridField.iconCursor} property, listGrid.iconCursor
// has no effect on the cursor displayed for +link{listGridField.valueIcons,valueIcons}. <br>
// See +link{listGrid.getValueIconCursor()} for more details.
//
// @see listGrid.getIconCursor()
// @visibility external
//<
iconCursor : isc.Canvas.POINTER,

//> @method   listGrid.getIconCursor()
// Returns the cursor to display when the mouse pointer is
// over an +link{listGridField.icon,icon} in an <code>"icon"</code> type field.
// <P>
// Default behavior will display the +link{listGridField.iconCursor} if specified, otherwise
// the component level +link{listGrid.iconCursor}.
//
// @param field (ListGridField) field displaying the icon
// @return (Cursor) cursor to display when the user rolls over icons in this field's cells
//  @visibility external
//<
getIconCursor : function (field) {
    if (field.iconCursor) return field.iconCursor;
    else return this.iconCursor;
},

//> @method   listGrid.getValueIconCursor()
// Returns the cursor to display when the mouse pointer is
// over a +link{listGridField.valueIcons,valueIcon} in a a cell.
// <P>
// Default behavior will display the +link{listGridField.iconCursor} if specified, otherwise
// the <code>"pointer"</code> cursor if a +link{listGridField.valueIconClick} hander is present.
// (If no valueIconClick handler is defined this method will return null and the cursor will
// be unchanged when the user rolls over the value icon image).
//
// @param field (ListGridField) field displaying the valueIcon
// @param record (ListGridRecord) record being rolled over
// @param value (Any) value of this cell
//
// @return (Cursor) cursor to display when the user rolls over icons in this field's cells.
//           May be null indicating no special cursor to display.
//  @visibility external
//<
getValueIconCursor : function (field, record, value) {
    if (field.iconCursor != null) return field.iconCursor;
    if (this.showValueIconHandCursor(field)) return isc.Canvas.HAND;
},

showValueIconHandCursor:function (field) {
    return field.valueIconClick != null;
},


getValueIconHTML : function (icon, cssClass, field, cursor) {

    
    var prefix = field.imageURLPrefix || field.baseURL || field.imgDir,
        suffix = field.imageURLSuffix,
        width = this.getValueIconWidth(field),
        height = this.getValueIconHeight(field),
        leftPad = this.getValueIconLeftPadding(field),
        rightPad = this.getValueIconRightPadding(field)
    ;

    if (suffix != null) {
        // if icon was specified as a sprite, we may be passed the sprite config
        // (either string or object)
        // attach the suffix to the 'src' portion of the object.
        var spriteConfig = isc.Canvas._getSpriteConfig(icon),
            isConfigObj = spriteConfig != null;
        
        if (isConfigObj) icon = spriteConfig;
            
        var url = isConfigObj ? icon.src : icon;
            
        
            
        if (url != isc.Canvas._$blank) {
            url += suffix;
            if (isConfigObj) {
                icon.src = url;
            } else {
                icon = url;
            }
        }
    }
    
    var extraCSSText;
    if (cursor != null) {
        if (cursor == isc.Canvas.HAND && isc.Browser._usePointerCursorForHand) {
            cursor = isc.Canvas.POINTER;
        }
        extraCSSText = "cursor:" + cursor;
    }

    var iconHTML = isc.Canvas._getValueIconHTML(icon, prefix, cssClass, width, height,
                                      leftPad, rightPad,
                                      // no need for an ID
                                      null,
                                      // pass in the LG as an instance - required
                                      // for generating the path of the valueIcon src
                                      this,
                                      null, extraCSSText);
    return iconHTML;
},

//> @method listGrid.getCellAlign()
// Return the horizontal alignment for cell contents. Default implementation returns
// +link{listGridField.cellAlign} if specified, otherwise +link{listGridField.align}.
//
// @see getCellStyle()
//
// @param   record (ListGridRecord) this cell's record
// @param   rowNum  (number)    row number for the cell
// @param   colNum  (number)    column number of the cell
// @return  (Alignment)     Horizontal alignment of cell contents: 'right', 'center', or 'left'
// @visibility external
//<
getCellAlign : function (record, rowNum, colNum) {
    var isRTL = this.isRTL();
    // single cells are aligned according to RTL - skip checkboxField (which needs center align)
    if (record && record[this.singleCellValueProperty] != null &&
        (!this.showSingleCellCheckboxField(record) ||
         !this.isCheckboxField(this.getField(colNum)))
       )
    {
        return isRTL ? isc.Canvas.RIGHT : isc.Canvas.LEFT;
    }

    return this.getFieldCellAlign(colNum, isRTL);
},

// helper for getHeaderButtonTitle() - not dependent on field.cellAlign
getFieldHeaderAlign : function (fieldNum, isRTL) {
    var field = this.getField(fieldNum);
    if (!field) return isRTL ? isc.Canvas.RIGHT : isc.Canvas.LEFT;

    // This is set up in applyFieldDefaults if not explicitly specified on the field config
    var align = field.align;

    // If 'reverseRTLAlign' is true, flip the explicitly specified alignment.
    // This is true by default and makes sense for common cases where you really want
    // specified 'left' / 'right' to have the meaning of 'start'/'end'
    if (isRTL && this.reverseRTLAlign) {
        if      (align == isc.Canvas.RIGHT) align = isc.Canvas.LEFT;
        else if (align == isc.Canvas.LEFT) align = isc.Canvas.RIGHT;
    }
    return align;
},

getFieldCellAlign : function (fieldNum, isRTL) {

    var field = this.getField(fieldNum);

    if (!field) return isRTL ? isc.Canvas.RIGHT : isc.Canvas.LEFT;

    
    if (field.cellAlign == null && field.userFormula) {
        return isRTL ? isc.Canvas.LEFT : isc.Canvas.RIGHT;
    }
    // This is set up in applyFieldDefaults if not explicitly specified on the field config
    var align = field.cellAlign || field.align;
    // If 'reverseRTLAlign' is true, flip the explicitly specified alignment.
    // This is true by default and makes sense for common cases where you really want
    // specified 'left' / 'right' to have the meaning of 'start'/'end'
    if (isRTL && this.reverseRTLAlign) {
        if (align == isc.Canvas.RIGHT) align = isc.Canvas.LEFT;
        else if (align == isc.Canvas.LEFT) align = isc.Canvas.RIGHT;
    }
    return align;
},

// Helper method
// If we're showing a singleCellValue for a record, should we show the checkboxField to the
// left of the single value
showSingleCellCheckboxField : function (record) {
    return (this.getCurrentCheckboxField() != null) && record &&
            (this.canSelectGroups || !record._isGroup) && 
            !record[this.isSeparatorProperty];
},

//> @method listGrid.getCellVAlign()
// Return the vertical alignment for cell contents.
// Expected values are: 'top', 'center', or 'bottom'
//
// @see getCellStyle()
//
// @param   record (ListgridRecord) this cell's record
// @param   rowNum  (number)    row number for the cell
// @param   colNum  (number)    column number of the cell
// @return  (VerticalAlignment)     Vertical alignment of cell contents: 'top', 'center', or 'bottom'
// @visibility external
//<
// Unset by default


// Helper method:
// If a displayField was specified for a field, should we pick up the 'displayField' value for
// this record and display it here?
// Basically this makes sense if no optionDataSource was specified, unless overridden by a valueMap
_useDisplayFieldValue : function (field) {
    // no display field, or we have an explicit valueMap
    if (!field || field.valueMap || field.displayField == null ||
        (field.displayField == field.name))
    {
        return false;
    }

    // displayField and no explicit optionDataSource, pick up the value from the record
    // unless explicitly suppressed by the developer
    if (field.optionDataSource == null) {
        if (field.displayValueFromRecord == false) return false;
        return true;
    }

    // field has an optionDataSource and autoFetchDisplayMap is true - in this case we'll
    // fetch against the ODS and build a valueMap from the data we get back - so even if we don't
    // have a valueMap yet, we soon will!
    var fetchDisplayMap = field.autoFetchDisplayMap;
    if (fetchDisplayMap == null) fetchDisplayMap = this.autoFetchDisplayMap;
    if (fetchDisplayMap) return false;

    // At this point, if optionDataSource and valueField matches we'll use the
    // value from the record - however allow the developer to override this to either
    // a) force the display field value to be picked up (as if there was no ODS specified - somewhat
    // probable if autoFetchDisplayMap has been disabled, since the ODS has really no other meaning
    // to the grid) or
    // b) suppress the display field value even if the dataSources do match (for example may want
    // to show display-field values in edit mode only.
    if (field.displayValueFromRecord  != null) return field.displayValueFromRecord;

    // same dataSource / same valueField - pick up the value from the record.
    return (field.valueField == null || field.valueField == field.name) &&
            (isc.DS.get(field.optionDataSource) == this.getDataSource());
},

// Row Spanning
// ---------------------------------------------------------------------------------------

//> @attr listGrid.allowRowSpanning (Boolean : false : IR)
// Should cells in this grid be allowed to span multiple rows?
// If set to <code>true</code>, the +link{listGrid.getRowSpan()} method will be
// called for every cell when rendering out the listGrid to determine how many
// rows the cell should span.
// <P>
// See +link{listGrid.getRowSpan()} for more details
// @visibility external
//<
allowRowSpanning:false,

//> @method listGrid.getRowSpan()
// Return how many rows this cell should span.  Default is 1.
// <P>
// This method will only be called if +link{listGrid.allowRowSpanning} is set to
// <code>true</code>
// <P>
// When using row spanning, consider setting +link{useRowSpanStyling} to enable
// row-span-sensitive styling behaviors.
// <P>
// Note that the standard implementation assumes that the number of rows spanned by cells
// decreases or stays the same, starting with the first (leftmost) column in the grid and
// moving rightwards.
// <P>
// When using row spanning:
// <ul>
// <li> APIs that allow modifying the contents of cells (such as +link{getCellStyle()} or
// +link{listGridField.formatCellValue()}) will be called only once per row-spanning cell
// <li> when using +link{listGrid.canSelectCells,cell-based selection}, only the
// spanning cell is considered selected, and not any of the cells spanned through.  For
// example, if the cell at row 2 column 0 spans 2 cells, +link{CellSelection,CellSelection.isSelected()}
// will be true for 2,0 but false for 3,0.
// <li> if using incremental rendering (either horizontal or vertical),
// <code>getRowSpan()</code> may be called for a rowNum <b>in the middle of a spanning
// cell</b>, and should return the remaining span from that rowNum onward.
// <li> cell-level events such as +link{listGrid.recordClick()} will report the logical
// rowNum for spanned cells. In other words if a cell spans two rows, a different
// rowNum parameter will be passed to the recordClick handler depending on whether the user
// clicks at the top of the spanning cell or the bottom. Developers can normalize
// this to the starting cell via the +link{listGrid.getCellStartRow()} API.
// <li> for cells that span multiple records, editing behavior may be controlled by the
// +link{rowSpanEditMode, rowSpanEditMode} attribute.
// <li> rowSpanning can be used in conjunction with
//  +link{showRecordComponents(),recordComponents}. If record
// component are enabled on a grid with row-spanning cells the behavior is as follows:
//   <ul>
//    <li>Having +link{recordComponentPosition} set to "expand" is not currently supported
//        for grids that render out spanning cells.
//    <li>The method to retrieve / create record components will not be run for cells that
//        are "spanned". In other words if the first row in a grid spans 2 rows for some
//        field, the second logical row is "spanned" for that field - that cell doesn't
//        render any content and won't attempt to create a recordComponent.
//    <li>If +link{showRecordComponentsByCell} is false, the method to create record
//        components will be called for every non-spanned cell in the first column
//        of the grid.
//    <li>Percentage sizing of record components spanning multiple cells will be
//        calculated relative to the set of spanned cells.
//   </ul>
// </ul>
// <P>
// More generally, the ListGrid has a data model of one +link{Record} per row, and spanning cells
// doesn't fit well with this model, meaning that many ListGrid features are incompatible
// with rowSpanning.
//
// @include gridRenderer.getRowSpan()
// @visibility external
//<
// Note the limitation of row spanning never increasing going left to right comes up
// in a couple of spots:
// - the default selection model basically assumes the number of rows spanned is reducing
//   and performs a selection of all spanned cells in the row, moving rightwards
// - the getRowHeight implementation makes this assumption to ensure frozen body row
//   heights are correct (we have an undocumented flag to remove this limitation, but
//   this introduces some extra calculation that would have to run, making this undesirable
//   for many-columned grids).

//> @method listGrid.getCellRowSpan()
// @include gridRenderer.getCellRowSpan()
// @visibility external
//<

//> @method listGrid.getCellStartRow()
// @include gridRenderer.getCellStartRow()
// @visibility external
//<

//> @attr listGrid.useRowSpanStyling (boolean : null : IR)
// Enables various styling behaviors that potentially make sense when +link{getRowSpan()} has
// been overridden to introduce spanning cells, and spanning is largest on the left and
// smaller as cells go to the right.  Specifically:
// <ul>
// <li> computes +link{alternateRecordStyles,banded styling} based on the span of the
//      cell in the left-most column
// <li> enables +link{listGrid.canSelectCells,cell-level selection}, including
//      +link{useCellRollOvers,cell-level rollover} styling
// <li> enables row-span-sensitive cell selection.  See also +link{rowSpanSelectionMode}
//      for available behaviors
// </ul>
// <P>
// Because this setting enables +link{canSelectCells}, it is incompatible with any APIs
// that expect a record-oriented data model.
// <P>
// Because this setting only makes sense when row spanning decreases from the first column
// to the last, it has unspecified behavior with +link{listGrid.canReorderFields}.
//
// @visibility external
//<

//> @type RowSpanSelectionMode
// Behavior of selection when row spanning is active.  See +link{listGrid.useRowSpanStyling}.
// @value "forward" when a cell is clicked on, select any cells in subsequent columns which
//                  are at least partially spanned by the clicked cell
// @value "both"    when a cell is clicked on, selects any cells in any other columns which
//                  are at least partially spanned by the clicked cell
// @value "outerSpan" behaves like "forward", except as though the cell in the first column
//                    was clicked instead.  If the largest row spans are in the first
//                    column and all cells in subsequent columns do not extend out of the
//                    first cell's span, this creates a row-like selection model where the
//                    span of the left-most cell defines the "row" of cells being selected.
// @visibility external
//<

//> @attr listGrid.rowSpanSelectionMode (RowSpanSelectionMode : "forward" : IR)
// Chooses the selection mode when +link{useRowSpanStyling} is enabled.  See
// +link{RowSpanSelectionMode}.
//
// @visibility external
//<
rowSpanSelectionMode:"forward",

//> @attr listGrid.rowSpanEditMode (RowSpanEditMode : "first" : IRWA)
// If +link{listGrid.allowRowSpanning} is enabled, this property may be used to specify
// editing behavior for cells that span multiple rows.
// @visibility external
//<
rowSpanEditMode:"first",

//> @type RowSpanEditMode
// When +link{listGrid.allowRowSpanning} is enabled, certain cells may span multiple
// rows. In this case, the cell displays the value from the record in the first row.
// If the grid is +link{listGrid.canEdit,editable} (and the
// +link{listGridField.canEdit,field is also editable}), these settings allow the user
// to specify what happens to the data when the user edits this cell.
// <P>
// Note that in this scenario, a user may begin an edit on the row-spanning cell directly
// (via double-click for example), or on a cell in another column in any of the rows
// spanned by the cell. The appropriate behavior with respect to user-experience and how
// the data is manipulated will depend on the application in question. Developers may
// of course entirely disable editing for the field via +link{listGridField.canEdit} or
// +link{listGrid.canEditCell()}.
// <P>
// See also: +link{listGrid.useRowSpanStyling}
//
// @value "first" This setting assumes that only the field-value for the first record
//  spanned by this cell is significant. In this case the editor will only show for this
//  cell if the user is editing the first spanned record. If the user initialized the edit
//  on another spanned row, the editor will not show for this field.
// @value "each" This setting assumes that each row's values are logically separate, so if
//  a cell spans multiple rows, and a user initializes an edit on some cell in the
//  second spanned row, the spanning cell will show an editor containing the value for
//  the second spanned row. This may differ from the value displayed when not
//  in edit mode (which is derived from the first spanned row by default). This setting may
//  be useful for developers who which to implement their own logic on how to handle
//  spanning cell display values and/or edit values (for example by using custom
//  +link{listGridField.formatCellValue(),formatting} and applying custom logic to handle
//  editing on +link{listGridField.editorEnter} and +link{listGridField.editorExit}).
//
// @visibility external
//<


// Value Icons
// ---------------------------------------------------------------------------------------

_valueIconStyleTemplate:[
    "style='margin-left:",  // [0]
    ,                       // [1] - icon padding
    "px;margin-right:",     // [2]
    ,                       // [3] - icon padding
    "px;'"
],

//> @method ListGrid.getValueIcon()
// Returns the appropriate valueIcon for a cell based on the field and the data value for the
// cell. Default implementation returns null if +link{ListGridField.suppressValueIcon} is true
// otherwise looks at +link{ListGridField.valueIcons}.
// @param field (ListGridField) field associated with the cell
// @param value (Any) data value for the cell's record in this field.
// @param record (ListGridRecord) record associated with this cell
// @return (SCImgURL) url for the icon
// @group imageColumns
// @visibility external
//<
// We need the rowNum for checking whether the cell is editable
// calculate this from the record object via findRowNum(), but also support being passed an
// explicit rowNum for critical path code
getValueIcon : function (field, value, record, rowNum) {
    if (!field.valueIcons || field.suppressValueIcon) {
        if (this._formatBooleanFieldAsImages(field)) {
            var img;
            if (value) {
                img = (this.isPrinting
                       ? this.printBooleanTrueImage || this.booleanTrueImage
                       : this.booleanTrueImage);
            } else {
                img = (this.isPrinting
                       ? this.printBooleanFalseImage || this.booleanFalseImage
                       : this.booleanFalseImage);
            }
            // if the cell can't be edited and can be toggled, make sure it displays the
            // disabled checkbox icon
            rowNum = (rowNum != null) ? rowNum : this.findRowNum(record);
            var colNum = field.masterIndex;
            if (field.canToggle && img != isc.Canvas._$blank && !this.canEditCell(rowNum, colNum)) {
                var spriteConfig = isc.Canvas._getSpriteConfig(img);
                if (spriteConfig != null) {
                    if (spriteConfig.src != null) {
                        spriteConfig.src = isc.Img.urlForState(spriteConfig.src, 
                                                false, false, isc.StatefulCanvas.STATE_DISABLED);
                    }
                    // Directly append disabled state to class
                    
                    if (spriteConfig.cssClass != null) {
                        spriteConfig.cssClass += isc.StatefulCanvas.STATE_DISABLED;
                    }
                    img = spriteConfig;
                } else {
                    img = isc.Img.urlForState(img, false, false, isc.StatefulCanvas.STATE_DISABLED);
                }
            }
            if (img == isc.Canvas._$blank || img == null) {
                // If no image was specified, still write out a blank gif into the slot, by
                // using the special value "blank" - this allows us to recognize events over 
                // the (invisible) icon for canToggle behavior
                img = isc.Canvas._$blank;
            }
            return img;
        }
        return null;
    }
    var icon = field.valueIcons[value];
    return icon;
},

//> @method listGrid.getValueIconStyle() [A]
// Returns the CSS style for a cell based on the field and the data value for the cell.
// @param field (ListGridField) field associated with the cell
// @param value (Any) data value for the cell's record in this field.
// @param record (ListGridRecord) record associated with this cell
// @return (CSSStyleName) CSS style to use, or null if no style should be used
//<
getValueIconStyle : function (field, value, record, rowNum) {
    var booleanBaseStyle = (this.isPrinting ? this.printBooleanBaseStyle || this.booleanBaseStyle : this.booleanBaseStyle);
    if (booleanBaseStyle && field && (!field.valueIcons || field.suppressValueIcon)) {
        if (this._formatBooleanFieldAsImages(field)) {
            var imgStyle = booleanBaseStyle + (value ? "True" : "False");
            // if the cell can't be edited and can be toggled, make sure it displays the
            // disabled checkbox style
            rowNum = (rowNum != null) ? rowNum : this.findRowNum(record);
            var colNum = field.masterIndex;
            if (field.canToggle && !this.canEditCell(rowNum, colNum)) {
                imgStyle += isc.StatefulCanvas.STATE_DISABLED;
            }
            
            return imgStyle;
        }
    }
    return null;
},

// Helpers to get padding on each side of a field's valueIcon
getValueIconLeftPadding : function (field) {
    return (field && field.valueIconLeftPadding != null ? field.valueIconLeftPadding
            : this.valueIconLeftPadding || 0);
},

getValueIconRightPadding : function (field) {
    return (field && field.valueIconRightPadding != null ? field.valueIconRightPadding
            : this.valueIconRightPadding || 0);
},

// showValueIconOnly - returns true if the valueIcon should be displayed without any
// text value for some field.
_$boolean:"boolean",
showValueIconOnly : function (field) {
    if (field.showValueIconOnly != null) return field.showValueIconOnly;

    // See discussion near showValueIconOnly docs.
    // If we have a valueIcons map, with no vmap, return text AND icon
    // if we have both valueIcons and a vmap, return just the icon
    // if we have no icon map, obviously return text (and icon, which is null)
    if (field.valueIcons != null && field.valueMap != null) return true;

    // If we are looking at a boolean field for which we want to show just the checkbox images
    // return true - otherwise false
    return this._formatBooleanFieldAsImages(field);

},

//> @method ListGrid.getValueIconWidth()
// If some field is showing valueIcons, this method returns the width those items should render
// Default implementation derives this from the first specified of
// +link{ListGridField.valueIconWidth}, +link{ListGridField.valueIconSize},
// +link{ListGrid.valueIconWidth}, or +link{ListGrid.valueIconSize}
// @param field (Object) field for which we're retrieving the valueIcon width
// @return (number) width for the icon
// @group imageColumns
// @visibility internal
//<
getValueIconWidth : function (field) {

    if (this.isCheckboxField(field)) return this._getCheckboxFieldImageWidth();
    if (this._formatBooleanFieldAsImages(field)) return this.booleanImageWidth;

    return (field.valueIconWidth != null ? field.valueIconWidth  :
                (field.valueIconSize != null ? field.valueIconSize :
                    (this.valueIconWidth != null ? this.valueIconWidth : this.valueIconSize)));
},

//> @method ListGrid.getValueIconHeight()
// If some field is showing valueIcons, this method returns the height those items should render
// Default implementation derives this from the first specified of
// +link{ListGridField.valueIconHeight}, +link{ListGridField.valueIconSize},
// +link{ListGrid.valueIconHeight}, or +link{ListGrid.valueIconSize}
// @param field (Object) field for which we're retrieving the valueIcon height
// @return (number) height for the icon
// @group imageColumns
// @visibility internal
//<
getValueIconHeight : function (field) {
    if (this.isCheckboxField(field)) return this._getCheckboxFieldImageHeight();
    if (this.isExpansionField(field)) return this._getExpansionFieldImageHeight();
    if (this._formatBooleanFieldAsImages(field)) return this.booleanImageHeight;

    return (field.valueIconHeight != null ? field.valueIconHeight  :
                (field.valueIconSize != null ? field.valueIconSize :
                    (this.valueIconHeight != null ? this.valueIconHeight : this.valueIconSize)));
},

// New record row: optional special row added to encourage new record entry
// ---------------------------------------------------------------------------------------

_isNewRecordRow : function (recordNum) {
    return this.shouldShowNewRecordRow() && (recordNum == this.getTotalRows()-1);
},

//> @method ListGrid.getNewRecordCellValue()
//  Returns the contents to display in the new record row.
//  Note that this row displays a single cell spanning every column.
//  @return (String)    Value to display in new record row. Default
//                      implementation returns <code>"-- Add New Row --"</code>
//<
getNewRecordRowCellValue : function () {
    return '<div align="center">' + this.newRecordRowMessage + '</div>';
},

// ---------------------------------------------------------------------------------------
getErrorIconHTML : function (record, rowNum, colNum) {
    var errors = this.getCellErrors(rowNum, colNum);
    if (errors == null) return isc._emptyString;

    var HTML = this.imgHTML(this.errorIconSrc, this.errorIconWidth, this.errorIconHeight, null,
                            null, null, null, null, " isErrorIcon='true'");

    var isRTL = this.isRTL(),
        align = this.getCellAlign(record, rowNum, colNum),
        spaceOnLeft = ((isRTL && align === isc.Canvas.LEFT) ||
                       (!isRTL && align === isc.Canvas.RIGHT));

    // Since we're writing the icon out to the left of our content, write a spacer out to the
    // right of the image to give us some padding between the image and the cell content
    
    var spacerHTML;
    if (isc.Browser.isIE && this._editorShowing && this.getEditRow() == rowNum &&
        (!this.editByCell || this.getEditCol() == colNum))
    {
        spacerHTML = " ";
    } else {
        
        spacerHTML = isc.Canvas.spacerHTML(this.cellPadding, "auto");
    }

    if (spaceOnLeft) {
        HTML = spacerHTML + HTML;
    } else {
        HTML += spacerHTML;
    }

    return HTML;
},

// Handle events over the error icon by showing a hover containing the
// error text
_handleErrorIconOver : function (rowNum, colNum) {
    // Remember that the Over event has fired - used by the Hover and Out handlers
    this._overErrorIcon = [rowNum,colNum];
    // Call the user handler if present
    if (this.cellErrorIconOver &&
            this.cellErrorIconOver(this.getRecord(rowNum, colNum), rowNum, colNum) == false)
    {
        return;
    }
    // This will fire the method on a delay unless the hover is already up
    // in which case it'll update it immediately.
    isc.Hover.setAction(this, this._handleErrorIconHover);


},
_handleErrorIconHover : function (rowNum, colNum) {
    if (this._overErrorIcon == null) return;

    // Call the user handler if present
    if (this.cellErrorIconHover &&
            this.cellErrorIconHover(this.getRecord(rowNum, colNum), rowNum, colNum) == false)
    {
        return;
    }

    var rowNum = this._overErrorIcon[0],
        colNum = this._overErrorIcon[1];

    var errors = this.getCellErrors(rowNum, colNum);
    if (errors == null) return;

    var promptString = isc.FormItem.getErrorPromptString(errors);
    isc.Hover.show(promptString, this._getHoverProperties());
},

_handleErrorIconOut : function (rowNum, colNum) {
    // Clear the "Over event has fired" flag - or it won't fire again...
    delete this._overErrorIcon;
    // Call the user handler if present
    if (this.cellErrorIconOut &&
            this.cellErrorIconOut(this.getRecord(rowNum, colNum), rowNum, colNum) == false)
    {
        return;
    }

    
    if (isc.Hover.isActive && !isc.Hover._hoverHasFocus) {
        isc.Hover.clear();
    }
},


// _formatCellValue: Helper method to format the static cell value using developer defined
// formatCellValue() methods.
_$text:"text",
_formatCellValue : function (value, record, field, rowNum, colNum, alwaysFormatValue, forExport)
{
    if (field && field.userSummary) {
        value = this.getSummaryFieldValue(field, record);

    } else {
        // If this is a summary row (group or grid level) we support custom formatting.
        // If custom formatters (formatGroupSummary / formatGridSummary) are present, apply them
        // and don't then run through additional formatting logic.
        var customFormatApplied = false;
        if (record && record[this.groupSummaryRecordProperty]) {
            if (field && field.formatGroupSummary) {
                if (!isc.isA.Function(field.formatGroupSummary)) {
                    field.formatGroupSummary =
                        isc.Func.expressionToFunction("value", field.formatGroupSummary);
                }
                if (isc.isA.Function(field.formatGroupSummary)) {
                    value = field.formatGroupSummary(value);
                    customFormatApplied = true;
                }
            }
        }

        // If we're writing out cell values outside the grid - for example
        // row-hight-spacer HTML, column auto-size HTML, drag tracker row HTML, etc,
        // provide the dev with an option to format the value differently.
        // This allows devs to avoid pitfalls writing out elements with explicit
        // DOM IDs, and having them duplicated on the page, etc.
        if (this._gettingInactiveCellHTML(rowNum, colNum)) {
            if (field && field.formatInactiveCellValue != null) {
                value = field.formatInactiveCellValue(value,record,rowNum,colNum,this);
                customFormatApplied = true;
                
            // listGrid-wide formatter
            } else if (this.formatInactiveCellValue != null) {
                value = this.formatInactiveCellValue(value, record, rowNum, colNum);
                customFormatApplied = true;
            }
        }

        
        if (record && this._isSummaryRow) {
            if (field && field.formatGridSummary) {
                if (!isc.isA.Function(field.formatGridSummary)) {
                    field.formatGridSummary =
                        isc.Func.expressionToFunction("value", field.formatGridSummary);
                }
                if (isc.isA.Function(field.formatGridSummary)) {
                    value =  field.formatGridSummary(value);
                    customFormatApplied = true;
                }
            }
        }

        // If we already ran through group/grid summary formatters, don't run
        // standard cellFormatters on top of them!
        if (!customFormatApplied) {
            var valueFormat;

            if (field && field.formatCellValue != null) {
                value = field.formatCellValue(value,record,rowNum,colNum,this);

            } else if (field && field.cellValueTemplate) {
                // NOTE:
                // - probably don't need grid.cellValueTemplate, as this would be rare
                // - not exposed publicly yet
                // - might want XSLT option
                value = field.cellValueTemplate.evalDynamicString(this, {
                            value:value, record:record, field:field});
            // listGrid-wide formatter
            } else if (this.formatCellValue != null) {
                value = this.formatCellValue(value, record, rowNum, colNum);

            } else if ((valueFormat = forExport ? this.getDeclarativeFormat(field) :
                                                  field && field.format) &&
                       (isc.isA.Number(value) || isc.isA.Date(value)))
            {
                value = isc.isA.Number(value) ? isc.NumberUtil.format(value, valueFormat)
                                              :   isc.DateUtil.format(value, valueFormat);

            } else if (isc.CubeGrid && isc.isA.CubeGrid(this) &&
                       (isc.isA.Number(value) || isc.isA.Date(value)) &&
                       (valueFormat = this.getValueFormat(rowNum, colNum, forExport)) != null)
            {
                value = isc.isA.Number(value) ? isc.NumberUtil.format(value, valueFormat)
                                              :   isc.DateUtil.format(value, valueFormat);

            
            } else if (field && (alwaysFormatValue || this._shouldApplyTypeFormatters(field))) {

                
                value =  this.applyCellTypeFormatters(value, record, field, rowNum, colNum);
            }
        }
    }
    
    // formatValueAsString() performs final conversions such as catching the case
    // where the value is null or "" and mapping to "&nbsp;" in the cell
    // We already do this as part of "getDefaultFormattedValue()".
    // A custom formatCellValue implementation may call 'getDefaultFormattedValue()' directly
    // in this case 'formatValueAsString()' will actually run twice, but should have
    // no ill effects since since the string won't be further modified by a second pass
    // through this method.
    value = this.formatValueAsString(value, record, field, rowNum, colNum);

    // hook for final processing of the display value that is applied to the actual display
    // value as derived by the various other hooks
    
    if (this.formatDisplayValue) {
        value = this.formatDisplayValue(value, record, rowNum, colNum);
    }

    // support escapeHTML flag per field
    if (field && field.escapeHTML) {
        // don't escape "&nbsp;" or the emptyCellValue, though, since DataSourceField.emptyCellValue's
        // documented type is HTMLString
        if (isc.isA.String(value) && value != this._$nbsp &&
            (field.emptyCellValue == null || value != field.emptyCellValue))
        {
            value = value.asHTML(null, this.shouldSkipLineBreaks(field));
        }
    }

    return value;
},

// Overridden in TreeGrid to suppress double-applying type formatters to the Tree field cellvals
_shouldApplyTypeFormatters : function (field) {
    return field && !field._suppressTypeFormatting;
},

_gettingInactiveCellHTML : function (rowNum, colNum) {

    // drag tracker row:
    if (this._gettingDragTrackerHTML) return true;

    // column width measuring HTML
    var body = this.getFieldBody(colNum);
    if (body && body._gettingAutoSizeHTML) return true;

    // row height spacer HTML    
    if (body && body._gettingRowHeightSpacerHTML) return true;
    
    return false;
},

//> @method listGrid.getDefaultFormattedValue() [A]
// Get the value for some cell with default formatters applied.
// <P>
// This method is useful for cases where a developer wishes to
// conditionally customize a cell's formatting, but needs to see what
// the default formatted value would be.
// <P>
// For example - a developer might wish to apply a custom
// +link{ListGridField.formatCellValue(),formatter} to some
// <code>link</code> type field, and be able to return the default
// active link HTML in some cases. In this case a formatter could
// check for the conditions in which custom formatting should be applied
// and run appropriate custom logic to generate a value for display - otherwise
// return the result of this method to leave the standard formatted-value intact.
//
// @param record (Record) the cell's record object
// @param rowNum (int) rowNum for the cell
// @param colNum (int) colNum for the cell
// @return (String) Cell value with default formatters applied
// @see ListGridField.formatCellValue
// @visibility external
//<

getDefaultFormattedValue : function (record, rowNum, colNum) {
    var field = this.getField(colNum);
    var value = this.applyCellTypeFormatters(
                    this.getRawCellValue(record, rowNum, colNum),
                    record, field, rowNum, colNum
                );
    return this.formatValueAsString(value, record, field, rowNum, colNum);
},

//> @method listGrid.getDefaultFormattedFieldValue() [A]
// Get a field value for some record with default field formatters applied.
// <P>
// This method differs from +link{getDefaultFormattedValue()} in a couple of ways.
// Firstly, this method does not rely on the rowNum and colNum parameters to find the
// record and field in the grid.<br>
// Secondly, unlike +link{getDefaultFormattedValue()} this method <i>will</i> call
// any explicit cell formatter specified on the field passed in (though it will not
// call a +link{listGrid.formatCellValue(),component level formatter} if one exists).
// <P>
// This is useful for cases where a developer wishes to
// display a formatted value for some record and field combination which does not
// necessarily map to a cell displayed in the ListGrid.
// <P>
// If <code>rowNum</code> and <code>colNum</code> parameters are passed through to
// the field level cell formatter if one exists. If not explicitly provided these are
// defaulted to -1.
//
// @param record (Record) the record object
// @param field (ListGridField) the field object
// @param [rowNum] (int) rowNum (passed to any field level cell formatter)
// @param [colNum] (int) colNum (passed to any field level cell formatter)
// @return (String) Default formatted value
// @see ListGridField.formatCellValue
// @visibility external
//<

getDefaultFormattedFieldValue : function (record, field, rowNum, colNum) {
    var rawValue = isc.DataSource.getFieldValue(field, record);

    if (rowNum == null) rowNum = -1;
    if (colNum == null) colNum = -1;

    var value;
    if (field && field.formatCellValue != null) {
        value = field.formatCellValue(rawValue,record,rowNum,colNum,this);
    } else {
         value = this.applyCellTypeFormatters(rawValue, record, field, rowNum, colNum);
    }
    return this.formatValueAsString(value, record, field, rowNum, colNum);
},

// Apply type-formatters to a cell value.
applyCellTypeFormatters : function (value, record, field, rowNum, colNum, isMultipleElement) {
    if (!isMultipleElement && field && field.multiple && isc.isA.Array(value)) {
        var values = [];
        for (var i = 0; i < value.length; i++) {
            values[i] = this.applyCellTypeFormatters(value[i], record, field,
                                                    rowNum, colNum, true);
        }
        // multipleValueSeparator documented at the DataSource level
        return values.join(field.multipleValueSeparator || ", ");
    }

    // check for formatter defined on a SimpleType definition
    if (field && field._simpleType != null && field._simpleType.shortDisplayFormatter != null) 
    {
        value = field._simpleType.shortDisplayFormatter(value, field, this, record, rowNum, colNum);
    // We apply some standard (default) formatters to fields with particular data types.
    // NOTE: these should be moved to the built-in SimpleType definitions
    } else if (field && field._typeFormatter != null) {
        value = field._typeFormatter(value, field, this, record, rowNum, colNum);
    }

    // Note: this method does *not* run if there is a custom formatter
    // applied to a field (including a custom grid/group formatter for grid/group summary rows).
    //
    // apply the plural title if the special flag was set on the record
    if (value != null && !isc.isA.emptyString(value) &&
        record && field && record[this.recordApplyPluralTitleProperty])
    {
        var fieldNames = record[this.recordApplyPluralTitleProperty];
        if (fieldNames.contains(field.name)) {
            var title = field.pluralTitle;
            if (title == null) title = field.title;
            if (title != null) value += " " + title;
        }
    }
    // For summary rows where the summary method returned null (indicating unable to calculate a
    // summary), return the invalidSummaryValue if specified.
    if (value == null &&
        record && field &&
        this.invalidSummaryValue != null &&
        ((record[this.groupSummaryRecordProperty] && this.shouldShowGroupSummary(field)) ||
         (record[this.gridSummaryRecordProperty] && this.shouldShowGridSummary(field)))
       )
    {
        value = this.invalidSummaryValue;
    }

    return value;
},

// formatValueAsString: This takes a value to be displayed in a cell and ensures it displays
// correctly.
// This is run after any custom formatters / type-based formatters have been applied to
// the value.
formatValueAsString : function (value, record, field, rowNum, colNum) {

    // For "empty" values, write out the emptyCellValue
    
    if (value == null || isc.is.emptyString(value)) {
        // if the field specifies a 'emptyCellValue' (or 'emptyDisplayValue')
        if (this._resolveEmptyDisplayValue(field) != this.emptyCellValue) {
            // return the field-specific value
            value = this._resolveEmptyDisplayValue(field);
        } else if (field.type == "summary") {
            value = this.invalidSummaryValue;

        } else {
            // otherwise return the emptyCellValue for the entire list
            value = this.emptyCellValue;
        }

    // In IE, an element containing only whitespace characters (space or enter) will not show css
    // styling properly.
    
    } else if (this._emptyCellValues[value] == true) {
        value = this._$nbsp;

    // convert the value to a string if it's not already
    } else if (!isc.isA.String(value)) {
        // For date type values we want to respect dateFormatter / timeFormatter specified at the
        // field or component level.
        // If the specified fieldType is "date", "datetime" or "time" this is already handled by the
        // _typeFormatter function (which calls formatDateCellValue / formatTimeCellValue for
        // these fields)
        
        if (isc.isA.Date(value)) {

            // We already know the "type" of this field is not "time" (as formatTimeCellValue)
            // would have run and converted it to a string already.
            // So we'll actually only format as time if the field has any explicit timeFormatter
            // and no explicit dateFormatter.
            if (this._formatAsTime(field)) {
                var formatter = this._getTimeFormatter(field);
                var isLogicalTime = isc.SimpleType.inheritsFrom(field.type, "time");
                value = isc.Time.toTime(value, formatter, isLogicalTime);
            } else {

                var isDatetime = field && isc.SimpleType.inheritsFrom(field.type, "datetime"),
                    isLogicalDate = !isDatetime && field && isc.SimpleType.inheritsFrom(field.type, "date"),
                    formatter = this._getDateFormatter(field);
                if (isDatetime) value = value.toShortDateTime(formatter, true);
                else value = value.toShortDate(formatter, !isLogicalDate);
            }
        } else {
            value = isc.iscToLocaleString(value);
        }
    }
    return value;
},

// these Strings can be considered to be "empty" cells, causing bad styling.  Replace with
// '&nbsp;'

_emptyCellValues:{" ":true, "\n":true, "\r":true, "\r\n":true},
_$nbsp:"&nbsp;",

//> @method listGrid.getEditItemCellValue()   ([IA])
//          Returns the HTML for a cell within a row that is being edited (as a result of a call
//          to 'editRow')<br>
//          Will <i>not</i> call 'updateEditRow()' to update the values displayed in the edit
//          row - this must be handled by calling methods, once we know the form element has
//          been written into the DOM.
//      @visibility internal
//      @group  editing
//
//      @param  record      (Object)    the current record object
//      @param  rowNum      (number)    index of the record containing this cell
//      @param  colNum      (number)    index of the field containing this cell
//
//      @return (String)    display value for this cell
//<
getEditItemCellValue : function (record, rowNum, colNum) {
    var itemName = this.getEditorName(rowNum, colNum);

    // If the editRowForm or item haven't yet been created, no op - implies this
    // is being called at an invalid time
    
    if (!this._editRowForm || !this._editRowForm.getItem(itemName)) {
        return "&nbsp;"
    }

    // Write a form item out into this cell.
    // We have already created the '_editRowForm' - a dynamic form with an appropriate set of
    // form items (see 'editRow').
    // Make use of the appropriate item's getStandaloneHTML() to write out the form element

    // If we have any errors for the field, set them on the form item too so the error icon
    // gets rendered out
    var errors = this.getCellErrors(rowNum, colNum);

    // get the HTML for the form item
    // Relies on the form item being present - this is fine as long as our logic to create
    // and remove edit form items for incremental rendering stays in sync with the set of
    // cells being written out.
    var item = this._editRowForm.getItem(itemName);
    
    var body = item.containerWidget;

    // FormItems have 2 notifications in the draw/redraw flow
    // drawing() (or redrawing()) which fires before the DOM is updated
    // drawn() or (redrawn()) which fires after the DOM is updated.
    // Fire drawing/redrawing now, then hang onto a list of drawn items so we can
    // fire drawn() / redrawn() when the DOM has been updated.
    
    if (item.isDrawn()) {
        item.redrawing();
    } else {
        // 'itemVisibilityChanged' parameter indicates whether the item is being shown/hidden
        // within an already drawn containerWidget, or whether the item is drawing as part
        // of the containerWidget draw() flow.
        item.drawing(body.isDrawn());
    }
        
    var HTML = item.getStandaloneItemHTML(item.getValue(), false, true);


    
    if (!body._drawnEditItems) body._drawnEditItems = [];
    if (!body._drawnEditItems.contains(item)) {
        body._drawnEditItems.add(item);
    }

    return HTML;
},

// should we show inactive version of the edit form item for some cell?
_showInactiveEditor : function (fieldNum) {
    return this._alwaysShowEditors(fieldNum);
},


// getInactiveEditorCellValue()
// If this.alwaysShowEditors is true, we write inactive versions of our edit form items in every
// row (with appropriate value displayed for the record in question)
getInactiveEditorCellValue : function (record, rowNum, colNum, suppressContext) {
    var itemName = this.getEditorName(rowNum, colNum);

    // get the HTML for the form item
    // Relies on the form item being present - this is fine as long as our logic to create
    // and remove edit form items for incremental rendering stays in sync with the set of
    // cells being written out.
    var item = this._editRowForm.getItem(itemName);
    // Don't crash if the form doesn't actually contain an item for this field.
    
    if (item == null) {
        return this.getFormattedValue(record, rowNum, colNum);
    }
    var editorType = isc.DynamicForm.getEditorType(item,this._editRowForm),
        value = this.getRawCellValue(record, rowNum, colNum),
        HTML;

    if (this.shouldShowEditorPlaceholder(this.getField(colNum),editorType)) {
        HTML = this.getEditorPlaceholderHTML(editorType, value, record,rowNum,colNum);
    } else {

        var context = {grid:this.getID(), record:record, rowNum:rowNum, colNum:colNum}
        HTML = item.getInactiveEditorHTML(value, false, true, context);

        // the inactiveEditorContext ID gets stored directly on the cell
        // When we refresh the cell we'll throw away this inactive context (and potentially create
        // another one)
        // We want to be able to map from row+colNum to contextID so we don't have
        // to iterate through all the inactiveContexts on all the form items
        
        if (!suppressContext) {
            if (!this._inactiveEditorContextMap) this._inactiveEditorContextMap = {};
            var row_col = "_" + rowNum + "_" + colNum;
            if (this._inactiveEditorContextMap[row_col]) {
                this.logWarn("creating new inactiveEditor context for a cell without having cleared " +
                    "the previous one." + this.getStackTrace(), "inactiveEditorHTML");
            }
            this._inactiveEditorContextMap[row_col] = context;
        }
    }

    
    return HTML;
},


// if we're showing editors for every record, if this method returns true, suppress showing
// inactive editorHTML and show simplified placeholder HTML instead for the field in question.
// This allows us to not have to ensure that every editorType supports inactiveHTML in an efficient
// manner.
shouldShowEditorPlaceholder : function (field, editorType) {

    if (field.showEditorPlaceholder != null) return field.showEditorPlaceholder;

    return !this._supportsInactiveEditorHTML[editorType];
},
// list of editorTypes that support inactiveEditorHTML for alwaysShowEditors:true

_supportsInactiveEditorHTML:{
    text:true, TextItem:true, 
    textArea:true, TextAreaItem:true,
    integer:true, IntegerItem:true, 
    float:true, FloatItem:true,
    
    select:true, SelectItem:true,
    combobox:true, ComboBoxItem:true,

    boolean:true, checkbox:true, CheckboxItem:true,

    date:true, DateItem:true, 
    datetime:true, DateTimeItem:true,
    time:true, TimeItem:true,

    password:true, PasswordItem:true,

    color:true, colorItem:true,
    spinner:true, SpinnerItem:true,
    popUpTextArea:true, PopUpTextAreaItem:true

},

// getEditorPlaceholderHTML()
// If this.alwaysShowEditors is true, return the placeholder HTML to show in place of
// inactiveEditorHTML for cells where shouldShowEditorPlaceholder returns true.
getEditorPlaceholderHTML : function (editorType, value, record, rowNum, colNum) {
    // for now just return the value.
    return value;
},

// _editItemsDrawingNotification - function to notify the edit row form items when they are
// drawn, cleared or redrawn.

_editItemsDrawingNotification : function (item, fireMoved, gr) {
    // Items with an optionDataSource may kick off a fetch request on draw
    // Set up a queue around the drawn notifications so we put any such requests into a queue.
    var shouldSendQueue = isc.RPCManager && !isc.RPCManager.startQueue();
    
    var items;
    if (item) items = [item];
    else {
        items = [];
        var allItems = this._editRowForm.getItems();
        for (var i = 0; i < allItems.length; i++) {
            if (allItems[i].containerWidget == gr) items.add(allItems[i]);
        }
    }
    var newlyDrawnItems = gr._drawnEditItems;

    for (var i = 0; i < items.length; i++) {
        var currentItem = items[i],
            wasDrawn = currentItem.isDrawn(),
            isDrawn = newlyDrawnItems ? newlyDrawnItems.contains(currentItem) : false,
            isCanvasItem = isc.CanvasItem && isc.isA.CanvasItem(currentItem);
        if (wasDrawn) {
            if (isDrawn) {
                currentItem.redrawn();
                // Redraw of the body will frequently result in repositioning the edit cells.
                // Fire the 'moved' handler on any visible form items that were present before
                // the redraw to notify them of being moved.
                
                if (fireMoved) currentItem.moved();
            } else {
                currentItem.cleared(true);
            }

        } else if (isDrawn) {
            // newly drawn
            
            if (isCanvasItem) currentItem.placeCanvas();
            currentItem.drawn(true);
        // Sanity check only - if we have a hidden / undrawn canvasItem, with a drawn
        // canvas, clear it.
        
        } else {
            
            if (isc.CanvasItem && isc.isA.CanvasItem(currentItem)) {
                if (currentItem.canvas && currentItem.canvas.isDrawn()) {
                    
                    currentItem.canvas.clear();
                    currentItem.canvas.deparent();
                }
            }
        }
    }

    if (this._editRowForm) {
        this._editRowForm.destroyOrphanedItems("Grid edit-items removed");
    }
    if (shouldSendQueue) isc.RPCManager.sendQueue();

    

    // Get rid of the _drawnEditItems. Next time this method is run we only want to catch
    // items which have subsequently been drawn
    delete gr._drawnEditItems;
},

// clearingInactiveEditorHTML
// Called when we're about to clear the generated inactiveEditorHTML due to cell refresh
// (so clearing a single row), or redraw (clearing all).
// Use this to clean up the generated inactive context objects so we don't fill up lots of memory on
// every redraw etc.
_clearingInactiveEditorHTML : function (rowNum,colNum) {

    // Don't crash if we have no inactiveEditorContextMap set.
    
    if (this._inactiveEditorContextMap == null) return;

    // have cells be rowNum/colNum pairs allowing us to clear just a single row, or
    // if we find we need more intelligent incremental update handling, single col, etc
    if (!this._editRowForm ||
        !this._alwaysShowEditors((colNum != null ? this.getField(colNum) : null),true)) return;

    if (rowNum != null) {
        var row_col = "_" + rowNum + "_" + colNum,
            context = this._inactiveEditorContextMap[row_col];
        if (context) {
            context.formItem.clearInactiveEditorContext(context);
            delete this._inactiveEditorContextMap[row_col];
        }
    } else {
        var editForm = this.getEditForm(),
            items = editForm.getItems();

        for (var i = 0; i < items.length; i++) {
            items[i].clearAllInactiveEditorContexts();
        }

        delete this._inactiveEditorContextMap;
    }
},

// setRecordValues()
// Method to update client-side data in place
// This is called directly by DynamicForms when saving values if this is acting as the selection
// component for a form.
setRecordValues : function (pks, values) {
    if (!this.shouldSaveLocally()) {
        this.logWarn("setRecordValues() not supported for grids where saveLocally is false");
        return;
        
    }
    if (!this.data) return;

    var rowNum = this.data.indexOf(pks),
        record = this.data.get(rowNum);
    

    this.combineRecords(record, values);
    this.calculateRecordSummaries(record, null, true, true);

    if (this.useCellRecords) {
        rowNum = this.findRowNum(record);
        var colNum = this.findColNum(record);
        this.refreshCell(rowNum,colNum);
    } else {
        this.refreshRow(rowNum);
    }

    // Reapply sort and filter, in case this change affects them
    this.resort();
    this.filterByEditor();

    if (this.valuesManager != null) {
        // _updateMultipleMemberValue handles combining a data-index into a path
        // 2nd param unnecessary since we're modifying the whole record, not a field within it.
        this.valuesManager._updateMultipleMemberValue(rowNum, null, record, this);
    }

},



combineRecords : function (destination, source) {
    return isc.combineObjects(destination, source);
},

//> @method listGrid.setRawCellValue()
//      @group  data
//          Set the raw data for one particular cell in the list.
//
//      @param  record      (Object)    record in question
//      @param  recordNum   (number)    number of that record
//      @param  fieldNum    (number)    number of the field to display
//      @param  newValue    (Any)       new value
//
//<
// Overridden at the cubeGrid level to handle being passed an entire record rather than a single
// field value for the cell
setRawCellValue : function (record, recordNum, fieldNum, newValue, suppressChanged) {

    var field = this.fields[fieldNum];
    // if record or field is null, we're dealing with an invalid column, so forget it
    if (!record || !field) return;
    // if the field has a 'setRawCellValue' attribute
    // We'll assume this DIRECTLY sets the value on the LG's data object, so we're basically done
    // at this point (other than firing dataChanged below to ensure everything gets updated
    // visually)
    if (field.setRawCellValue) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "setRawCellValue", "viewer,record,recordNum,field,fieldNum,value");

        // call it as a function (returns string | null)
        field.setRawCellValue(this, record, recordNum, field, fieldNum, newValue);

    // otherwise just use the cells value in the normal way
    } else {
        isc.Canvas._saveFieldValue(null, field, newValue, record, this, true);
    }

    // HACK: fire dataChanged() by hand.  Really, we need an interface to update fields on
    // objects in the List so the List can recognize the change and fire dataChanged() itself
    if (!suppressChanged) this.getOriginalData().dataChanged();
},

//> @method listGrid.getCellBooleanProperty()   (A)
//  Given a property name, and a cell, check for the value of that property (assumed to be a
//  boolean) on the ListGrid, and the cell's field, returning false if the value is false at
//  either level.
//  If true at the ListGrid and Field level, check the value of the the second "recordProperty"
//  on the record object for the cell.
//  (If recordProperty is not passed, the record object will not be examined).
//
//  @param  property    (String)    Name of the property to look for.
//  @param  rowNum  (number)    Row number of the cell.
//  @param  colNum  (String)    Field number for the cell.
//  @param  [recordProperty]    (String)    Name of the equivalent property to check on the
//                                          record object
//
//  @return (boolean)   true == at least one is true and none are false
//
//<

_$false:"false", _$true:"true",
getCellBooleanProperty : function (property, recordNum, fieldNum, recordProperty) {
    var trueFound = false,
        listValue = this[property]
    ;
    if (listValue == false || listValue == this._$false) return false;
    var fieldValue = this.fields[fieldNum][property];
    if (fieldValue == false || fieldValue == this._$false) return false;

    
    if (recordProperty != null) {

        var record = this.getRecord(recordNum, fieldNum),
            recordValue = (record != null ? record[recordProperty] : false)
        ;
        if (recordValue == false || recordValue == this._$false) return false;
        if (recordValue == true || recordValue == this._$true) return true;
    }

    // At this point we know none of the values was an explicit false - but we only want to
    // return true if the value was specified as true (rather than undefined) at some level.
    // We've already checked at the record level (if necessary)
    return listValue == true        || fieldValue == true        ||
           listValue == this._$true || fieldValue == this._$true;
},


// ---------------------------------------------------------------------------------------

//> @method listGrid.setShowRecordComponents()
// Setter for the +link{listGrid.showRecordComponents} attribute
// @param showRecordComponents (boolean) new value for <code>this.showRecordComponents</code>
// @group recordComponents
// @visibility external
//<
setShowRecordComponents : function (showRC) {
    if (this.showRecordComponents == showRC) return;

    
    if (showRC) {
        if (this.animateFolders) {
            this._animateFoldersWithoutRC = true
            this.animateFolders = false;
        }
    } else {
        if (this._animateFoldersWithoutRC) {
            this.animateFolders = true;
            delete this._animateFoldersWithoutRC;
        }
    }

    this.showRecordComponents = showRC;

    // Update virutalScrolling if necessary.
    // We'll also update virtual scrolling in createBodies() - this handles the case where
    // we're already showing recordComponents and a grid is frozen at runtime.
    this._updateVirtualScrollingForRecordComponents();

    // suppress 'drawAllMaxCells' type behavior - we don't want to render out potentially
    // hundreds of canvases.
    if (showRC) {
        this._oldDrawAllMaxCells = this.drawAllMaxCells;
        this.drawAllMaxCells = 0;
        if (this.body != null) this.body.drawAllMaxCells = 0;

    } else {
        if (this._oldDrawAllMaxCells != null) {
            this.drawAllMaxCells = this._oldDrawAllMaxCells;
            if (this.body != null) this.body.drawAllMaxCells = this._oldDrawAllMaxCells;
            delete this._oldDrawAllMaxCells;
        }

    }
    this.invalidateRecordComponents();

    // For "within" record components, if autoFitting to values, we may need to
    // resize smaller once the components have been removed.
    if (!showRC &&
        (this.recordComponentPosition == this._$within ||
         (this.recordComponentPosition == null && this.showRecordComponentsByCell)))
    {
        this.updateFieldWidthsForAutoFitValue("showRecordComponents changed");
        this._updateFieldWidths();
    }

},

_updateVirtualScrollingForRecordComponents : function () {
    if (!this.showRecordComponents) {
        if (this._rcVScroll) {
            delete this.virtualScrolling;
            delete this._rcVScroll;
        }

    // Virtual scrolling:
    // Embedded components can make row heights unpredictable
    // (may not show for every row, may be 'position:"expand"', or exceed this.cellHeight
    // etc)
    // Because of this we typically have to enable virtual scrolling for record components.
    // However we don't currently support virtual scrolling with frozen fields, so
    // don't enable it if we have frozen fields.
    // This *may* lead to unpredictable behavior. Cases where it's ok:
    // - if recordComonentPosition is 'within' and
    //   the recordComponentPosition < this.cellHeight
    // - if recordComponentHeight is set (and truly is not exceeded by embedded components)
    
    } else {
        if (this.virtualScrolling == null || this._rcVScroll) {
            if (this.frozenFields == null) {
                this.virtualScrolling = true;
                this._rcVScroll = true;

            } else {

                if (this.recordComponentHeight == null) {
                    this.logWarn("This grid has frozen fields and is showing " +
                        "recordComponents. This may lead to unpredictable row heights which " +
                        "are not supported with frozen fields. Setting " +
                        "listGrid.recordComponentHeight will avoid this issue.",
                        "recordComponents");
                }
                if (this._rcVScroll) {
                    delete this.virtualScrolling;
                    delete this._rcVScroll;
                }
            }
        }
    }

    if (this.body && this.virtualScrolling != this.body.virtualScrolling) {
        this.body.virtualScrolling = this.virtualScrolling;
        if (this.frozenBody) {
            this.frozenBody.virtualScrolling = this.virtualScrolling;
        }
    }
    // No need to call 'redraw' on the body -- calling code is expected to handle this.
},



//> @method listGrid.getDrawArea() (A)
// Returns the extents of the rows and columns currently visible in this grid's viewport.
// <P>
// Note: if there are any +link{listGridField.frozen,frozen fields}, they are not included
// in the draw area range returned by this method. Frozen fields are assumed to never be
// scrolled out of view.  The column coordinates returned by this method will only include
// unfrozen columns.
//
// @return  (Array of Integer)  The row/col co-ordinates currently visible in the viewport as
//    [startRow, endRow, startCol, endCol].
// @visibility external
//<

getDrawArea : function (a, b, c) {
    if (this.body) {
        var drawArea = this.body.getDrawArea(a, b, c);
        if (this.frozenFields && this.freezeStart()) {
            drawArea[2] += this.frozenFields.length;
            drawArea[3] += this.frozenFields.length;
        }
        return drawArea;
    }
    
    return null;
},

// _drawAreaChanged() - notification fired on GridRenderer.redraw() when the
// previous draw area doesn't match the new draw area

_drawAreaChanged : function (oldStartRow, oldEndRow, oldStartCol, oldEndCol, body) {
    if (this.frozenFields && this.freezeStart()) {
        oldStartCol += this.frozenFields.length;
        oldEndCol += this.frozenFields.length;
    }
    var oldDrawArea = [oldStartRow, oldEndRow, oldStartCol, oldEndCol];
    if (oldDrawArea.equals(this.getDrawArea())) return;
    
    this.drawAreaChanged(oldStartRow,oldEndRow,oldStartCol,oldEndCol);
    if (this.rowRangeDisplayStyle != "countOnly") {
        this.rowRangeDisplayValueChanged("body draw area changed");
    }
},

// documented in registerStringMethods
drawAreaChanged:function () {},

// if any records were programmatically expanded before the grid was drawn,
// expand them properly now
updateExpansionComponents : function () {
    if (!this._recordsToExpand || this._recordsToExpand.length == 0) return;
    this._updatingExpansionComponents = true;
    for (var i=this._recordsToExpand.length-1; i>=0; i--) {
        this.expandRecord(this._recordsToExpand[i]);
    }
    delete this._updatingExpansionComponents;
    delete this._recordsToExpand;
},

// updateRecordComponents() - fired from redraw on grid body (or frozen body).
// This method essentially iterates through our current draw area and ensures that if
// showRecordComponents is true, we're showing recordComponents for each row (or cell),
// calling 'createRecordComponent()' or 'updateRecordComponent()' as necessary to create
// new components, and discarding (or pooling) record components that we previously created
// which are no longer visible.
// This method should not need to be called by developers directly.
// To force an explicit invalidation and refresh of recordComponents, use
// invalidateRecordComponents()
// *Note: This method also handles updating backgroundComponents if specified

updateRecordComponents : function () {
    // Sanity check to avoid infinite loops if adding embedded components trips redraw of
    // body for example
    var debugLog = this.logIsDebugEnabled("recordComponents");
    if (this._updatingRecordComponents) {
        if (debugLog) {
            this.logDebug("updateRecordComponents called recursively - returning",
                "recordComponents");
        }
        return;
    }

     // If we're performing a show/hide row height animation, bail.
    // In this case the HTML in the body won't match the set of records in our data set
    // so we can't update / place embedded components properly
    var body = this.body,
        frozenBody = this.frozenBody;
    if (body == null) return;

    if (body._animatedShowStartRow !=  null) {
        return;
    }

    // This method is fired from various places including gridBody.draw.
    // In this case we may have one body drawn and the other not yet drawn. Wait for both
    // to be drawn before continuing - addEmbeddedComponent (used below) requires the
    // GR be drawn.
    // Also if _fieldWidths isn't set, we can't
    // yet size/position our embedded components. This can occur when we rebuildForFreeze.
    // Catch this case and return.
    if ((!body.isDrawn() || body._fieldWidths == null ||
        (body._fieldWidths.length == 0 && body.fields.length > 0)) ||
        (frozenBody &&
            (!frozenBody.isDrawn() || frozenBody._fieldWidths == null ||
            (frozenBody._fieldWidths.length == 0 && frozenBody.fields.length > 0))))
    {
        return;
    }

    this._updatingRecordComponents = true;

    // Implementation overview: The concept here is that if showRecordComponents is true,
    // we call a method 'createRecordComponent()' [or potentially 'updateRecordComponent']
    // for every visible row, or if showing by cell, every visible cell, lazily as its rendered
    // out.
    // When new cells are rendered out we want to
    // - call createRecordComponent() [or updateRC] for newly rendered cells
    // - *not* call createRC for cells that were visible and still are (regardless of whether
    //   createRecordComponent returned an actual component or just null)
    // - for cells that are no longer visible, clear up the created record components,
    //   clearing them, destroying them or adding them to our 'recordComponentPool' depending on
    //   the recordComponentPoolingMode.
    // Rather than trying to achieve this by tracking viewports (which has the major disadvantage
    // of being fragile on data change or field config change), we take this approach:
    // We store all generated record components in 2 places:
    // - on the records themselves, indexed by fieldName, under record._recordComponents
    // - on the ListGrid in both an array and an object mapping componentIDs to true
    // If the createRecordComponent method returned null for any cell, we store a special
    // nullMarker object on the record._recordComponents object as well.
    //
    // When this method runs we can then iterate through all visible records / fields
    // - determine if we have visible record components already present, or null markers,
    //   in which case we leave the component alone
    // - otherwise run the method to create a new record component / get one from the pool and
    //   apply it to the cell.
    // Once we've gone through all visible cells we iterate through all the recordComponents
    // we previously created and wipe out (either clear, destroy or recycle) any that weren't
    // noted as being attached to a visible cell in the previous step.

    // _liveRecordComponents / _liveRecordComponentsObj is the full set of recordComponents
    // generated last time this method was run.
    var oldRecordCompArr = this._liveRecordComponents || [],
        oldRecordCompObj = this._liveRecordComponentsObj || {};

    if (debugLog) {
        this.logDebug("updateRecordComponents - old record components before refreshing:" +
            this.echo(oldRecordCompArr),
            "recordComponents");
    }

    this._liveRecordComponentsObj = {};
    this._liveRecordComponents = [];

    // If showRecordComponents is false we can skip all logic to create
    // new recordComponents. If we had any previously created recordComponents we'll clear
    // them below. This will handle the showRecordComponents setting being changed dynamically.
    if (this.showRecordComponents || this.showBackgroundComponents) {

        // Determine what our current draw area is - set of drawn fields and rows.
        // This method is being called as part of redraw, before the render has occurred, so
        // we can't just look at body._firstDrawnRow / _lastDrawnRow etc - we need
        // to call the getDrawArea() APIs on the body to actually calculate the new values
        
        var drawArea = this.body.getDrawArea(),
            cellComponents = this.showRecordComponentsByCell,
            bodyID = this.body.getID(),
            frozenBodyID = this.frozenBody ? this.frozenBody.getID() : null;
        if (this.recordComponentPoolingMode == "recycle") {
            if (debugLog) {
                this.logDebug("START updateRecordComponents - pre-loop recordComponent " +
                    "cleanup - drawArea is " + drawArea);
                var cleaned = [];
            }
            for (var i = 0; i < oldRecordCompArr.length; i++) {
                // if the component's row is outside of the new draw area, clean the component 
                // up now - this adds it to the pool and allows it to be recycled in the loop 
                // below - otherwise, on the first scroll, we will call createRecordComponent 
                // when we ought to be calling updateRecordComponent
                var comp = oldRecordCompArr[i];
                if (!comp) continue;
                var row = this.getRecordIndex(comp.currentRecord);
                //var row = comp._lastRowNum;
                if (row < drawArea[0] || row > drawArea[1]) {
                    this._cleanUpRecordComponent(comp);
                    oldRecordCompObj[comp.getID()] = null;
                    if (debugLog) {
                        cleaned.add(comp);
                        this.logDebug("cleaned up recordComponent: " + comp.ID + " from row " + row);
                    }
                }
            }
            if (debugLog) {
                this.logDebug("END updateRecordComponents - pre-loop recordComponent cleanup: " + 
                    "cleaned " + cleaned.length + " components");
            }
        }

        if (debugLog) {
            this.logDebug("updating to potentially show recordComponents for drawArea:"
                + drawArea, "recordComponents");
        }
        for (var rowNum = drawArea[0]; rowNum <= drawArea[1]; rowNum++) {
            var record = this.getRecord(rowNum);

            if (record == null || Array.isLoading(record)) continue;

            if (this.showRecordComponents) {
                // If we don't have cell components we will add components to the (unfrozen) body,
                // one per row.
                if (!cellComponents) {
                    var shouldShowRecordComponent = null;
                    // Skip spanned cells.
                    
                    if (this.allowRowSpanning && this.getRowSpan) {
                        var isSpanned = this.getCellStartRow(rowNum, 0) != rowNum;
                        if (isSpanned) shouldShowRecordComponent = false;
                    }

                    if (shouldShowRecordComponent == null) {
                         
                         shouldShowRecordComponent = this.shouldShowRecordComponent(record);
                    }
                    var liveComp = null;
                    if (shouldShowRecordComponent) {
                        // getLiveRecordComponent() will pick up the record component we've already
                        // applied to the record/field.
                        // NOTE: If createRecordComponent ran and returned null we store a special
                        // null-marker object which we'll get back here as well. This means we
                        // don't re-run createRecordComponent() unless we actually want to.
                        liveComp = this._getLiveRecordComponent(record, null, bodyID);
                        if (liveComp != null) {
                            if (liveComp.isNullMarker) {
                                liveComp = null;
                            } else {
                                var ID = liveComp.getID();
                                oldRecordCompObj[ID] = null;
                            }
                        } else {
                            liveComp = this._applyNewRecordComponent(record, null, this.body, rowNum);
                        }
                    }

                    // Store pointers to both the component and its ID
                    
                    if (liveComp != null) {
                        var ID = liveComp.getID();
                        this._liveRecordComponentsObj[ID] = true;
                        this._liveRecordComponents[this._liveRecordComponents.length] = liveComp;
                    }

                // same logic as above, but applied per cell to both the frozen and
                // unfrozen body.
                } else {
                    if (this.frozenBody != null) {
                        for (var fieldNum = 0; fieldNum < this.frozenBody.fields.length; fieldNum++) {
                            var field = this.frozenBody.fields[fieldNum],
                                fieldName = field.name;
                            var shouldShowRecordComponent = null;
                            // Skip spanned cells.
                            if (this.allowRowSpanning && this.getRowSpan) {
                                var isSpanned = this.getCellStartRow(rowNum, field.masterIndex) != rowNum;
                                if (isSpanned) shouldShowRecordComponent = false;
                            }
                            if (shouldShowRecordComponent == null) {
                                shouldShowRecordComponent = this.shouldShowRecordComponent(record, field.masterIndex);
                            }
                            var liveComp = null;

                            if (shouldShowRecordComponent) {
                                liveComp = this._getLiveRecordComponent(record, fieldName, frozenBodyID);
                                if (liveComp != null) {
                                    if (!liveComp.isNullMarker) {
                                        var ID = liveComp.getID();
                                        oldRecordCompObj[ID] = null;
                                    } else {
                                        liveComp = null;
                                    }
                                } else {
                                    liveComp = this._applyNewRecordComponent(record, fieldName, this.frozenBody,
                                                    rowNum, fieldNum);
                                }
                            }
                            if (liveComp != null) {
                                var ID = liveComp.getID();
                                this._liveRecordComponentsObj[ID] = true;
                                this._liveRecordComponents[this._liveRecordComponents.length] = liveComp;
                            }
                        }
                    }
                    for (var bodyCol = drawArea[2]; bodyCol <= drawArea[3]; bodyCol++) {
                        var field = this.body.fields[bodyCol],
                            fieldName = field.name;
                        var shouldShowRecordComponent = null;
                        // Skip spanned cells.
                        if (this.allowRowSpanning && this.getRowSpan) {
                            var isSpanned = this.getCellStartRow(rowNum, field.masterIndex) != rowNum;
                            if (isSpanned) shouldShowRecordComponent = false;
                        }
                        if (shouldShowRecordComponent == null) {
                            shouldShowRecordComponent = this.shouldShowRecordComponent(record, field.masterIndex);
                        }
                        var liveComp = null;

                        if (shouldShowRecordComponent) {
                            var liveComp = this._getLiveRecordComponent(record, fieldName, bodyID);
                            if (liveComp != null) {
                                if (!liveComp.isNullMarker) {
                                     var ID = liveComp.getID();
                                     oldRecordCompObj[ID] = null;
                                } else {
                                    liveComp = null;
                                }
                            } else {
                                liveComp = this._applyNewRecordComponent(record, fieldName, this.body,
                                            rowNum, bodyCol);
                            }
                        }

                        if (liveComp != null) {
                            var ID = liveComp.getID();
                            this._liveRecordComponentsObj[ID] = true;
                            this._liveRecordComponents[this._liveRecordComponents.length] = liveComp;
                        }
                    }
                }
            }

            
            if (this.showBackgroundComponents) {
                if (record && record.backgroundComponent) {
                    var component = 
                            this._getEmbeddedComponents(record).find("isBackgroundComponent", true);

                    if (!component) {
                        // should be showing a backgroundComponent but it's not present yet - add it now
                        if (isc.isA.Canvas(record.backgroundComponent)) {
                            // backgroundComponent is specified as a canvas
                            var comp = record.backgroundComponent.addProperties(
                                this.backgroundComponentProperties,
                                { isBackgroundComponent: true }
                            );
                        } else {
                            // backgroundComponent is specified as properties
                            var props = isc.addProperties({ isBackgroundComponent: true },
                                this.backgroundComponentProperties,
                                record.backgroundComponent);
                            var comp = this.createAutoChild("backgroundComponent", props);
                        }

                        var tableIndex = body.getTableZIndex();
                        comp.setZIndex(tableIndex - 49);
                        comp.setWidth("100%");
                        comp.setHeight("100%");
                        comp.setOverflow("hidden");

                        comp.removeOnHideField = true;

                        
                        this.addEmbeddedComponent(record.backgroundComponent, record, rowNum,
                            null, "within");

                        // This should stick with the record until it's wiped due to data change
                        // or similar (EG remapEmbeddedComponents)
                        // At that point, if this method runs again it'll be cleared
                    }
                }
            }
        }
    }

    var drawArea = this.body.getDrawArea();
    for (var rowNum = drawArea[0]; rowNum <= drawArea[1]; rowNum++) {
        var record = this.getRecord(rowNum);

        if (record == null || Array.isLoading(record) || !record.embeddedComponent) {
            continue;
        }

        // Add embedded component to this record
        var position = record.embeddedComponentPosition || "within";
        var fields = record.embeddedComponentFields;
        var colNum = null;

        if (isc.isA.Array(fields) && fields.length > 0) {
            if (fields.length > 2) {
                this.logWarn("Only 2 fields are supported for embeddedComponentFields but " +
                    fields.length + " was provided. Only the 2 first fields will be used.");

                // Lets reduce the fields array down to the first two entries.
                fields = [fields[0], fields[1]];
            }

            for (var fieldIndex = 0; fieldIndex < fields.length; fieldIndex++) {
                colNum = this.fields.findIndex(this.fieldIdProperty, fields[fieldIndex]);

                if (colNum) {
                    break;
                } else {
                    this.logWarn("Could not find field '" + fields[fieldIndex] + "' to embed component inside.");
                }
            }
        }

        // Lets default width and height to 100% on a component that has position "within" and
        // no explicit width and height set.
        if (position === "within" && !record.embeddedComponent.width && !record.embeddedComponent.height) {
            record.embeddedComponent.width = "100%";
            record.embeddedComponent.height = "100%";
        }

        // Turn off autoDismiss on a record with an embedded component.
        record.autoDismiss = false;

        this.addEmbeddedComponent(record.embeddedComponent, record, rowNum, colNum, position);
    }

    if (oldRecordCompArr.length > 0 || this._liveRecordComponents > 0) {
        this.resized();
    }

    if (this.logIsInfoEnabled("recordComponents")) {
        this.logInfo("updateRecordComponents - new recordComponents:" +
            this.echo(this._liveRecordComponentsObj) +
            ", old record components (will be cleaned up if value is 'true'):" +
            this.echo(oldRecordCompObj), "recordComponents");
    }

    // At this point we've iterated through our draw area (or showRecordComponents is false,
    // in which case we want to drop all pre existing Record Components).
    // Any pre-existing recordComponents that are still visible have been removed from
    // the 'oldRecordCompObj'.
    // Iterate through pre-existing record components that are left and clear them up
    // (remove from DOM if necessary, destroy / pool if necessary)
    for (var i = 0; i < oldRecordCompArr.length; i++) {
        // if it's been cleared from the oldRecordCompObj we know its still visible / being used
        var ID = oldRecordCompArr[i].getID();
        if (oldRecordCompObj[ID] != true) {
            continue;
        }
        if (debugLog) {
            this.logDebug("cleaning up RecordComponent:" + oldRecordCompArr[i], "recordComponents");
        }
        this._cleanUpRecordComponent(oldRecordCompArr[i]);
        oldRecordCompObj[ID] = null;
    }
    delete this._updatingRecordComponents;
},

recordScreenPlaceholderDefaults: {
    _constructor: isc.Label,
    autoDraw: false,
    border: "1px solid red",
    contents: "recordScreen<br>Placeholder",
    align: "center"
},

// _applyNewRecordComponent()
// This method will run 'createRecordComponent()' or 'updateRecordComponent()' to
// get the recordComponent for some record or cell.
_applyNewRecordComponent : function (record, fieldName, body, rowNum, bodyCol, suppressRedraw) {

    var debugLog = this.logIsDebugEnabled("recordComponents");

    if (debugLog) {
        this.logDebug("getting record component for row/field:" + [rowNum,fieldName],
            "recordComponents");
    }

    var pool = this.recordComponentPoolingMode == "recycle",
        component,
        // same row variable - only used if we're picking up a pooled component
        sameRow,
        colNum = fieldName == null ? null : this.getColNum(fieldName)
    ;

    if (pool) {
        var compConfig = this.getFromRecordComponentPool(record, fieldName);
        component = compConfig ? compConfig[0] : null;
        sameRow = compConfig ? compConfig[1] : null;
    }

    if (!component) {
        if (this.createRecordComponent && isc.isA.Function(this.createRecordComponent)) {
            component = this.createRecordComponent(record, this.getColNum(fieldName));
            if (component != null) {
                component.isRecordComponent = true;
                if (debugLog) {
                    this.logDebug("created new record component:" + component, "recordComponents");
                }
            }
        } else if (this.recordScreen) {
            var ds = this.getDataSource(),
                settings = {}
            ;
            if (ds) {
                settings.dataContext = {};
                settings.dataContext[ds.ID] = record;
            }
            component = isc.RPCManager.createScreen(this.recordScreen, settings);
            if (!component) {
                component = this.createAutoChild("recordScreenPlaceholder");
            }
            if (component != null) {
                component.isRecordComponent = true;
                if (debugLog) {
                    this.logDebug("created new record component from screen " + this.recordScreen + ":" + component, "recordComponents");
                }
            }
        }
    } else {
        if (this.updateRecordComponent && isc.isA.Function(this.updateRecordComponent)) {
            var origComponent = component;

            component = this.updateRecordComponent(record, colNum, component, !sameRow);

            // component may well be null - this is valid and allows the developer to
            // suppress components in cells even in pooling mode.
            if (component == null) {
                if (this.logIsInfoEnabled("recordComponents")) {
                    this.logInfo("showRecordComponents: updateRecordComponent() method " +
                        "failed to return an updated component.", "recordComponents");
                }
                // stick it back into the pool for future use
                this.addToRecordComponentPool(origComponent);
            }
            if (debugLog) {
                this.logDebug("updated record component from pool: " + component, "recordComponents");
            }
        } else if (this.recordScreen && component._screen != null) {
            var ds = this.getDataSource();
            if (ds) {
                var dataContext = {};
                dataContext[ds.ID] = record;
                component.setDataContext(dataContext);
            }
        }
    }
    return this._finishApplyNewRecordComponent(record, fieldName, body, rowNum, bodyCol, component, suppressRedraw);
},

_finishApplyNewRecordComponent : function (record, fieldName, body, rowNum, bodyCol, component, suppressRedraw) {
    var pool = this.recordComponentPoolingMode == "recycle",
        addNullMarker = (component == null);
    if (addNullMarker) {
        component = {
            isNullMarker:true,
            _embedBody:body.getID(),
            _recordComponentBatch:this._recordComponentSequence
        }
    }
    if (fieldName == null) fieldName = this._$noFieldString;
    
    this._addRecordComponent(record, fieldName, component);
    // We're applying a "currentFieldName" / "currentRecord" flag in addition
    // to the _currentFieldName applied by the embeddedComponents code. This is
    // intentional - we use these flags in pooling mode to pick up the component that
    // matched the previous record (if possible) and previous field if
    // poolComponentsPerColumn is true. Don't want to rely on the flags that are set up and
    // potentially cleared by the standard embeddedComponent subsystem.
    if (pool && !addNullMarker) {
        component.currentFieldName = fieldName;
        component.currentRecord = record;
    }
    if (!addNullMarker) {
        // have the recordComponent removed if the field it's in is hidden
        component.removeOnHideField = true;

        //this.logWarn("created component:" + component + ", adding to:" + [rowNum,fieldName]);
        return body.addEmbeddedComponent(component, record, rowNum, bodyCol, this.getRecordComponentPosition(), suppressRedraw);
    }
},

//> @method listGrid.setDontAutoDestroyComponent()
// If +link{listGrid.showRecordComponents} is true, by default any created record components
// are destroyed once they are no longer in use (for example, if the ListGrid as a whole is
// destroyed).  This method may be used to suppress this behavior for some component. Typical
// usage might call this method as part of +link{listGrid.createRecordComponent()} to suppress
// this behavior.
// @param component (Canvas) component in question.
// @param dontAutoDestroy (boolean) If true, the component will not be destroyed automatically when
//   the grid is destroyed
// @visibility external
//<

setDontAutoDestroyComponent : function (component, dontAutoDestroy) {
    component.dontAutoDestroy = dontAutoDestroy;
},

// fired when a recordComponent's cell is no longer visible. Behavior depends on
// recordComponentPoolingMode.
_cleanUpRecordComponent : function (component, forceDestroy, suppressRedraw) {
    var debugLog = this.logIsDebugEnabled("recordComponents");
    if (debugLog) {
        this.logDebug("cleaning up recordComponent:" + component,
            "recordComponents");
    }

    var poolingMode = this.recordComponentPoolingMode;
    // If passed the forceDestroy parameter, behave in 'viewport' mode regardless of
    // the actual pooling mode - this means we'll destroy the component passed in.
    if (forceDestroy) poolingMode = "viewport";

    if (poolingMode == "data") {
        // No need to attempt to pool, etc here:
        // If the record is still around, placeEmbeddedComponent() will have cleared it and
        // it'll simply re-render when scrolled back into view, etc.
        //
        // If the record is no longer present in the data array, remapEmbeddedComponents()
        // will have already marked it for destruction, and updateRecordComponents() has
        // already rebuilt the array of _liveRecordComponents so we won't be hanging onto
        // a pointer to it anymore.
        //
        // However - when the listGrid as a whole gets destroyed, we should ensure the
        // recordComponent gets destroyed too.
        // Handle this by storing a separate reference to it which we can look at on
        // destroy(). Use "pointersToThis" to ensure that if the component gets destroyed separately
        // (while this component is still intact) we don't hang onto this reference.
        if (!component.destroyed && !component.destroying && !component._pendingDestroy) {
            if (this._orphanedRecordComponents == null) {
                this._orphanedRecordComponents = {};
            }
            var ID = component.ID;
            if (this._orphanedRecordComponents[ID] != component) {
                this._orphanedRecordComponents[ID] = component;
                // set up 'pointersToThis'
                if (component.pointersToThis == null) component.pointersToThis = [];
                component.pointersToThis.add({
                    object: this._orphanedRecordComponents, property: ID
                });
            }
            if (debugLog) {
                this.logDebug("_cleanUpRecordComponent - poolingMode 'data' - added orpahaned " +
                    "component : " + component.ID,
                    "recordComponents");
            }
        }

    } else {
        var ID = component.ID,
            body = isc.Canvas.getById(component._embedBody),
            record = component.embeddedRecord,
            fieldName = component._currentFieldName;

        // wipe the component from the components-cache on the record [IF it hasn't been updated
        // to point at a new component]
        
        
        if (this._hasRecordComponents(record)) {
            this._deleteRecordComponent(record, fieldName);
        }

        // this component may have already been removed from the body, for example by
        // _remapEmbeddedComponentColumns(). In this case _embedBody will have been null
        // so we can detect this by the body var being unset here.
        if (body != null) {
            body.removeEmbeddedComponent(record, component, null, suppressRedraw);
            // also remove the entry from record._embeddedComponents_{ID}
            this._removeEmbeddedComponent(record, component);
        }

        if (poolingMode == "viewport") {
            if (debugLog) {
                this.logDebug("_cleanUpRecordComponent - not pooling component : " + 
                    component.ID,
                    "recordComponents");
            }                    
            if (!component.dontAutoDestroy) {
                component.markForDestroy();
                if (debugLog) {
                    this.logDebug("_cleanUpRecordComponent - marked component : " + component.ID +
                        " for destruction",
                        "recordComponents");
                }
            }
        } else {
            
            if (component.destroying || component.destroyed || component._pendingDestroy) return;
            if (debugLog) {
                this.logDebug("_cleanUpRecordComponent - adding component : " + component.ID +
                    " to the pool",
                    "recordComponents");
            }
            this.addToRecordComponentPool(component);
        }
    }
},

// Helper method - look at a record and see if we currently have a recordComponent for it.

_$noFieldString:"_noField",
_recordComponentSequence:0,

getLiveRecordComponent : function (record, fieldName, bodyID) {
    if (!record) return null;
    if (isc.isA.Number(record)) record = this.getRecord(record);
    if (!bodyID) bodyID = this.body.getID();
    var comp = this._getLiveRecordComponent(record, fieldName, bodyID);
    return comp;
},
_getLiveRecordComponent : function (record, fieldName, bodyID) {
    if (fieldName == null) fieldName = this._$noFieldString;

    if (!this._hasRecordComponents(record)) return null;
    var recordComponents = this._getRecordComponents(record);

    if (recordComponents[fieldName] == null) return null;

    var component = recordComponents[fieldName];

    if (component._embedBody != bodyID) {
        return null;
    }
    if (component.isNullMarker && component._recordComponentBatch != this._recordComponentSequence) {
        return null;
    }

    // We should never see this but if a component gets destroyed without first being
    // cleared out of the record._recordComponents block, wipe it out now. This will force
    // creation of a new recordComponent in calling code.
    if (component.destroyed || component.destroying || component._pendingDestroy) {
        this.logWarn("Destroyed or Destroying record component:" + component +
            " present on record. Ignoring", "recordComponents");
        recordComponents[fieldName] = null;
        return null;
    }
    if (component._currentRowNum != null && component._currentRowNum != this.getRowNum(record)) {
        // don't use the component if it's already assigned to another row
        return null;
    }
    return component;
},

//> @method listGrid.invalidateRecordComponents()
// Invalidates the currently visible set of +link{listGrid.showRecordComponents,recordComponents}
// and gets fresh ones for the visible rows in the grid according to the
// +link{listGrid.recordComponentPoolingMode}
// <P>
// See also +link{listGrid.refreshRecordComponent()} which allows you to refresh a specific
// recordComponent
//
// @group recordComponents
// @visibility external
//<
invalidateRecordComponents : function () {

    // force destruction of the visible recordComponents - otherwise this
    // method would have no visible effect in 'data' pooling mode.
    this.dropRecordComponents(true);

    if (this.showRecordComponents && this.isDrawn()) {
        this.updateRecordComponents();
    }
},

dropRecordComponents : function (forceDestroy) {

    // up the recordComponentSequence count. This is used to identify our special null markers
    // and essentially invalidates them, meaning we'll re-run the createRecordComponent logic
    // for records with null markers we've already set at this point.
    
    this._recordComponentSequence++;

    var oldRecordCompArr = this._liveRecordComponents || [];

    delete this._liveRecordComponents;
    delete this._liveRecordComponentsObj;

    for (var i = 0; i < oldRecordCompArr.length; i++) {
        this._cleanUpRecordComponent(oldRecordCompArr[i], forceDestroy);
    }
},

//> @method listGrid.refreshRecordComponent()
// Discards any +link{listGrid.showRecordComponents,recordComponent} currently assigned to the
// specified record (or cell) and gets a fresh one, according to the
// +link{listGrid.recordComponentPoolingMode}
// <P>
// See also +link{listGrid.invalidateRecordComponents()} which allows you to refresh all record
// components that are currently visible in the grid.
//
// @param rowNum (int) Row to refresh
// @param [colNum] (Integer) Column to refresh. This parameter should be passed
//      if +link{showRecordComponentsByCell} is true.
// @group recordComponents
// @visibility external
//<
// Internal extra parameter to avoid redrawing the grid (or refreshing the cell / row)
// Used in cases where the caller is about to refresh the grid/cell directly
refreshRecordComponent : function (rowNum, colNum, suppressRedraw) {
    if (!this.showRecordComponents || rowNum == null || this.body == null) return;

    if (this.showRecordComponentsByCell && colNum == null) {
        this.logWarn("refreshRecordComponent() called with no colNum. This parameter is required when " +
            "showRecordComponentsByCell is true. Taking no action.");
        return;
    }

    var record = this.getRecord(rowNum);
    if (record == null || Array.isLoading(record)) return;

    var debugLog = this.logIsDebugEnabled("recordComponents");
    
    var body = this.body,
        bodyColNum = null,
        fieldName = null;

    if (this.showRecordComponentsByCell) {
        body = this.getFieldBody(colNum);
        bodyColNum = this.getLocalFieldNum(colNum);
        fieldName = this.getFieldName(colNum);
    }

    var prevComp = this._getLiveRecordComponent(record, fieldName, body.getID());
    if (prevComp != null && prevComp.isNullMarker) prevComp = null;

    var shouldShowComponent = this.shouldShowRecordComponent(record, colNum);

    var liveComp;
    if (prevComp != null) {
        if (debugLog) {
            this.logDebug("refreshRecordComponent detected previous component " + prevComp.ID,
                "recordComponents");
        }
        
        if (shouldShowComponent && isc.isA.Function(this.updateRecordComponent)) {
            liveComp = this.updateRecordComponent(record, colNum, prevComp, false);
            if (liveComp != prevComp) {
                if (debugLog) {
                    this.logDebug("refreshRecordComponent() - updateRecordComponent returned a " +
                        "different component: " + (liveComp ? liveComp.ID : "null") + 
                        " - cleaning up the old one: " + prevComp.ID,
                        "recordComponents");
                }
                this._cleanUpRecordComponent(prevComp, (this.recordComponentPoolingMode != "recycle"), suppressRedraw);
                liveComp = this._finishApplyNewRecordComponent(
                                record, fieldName, body, rowNum, bodyColNum, 
                                liveComp, suppressRedraw
                           );
                if (liveComp && liveComp.isNullMarker) liveComp = null;
            } else {
                if (debugLog) {
                    this.logDebug("refreshRecordComponent() - updateRecordComponent returned the " +
                        "same component: " + prevComp.ID,
                        "recordComponents");
                }
            }
            shouldShowComponent = false;
        } else if (shouldShowComponent && this.recordScreen && prevComp._screen != null) {
            var ds = this.getDataSource();
            if (ds) {
                var dataContext = {};
                dataContext[ds.ID] = record;
                prevComp.setDataContext(dataContext);
            }
            shouldShowComponent = false;
        } else {
            // This will destroy the component, or add to the pool.
            this._cleanUpRecordComponent(prevComp, (this.recordComponentPoolingMode != "recycle"), suppressRedraw);
        }
    }
    if (shouldShowComponent) {
        liveComp = this._applyNewRecordComponent(record, fieldName, body, rowNum, bodyColNum, suppressRedraw);
        if (liveComp && liveComp.isNullMarker) liveComp = null;
    }

    // Update this._liveRecordComponents and this._liveRecordComponentsObj
    var index = this._liveRecordComponents.length;
    if (prevComp) {
        var ID = prevComp.getID();
        this._liveRecordComponentsObj[prevComp.getID()] = null;
        // Null the slot in the live recordComponents array and reuse it if possible for
        // efficiency.
        if (liveComp != null) {
            index = this._liveRecordComponents.indexOf(prevComp);
            this._liveRecordComponents[index] = null;
        } else {
            this._liveRecordComponents.remove(prevComp);
        }
    }

    if (liveComp != null) {
        var ID = liveComp.getID();
        this._liveRecordComponentsObj[ID] = true;
        this._liveRecordComponents[index] = liveComp;
    }
},

getRecordComponentPosition : function () {
    if (this.recordComponentPosition != null) return this.recordComponentPosition;
    return (this.showRecordComponentsByCell ? "within" : "expand");
},

getRecordComponentPool : function () {
    if (!this._recordComponentPool) this._recordComponentPool = [];
    return this._recordComponentPool;
},

// we want to indicate whether the record changed. Handle this by returning a 2 element array
// - the component and a boolean.
getFromRecordComponentPool : function (record, fieldName) {
    var components = this.getRecordComponentPool(),
        subList = [],
        fieldSpecific = this.showRecordComponentsByCell && this.poolComponentsPerColumn == true,
        component
    ;

    if (!components || components.length == 0) return null;

    if (fieldSpecific) {
        subList = components.findAll("currentFieldName", fieldName);
    } else {
        subList = components;
    }
    if (!subList || subList.length == 0) return null;

    for (var i = 0; i < subList.length; i++) {
        component = subList[i];
        var prevRecord = component.currentRecord;
        if (this.comparePrimaryKeys(prevRecord, record)) {
            components.remove(component);
            return [component,true];
        }
    }
    
    // we didn't find a component that previously sat in this record (and that had the correct
    // fieldName, if we're pooling by column) - just return the last component from the 
    // applicable list (subList)
    
    components.remove(component);
    return [component,false];
},

addToRecordComponentPool : function (component) {
    var components = this.getRecordComponentPool();

    if (!components.contains(component)) {
        components.add(component);
        if (this.logIsDebugEnabled("recordComponents")) {
            this.logDebug("addToRecordComponentPool() added " + component.ID + " to the pool", 
                "recordComponents");
        }
        return true;
    } else {
        if (this.logIsDebugEnabled("recordComponents")) {
            this.logDebug("addToRecordComponentPool() passed a component that's already pooled" +
                " - " + component.ID + " - ignoring...", 
                "recordComponents");
        }
    }
    return false;
},

// Should we show a recordComponent for this record/col?
// checks for various records we want to skip, like the separator rows, and
// fires the public 'showRecordComponent()' method to allow custom suppression of RCs for
// certain rows or cells.
shouldShowRecordComponent : function (record, colNum) {

    if (record == null || record._isGroup || record._isSummaryRow ||
        record[this.isSeparatorProperty] || record[this.groupSummaryRecordProperty] ||
        Array.isLoading(record))
    {
        return false
    }
    return this.showRecordComponent(record,colNum);
},

// Override point documented in registerStringMethods().

showRecordComponent : function () {
    return true;
},

// notification from each body when getInnerHTML is called.
bodyDrawing : function (body) {

    if (isc._traceMarkers) arguments.__this = this;

    // don't fetch valueMap in response to draw on both the frozen and liquid body - just
    // on the normal (liquid) one
    if (body != this.body) return;

    // when the primary body draws, kick of a queue of requests for the visible data and any
    // valueMaps we'll need for fields with optionDataSource set
    var startedQueue;
    if (this._fetchValueMap) {
        // fetch valueMaps for fields where optionDataSource is set
        startedQueue = !isc.RPCManager.startQueue();
        this._fetchValueMapData();
    }
    this.requestVisibleRows();

    if (startedQueue) isc.RPCManager.sendQueue();
    this._fetchValueMap = null;
    delete this._redrawOnScrollInProgress;
},


//> @attr listGrid.recordComponentHeight (Integer : null : IRWA)
// If +link{listGrid.showRecordComponents} is true, this attribute may be used to
// specify a standard height for record components.
// If specified every row in the grid will be sized tall enough to accommodate a recordComponent
// of this size.
// <P>
// Note that if this property is unset, the grid will not be able to know row heights in
// advance, and +link{listGridField.frozen,frozen fields} are not currently supported in
// this case.  If you are putting a recordComponent in every row, and they all have a consistent
// height, set <code>recordComponentHeight</code> and you will then be able to use frozen fields
// <i>and</i> avoid the whitespace side-effect of virtual scrolling by setting 
// +link{virtualScrolling}:false.
// <P>
// Similarly, if your recordComponents are never tall enough that they will expand the row
// beyond the +link{cellHeight}, set +link{virtualScrolling}:false to avoid the whitespace
// side-effect of +link{virtualScrolling,virtual scrolling} and to allow 
// +link{listGridField.frozen,frozen fields} to be used.  In this mode, you can have
// recordComponents on some rows but not others, and recordComponents of different heights, so
// long as no recordComponent ever causes a row to grow beyond +link{cellHeight} (which would
// happen if the recordComponents height + 2*+link{cellPadding} is larger than 
// +link{cellHeight}).
// 
// @see virtualScrolling
// @group recordComponents
// @visibility external
//<


//> @method listGrid.setRecordComponentHeight()
// Setter for the +link{listGrid.recordComponentHeight}
// @param height (Integer) recordComponent height
// @group recordComponents
// @visibility external
//<
setRecordComponentHeight : function (height) {
    this.recordComponentHeight = height;
    if (this.isDrawn()) this.markForRedraw();
},

// Override 'getAvgRowHeight()' - if recordComponentHeight is specified and we're showing
// recordComponents, make use of it.
// Used by the gridRenderer in virtual scrolling mode to figure out end spacer size /
// thumb size.
getAvgRowHeight : function (body) {

    if (this.showRecordComponents && this.recordComponentHeight != null) {
        var rcrh = this.getRecordComponentRowHeight();
        if (rcrh != null) return rcrh;
    }
    // standard behavior
    // For virtual-scrolling, rely on the "avgRowHeight" specified in the body
    // otherwise assume constant record heights for all rows.
    return !body.virtualScrolling ? body.cellHeight
                                 : Math.max(body.cellHeight,body.avgRowHeight);

},

_$expand:"expand",
getRecordComponentRowHeight : function () {
    if (this.recordComponentHeight == null) return null;
    var pos = this.getRecordComponentPosition();
    if (pos == this._$expand) return this.cellHeight + this.recordComponentHeight;
    else return Math.max(this.recordComponentHeight, this.cellHeight);
},

// ListGridField.optionDataSource handling
// ---------------------------------------------------------------------------------------

// This logic handles fields where an optionDataSource acts as a server-side valueMap
//
// For fields with a specified optionDataSource separate from this grid's dataSource, with
// displayField and valueField specified, we need to perform a fetch against the server to
// get a map from data values to display values

// _setOptionDataSources() (called from setFields())
// iterate through the list of fields and take note of optionDataSource property to look up the
// display map later when the LG is drawn or redrawn (see bodyDrawing)
_setOptionDataSources : function () {

    
    // _fetchValueMap - one time flag to kick off a fetch in bodyDrawing
    var pendingFetch = this._fetchValueMap;
    this._fetchValueMap = null;

    var oldODSs = this._optionDataSources;
    this._optionDataSources = [];

    var gridDS = this.getDataSource();

    for (var i = 0; i < this.completeFields.length; i++) {
        var field = this.completeFields[i];
        
        if (field == null) {
            this.logWarn("Fields array contains an empty entry");
            continue;
        }

        var displayField = field.displayField || field[this.fieldIdProperty],
            valueField = field.valueField || field[this.fieldIdProperty];

        // autoFetchDisplayMap can be set at the field or LG level
        if (field.optionDataSource == null ||
            // If the display field matches the valueField don't bother to do a fetch since
            // we don't need to map the static raw cell value to a display value.
            // If the field is editable this means that we'll rely on the editor to perform a fetch
            // based on the optionDataSource rather than being passed an explicit valueMap.
            field.displayField == null || (field.displayField == field.valueField) ||
            (field.valueField == null && (field.displayField == field[this.fieldIdProperty])) ||
            (field.autoFetchDisplayMap == false) ||
            (this.autoFetchDisplayMap == false && field.autoFetchDisplayMap == null))
        {
            continue;
        }

        var optionDS = isc.DS.get(field.optionDataSource);
        if (optionDS == null) {
            this.logWarn(field.optionDataSource + " dataSource not found, check value of " +
                         "optionDataSource property on the " + field[this.fieldIdProperty] +
                         " field");
            continue;
        

        }

        var optionDSID = optionDS.ID,
            fieldName = field[this.fieldIdProperty],
            optionCriteria = field.optionCriteria;

        // have we already set up an optionDataSource config object from our previous set of fields?
        // which matches this ODS / criteria?

        // If so re-use it - we may not even need to re-fetch data!
        var addedToConfig = false;
        // Never try to fold fields with explicitly specified optionFetchContext into
        // a single responses
        if (oldODSs && !field.optionFilterContext) {
            for (var ii = 0; ii < oldODSs.length; ii++) {
                var ODSConfig = oldODSs[ii];
                if (ODSConfig == null) continue;
                if (this._fieldMatchesODSConfig(field, ODSConfig)) {
                    ODSConfig._fields = [field];
                    this._optionDataSources.add(ODSConfig);
                    oldODSs[ii] = null;
                    addedToConfig = true;
                    /*
                    this.logWarn("setOptionDataSources() field:"+ field.name +
                        " bound to dataSource ID:"+ optionDSID +
                        ", [crit:"+ this.echo(optionCriteria) +
                        "] matched existing optionDataSource config block from previous fields " +
                        "so added field to config.");
                    */
                    break;
                }
            }
        }

        if (!addedToConfig && !field.optionFilterContext) {
            for (var ii = 0; ii < this._optionDataSources.length; ii++) {
                var ODSConfig = this._optionDataSources[ii];
                if (this._fieldMatchesODSConfig(field, ODSConfig)) {
                    ODSConfig._fields.add(field);
                    addedToConfig = true;
                    /*
                    this.logWarn("setOptionDataSources() field:"+ field.name +
                        " bound to dataSource ID:"+ optionDSID +
                        ", [crit:"+ this.echo(optionCriteria) +
                        "] matched existing optionDataSource config block so added to field.");
                    */
                    break;
                }
            }
        }

        if (!addedToConfig) {
            this._optionDataSources.add({
                _dsID:optionDSID,
                _fields:[field],
                _textMatchStyle:field.optionTextMatchStyle,
                _criteria:optionCriteria,
                _optionContext:field.optionFilterContext,
                _optionOperationId:field.optionOperationId
            });

            // -- is this the only case where we need to fetch?
            //    Assumption is that in other cases we either already kicked off a fetch
            //    or picked up the field from our 'old ds's', and so already have a resultSet

            // keep going for a bit...


            // in this case we need to kick off a fetch for this dataSource
            // Set the flag to handle this when the body gets redrawn to reflect the new set of
            // fields
            /*
            this.logWarn("setOptionDataSources() field:"+ field.name +
                " bound to dataSource ID:"+ optionDSID +
                ", [crit:"+ this.echo(optionCriteria) +
                "] doesn't match fetch conditions for any other field with an option dataSource, " +
                "so performing a new fetch for it.");
            */
            this._fetchValueMap = true;
        }
    }

    // If we added to existing config, and we've cleared the _fetchValueMap flag,
    // this implies we have a fetch config set up (which we've updated) but we haven't
    // kicked off the fetch. Re-set the fetchValueMap flag so we do fetch on body draw.
    if (addedToConfig && !this._fetchValueMap && pendingFetch) {
        this._fetchValueMap = true;
    }

    // update the valueMaps for new fields bound to optionDataSources for which we already have
    // a resultSet
    for (var i = 0; i < this._optionDataSources.length; i++) {
        if (this._optionDataSources[i]._data != null) {
            this._updateValueMapFromODS(this._optionDataSources[i]);
        }
    }

    // If we had any previous optionDataSource config type options which are no longer required,
    // clean them up now by calling 'destroy()' on the resultSet (data object) and letting everything
    // go out of scope at the end of the method.
    if (oldODSs != null) {
        for (var i = 0; i < oldODSs.length; i++) {
            if (oldODSs[i] && oldODSs[i]._data) oldODSs[i]._data.destroy();
        }
    }
},

// little helper method - does a field with an optionDataSource specified match an existing
// optionDataSource config object.

_fieldMatchesODSConfig : function (field, config) {

    return (
        // same dataSource
        config._dsID == field.optionDataSource &&
        // optionTextMatchStyle should match
        
        (field.optionTextMatchStyle == config._textMatchStyle) &&
        // if optionOperationId is specified on a field it must also match
        (field.optionOperationId == config._optionOperationId) &&
        // criteria unset or match
        (isc.DataSource.getDataSource(config._dsID).compareCriteria(
            field.optionCriteria || {}, config._criteria || {}) == 0)
    );

},

// Given a resultSet bound to a dataSource, update the valueMap for any fields bound to this
// optionDataSource.
_updateValueMapFromODS : function (ODSConfig) {
    var odsID = ODSConfig._dsID,
        fields = ODSConfig._fields;

    if (fields == null || fields.length == 0) {
        this.logWarn("_updateValueMapFromODS fired for dataSource:"+ odsID +
                    " which no longer applies to any fields in this ListGrid");
        return;
    }

    var resultSet = ODSConfig._data;

    // avoid trying to get a valueMap if we are called when the cache has just been invalidated
    // or before the ResultSet has been created
    if (resultSet == null ||
        // only bail if we have a resultSet with unknown length AND no initialData
        (isc.isA.ResultSet(resultSet) && !resultSet.lengthIsKnown() && !resultSet.initialData))
    {
            return;
    }

    if (ODSConfig._optionOperationId) {
        // if the ODSConfig has an optionOperationId, set that as the fetch op on the resultSet
        resultSet.fetchOperation = ODSConfig._optionOperationId;
    }

    var groupBy = this.getGroupByFields() || [],
        fieldNames = fields.getProperty(this.fieldIdProperty),
        needsRegroup = false
    ;

    if (!isc.isAn.Array(groupBy)) groupBy = [groupBy];

    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            valueField = (field.valueField || field[this.fieldIdProperty]),
            map = resultSet.getValueMap(valueField, field.displayField)
        ;
        // If we haven't yet integrated the field into our fields array, store the
        // valueMap on it directly rather than calling this.setValueMap() -- this way it'll get
        // picked up when setFields() completes
        if (this.getField(field[this.fieldIdProperty]) == null) {
            field.valueMap = map;
        } else {
            this.setValueMap(field[this.fieldIdProperty], map);
        }

        if (groupBy.contains(field.valueField) || groupBy.contains(field.displayField)) {
            // if we've just loaded the ODS for one of the groupFields, we need to regroup to
            // re-evaluate the groupTitles
            this._needsRegroup = true;
        }

    }

    if (this._needsRegroup) {
        // we need a regroup - check to see if all ODSs have been loaded and only regroup if
        // they have
        var allConfigLoaded = true;
        for (var i = 0; i < this._optionDataSources.length; i++) {
            var ODSConfig = this._optionDataSources[i];
            if (!ODSConfig._data) {
                allConfigLoaded = false;
                break;
            }
        }

        if (allConfigLoaded) {
            this.regroup(true);
            delete this._needsRegroup;
        }
    }
},


// _fetchValueMapData()
// for fields with an optionDataSource, kick off a fetch to get a valueMap for the field
_fetchValueMapData : function () {

    var shouldSendQueue;

    // For each field with an optionDataSource, kick off a fetch if we have no data, otherwise
    // update the valueMap with the existing data
    for (var i = 0; i < this._optionDataSources.length; i++) {
        var ODSConfig = this._optionDataSources[i];
        if (ODSConfig._data == null) {
            if (shouldSendQueue == null) {
                shouldSendQueue = !isc.RPCManager.startQueue();
            }

            var optionDSID = ODSConfig._dsID;

            // add component context to request properties for rpc history tree in dev console
            // as a comma delimited list of fields bound to the ODS in question
            var compContext,
                optFields = ODSConfig._fields;
            if (optFields && optFields.length > 0) {
                compContext = "ODS:";
                for (var ii = 0; ii < optFields.length; ii++) {
                    compContext += optFields[ii].name;
                    if (ii < optFields.length - 1) compContext += ",";
                }
            }

            var context = ODSConfig._optionContext || {};
            isc.addProperties(
                context,
                {showPrompt:false, internalClientContext:{ODSConfig:ODSConfig},
                 componentId:this.getID(),
                 componentContext: compContext,
                 textMatchStyle:ODSConfig._textMatchStyle
                }
            );
            if (ODSConfig._optionOperationId != null) {
                context.operationId = ODSConfig._optionOperationId;
            }
            isc.DataSource.getDataSource(optionDSID).fetchData(
                ODSConfig._criteria,
                {target:this, methodName:"_fetchValueMapCallback"},
                context
            );
        }
    }

    if (shouldSendQueue) isc.RPCManager.sendQueue();
},


// _fetchValueMapCallback()
// Callback from request to get all data from some field's optionDS.
// Creates a valueMap so we show the displayField value in the field
_fetchValueMapCallback : function (dsResponse, data, dsRequest) {

    var optionDataSourceConfig = dsRequest.internalClientContext.ODSConfig;
    // if the fields were changed before the fetch returned
    // OR we kicked off 2 fetches against the same dataSource and have already
    // set up our resultSet data, bail
    if (!optionDataSourceConfig || (optionDataSourceConfig._data != null) ||
        !this._optionDataSources || !this._optionDataSources.contains(optionDataSourceConfig))
    {
        return;
    }

    optionDataSourceConfig._data = isc.ResultSet.create({
        dataSource:optionDataSourceConfig._dsID,
        ODSConfig:optionDataSourceConfig,
        targetGrid:this,
        dataChanged:"this.targetGrid._updateValueMapFromODS(this.ODSConfig)",
        initialData:data
    })

    // Force an update now
    this._updateValueMapFromODS(optionDataSourceConfig);

    return true;
},

getPromptStyle : function () {
    return isc.Browser.useHighPerformanceGridTimings && this._redrawOnScrollInProgress ? "component" : null;
},
    
showComponentPrompt : function () {
    this.loadingData = true;
    if (this.sorter && this.sorter.setTitle) {
        this.sorter.setTitle(this.sorter.getTitle());
    }
},
clearComponentPrompt : function () {
    delete this.loadingData;
    if (this.sorter && this.sorter.setTitle) {
        this.sorter.setTitle(this.sorter.getTitle());        
    }
},
    
// Helper to destroy() the resultSet(s) we create to handle valueMaps from the server
_dropODSData : function () {
    if (this._optionDataSources == null) return;
    for (var i = 0; i < this._optionDataSources.length; i++) {
        var data = this._optionDataSources[i]._data;
        if (data) data.destroy();
    }
    delete this._optionDataSources;
},

requestVisibleRows : function () {

    var data = this.data,
        body = this.body,
        isResultSet  = isc.ResultSet  != null && isc.isA.ResultSet(data),
        isResultTree = isc.ResultTree != null && isc.isA.ResultTree(data)
    ;

    
    if (isResultSet && !data.lengthIsKnown() || isResultTree && data.isLoading(data.root)) {
        if (body && body.getScrollTop() > 0) body._resetScrollTopBeforeFetch();
    }

    // ask for all the rows we're about to render.  This enables better predictive fetching
    // relative to asking for data one row at a time while we render.
    
    var isPagedResultTree = isResultTree && this.data.isPaged();
    
    if (isResultSet || isPagedResultTree) {
        if (body == null || body._reused) {
            
            var willBeGrouped = (isResultSet && (
                    this.isGrouped ||
                    (this.groupByField != null && this.getUnderlyingField(this.groupByField))));
            
            var dataPageSize = Math.max(this.dataPageSize || 0, 1);

            // If drawAllMaxCells is specified and we don't yet know our total size, 
            // request enough rows to satisfy drawAllMaxCells.
            // We have equivalent logic in the body - see GR.getDrawArea()
            if (this.drawAllMaxCells && numCols != null && numCols > 0) {                
                var numCols = this.getFields().length,
                    drawAllMaxRows = Math.floor(this.drawAllMaxCells / numCols);
                if (drawAllMaxRows > dataPageSize) dataPageSize = drawAllMaxRows;
            }
            
            if (willBeGrouped) {
                
                return this.data.getRange(0, Math.max(dataPageSize, this.groupByMaxRecords));
            } else {
                return this.data.getRange(0, dataPageSize);
            }
        }
        
        if (isResultSet && this.data.lengthIsKnown() && this.data.getLength() == 0) {
            return;
        }

        
        if ((isResultSet && !this.data.lengthIsKnown()) || isPagedResultTree) {
            body.showAllRows = false;
        } else {
            // NOTE: this check is necessary because the body itself forces showAllRows to true
            // on init if overflow:visible.  It would probably be more robust to pass a
            // one-time flag to getTableHTML() so that we don't clobber other changes to
            // showAllRows
            body.showAllRows = body.overflow == isc.Canvas.VISIBLE ? true : this.showAllRecords;
        }
        
        var scrollTop, scrollRowNum,
            cell = this._scrollCell;
        if (cell != null) {
            if (body.virtualScrolling) scrollRowNum = isc.isAn.Array(cell) ? cell[0] : cell;
            else                       scrollTop = this._getScrollTopFromScrollCell(cell);
        }

        // grab the drawRect, adjusted by the saved scrollCell
        var drawRect = body.getDrawArea(null, scrollTop);
        if (scrollRowNum) body._moveDrawRect(drawRect, scrollRowNum);
        
        // force all rows to be grabbed if we're grouping. (We'll need them anyway.)
        if (isResultSet && this.isGrouped) {
            
            return this.data.getRange(0, this.groupByMaxRecords);
        } else {
            // getRange() is non-inclusive at the end, but getDrawArea() is inclusive
            // at the end so we need to increment drawRect[1] by 1.
            return this.data.getRange(drawRect[0], drawRect[1] + 1);
        }

    
    } else if (this.body != null) {
        // If our data isn't a resultSet, ensure that showAllRows reflects this.showAllRecords
        // This is required for the case where we are databound and grouped so this.data
        // was a resultSet when this method last ran and is now a client-side tree with
        // complete results
        this.body.showAllRows = (this.body.overflow == isc.Canvas.VISIBLE ?
                                     true : this.showAllRecords);
    }
    return null;
},

// return desired scrollTop associated with passed scrollCell
_getScrollTopFromScrollCell : function (scrollCell) {
    var body = this.body;
    if (!body || body.overflow == isc.Canvas.VISIBLE || body.overflow == isc.Canvas.IGNORE) {
        return;
    }
    // scrollCell may be a rowNum or an array of the form [rowNum, colNum, xPosition, yPosition]
    var rowNum, position;
    if (isc.isAn.Array(scrollCell)) {
        rowNum = scrollCell[0], position = scrollCell[3];
    } else if (scrollCell != null) {
        rowNum = scrollCell;
    } else return;

    

    // y coordinate from rowNum calculation must be adjusted to comply with yPosition
    
    var y = this.cellHeight * rowNum,
        rowHeight = this.cellHeight
    ;
    if      (position == this._$center || position == null) y += Math.floor(rowHeight / 2);
    else if (position == this._$bottom)                     y +=            rowHeight;

    // now calculate desired scrollTop using canvas API
    return body._getDesiredScrollTop(y, null, position);
},

// Printing
// --------------------------------------------------------------------------------------------

//> @attr listGrid.printAutoFit (Boolean : true : IRW)
// Whether cell contents should wrap during printing.  Equivalent to +link{type:Autofit}, but
// specific to printed output.
// @group printing
// @visibility external
//<
printAutoFit:true,

//> @attr listGrid.printWrapCells (Boolean : true : IRW)
// Whether cell contents should wrap during printing.  Equivalent to +link{wrapCells}, but
// specific to printed output.
// @group printing
// @visibility external
//<
printWrapCells:true,

//> @attr listGrid.printHeaderStyle (CSSStyleName : "printHeader" : IRW)
// Style for header cells in printed output.  Defaults to +link{headerBaseStyle} if null.
// @group printing
// @visibility external
//<
printHeaderStyle:"printHeader",

//> @attr listGrid.printBaseStyle (CSSStyleName : null : IRW)
// Style for non-header cells in printed output.  Defaults to +link{baseStyle} if null.
// @group printing
// @visibility external
//<

//> @attr ListGrid.printMaxRows (int : 100 : IRWA)
// Advanced property - when generating printHTML for a large ListGrid, rows are printed in
// batches in order to avoid triggering a native "script is running slowly" browser dialog.
// <P>
// For grids with exceptional numbers of columns or complex formatting logic, this number
// might need to be adjusted downward.
//
// @group printing
// @visibility external
//<
// Note that this means getPrintHTML() is frequently asynchronous for ListGrids
printMaxRows:100,





getPrintHTML : function (printProperties, callback) {

    var body = this.body;
    // we may have getPrintHTML called while we're undrawn - if so, we'll need to set up our
    // children here
    if (body == null) {
        this.createChildren();
        body = this.body;
    }

    // if the body is pending a redraw, force it now
    if (this.isDirty() || body.isDirty()) {
        this.redraw("updating HTML for printing");
    }

    var printProps = this.updatePrintProperties(printProperties);
    // with a partial cache, print only the contiguous cache around the currently visible rows
    
    var startRow, endRow;
    if (isc.isA.ResultSet(this.data) && !this.data.allMatchingRowsCached()) {
        var visRows = this.body.getVisibleRows(),
            firstVisibleRow = visRows ? visRows[0] : null,
            cachedRange = this.data.getCachedRange(firstVisibleRow);
        if (cachedRange != null) {
            startRow = cachedRange[0];
            endRow = cachedRange[1];
        }
    }

    
    var printWidths = isc.Canvas.applyStretchResizePolicy(this.fields.getProperty("width"),
                                                printProps.width || isc.Page.getWidth());

    // set up the HTML for the header / footer rows based on
    // gridComponents. This will actually be written out by the grid body.
    // Ultimately calls body.getTablePrintHTML() and returns the combined result
    var HTML = this.setupHeaderPrintHTML({startRow:startRow, endRow:endRow, callback:callback,
                                     printWidths:printWidths, printProps:printProps});
                                     
    // if a callback was passed, it will always fire, and this method should return nothing,
    // unless it's being used as an expansionRelated grid inside another LG
     if (this.isExpansionGrid || !callback) {
        return HTML;
    }
},

// This method will generate HTML for the header / footer rows, ultimately picked up by
// the override to gridBody.getPrintHeaders() / getPrintFooters()
// Note - potentially asynchronous, depending on what gridComponents are specified.
setupHeaderPrintHTML : function (gridPrintConfig, HTML, componentIndex) {
    var isAsync = componentIndex != null;
    if (HTML == null) HTML = "";
    if (componentIndex == null) componentIndex = 0;

    var body = this.body;

    // Used by 'shouldPrintChild' and possibly printHTML of arbitrary children
    this.currentPrintProperties = gridPrintConfig.printProps;

    var components = this.gridComponents;
    for (var i = componentIndex; i < components.length; i++) {
        var comp = components[i];

        // Once we hit the body, we've got all the "header" row HTML - store that
        // on the body (will be returned by customized 'getPrintHeaders()'), and
        // continue onto the footer HTML
        
        if (comp == "body") {
            body._printHeadersHTML = HTML;
            // reset "HTML" to start collecting "footers" HTML
            HTML = "";
            continue;
        }

        // This will skip the filterEditor, and anything that's not actually showing
        // by default.
        if (!this.shouldPrintGridComponent(comp)) {
            continue;
        }

        if (comp == "header") {
            HTML += this.getPrintHeaderRow();

        } else if (comp == "summaryRow") {
            HTML += this.getPrintSummaryRow();

        } else if (isc.isA.Canvas(comp)) {
            // this maybe asynchronous, so pass in a callback to continue
            // generating HTML
            
            // Use closure to hang onto context
            var _this = this,
                componentPrintCallback = function componentPrintCallback (compPrintHTML) {
                HTML += "<TR><TD colSpan='" + _this.fields.length + "'>"
                        + compPrintHTML + "</TD></TR>";
                _this.setupHeaderPrintHTML(gridPrintConfig, HTML, i+1);
            }
            var compHTML = comp.getPrintHTML(gridPrintConfig.printProps,
                                componentPrintCallback);

            // Component getPrintHTML method returned null - must be asynchronous, so
            // we'll continue this loop when that method completes.
            if (compHTML == null) {
                return null;
            }

            HTML += "<TR><TD colSpan='"+this.fields.length+ "'>" +
                    compHTML +
                    "</TD></TR>";
        } else {
            // Not an explicit widget, nor one of the standard strings - not clear
            // how to handle this.
            
            this.logWarn("getPrintHTML() - unable to get print HTML for gridComponent " +
                comp);
        }
    }
    delete this.currentPrintProperties;


    // at this point we've got the footer HTML for the body set up - store that off
    // so body.getPrintFooters() behaves correctly
    body._printFootersHTML = HTML;

    return this.setupHeaderPrintHTMLComplete(gridPrintConfig, isAsync);

},


setupHeaderPrintHTMLComplete : function (gridPrintConfig, isAsync) {
    // getTablePrintHTML() - implemented at the GridBody level.
    // If it goes asynchronous it'll fire the callback and return null - otherwise it'll
    // return print HTML
    var bodyHTML = this.body.getTablePrintHTML(gridPrintConfig);

    // isAsync flag - implies setupHeaderPrintHTML was asynchronous - in this case
    // rather than returning the generated HTML, or relying on the grid body to fire the
    // print callback, we have to fire the callback ourselves.
    // September 2015 - if a dev installed a callback, always fire it (as per the docs)

    
    var devCallback = gridPrintConfig.callback && gridPrintConfig.callback.printCallback;
    if (bodyHTML != null && (devCallback || isAsync)) {
        var callback = gridPrintConfig.callback;
        if (callback) {
            this.fireCallback(callback, "HTML,callback", [bodyHTML,callback]);
        }
    }

    return isAsync ? null : bodyHTML;
},

// Undocumented feature - suppress printing of gridComponents via "print<CompName>" flags
// being set to false
shouldPrintAttributeMap:{
    filterEditor:"printFilterEditor",
    header:"printHeader",
    summaryRow:"printSummaryRow"
},
// Suppress printing of filterEditor by default

printFilterEditor:false,

shouldPrintGridComponent : function (component) {
    if (component == null) return false;

    if (isc.isA.String(component)) {
        var shouldPrintAttr = this.shouldPrintAttributeMap[component];
        if (shouldPrintAttr != null && this[shouldPrintAttr] != null) {
            return this[shouldPrintAttr];
        }
        return this.shouldShowGridComponent(component);
    }
    return this.shouldPrintChild(component);

},


// Returns the print HTML (table row) for headers for this grid.
// This is a helper for "setupHeaderPrintHTML"
getPrintHeaderRow : function () {
    var fields = this.fields.duplicate();
    // suppress rendering out the shouldPrint fields
    fields.removeAll(fields.findAll("shouldPrint", false));

    var startCol = 0, endCol = fields.length;
    var defaultAlign = isc.Canvas.LEFT,
        printHeaderStyle = this.printHeaderStyle || this.headerBaseStyle,
        HTML;


    // We support arbitrarily nested, asymmetrical header-spans - these require
    // some slightly tricky logic so use a conditional to avoid this if not required.
    if (this.headerSpans) {

        // Step 1: We'll build an array of "logical columns" in this format:
        // [field1], [innerHeader1], [topHeader]
        // [field2], [innerHeader2], [topHeader]
        // [field3], [topHeader2]
        // Each array contains an entry for each row we'll write out (each header
        // span the field is embedded in, plus the field).
        // Note that the top row of HTML will be the last entry in each sub-array and
        // the bottom row will be the first entry (the field should appear below
        // all its headers).
        // Also note we have repeats in here - we'll handle this by applying colSpans
        // to the generated HTML - and that the column arrays will be different lengths
        // due to different depth of nesting of header spans - we'll handle this by
        // applying rowSpans.
        var logicalColumns = [],
            numRows = 1;

        var spanMap = this.buildSpanMap(null, null, true);
        for (var i = startCol; i < endCol; ++i) {
            var field = fields[i];
            logicalColumns[i] = [field];

            var span = spanMap[field.name];

            // build a logical column from the fieldName up to the top span
            // (Note that we will have the same span in multiple cols, which is ok)
            while (span != null) {
                logicalColumns[i].add(span);
                span = span.parentSpan;
            }
            // Remember how deep the deepest nested column is - this is required to
            // allow us to apply numRows.
            numRows = Math.max(logicalColumns[i].length, numRows);
        }
        

        // Step 2: Iterate through the column arrays starting at the last entry
        // (outermost header)
        HTML = [];

        for (var i = numRows-1; i >= 0; i--) {
            HTML[HTML.length] = "<TR>";

            var lastEntry = null,
                colSpanSlot = null;
            for (var ii = startCol; ii < endCol; ii++) {
                var rowSpan = 1, colSpan = 1;
                // When we reach the first entry in the array we'll be looking at a field
                var isField = (i == 0);

                var entry = logicalColumns[ii][i];
                

                // If we hit a spanned marker we've already written out a row and/or
                // colSpanning cell that covers this entry - short-circuit the logic
                // below in this case.
                if (entry == "spanned") {
                    continue;
                }
                // our logical column arrays will be different lengths as
                // we can have unequal depth header spans (including potentially
                // just fields).
                // To handle this we'll have to apply rowSpans.
                // Sub-headers can have unequal depths - for example a header
                // span could contain a child span with fields and another child span
                // with its own child-span before their are fields.
                // This means we cant "take up all the slack" on the outer headers, we
                // have to apply rowSpans at potentially several levels.
                // Strategy:
                // - if this is a null entry there are fewer rows in this column than
                //   the total, so we need a rowSpan > 1 somewhere.
                //   Reach up the column until we find an entry - this will be the
                //   header we'll write out, and remember how deep we had to go
                //   (that will be the rowSpan)
                // - The header may span multiple columns - repeat this process for
                //   each subsequent column until we find a header span that differs
                //   from the one we were looking at.
                // At this point we'll know how many cols the header spans, and how deep
                // we had to go to find it in each col.
                // ColSpan will be the number of cols spanned.
                // RowSpan will be the minimum depth we had to go.
                // Now modify the logical column arrays to ensure we don't write out
                // duplicate cells in the generated HTML:
                // - replace every cell we span with a "spanned" marker so we skip it
                // - if the entry we are using as the source for the header doesn't
                //   fall in this range, clear its entry from the logical column array.
                //   Then on the iteration for the row where we would have it it we'll
                //   hit another null entry, and that will cause us to look at the
                //   next entry down instead and render it out with appropriate rowSpan
                var minDepth = 0,
                    spanningColNum = ii,
                    spannedColOffsets = [];

                // set colSpan to zero. We'll increment in the loop below
                colSpan = 0;

                while (spanningColNum < endCol) {
                    var entryToTest = null,
                        foundMismatch = false;
                    for (var offset = 0; (i-offset) >= 0; offset++) {
                        entryToTest = logicalColumns[spanningColNum][i-offset];
                        

                        if (entryToTest != null) {
                            // If we originally hit a null entry, pick up the first
                            // non null entry so we have something to actually write out.
                            if (entry == null) {
                                entry = entryToTest;
                                minDepth = offset;
                                if (i-offset == 0) {
                                    isField = true;
                                }
                            }
                            if (entry == entryToTest) {
                                spannedColOffsets[colSpan] = offset;
                                minDepth = Math.min(offset, minDepth);
                            } else {
                                foundMismatch = true;
                            }
                            break;
                        }
                    }
                    if (foundMismatch) {
                        break;
                    }
                    spanningColNum ++;
                    
                    colSpan++;
                }

                // set rowSpan for the cell based on how deep we had to
                // go to find a real entry (shift from zero to 1-based)
                if (minDepth != null) {
                    rowSpan = minDepth+1;
                }

                

                // For each column this entry spans, add markers indicating that
                // we're handling this via TD with rowSpan and colSpan set (and
                // clear out duplicate entries).
                for (var spannedCols = 0; spannedCols < spannedColOffsets.length;
                    spannedCols++)
                {

                    var logicalColArray = logicalColumns[spannedCols + ii],
                        offset = spannedColOffsets[spannedCols];

                    for (var spannedRows = 0; spannedRows <= offset; spannedRows++) {
                        
                        if (spannedCols == 0 && spannedRows == 0) {
                            logicalColArray[i-spannedRows] = entry;
                        } else if (spannedRows <= minDepth) {
                            logicalColArray[i - spannedRows] = "spanned";
                        } else {
                            logicalColArray[i - spannedRows] = null;
                        }
                    }
                }

                

                // We don't expect to ever end up with a null entry - not sure
                // how this could happen but log a warning
                if (entry == null) {
                    this.logWarn("Error in getPrintHeaders() - unable to generate " +
                        "print header HTML from this component's specified headerSpans");
                }

                var align = "center",
                    cellValue;

                if (isField) {
                    align = entry.align || defaultAlign;
                    cellValue = this.getHeaderButtonTitle(entry.masterIndex);
                } else {
                    cellValue = entry.title;
                }

                // Flip alignment if isRTL is true and reverseRTLAlign is set
                if (this.isRTL() && this.reverseRTLAlign) {
                    if (align == isc.Canvas.LEFT) align = isc.Canvas.RIGHT;
                    else if (align == isc.Canvas.RIGHT) align = isc.Canvas.LEFT;
                }

                var cellStart = HTML.length;

                HTML[HTML.length] = "<TD class='";
                HTML[HTML.length] = printHeaderStyle;
                HTML[HTML.length] = "' align='";
                HTML[HTML.length] = align;
                HTML[HTML.length] = "' rowSpan='";
                HTML[HTML.length] = rowSpan;
                HTML[HTML.length] = "' colSpan='";
                HTML[HTML.length] = colSpan;
                HTML[HTML.length] = "'>";
//                    HTML[HTML.length] = "' style='border:1px solid black'>";
                HTML[HTML.length] = cellValue;
                HTML[HTML.length] = "</TD>";

                

            }
            HTML[HTML.length] = "</TR>"
        }
//         this.logWarn("\n\nGenerated print header HTML (including spans):" + HTML.join(""));

    } else {
        var HTML = ["<TR>"];

        var cellStartHTML = ["<TD CLASS=", printHeaderStyle,
                             " ALIGN="].join("");

        // Just iterate through the fields once, then assemble the HTML and return it.
        for (var colNum = startCol; colNum < endCol; colNum++) {
            var field = fields[colNum];
            
            var align = field.align || defaultAlign;
            // Flip alignment if isRTL is true and reverseRTLAlign is set
            if (this.isRTL() && this.reverseRTLAlign) {
                if (align == isc.Canvas.LEFT) align = isc.Canvas.RIGHT;
                else if (align == isc.Canvas.RIGHT) align = isc.Canvas.LEFT;
            }

            HTML.addList([cellStartHTML, align, ">",
                                this.getHeaderButtonTitle(field.masterIndex), "</TD>"]);
        }

        // Output the standard header row
        HTML[HTML.length] = "</TR>";
    }
    return HTML.join(isc.emptyString);
},


getPrintSummaryRow : function () {
    if (!(this.summaryRow) || !(this.summaryRow.body) || !(this.showGridSummary)) {
        // return empty string if no data in the grid
        return "";
    }

    var chunkContext = {
        startRow:0,
        endRow:this.summaryRow.getTotalRows(),
        maxRows:this.summaryRow.printMaxRows,
        printProps:this.printProperties || {},
        html:[]
    }

    
    var printWidths = isc.Canvas.applyStretchResizePolicy(this.fields.getProperty("width"),
                                                          chunkContext.printProps.width || isc.Page.getWidth());
    chunkContext.printWidths = printWidths;
    
    this.summaryRow.body.printChunkOnly = true;
    
    var HTML = this.summaryRow.body.getPrintHTMLChunk(chunkContext, true);
    delete this.summaryRow.body.printChunkOnly;
    // this.logWarn("print summary row HTML:" + HTML);
    return HTML;
},

// -------

// This is run before getting the body tableHTML for printing
// If printing HTML in chunks it'll be run repeatedly for each chunk!
// Purpose is to set up the necessary attributes so the body generates print-formatted
// output
_prepareBodyForPrinting : function (printWidths, printProperties) {
    this.isPrinting = this.body.isPrinting = true;
    this.currentPrintProperties = printProperties;

    var body = this.body,
        // don't print editors?
        oldEditorShowing = this._editorShowing;

    // properties to store off and restore
    var origProps = isc.getProperties(body, ["autoFit", "wrapCells", "showAllRows",
                                "showAllColumns", "fixedRowHeights", "_fieldWidths", "fields"
                                

                    ]);

    body.showAllRows = true;
    body.showAllColumns = true;

    this._editorShowing = false; // never show editors
    body.autoFit = this.printAutoFit;
    body.wrapCells = this.printWrapCells;
    body.fixedRowHeights = !this.printWrapCells;

    var fields = this.fields.duplicate();
    // suppress rendering out the shouldPrint fields
    fields.removeAll(fields.findAll("shouldPrint", false));
    body.fields = fields;

    // mark ourselves as unfrozen so we avoid logic to (for example) offset body col-num
    // with frozen col num)
    var oldFrozenFields = this.frozenFields;
    delete this.frozenFields;
    // Temporarily copy all components embedded in the frozenBody into the _embeddedComponents
    // list of the body.
    var oldEmbeddedComponents = this._oldEmbeddedComponents = body._embeddedComponents,
        numFrozenComponents = (
            this.frozenBody != null && this.frozenBody._embeddedComponents != null ?
                this.frozenBody._embeddedComponents.length : 0);
    if (numFrozenComponents > 0) {
        var numNonFrozenComponents = (
                oldEmbeddedComponents != null ? oldEmbeddedComponents.length : 0),
            numComponents = numFrozenComponents + numNonFrozenComponents,
            newComponents = body._embeddedComponents = new Array(numComponents);

        for (var i = numNonFrozenComponents; i--; ) {
            newComponents[i] = oldEmbeddedComponents[i];
        }
        for (var i = numFrozenComponents; i--; ) {
            var ec = this.frozenBody._embeddedComponents[i];
            ec._wasFrozen = true;
            newComponents[numNonFrozenComponents + i] = ec;
        }
    }
    
    this._embeddedComponentColNumOffset = 0;
    this._frozenEmbeddedComponentColNumOffset = 0;
    if (this.freezeStart()) {
        if (this.frozenBody &&
            this.frozenBody._lastDrawnCol != null &&
            this.frozenBody._firstDrawnCol != null)
        {
            this._embeddedComponentColNumOffset = (
                this.frozenBody._lastDrawnCol - this.frozenBody._firstDrawnCol + 1);
        }
    } else {
        if (this.body &&
            this.body._lastDrawnCol != null &&
            this.body._firstDrawnCol != null)
        {
            this._frozenEmbeddedComponentColNumOffset = (
                this.body._lastDrawnCol - this.body._firstDrawnCol + 1);
        }
    }

    body._fieldWidths = printWidths;
    return {oldEditorShowing:oldEditorShowing, oldFrozenFields:oldFrozenFields,
            origProps:origProps};

},

_bodyDonePrinting : function (context) {
    var body = this.body,
        origProps = context.origProps,
        oldEditorShowing = context.oldEditorShowing;

    isc.addProperties(body, origProps);
    if (origProps.showAllRows == null) body.showAllRows = null;
    this._editorShowing = oldEditorShowing;
    this.frozenFields = context.oldFrozenFields;
    body._embeddedComponents = this._oldEmbeddedComponents;
    delete this._oldEmbeddedComponents;
    if (this.frozenBody != null && this.frozenBody._embeddedComponents != null) {
        for (var i = this.frozenBody._embeddedComponents.length; i--; ) {
            var ec = this.frozenBody._embeddedComponents[i];
            delete ec._wasFrozen;
        }
    }
    delete this._embeddedComponentColNumOffset;
    delete this._frozenEmbeddedComponentColNumOffset;

    delete this.currentPrintProperties;

    this.isPrinting = this.body.isPrinting = false;
    
    this.body.markForRedraw("finished printing");
},

// Event Handling
// --------------------------------------------------------------------------------------------

//> @method listGrid.rowClick() (A)
//
// Event handler for when rows in the body are clicked upon. The default implementation handles
// firing +link{ListGrid.startEditing()} if appropriate, and fires
// +link{ListGridField.recordClick()} and/or +link{ListGrid.recordClick()} if set. Developers
// should typically implement recordClick rather than overriding this method.
// <P>
// Note that this method fires in addition to any specified +link{listGrid.cellClick}
// handler (even if that method cancels the event as a whole by returning <code>false</code>).
//
//      @param  record      (ListGridRecord)    record object returned from getCellRecord()
//      @param  recordNum   (int)   index of the row where the click occurred
//      @param  fieldNum    (int)   index of the col where the click occurred
//      @param  [keyboardGenerated]   (boolean) indicates whether this was a synthesized record
//                                              click in response to a keyboard event
//      @group  events
//      @see    recordClick()
//
//      @group  events
//      @return (Boolean)
//      @visibility external
//<
rowClick : function (record, recordNum, fieldNum, keyboardGenerated) {

    // record the last record clicked (used for keyboard navigation)
    this._lastRecordClicked = recordNum;

    var record = this.getCellRecord(recordNum, fieldNum),
        field = this.fields[fieldNum];

    // don't fire recordClick on loading rows
    if (Array.isLoading(record)) return;

    // if the field has a 'recordClick' method, call that
    var value = this.getCellValue(record, recordNum, fieldNum);
    var rawValue = this.getRawCellValue(record, recordNum, fieldNum);

    // if the record is a group header, expand/collapse the group
    if (record != null && record._isGroup) {
        if (this.canCollapseGroup == false) return;
        // if the user navigates through the grid using arrow up / down keys, don't toggle
        // the group when the user hits the group header (Except on explicit space keypress which is
        // more of a deliberate 'pseudo-click' type interaction).
        
        if (keyboardGenerated) {
            var key = isc.EH.getKey();
            if (key != "Space" && key != "Enter") return;
        }
        
        // Click on the "selection" col will toggle the select value - don't
        // also expand/collapse
        
        if (this.canSelectGroups && this.isCheckboxField(field)) {
            return;
        }
        
        if (!this.collapseGroupOnRowClick) {
            var part = this.getEventPart();
            if (!part || part.part != "opener") return;
        }
        
        
        var mythis = this, myrecord=record;
        if (this.getEditRow() != null) {
            if (this.autoSaveEdits) {
                var saveAttempted = this.saveAllEdits(null, function () {
                    mythis.toggleFolder(myrecord);
                });
                // we'll toggle folder in the callback so no need to carry on here.
                if (saveAttempted) return;
            } else {
                this.storeUpdatedEditorValue();
            }
        }
        this.toggleFolder(record);
        return;
    }


    
    if (field.valueIconClick != null && !keyboardGenerated) {
        var part = this.getEventPart();
        if (part && part.part == "valueicon") {
            isc.Func.replaceWithMethod(field, "valueIconClick",
                                             "viewer,record,recordNum,field,rawValue,editor");
            var returnVal = field.valueIconClick(this, record, recordNum, field, rawValue, null);
            if (returnVal == false) return false;
        }
    }
    var editedRecord = this.getEditedRecord(recordNum);

    if (field.recordClick && !(keyboardGenerated && field.keyboardFiresRecordClick == false)) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value,rawValue"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "recordClick",
                                         "viewer,record,recordNum,field,fieldNum,value,rawValue,editedRecord");
        var returnVal = field.recordClick(this, record, recordNum, field, fieldNum, value, rawValue,editedRecord);
        if (returnVal == false) return false;
    }

    // Note - there is also a (legacy) recordClick handler on the GridRenderer class, with a
    // different signature.
    // 'recordClick()' is not one of the GridAPIs - so won't be fired automatically from the
    // GridRenderer click handling code.  If the method was defined on both the ListGrid and
    // the Body, both methods would be fired.
    // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value,rawValue"
    if (this.recordClick) {
        if (this.onRecordClick(this,record,recordNum,field,fieldNum,value,rawValue,editedRecord) == false)
            return false;
        if (this.recordClick(this,record,recordNum,field,fieldNum,value,rawValue,editedRecord) == false)
            return false;
    }

    var editOnClick = this.canEdit != false && 
            (this.editEvent == isc.EH.CLICK || this.editOnFocus || 
             this._isNewRecordRow(recordNum) );

    // Exception - if the user clicked the checkbox field we don't want to start editing
    
    if (this.isCheckboxField(field)) editOnClick = false;

    // one-click toggling of boolean/valueMapped fields.
    // Note: also allows entering of editing if editEvent is click.
    if (field.canToggle && this.canEditCell(recordNum, fieldNum) &&
        this.shouldToggle(field, keyboardGenerated))
    {
        var valueMap = this.getEditorValueMap(field, this.getEditedRecord(recordNum,fieldNum));
        // autocreate a valueMap for boolean
        if (valueMap == null && isc.SimpleType.getBaseType(field.type) == this._$boolean) {
            valueMap = [true,false];
        }
        if (valueMap != null) {
            if (!isc.isAn.Array(valueMap)) valueMap = isc.getKeys(valueMap);
            if (valueMap.length > 1) {

                var fieldName = this.getFieldName(fieldNum),
                    editValue = this.getEditedCell(recordNum, fieldNum),
                    index = valueMap.indexOf(editValue);
                index += 1;
                if (index >= valueMap.length) index = 0;
                var oldValue = editValue;

                editValue = valueMap[index];

                var cancelChange;

                if (field.change != null) {
                    this.logInfo("canToggle firing specified field.change() event directly", "gridEdit");
                    cancelChange = this.fireCallback(
                            field.change,
                            "form,item,value,oldValue",
                            [null,null,editValue,oldValue]
                    ) == false;
                }

                if (!cancelChange) {
                    // autoSaveEdits: Usually if canToggle is true we instantly commit
                    // however if we're also jumping into edit mode it makes more sense to
                    // just toggle the edit value and save when the user dismisses the editor
                    // as usual.
                    if (!editOnClick && this.autoSaveEdits) {
                        this.setEditValue(recordNum, fieldNum, editValue, true, false);

                    } else {
                        this.setEditValue(recordNum, fieldNum, editValue);
                    }
                    if (field.changed != null) {
                        this.logInfo("canToggle firing specified field.changed() event directly", "gridEdit");
                        this.fireCallback(
                            field.changed,
                            "form,item,value",
                            [null,null,editValue]
                        );
                    }

                    if (this.autoSaveEdits) {
                        this.saveEdits(null, null, recordNum, fieldNum);
                    } else {
                        // toggled boolean value - if we are not 
                        // saving it, we still need to validate it
                        this.validateCell(recordNum, fieldNum);
                    }
                }
            }
        }
    }

    if (editOnClick) {
        if (this.handleEditCellEvent(recordNum, fieldNum, isc.ListGrid.CLICK) == true) {
            return true;
        }
        // If this was a keyboard event, and the keyboard click field is not editable, iterate
        // through the other fields, and edit the first editable one we find
        if (keyboardGenerated) {
            for (var i = 0; i< this.fields.length; i++) {
                if (i == fieldNum) continue;
                if (this.handleEditCellEvent(recordNum, i, isc.ListGrid.CLICK) == true) {
                    return true;
                }
            }
        }
    }
},

// By default we only toggle if the event occurred over a field's value-icon
// Exception: If _formatBooleanFieldAsImage returns false we didn't write out an icon for
// the cell
shouldToggle : function (field, keyboardGenerated) {
    if (keyboardGenerated) {
        var key = isc.EH.getKey();
        if (key == this._$Space || key == this._$Enter) return true;
    }
    // Note: no need to check 'canToggle' - this method is only called for fields where
    // canToggle is true.
    if (!this._formatBooleanFieldAsImages(field)) return true;
    var part = this.getEventPart();
    return (part && part.part == "valueicon");
},

//> @method listGrid.rowDoubleClick()   (A)
// Event handler for when a body record is double-clicked.
// <P>
// Default implementation fires 'editCell' if appropriate, and handles firing
// 'recordDoubleClick' stringMethod if defined at the field or LG level (That method has a
// different signature from this one)
//
//      @param  record      (ListGridRecord)    record object returned from getCellRecord()
//      @param  recordNum   (number)    index of the row where the click occurred
//      @param  fieldNum    (number)    index of the col where the click occurred
//      @param  [keyboardGenerated]   (boolean) indicates whether this was a synthesized record
//                                              doubleclick in response to a keyboard event
//
//      @see    recordDoubleClick()
//      @group  events
//      @return (boolean)   false if first click not on same record; true otherwise
//      @visibility external
//<
rowDoubleClick : function (record, recordNum, fieldNum, keyboardGenerated) {

    var field = this.fields[fieldNum],
        value = this.getCellValue(record, recordNum, fieldNum),
        rawValue = this.getRawCellValue(record, recordNum, fieldNum);
    // suppress user-defined handlers on the group header node
    if (record != null && record._isGroup) return;

    var editedRecord = this.getEditedRecord(recordNum,fieldNum);

    if (field.recordDoubleClick) {
        // CALLBACK API:  available variables:  "viewer,record,recordNum,field,fieldNum,value,rawValue"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "recordDoubleClick",
                                         "viewer,record,recordNum,field,fieldNum,value,rawValue,editedRecord");
        var returnVal = field.recordDoubleClick(this, record, recordNum, field, fieldNum, value, rawValue, editedRecord);
        if (returnVal == false) return returnVal;
    }
    if (this.recordDoubleClick != null) {
        // CALLBACK API:  available variables: "viewer,record,recordNum,field,fieldNum,value,rawValue"
        var returnVal = this.recordDoubleClick(this, record, recordNum, field, fieldNum, value, rawValue, editedRecord);
        if (returnVal == false) return returnVal;
    }

    // if the cell is editable, edit it now
    //  (editCell will return true if we've brought up the cell editor)
    if (this.canEdit != false && this.editEvent == isc.EH.DOUBLE_CLICK) {
        if (this.handleEditCellEvent(recordNum, fieldNum, isc.ListGrid.DOUBLE_CLICK) == true) return true;
        // If this was a keyboard event, and the keyboard click field is not editable, iterate
        // through the other fields, and edit the first editable one we find
        if (keyboardGenerated) {
            for (var i = 0; i< this.fields.length; i++) {
                if (i == fieldNum) continue;
                if (this.handleEditCellEvent(recordNum, i, isc.ListGrid.DOUBLE_CLICK) == true) return true;
            }
        }
    }

},

// Body Context Menu
// --------------------------------------------------------------------------------------------
// This will fire 'ListGrid.cellContextClick' if defined.
// Otherwise implements default behavior of showing context menu for the cell.
// enhancement: check for contextMenu,cellContextClick on cell, row, field?
_cellContextClick : function (record, rowNum, colNum) {

    // clear any previous context menu items
    this.cellContextItems = null;

    // Call handler if defined; return false to cancel context menu if handler returns false.  The
    // handler can call lv.makeCellContextItems(record,recordNum,fieldNum), modify the items, and
    // set lv.cellContextItems to customize the context menu.
    if (this.cellContextClick) {
        var record = this.getCellRecord(rowNum, colNum);
        if (this.cellContextClick(record, rowNum, colNum) == false) return false;
    }

    // show cell context menus, or generic context menu?
    if (this.showCellContextMenus) {

        // create the cellContextMenu if necessary
        if (!this.cellContextMenu) {
            this.cellContextMenu = this.createAutoChild("cellContextMenu", this.contextMenuProperties , this.getMenuConstructor());
        }

        // get standard menu items if the handler above did not set custom items
        if (!this.cellContextItems) {
            this.cellContextItems = this.getCellContextMenuItems(
                this.getCellRecord(rowNum, colNum), rowNum, colNum);
        }
        // if there are any menu items, set and show the menu
        if (isc.isAn.Array(this.cellContextItems) && this.cellContextItems.length > 0) {
            this.cellContextMenu.setData(this.cellContextItems);
            this.cellContextMenu.showContextMenu(this);
        }

        // return false to kill the standard context menu
        return false;

    } else {
        // do normal Canvas context menu handling. Will fall through to this.showContextMenu.
        return true;
    }
},

//> @method ListGrid.getShowChildDataSourceContextMenuItemTitle() [A]
// If +link{ListGrid.canOpenRecordDetailGrid} is true and +link{ListGrid.showCellContextMenus}
// is true, we will show menu items to drill into the child datasources in this grid's context
// menu. This method returns the title for that menu item. Override for localization.
// @param ds (DataSource) child datasource to be drilled into
// @return (String) By default returns <code>"Show " + ds.getPluralTitle()</code>
// @group i18nMessages
// @visibility nestedGrid
//<
getShowChildDataSourceContextMenuItemTitle : function (ds) {
    return "Show " + ds.getPluralTitle();
},

//> @method ListGrid.getCellContextMenuItems()
// If +link{attr:listGrid.showCellContextMenus} is <code>true</code> this method returns
// the menu items to be displayed in the default cell context menu.
// <P>
// This method is called at various times, so this method should not instantiate any classes, 
// because they'll be re-created on each call, resulting in a leak - your implementation should 
// return an array of menuItem config-blocks only, so you shouldn't instantiate actual Menu 
// instances to apply as the +link{menuItem.submenu, submenu} of items - instead, set submenu 
// to a simple array of menuItems.  If your use-case necessitates that class instances are 
// created, because specific submenus have a different Menu class, for example, you should keep 
// a reference to them and either, if their content is dynamic, destroy and recreate them with
// the new items, or just return the existing instances otherwise. 
// <P>
// The default set of menu items includes items for built-in ListGrid features, like showing or
// hiding an inline edit form, or removing records.
//
// @param record (Integer) The record the user clicked in
// @param rowNum (Integer) Index of the record the user clicked in
// @param colNum (Integer) Index of the column the user clicked in
//
// @return (Array of MenuItem)
// @visibility external
//<
getCellContextMenuItems : function (record, rowNum, colNum) {
    return this.makeCellContextItems(record, rowNum, colNum);
},

// generate standard cell context menu items
makeCellContextItems : function (record, rowNum, colNum) {
    if (this.dataSource != null) {
        var menuItems = [];

        // menu items to drill into a child DataSource via a nested grid
        if (this.canOpenRecordDetailGrid) {
            var recordDS = isc.DS.get(this.getRecordDataSource(record)),
                childDataSources = recordDS.getChildDataSources();
            if (childDataSources != null) {
                for (var i = 0; i < childDataSources.length; i++) {
                    var ds = childDataSources[i];
                    menuItems.add({
                        title : this.getShowChildDataSourceContextMenuItemTitle(ds),
                        record : record,
                        dataSource : ds,
                        click : "target.openRecordDetailGrid(item.record, item.dataSource)"
                    });
                }
            }
        }

        // menu item to edit with an embedded form
        if (this.canOpenRecordEditor) {
            
            menuItems.add({
                title : this.openRecordEditorContextMenuItemTitle,
                record : record,
                click : "target.endEditing();target.openRecordEditor(item.record)"
            });
        }

        // if we are currently showing anything inside the row offer to dismiss it
        if (record != null && this._openRecord == record) {
            menuItems.add({
                title : this.dismissEmbeddedComponentContextMenuItemTitle,
                click : "target.closeRecord()"
            });
        }

        // menu item to delete a record
        menuItems.add({
            title : this.deleteRecordContextMenuItemTitle,
            click : "target.removeSelectedData()"
        });
        return (menuItems.length > 0 ? menuItems : null);
    }

    return null;
},

// Hover
// ---------------------------------------------------------------------------------------

// override getCanHover.
// If this.canHover is explicitly set to true or false, respect it,
// Otherwise - if any fields are going to show hovers, return true

getCanHover : function () {
    if (this.canHover != null) return this.canHover;
    var showClippedValuesOnHover = this._getShowClippedValuesOnHover();
    if (showClippedValuesOnHover) return showClippedValuesOnHover;
    var fields = this.getFields();
    if (fields != null) {
        for (var i = 0; i < fields.length; i++) {
            if (fields[i].showHover) return true;
        }
    }
    // Either null or false
    return this.canHover;
},

_$hoverHTML: "hoverHTML",
_$fieldHoverHTMLArgNames: "record,value,rowNum,colNum,grid",
_getFieldHoverHTMLCallback : function (rowNum, colNum) {
    var field = this.getField(colNum);
    if (field == null) return null;
    if (field.showHover == false) return null;
    if (field.showHover == null && !this.canHover) return null;
    // if the record is a group-row and singleCellGroupHeaders() is true, bail now, before
    // checking for a hoverHTML implementation on the field
    var record = this.getRecord(rowNum);
    if (record._isGroup && this.singleCellGroupHeaders()) return null;
    if (field.hoverHTML) {
        isc.Func.replaceWithMethod(field, this._$hoverHTML, this._$fieldHoverHTMLArgNames);
        return {
            target: field,
            methodName: this._$hoverHTML
        };
    }
    return null;
},

_isCellHoverSuppressed : function (rowNum, colNum, field) {
    // If we're showing an editor in the cell suppress the standard cell hover.
    if (this.isEditingCell(rowNum, colNum)) {
        return true;
    }
    // Don't attempt to write inactive editor HTML into the hover prompt. This would be
    // odd user-experience and can lead to warnings about inactiveEditorContexts getting
    // unexpectedly dropped.
    
    if (this._showInactiveEditor(colNum) && this.canEditCell(rowNum, colNum)) {
        return true;
    }

    if (field) {
        // if the grid is showHover:false, suppress unless field.showHover is true
        if (this.showHover == false && field.showHover != true) return true;
        // otherwise, suppress if the field is showHover:false
        if (field.showHover == false) return true;
    }

    return false;
},

getCellHoverDelay : function (record, rowNum, colNum) {
    var field = this.getField(colNum);
    return field && field.hoverDelay != null ? field.hoverDelay : this.hoverDelay;
},

// NOTE: JSDoc imported from GR
cellHoverHTML : function (record, rowNum, colNum) {
    var fieldHoverHTMLCallback = this._getFieldHoverHTMLCallback(rowNum, colNum),
        // for the group-cell itself, use getGroupTitle() instead of getCellValue(), which will
        // call through getGroupNodeHTML() and, thus, show the group open/close icon in the
        // hover
        isGroupCell = record._isGroup && (colNum == 0 || this.singleCellGroupHeaders()),
        value = isGroupCell ? this.getGroupTitle(record) : 
            this.getCellValue(record, rowNum, colNum)
    ;
    // if there's a hoverHTML, run it
    if (fieldHoverHTMLCallback) {
        return isc.Class.fireCallback(fieldHoverHTMLCallback,
                                      this._$fieldHoverHTMLArgNames,
                                      [ record, value, rowNum, colNum, this ]);
    }

    if (this.getTreeFieldNum && colNum == this.getTreeFieldNum()) {
        // if the hover was over a TreeGrid's TreeField, show just node icon and title-text
        return this.getTreeCellHoverHTML(record, rowNum, colNum);
    }

    // cellPrompt is the hover for cells in the field, rather than its header - if set, use it 
    // as the value
    var field = this.getField(colNum);
    if (field != null && field.cellPrompt) value = field.cellPrompt;
    
    if (value != null && !isc.isAn.emptyString(value) && value != this.emptyCellValue) {
        return value;
    }
},

cellValueHoverHTML : function (record, rowNum, colNum, defaultHTML) {
    var field = this.getField(colNum);
    if (field.showHover == false) return null;
    if (field.showHover == null && this.canHover == false) return null;

    return defaultHTML;
},

//> @method listGridField.hoverHTML()
// StringMethod override point for returning HTML to be shown in hovers over cells in the
// column described by this field.
// <P>
// Called only when +link{listGrid.canHover,canHover} and +link{listGrid.showHover,showHover}
// are both true.
// <P>
// The value of "this" within the method will by the +link{ListGridField,field definition}.
// <P>
// Note that the field described by the column might provide a custom
// +link{listGridField.cellPrompt, cellPrompt} which won't be applied unless you return it 
// from your implementation. 
//
// @param record (ListGridRecord) record being hovered over
// @param value  (Any) value of the cell being hovered over
// @param rowNum (number) row number where hover occurred
// @param colNum (number) column number where hover occurred
// @param grid   (ListGrid) ListGrid this field is a part of
// @return (HTMLString) HTML to show in the hover
// @group hovers
// @visibility external
// @example valueHoverTips
//<

//> @attr listGridField.hoverDelay (Integer : null : IRW)
// Delay in ms for hovers shown for cells in this field. If unset, the grid's
// hoverDelay will be used.
// <p>
// This property also governes the hoverDelay for the header button. Developers wishing
// to have a different delay for hovers on the header can use +link{listGridField.headerHoverDelay}
// in addition to this property.
//
// @visibility external
//<


//> @attr listGridField.headerHoverDelay (Integer : null : IRW)
// Delay in ms for hovers shown over this field's header.
// <P>
// If unset, any +link{listGridField.hoverDelay} will be used for both header hovers
// and hovers shown over cells in the grid's body.
//
// @visibility external
//<

//> @attr listGrid.showHoverComponents (Boolean : null : IRW)
// When set to true and canHover is also true, shows a widget hovering at the mouse point.
// <P>
// A number of builtin modes are provided - see +link{listGrid.hoverMode}.  Note, if a 
// <code>hoverMode</code> is set but <code>showHoverComponents</code> is left null, it will
// default to true.
// <P>
// Also supported at the +link{listGridField.showHoverComponents, field-level}.
// @group hoverComponents
// @visibility external
//<


//> @type HoverMode
// When +link{ListGrid.canHover, canHover} and
// +link{ListGrid.showHoverComponents, showHoverComponents} are both true, HoverMode
// dictates the type of UI to be displayed when a user hovers over a row or cell.
// <P>
// There are a number of builtin HoverModes and you can override
// +link{listGrid.getCellHoverComponent, getCellHoverComponent()} to create your own
// hover behaviors.
//
//  @value  "detailField"  Show a single field's value in an +link{class:HtmlFlow}. Field
//      to use is +link{listGrid.detailField}.
//  @value  "details"   Show a +link{class:DetailViewer} displaying those fields from the
//      record which are not already displayed in the grid.
//  @value  "related"    Show a separate +link{class:ListGrid} containing related-records.
//      See +link{ListGridRecord.detailDS} and +link{ListGrid.recordDetailDSProperty} for
//      more information.
//  @value  "detailRelated"    Show a +link{class:DetailViewer} displaying those fields
//      from the record not already displayed in the grid, together with a separate
//      +link{class:ListGrid} containing related-records.
// @group hoverComponents
// @visibility external
//<

//> @attr listGrid.hoverMode (HoverMode : null : IRW)
// When +link{ListGrid.showHoverComponents, showHoverComponents} is true, the builtin mode
// to use when automatically creating a hover component for rows in this grid.
// <P>
// A number of builtin modes are provided - see +link{type:HoverMode}.  You can also override
// +link{ListGrid.getCellHoverComponent, getCellHoverComponent()} to provide a custom hover
// widget - in that case, this attribute is ignored.
// <p>
// If <code>showHoverComponents</code> is true but <code>hoverMode</code> is not set, it 
// defaults to "detailRelated" if +link{listGrid.detailDS} is set, or to "details" otherwise.
// If <code>showHoverComponents</code> is not set (ie, is null) and <code>hoverMode</code>
// <i>is</i> set, <code>showHoverComponents</code> defaults to true.
// @group hoverComponents
// @visibility external
//<

_shouldShowCellHoverComponent : function (record, rowNum, colNum) {
    if (this.showHoverComponents === false || 
                (this.showHoverComponents == null && this.hoverMode == null))
    {
        var field = colNum != null ? this.getField(colNum) : null;
        if (field && field.showHoverComponents == true) return true;
        return false;
    }
    return true;
},

_getCellHoverComponent : function (record, rowNum, colNum) {
    // of not showing a cellHoverComponent for this cell, return null - a regular or 
    // clipped-value hover may be shown instead
    if (!this._shouldShowCellHoverComponent(record, rowNum, colNum)) return null;
    // If we're showing an editor in the cell suppress the standard cell hover.
    if (this._editorShowing && this.getEditRow() == rowNum &&
        (!this.editByCell || this.getEditCol() == colNum)) return null;
    var field = this.getField(colNum);
    if (field.showHover == false) return null;
    if (field.showHover == null && !this.canHover) return null;

    if (this.hoverScreen) {
        var ds = this.getDataSource(),
            settings = {}
        ;
        if (ds) {
            settings.dataContext = {};
            settings.dataContext[ds.ID] = record;
        }
        return isc.RPCManager.createScreen(this.hoverScreen, settings);
    } else if (this.getCellHoverComponent && isc.isA.Function(this.getCellHoverComponent)) {
        // react to blocking-requests during getHoverComponent() - see comment
        // in Hover.show()
        isc.Hover.preparingHoverComponent = true;
        var result = this.getCellHoverComponent(record, rowNum, colNum);
        delete isc.Hover.preparingHoverComponent;
        return result;
    } else {
        return null;
    }
},

//> @method listGrid.getCellHoverComponent()
// When +link{showHoverComponents} is set, this method is called to get the component to show
// as a hover for the current cell.
// <P>
// By default, this method returns one of a set of builtin components, according to the
// value of +link{type:HoverMode, listGrid.hoverMode}.  You can override this method
// to return any component you wish to provide as a hoverComponent, or invoke the superclass
// method to have the default hover component generated, then further customize it.
// <P>
// By default, components returned by <code>getCellHoverComponent()</code> will be
// automatically destroyed when the hover is hidden.  To prevent this, set
// +link{canvas.hoverAutoDestroy} to false on the returned component.
// <P>
// If you return a component that fetches data or loads content dynamically:
// <ol>
// <li> set rpcRequest.promptStyle to "cursor" or set rpcRequest.showPrompt to false on any 
//      network requests, or the default masking that blocks the screen during network requests 
//      will dismiss the hover</li>
// <li> as covered above, your component may have been automatically destroyed by the time your 
//      content has been loaded.  Check +link{canvas.destroyed} before taking action in an 
//      asynchronous callback
// </li>
// <li> if your component grows in size after data is loaded, and it would then be rendered
//      partially off-screen, it will be automatically re-positioned to keep it on-screen.  
//      However this will not automatically happen in cases where you provide HTML content that
//      changes size after initial render, in which case a call to 
//      +link{canvas.adjustForContent()} will be required.  See that API for details.
// </li>
// </ol>
// @param record (Record) record to get the hoverComponent for
// @param rowNum (Integer) row number for the cell
// @param colNum (Integer) column number of the cell
// @return (Canvas | Canvas Properties) the component to show as a hover
// @group hoverComponents
// @visibility external
//<
defaultCellHoverComponentWidth: 100,
defaultCellHoverComponentHeight: 1,
getCellHoverComponent : function (record, rowNum, colNum) {
    return this._getStockEmbeddedComponent(record, false, true, rowNum, colNum);
},

//> @attr listGrid.hoverScreen (String : null : IR)
// Screen to create (via +link{RPCManager.createScreen,createScreen()}) in lieu of calling
// +link{getHoverComponent()} or +link{getCellHoverComponent()}.
// <P>
// If this grid has a +link{dataBoundComponent.dataSource,dataSource}, the created screen is
// provided with a +link{canvas.dataContext} that includes the record being shown at the row.
// @group hoverComponents
// @visibility external
//<

_getStockEmbeddedComponent : function (record, isExpansion, isHover, rowNum, colNum) {
    var gridFields = this.getFields(),
        dsFields = this.dataSource ? isc.getValues(this.getDataSource().getFields()) :
            gridFields,
        defWidth = (!isHover ? null :
            this.hoverWidth || this.hoverSize || this.defaultCellHoverComponentWidth),
        defHeight = (!isHover ? null :
            this.hoverHeight || this.hoverSize || this.defaultCellHoverComponentHeight),
        remainingFields = [],
        component,
        fieldEscapeHTML = false,
        detailField = this.detailField
    ;

    if (isExpansion && this.expansionMode == "detailField" && !detailField) {
        detailField = this.getDefaultExpansionDetailField();
        if (detailField) {
            detailField = detailField.name;
        }
    }

    for (var i=0; i<dsFields.length; i++) {
        var field = dsFields.get(i);
        
        if (detailField && field.name == detailField && field.escapeHTML) {
            fieldEscapeHTML = true;
        }
        
        if (this.dataSource) {
            if (!gridFields.find("name", field.name)) {
                remainingFields.add(field);
            }
        } else {
            // show all fields when not databound
            if (!this.isExpansionField(field)) {
                remainingFields.add(field);
            }
        }
    }

    var mode = (isHover ? this.hoverMode : (isExpansion ? this.expansionMode : null));

    // Dynamically default hoverMode/expansionMode per #R970 spec
    if (!mode) {
        if (this.detailDS) {
            mode = "detailRelated";
        } else {
            mode = "details";
        }
    }

    var props;
    
    // create an appropriate subcomponent and bind it
    if (mode == "detailField") {
        if (!isExpansion && !record[detailField]) return null;
        var value = record[detailField];
        if (fieldEscapeHTML && isc.isA.String(value) && value != this._$nbsp) {
            value = value.asHTML(null, this.shouldSkipLineBreaks(field));
        }
        component = this.createAutoChild("expansionDetailField", {
            contents: value
        });
        props = {
            width: (isHover ? defWidth : "100%"),
            height: (isHover ? defHeight : "100%"),
            autoDraw: false,
            members: [component]
        };

        if (isHover) {
            props = isc.addProperties(props, {
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        component = isc.VLayout.create(props);
    } else if (mode == "details") {
        
        remainingFields = remainingFields.map(function (field) {
            if (field.showIf == null) return field;
            return isc.addProperties({}, field, {showIf: "true"});
        });
        props = { dataSource: this.dataSource, fields: remainingFields };

        if (isHover) {
            props = isc.addProperties(props, {
                width: defWidth,
                height: defHeight,
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }
        component = this.createAutoChild("expansionDetails", props);

        // if !this.dataSource, can't use a ResultSet below
        if (isc.isA.ResultSet(record) || !this.dataSource) {
            component.setData(record);
        } else {
            // create ResultSet wrapper on the record, it is possible to observe changes in the datasource
            var recordResultSet = isc.ResultSet.create({
                dataSource : this.dataSource,
                initialData : [record]
            });
            component.setData(recordResultSet);
        }
    } else if (mode == "related") {
        props = { dataSource: this.getRelatedDataSource(record) };

        if (isHover) {
            props = isc.addProperties(props, {
                canEdit: false,
                width: defWidth,
                height: defHeight,
                dataProperties: { context: { showPrompt: false } },
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        if (isExpansion) {
            // only propagate to autochild if childExpansionMode has been set
            if (this.childExpansionMode != null) props = isc.addProperties(props, {
                canExpandRecords: this.childExpansionMode ? true : false,
                expansionMode: this.childExpansionMode
            });
            // only propagate to autochild if expansionCanEdit has been set
            if (this.expansionCanEdit != null) props = isc.addProperties(props, {
                canEdit: this.expansionCanEdit
            });
            props.isExpansionGrid = true;
        }

        component = this.createAutoChild("expansionRelated", props);

        // if editing is allowed in the sub-grid, set autoSaveEdits: true
        if (this.expansionCanEdit) component.autoSaveEdits = true;
        component.delayCall("fetchRelatedData", [record, this.dataSource,
            function (dsResponse, data) {
                // for hoverMode: "related", fix ListGrid shown when no related records are
                // present; grid's GridBody is squished; apply overflow: visible to fix it
                if (data == null || data.length == 0) component.setBodyOverflow("visible");
        }]);

    } else if (mode == "detailRelated") {
        props = { dataSource: this.dataSource, fields: remainingFields };

        if (isHover) {
            props = isc.addProperties(props, {
                dataProperties: { context: { showPrompt: false } },
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        var detail = this.createAutoChild("expansionDetails", props)
        detail.setData(record);

        props = { dataSource: this.getRelatedDataSource(record), height: "100%" };

        if (isHover) {
            props = isc.addProperties(props, {
                dataProperties: { context: { showPrompt: false } },
                hoverAutoDestroy: this.hoverAutoDestroy,
                canEdit: false
            });
        }
        if (isExpansion) {
            // only propagate to autochild if childExpansionMode has been set
            if (this.childExpansionMode != null) props = isc.addProperties(props, {
                canExpandRecords: this.childExpansionMode ? true : false,
                expansionMode: this.childExpansionMode
            });
            // only propagate to autochild if expansionCanEdit has been set
            if (this.expansionCanEdit != null) props = isc.addProperties(props, {
                canEdit: this.expansionCanEdit
            });
            props.isExpansionGrid = true;
        }

        var related = this.createAutoChild("expansionRelated", props);

        props = { members:[detail, related] };
        if (isHover) {
            props = isc.addProperties(props, {
                width: defWidth,
                height: defHeight,
                hoverAutoDestroy: this.hoverAutoDestroy
            });
        }

        component = this.createAutoChild("expansionDetailRelated", props);

    } else if (mode == "editor") {
        component = isc.VLayout.create({
            autoDraw: false,
            width: "100%",
            height: "100%",
            creator: this
        });

        // create an editor form, edit the record in question and validate it - this causes an
        // editor to show validation errors when autoSaveEdits is false and saveAllEdits is
        // called.
        var editorForm = this.createAutoChild("expansionEditor", {
            dataSource: this.dataSource,
            fields: remainingFields,
            extraSpace: 5,
            itemChanged : function () {
                if (this.saveButton) this.saveButton.setDisabled(false);
            }
        });
        editorForm.editRecord(this.getEditedRecord(rowNum) || record);
        editorForm.validate();

        if (this.showExpansionEditorSaveButton) {
            // create a save button for this expansionEditor - add refs to the editor-form and the
            // record being edited for later use.
            var saveButton = this.createAutoChild("expansionEditorSaveButton", {
                title: this.expansionEditorSaveButtonTitle,
                grid: this,
                form: editorForm,
                record: record,
                disabled: true,
                extraSpace: 5
            });

            // add a ref to the save-button onto the editor-form, so we can enable/disable the
            // button according to whether changes have been made
            editorForm.saveButton = saveButton;
        }

        // add a ref to the editorForm to the actual expansion-component - this is used when
        // getting hold of the editor-form to check for changes when a record is collapsed
        component.formMember = editorForm;
        component.addMembers([editorForm, saveButton]);
    }

    if (component) {
        // mark as a stock (auto-generated) component so we can auto-destroy it later
        component.isStockComponent = true;
        component.expandedRecord = record;
    }

    return component;
},

getDefaultExpansionDetailField : function() {
    var allFields = this.getAllFields(),
        visibleFields = this.getVisibleFields(allFields),
        absentFields = [],
        detailField;
    ;
    for (var i = 0; i < allFields.length; i++) {
        if (!visibleFields.contains(allFields[i])) {
            absentFields.add(allFields[i]);
        }
    }
    // 1. the longest text field which is not currently showing in the grid
    var longestField, longest = 0;
    for (var i = 0; i < absentFields.length; i++) {
        if (absentFields[i].length > longest) {
            longest = absentFields[i].length;
            longestField = absentFields[i];
        }
    }
    if (longestField) {
        return longestField;
    }

    // 2. a text field that *is* currently visible, if one exists that has a length set that 
    //    is longer than DF.longTextEditorThreshold
    longestField = null;
    longest = 0;
    for (var i = 0; i < visibleFields.length; i++) {
        if (visibleFields[i].length > longest) {
            longest = visibleFields[i].length;
            longestField = visibleFields[i];
        }
    }
    if (longestField) {
        var threshold = isc.DynamicForm.getInstanceProperty("longTextEditorThreshold");
        if (longestField.length >= threshold) {
            return longestField;
        }
    }

    // 3. any non-visible field of text type
    for (var i = 0; i < absentFields.length; i++) {
        if (absentFields[i].type == "text") {
            return absentFields[i];
        }
    }
    // 4. any non-visible field
    if (absentFields[0]) {
        return absentFields[0];
    }
    // 5. the longest text type visible field
    longestField = null;
    longest = 0;
    for (var i = 0; i < visibleFields.length; i++) {
        if (visibleFields[i].type == "text" && visibleFields[i].length > longest) {
            longest = visibleFields[i].length;
            longestField = visibleFields[i];
        }
    }
    if (longestField) {
        return longestField;
    }

    // 6. the first field
    return allFields[0];
},

//> @attr listGridField.showAlternateStyle (boolean : null : IRWA)
// When set to false, don't apply alternate-row styling to this field.
// @visibility external
//<

// Selection
// --------------------------------------------------------------------------------------------

// Simple helper methods to avoid having to refer directly to this.selectionManager
// Genericized up to DataBoundComponent, July 2008


//> @method listGrid.selectRecord()
// Select/deselect a +link{Record} passed in explicitly, or by index.
// <P>
// Note that this method selects records unconditionally, allowing multiple selected
// records, even when +link{listGrid.selectionType} is "single".  To enforce mutually-exclusive
// record-selection, use +link{listGrid.selectSingleRecord}.
// @include dataBoundComponent.selectRecord()
//<

//> @method listGrid.deselectRecord()
// @include dataBoundComponent.deselectRecord()
//<

//> @method listGrid.selectRecords()
// @include dataBoundComponent.selectRecords()
//<

//> @method listGrid.deselectRecords()
// @include dataBoundComponent.deselectRecords()
//<

//> @method listGrid.selectAllRecords()
// Select all records.
// <P>
// Note that this method will select records even if +link{listGrid.canSelectRecord()} returns
// false for the record in question. See also +link{listGrid.userSelectAllRecords()}
//
// @param [visibleNodesOnly] (boolean) For TreeGrids, or listGrids showing 
//   hierarchical +link{listGrid.isGrouped,group data}, if <code>true</code> is 
//   passed for this parameter, only visible nodes will be selected. 
//   Nodes embedded in a closed parent folder
//   (and thus hidden from the user) will not be selected.
// @visibility external
//<

selectAllRecords : function (visibleNodesOnly) {
    this._dontRefreshSelection = true;
    this.selectionManager.selectAll(visibleNodesOnly);
    this._dontRefreshSelection = null;
    this._markBodyForRedraw("select all");
    if (this.getCurrentCheckboxField() != null) {
        // don't check the "all records selected header box if we can't select all records
        if (!isc.ResultSet || !isc.isA.ResultSet(this.data) ||
                this.data.allMatchingRowsCached())
        {
            this._setCheckboxHeaderState(true);
        }
    }
    this.fireSelectionUpdated();
},

//> @method listGrid.deselectAllRecords()
// @include dataBoundComponent.deselectAllRecords()
//<
deselectAllRecords : function () {
    this._dontRefreshSelection = true;
    this.selectionManager.deselectAll();
    this._dontRefreshSelection = null;
    this._markBodyForRedraw("deselect all");
    if (this.getCurrentCheckboxField() != null) this._setCheckboxHeaderState(false);
    this.fireSelectionUpdated();
},

//> @method listGrid.selectRange()
// @include dataBoundComponent.selectRange()
//<

//> @method listGrid.deselectRange()
// @include dataBoundComponent.deselectRange()
//<

//> @method listGrid.userSelectAllRecords()
// Selects every user-selectable record in the grid. Unlike +link{listGrid.selectAllRecords()},
// if a record is +link{listGrid.canSelectRecord(),unselectable}, this method will not
// attempt to select it.
// @visibility external
//<
userSelectAllRecords : function () {
    var data = this.getOriginalData(),
        total = data.getLength();
    if (isc.ResultSet && isc.isA.ResultSet(data) && !data.rangeIsLoaded(0, total)) {
        this.selectionManager.warnSelectionRangeNotLoaded();
        return;
    }
    var records = (this.isGrouped ? this.getAllRecordsFromGroupTree() 
                                : data.getRange(0, total)),
        finalRecords = [];
    for (var i = 0; i < records.length; i++) {
        if (!this.canSelectRecord(records[i])) continue;
        finalRecords[finalRecords.length] = records[i];
    }

    this.selectionManager.selectList(finalRecords);
    this.fireSelectionUpdated();
},

getAllRecordsFromGroupTree : function () {
    var data;
    if (this.isGrouped) data = this.data;
    if (!data || !isc.isA.Tree(data)) return;
    
    // getDescendantLeaves will skip over the group-header nodes.
    return this.data.getDescendantLeaves(this.data.getRoot());
},

//> @method listGrid.anySelected()
// @include dataBoundComponent.anySelected()
//<

//> @method listGrid.selectSingleRecord()
// @include dataBoundComponent.selectSingleRecord
// @visibility external
//<

//> @method listGrid.canSelectCell() (A)
// If +link{listGrid.canSelectCells} is set to <code>true</code> then, whenever an end-user or
// programmatic cell-selection is attempted, this method is called for 
// each cell in the selection. If it returns false, the cell will not be selected.
//
// @param rowNum (int) rowNum being selected
// @param colNum (int) colNum being selected
// @return (boolean) return false to disallow selection
//
// @visibility external
//<
canSelectCell : function(rowNum, colNum) {
    return true;
},

//> @method listGrid.canSelectRecord()
// If +link{listGrid.selectionType} is not set to <code>"none"</code>,
// This method will be called for each record the user attempts to select. If it returns false, the
// record will not be selected.
// <P>
// The default implementation will return true for any records where
// +link{listGrid.recordCanSelectProperty} is not explicitly set to false, and false
// if this method was called by a click on the +link{listGrid.expansionField, expansion field}
// and +link{listGrid.selectOnExpandRecord, selectOnExpandRecord} is set to false.
// 
// <P>
// Note this method will not be called at all if +link{canSelectCells} is true.
//
// @param record (ListGridRecord) record being selected
// @return (boolean) return false to disallow selection
//
// @visibility external
//<
// If this method returns false, we disallow user-actions from
// selecting stuff, but still allow programmatic selection via direct access to the
// Selection object, since the "_canSelectItem()" method in Selection just checks for
// the value of the "canSelectProperty".
// We actually make use of this in some cases, such as allowing cascading selection of
// group header nodes when  "canSelectGroups" is false, so "getGroupTreeSelection()"
// can pick up selected header nodes.
canSelectRecord : function(record) {
    if (!record) return false;
    if (this.isGrouped && !this.canSelectGroups && record._isGroup) return false;
    if (record[this.recordCanSelectProperty] != null) {
        return record[this.recordCanSelectProperty];
    }
    if (this.selectOnExpandRecord == false && this.selectionAppearance != "checkbox") {
        // return false if the mouse is over the expansionField
        var field = this.getUnderlyingField(this.getEventColumn());
        if (field) {
            if (this.isExpansionField(field)) return false;
            
        }
    }
    return true;
},

//> @attr listGrid.selectOnExpandRecord (boolean : true : IRW)
// When set to false, clicking a record's +link{listGrid.expansionField, expansion field} will
// not add the record to the current selection.
// @visibility external
//<
selectOnExpandRecord: true,

// Native text selection of cell content
// --------------------------------------------------------------------------------------------

//> @attr listGrid.selectCellTextOnClick (Boolean : null : IRW)
// If this property is set to true, clicking on a cell will natively select the 
// cell's content, ready to be copied to the browser clipboard.
// <P>
// For control of this behavior at the field level, 
// +link{listGridField.selectCellTextOnClick} may be used. These properties interact
// as follows:
// <table border=1 cellpadding=4><tr>
//  <td><b>listGrid.selectCellTextOnClick value</b></td>
//  <td><b>listGridField.selectCellTextOnClick value</b></td>
//  <td><b>Behavior</b></td>
// </tr><tr>
//  <td rowspan=2><code>true</code></td>
//      <td><i>unset</i> or <code>true</code></td>
//          <td>Cell contents will be natively selected on click.</td>
// </tr><tr>
//      <td><code>false</code></td>
//          <td>Cell contents will not be natively selected on click.</td>
// </tr><tr>
// </tr><tr>
//  <td rowspan=2><i>unset</i></td>
//      <td><code>true</code></td>
//          <td>Cell contents will be natively selected on click.</td>
// </tr><tr>
//      <td><i>unset</i> or <code>false</code></td>
//          <td>Cell contents will not be natively selected on click.</td>
// </tr><tr>
//  <td><code>false</code></td>
//      <td><code>true</code>, <code>false</code> or <i>unset</i></td>
//          <td>Cell contents will not be natively selected on click.</td>
// </tr></table>
// <P>
// This is related to the +link{listGrid.canDragSelectText} attribute which enables
// native text selection of grid content by standard browser interactions (drag
// selecting or double-click selecting).
// <P>
// Note that developers may also be interested in the related formItem properties
// +link{formItem.selectOnClick} and +link{formItem.selectOnFocus}.
// 
// @visibility external
//<
selectCellTextOnClick:null,

// selectCellText() - select the text of a cell ready for copying to clipboard
// Called from gridBody._rowClick override if selectCellTextOnClick is true.
//

selectCellText : function (rowNum, colNum) {

    if (!this.isDrawn() || !this.body) return;

    var frozen = this.fieldIsFrozen(colNum),
        body = frozen ? this.frozenBody : this.body,
        localFieldNum = this.getLocalFieldNum(colNum);
    
    var cell = body.getTableElement(rowNum, localFieldNum);
    if (cell != null) isc.Element.selectElementText(cell);
    
},

// We want the ability to remember the selected cell text and reset on redraw if it's 
// in our body.
// If the user has selected text within a cell, this method will return a config
// object indicating the cell that has selection and its current text.

_getSelectedCellTextConfig : function (rowNum, colNum) {
    if (!this.isDrawn() || !this.body || !this.body.getTableElement()) return;
    
    var hasTargetCell = rowNum != null && colNum != null;

    if (window.getSelection != null) {
        var sel = window.getSelection(),
            range = sel != null && sel.rangeCount > 0 && sel.getRangeAt(0),
            selNode = range && !range.collapsed ? range.commonAncestorContainer : null;
            
            
        // Simple ignore the case where the selection is a partial selection of some
        // nested HTML structure for now
        if (selNode && (range.startContainer != selNode) ||
                       (range.endContainer != selNode)) 
        {
            selNode = null;
        }
            
        if (selNode != null) {
            var containsSelection;
        
            // check for selection in a specific cell
            if (hasTargetCell) {
                var targetCell;
                if (this.fieldIsFrozen(colNum)) {
                    if (this.frozenBody) {
                        targetCell = this.frozenBody.getTableElement(rowNum, 
                                                            this.getLocalFieldNum(colNum));
                    }
                } else {
                    targetCell = this.body.getTableElement(rowNum, 
                                                    this.getLocalFieldNum(colNum));
                }
                
                if (targetCell && targetCell.contains(selNode)) {
                    return {
                        rowNum:rowNum,
                        colNum:colNum,
                        text:range.toString()
                    }
                }
            // Check for selection any where in the body   
            } else {
        
                var body = this.body,
                    bodyTable = body.getTableElement(),
                    inBody = bodyTable && bodyTable.contains(selNode);
                if (!inBody && this.frozenBody) {
                    body = this.frozenBody;
                    bodyTable = body.getTableElement();
                    inBody = bodyTable && bodyTable.contains(selNode);
                }
                // We have a selection within our body.
                // Figure out which cell it's in
                if (inBody) {
            
                    // If we already know the cell, just remember details
                    var config = {};
    
                    var cellElement,
                        rowElement,
                        currentElement = selNode;
            
                    // walk up the dom to the body table. Remember the row/cell element
                    
                    while (currentElement != bodyTable) {
                        if (currentElement.tagName == "TD") {
                            cellElement = currentElement;
                        }
                        if (currentElement.tagName == "TR") {
                            rowElement = currentElement;
                        }
                        currentElement = currentElement.parentNode;
                    }
        
                    if (cellElement != null) {
                        var drawnRowNum = rowElement.rowIndex,
                            drawnColNum = cellElement.cellIndex;
            
                        config.rowNum = drawnRowNum +  (body._firstDrawnRow || 0);
                        var bodyColNum = drawnColNum + (body._firstDrawnCol || 0);
                        config.colNum = this.getFieldNumFromLocal(bodyColNum, body);
                        // remember text rather than innerHTML - we don't care if
                        // styling details of nested elements change, etc.
    //                    config.innerHTML = cellElement.innerHTML;
                        config.text = range.toString();
                    
                        return config;
                    }
                }
            }
        }
    } // end of window.getSelection != null conditional. 
    

},


// Option to disable select-on-click behavior for specific fields or cells

shouldSelectCellTextOnClick : function (rowNum, colNum) {
    // If we're showing an editor always return false - selecting cell text on click
    // can interfere with text selection within the edit item.
    
    if (this.isEditingCell(rowNum,colNum)) return false;
    if (this.selectCellTextOnClick == false) return false;
    var field = this.getField(colNum);
    if (field) {
        if (field.selectCellTextOnClick == false) return false;
        if (field.selectCellTextOnClick) return true;
    }
    if (this.selectCellTextOnClick) return true;
    return false;
},

// Keyboard Navigation
// --------------------------------------------------------------------------------------------

//> @method listGrid.keyPress()
// Handle a keyPress event on the ListGrid as a whole.
// <P>
// Note that the majority of keyboard handling for a ListGrid is performed by
// +link{bodyKeyPress()} and most overrides are better performed there.
//
// @return (boolean) return false to cancel
// @visibility external
//<

//> @method listGrid.bodyKeyPress()
// Handle a keyPress event on the body.
// <P>
// Default implementation handles navigating between records with arrow keys, and activating
// records with space and enter.
//
// @return (boolean) return false to cancel
//
// @visibility external
//<

_$ArrowUp:"Arrow_Up", _$ArrowDown:"Arrow_Down",
_$ArrowLeft:"Arrow_Left", _$ArrowRight:"Arrow_Right",
_$Space:"Space", _$Enter:"Enter",
_$f2:"f2",
_$Tab:"Tab",
bodyKeyPress : function (event, eventInfo) {
    // Easy to wrap entryPoint for SGWT.
    if (this.onBodyKeyPress(event, eventInfo) == false) return false;

    
    if (this._editorShowing) {
        var target = event.keyTarget,
            canvasItem;
        while (canvasItem == null && target != this && target != null) {
            canvasItem = target.canvasItem;
            target = target.parentElement;
        }
        if (canvasItem != null && canvasItem.form == this.getEditForm()) {
            var returnVal = this.editorKeyPress(canvasItem, isc.EH.getKey(),
                                isc.EH.getKeyEventCharacterValue());
            return (returnVal == null ? isc.EH.STOP_BUBBLING : returnVal);
        }
    }
    if (this.data.getLength() > 0) {

        // if we start editing on keypress, return false to kill the event (avoiding
        // page navigation on backspace keypress, etc)
        var EH = isc.EventHandler,
            keyName = event.keyName;

        // for arrow keys, navigate to the appropriate record
        var editOnKeyPress = this.editOnKeyPress && this.canEdit != false;
        if (editOnKeyPress && this._editOnKeyPress(event, eventInfo)) return false;

        var focusCell = this.getFocusCell();
        
        if (this.isGrouped) {
            var isLeft = keyName == this._$ArrowLeft,
                isRight = !isLeft && keyName == this._$ArrowRight;
                
            if (isLeft || isRight) {
                var row = focusCell[0],
                    node = this.data ? this.data.get(row) : null;
                if (node && node._isGroup) {
                    if (isLeft) this.closeFolder(node);
                    else this.openFolder(node);
                    return;
                }
            }
        }

        var focusCell = this.getFocusCell(),
            record = focusCell[0] != null ? this.getCellRecord(focusCell[0], focusCell[1]) : null
        ;
        
        if (this.canExpandRecords && this._canExpandRecord(record, focusCell[0])) {
            var expanded = this.isExpanded(record);
            if (expanded && keyName == this._$ArrowLeft) {
                this.collapseRecord(record);
                return;
            } 
            if (!expanded && keyName == this._$ArrowRight) {
                this.expandRecord(record);
                return;
            }
        }

        switch (keyName) {
            case this._$ArrowUp:    return this._navigateToNextCell(-1,  0);
            case this._$ArrowDown:  return this._navigateToNextCell( 1,  0);
            case this._$ArrowLeft:  return this._navigateToNextCell( 0, -1);
            
            case this._$ArrowRight: return this._navigateToNextCell( 0,  1);
        }
        if (keyName == this._$Tab) {
            if (this.shouldNavigateOnTab()) {
                if (isc.EH.shiftKeyDown()) return this._navigateToNextCell(0, -1, true);
                else return this._navigateToNextCell(0,1, true);
            }
            
        }

        // Generate a click on the current focus record when the user hits Space
        if (keyName == this._$Space) {

            // generateFocusRecordClick return values
            // - false implies the actual rowClick handler returned false
            //   In this case suppress the doubleClick (if necessary) and return
            //   false immediately to stop propagation
            // - true implies we found a real cell and executed the rowClick handler
            //   allow doubleclick to fire if necessary, then return false to
            //   cancel propagation of the keypress event.
            //   [we don't for example want a parent to do some odd scroll etc
            //   responding to the space keypress]
            // - null implies we didn't find a target cell. Just allow normal
            //   event propagation.
            var propagate = true;
            if (this.generateClickOnSpace) {
                var rowClickReturnValue = this._generateFocusRecordClick();
                if (rowClickReturnValue == false) return false;
                else if (rowClickReturnValue == true) propagate = false;
            }

            if (this.generateDoubleClickOnSpace) {
                var rowDCReturnValue = this._generateFocusRecordDoubleClick();
                if (rowDCReturnValue != null) propagate = false;
            }
            if (!propagate) return false;

        // Generate a doubleClick on the current focus record when the user hits Enter
        } else if (keyName == this._$Enter) {
            // See "Space" keypress handling for overview of
            // the generateFocusRecordXXX() return values
            var propagate = true;
            if (this.generateClickOnEnter) {
                var rowClickReturnValue = this._generateFocusRecordClick();
                if (rowClickReturnValue == false) return false;
                else if (rowClickReturnValue == true) propagate = false;
            }

            if (this.generateDoubleClickOnEnter) {
                var rowDCReturnValue = this._generateFocusRecordDoubleClick();
                if (rowDCReturnValue != null) propagate = false;
            }
            if (!propagate) return false;

        // Invoke one of the copy/paste shortcuts controlled by useCopyPasteShortcuts
        } else if (EH.modifierKeyDown() &&
                   (keyName == "D" || keyName == "R" || keyName == "C" || keyName == "V")) {
            return this._invokeKeyboardCopyPasteShortcut(keyName);

        // support selecting all cells using Ctrl-A shortcut
        } else if (EH.modifierKeyDown() && keyName == "A" &&
                   this.canSelectCells && this.canSelectAll) {
            this.selectionManager.selectAll();
            this.fireSelectionUpdated();
            return false;

        // Start editing on f2 keypress if editOnF2Keypress is true.
        } else if (this.getTotalRows() >= 0 && keyName == this._$f2 && this.editOnF2Keypress &&
                    this.canEdit != false && this.editEvent != "none")
        {
            var rowNum, colNum;
            if (this.canSelectCells && this.editByCell) {
                var cell = this.getFocusCell();
                if (cell[0] >= 0) rowNum = cell[0];
                if (cell[1] >= 0) colNum = cell[1];
            } else {
                rowNum = this.getFocusRow();
                if (rowNum < 0) rowNum = null;
            }

            if (rowNum == null || colNum == null) {
                var testRow = (rowNum == null ? 0 : rowNum),
                    testCol = (colNum == null ? 0 : colNum);
                var newCell = this.findNextEditCell(testRow, testCol, 1, (colNum == null), true);
                if (newCell == null) {
                    rowNum = colNum = null;
                } else {
                    rowNum = newCell[0];
                    colNum = newCell[1];
                }
            }
            if (rowNum != null && colNum != null && this.canEditCell(rowNum, colNum)) {
                this.startEditing(rowNum, colNum);
                return false;
            }
        }
    
    // If the grid is empty, do nothing.
    
    }
    return true;
},

//> @method ListGrid.onBodyKeyPress()
// @include ListGrid.bodyKeyPress
// @return (boolean) return false to cancel default drop handling
// @visibility sgwt
//<

onBodyKeyPress : function () {
},


_navigateToNextCell : function (rowStep, colStep, isTabNavigation, checkFirst, navStyle) {
    // If the event was propagated from an embedded component explicitly put focus
    // into the body itself
    
    var event = isc.EH.lastEvent;
    if (this.body.contains(event.keyTarget) && !this.body.hasFocus) {
        this.body.focus();
    } else if (this.frozenBody && 
                this.frozenBody.contains(event.keyTarget) == this.frozenBody && 
                !this.frozenBody.hasFocus)
    {
        this.frozenBody.focus();
    }
    
    if (!this.canSelectCells) {
        // pass in colStep so in screen reader mode a left or right-arrow key can natively shift
        // focus to a new cell within the selected record
        return this._navigateToNextRecord(rowStep, checkFirst, navStyle, false, colStep);
    } else if (this.selectionType == isc.Selection.NONE) return true;

    if (navStyle == null) {
        navStyle = isTabNavigation ? this.tabKeyAction : this.getArrowKeyAction();
    }
    if (navStyle == this._$none) return true;

    var willSelect = navStyle == "select" || navStyle == "selectOnly";

    // TabNavigation is slightly different

    var shiftedSelection = isc.EH.shiftKeyDown();

    // To match Excel, re-establish origin if it has been lost
    if (willSelect && shiftedSelection) {
        this._ensureValidSelectionOrigin();
    }

    var hiliteCell = this.getFocusCell(shiftedSelection);

//this.logWarn("Get HiliteCell returned this:" + hiliteCell);
    var newRow = hiliteCell[0], newCol = hiliteCell[1];

    if (newRow != null && newCol != null) {
        if (!checkFirst) {
            newRow += rowStep;
            newCol += colStep;
        }
    } else {
        newRow = newCol = 0;
    }
    // getCellRecord ignores the colNum for 1 record / row data models, so
    // with cellSelection enabled, we can go off the end horizontally and
    // still appear to have a valid (enabled) record.
    // Catch this case explicitly
    var totalRows = this.getTotalRows(), totalCols = this.getTotalCols();
    var rowEndAction = "done";
    if (isTabNavigation) rowEndAction = this.rowEndEditAction || "next";

    if (newCol < 0 || newCol >= totalCols) {
        if (rowEndAction == "same") {
            if (colStep > 0) newCol = 0;
            else newCol = totalRows -1;
        } else if (rowEndAction == "next") {
            if (colStep > 0) {
                if (newRow < totalRows-1) {
                    newRow++;
                    newCol = 0;
                } else return true;
            } else {
                if (newRow > 0) {
                    newRow--;
                    newCol = totalCols-1;
                } else return true;
            }
        } else {
            if (rowEndAction == "stop") return false; // suppress normal tab behavior
            // rowEndAction "done" or "none" - return true allowing the
            // user to tab out of the widget.
            return true;
        }
    }

    // For Ctrl+Shift+Arrow Key, We don't want to end up on a disabled cell, so we
    // still need to use the skipping logic below, but reverse the search direction
    var selectToEnd = willSelect && isc.EH.modifierKeyDown();
    if (selectToEnd) {
        if      (rowStep > 0) newRow = this.getTotalRows() -1;
        else if (rowStep < 0) newRow = 0;
        if      (colStep > 0) newCol = this.getTotalCols() -1;
        else if (colStep < 0) newCol = 0;
        rowStep = -rowStep;
        colStep = -colStep;
    }
    // At this point we have a pointer to the cell we'd like to hilite / click.
    // If the cell is not enabled, find the next one that is
    while (!this.recordIsEnabled(this.getCellRecord(newRow, newCol), newRow, newCol)) {
        if (rowStep != 0) newRow += rowStep;
        if (colStep != 0) newCol += colStep;
        // bail if reverse search returns to original cell
        if (newRow == hiliteCell[0] && newCol == hiliteCell[1]) {
            return true;
        }
        // moving off the end of the row in either direction - respect the
        // rowEndAction (set up for tab keypresses only)
        if (newCol < 0 || newCol >= totalCols) {
            if (rowEndAction == "same") {
                if (colStep > 0) newCol = 0;
                else newCol = totalRows -1;
            } else if (rowEndAction == "next") {
                if (colStep > 0) {
                    if (newRow < totalRows-1) {
                        newRow++;
                        newCol = 0;
                    } else return true;
                } else {
                    if (newRow > 0) {
                        newRow--;
                        newCol = totalCols-1;
                    } else return true;
                }
            } else {
                if (rowEndAction == "stop") return false; // suppress normal tab behavior
                // rowEndAction "done" or "none" - return true allowing the
                // user to tab out of the widget.
                return true;
            }
        } else if (newRow < 0 || newRow >= totalRows) {
            return true;
        }
    }

    // Note - we already returned if the navigation style is null, so it is fair to assume that
    // we're either going to simulate a click on a cell, or hilite one.
    //
    // Clear out the last hilite. This will both clear out the keyboard specific properties
    // (_lastKeyboardHiliteRow and col), and reset the css style of the last over cell
    this.clearLastHilite();

    // Remember which row and col we're interested in
    this._lastKeyboardHiliteRow = newRow;
    this._lastKeyboardHiliteCol = newCol;
    this._lastKeyboardHiliteBody = this.getFieldBody(newCol);
    if (willSelect) {
        // Explicitly hilite the cell.
        // This provides a visual cue (roll over styling) to indicate the record has
        // keyboard focus even if it is un-selectable.
         this._hiliteCell(newRow, newCol);
         
        if (isTabNavigation)this.selectionManager.deselectAll()
        this._generateCellClick(newRow, newCol, null, (navStyle == "selectOnly"));
    } else {
        if (navStyle == this._$focus)  this._hiliteCell(newRow, newCol);
    }

    this._handlingKeyboardNavigation = true;
    this.scrollToCell(newRow, newCol);
    this._handlingKeyboardNavigation = false;

    return false; // stop event propagation
},

//> @method listGrid.focusInCell()
// Puts keyboard focus into the specified cell, showing a highlighted (roll-over style)
// appearance, and ensuring that arrow-key navigation will start from the specified cell.
// <P>
// Only applies where +link{listGrid.canSelectCells} is true.
// @param row (Integer) Index of target row
// @param col (Integer) Index of target col
// @see listGrid.focusInRow()
// @visibility external
//<
focusInCell : function (row, col) {
    this._lastKeyboardHiliteRow = row;
    this._lastKeyboardHiliteCol = col;
    var body = this.getFieldBody(col);
    this._lastKeyboardHiliteBody = body;

    this._hiliteCell(row, col);

    if (!body.hasFocus) body.focus();

},

//> @method listGrid.focusInRow()
// Puts keyboard focus into the specified row, showing a highlighted (roll-over style)
// appearance, and ensuring that arrow-key navigation will start from the specified row.
// <P>
// Only applies where +link{listGrid.canSelectCells} is false.
// @param row (Integer) Index of target row
// @see listGrid.focusInCell()
// @visibility external
//<
focusInRow : function (row) {
    this._hiliteRecord(row);
    if (this.body && !this.body.isFocused()) this.body.focus();
},

_hiliteCell : function (row, col) {
    // if passed in a cell, resolve it to row / col
    if (isc.isAn.Object(row)) {
        col = row._colNum;
        row = row._rowNum;
    }

    // bail if the coordinates passed in don't match a valid row
    if (row == null || col == null ||
        row < 0     || col < 0     ||
        row >= this.getTotalRows() || col >= this.getTotalCols()) return;

    var body = this._lastKeyboardHiliteBody,
        colOffset = body.selectionManager.firstCol || 0;
    body.lastOverRow = row;
    body.lastOverCol = col - colOffset;
    body.setRowStyle(row, null, col - colOffset);

    this.updateRollOverCanvas(row, col);

},

_getLastMouseOverBody : function () {
    if (!this.frozenBody) return this.body;
    if (this.frozenBody.lastMouseOverRow == null &&
        this.frozenBody.lastMouseOverCol == null) return this.body;
    return this.frozenBody;
},

_ensureValidSelectionOrigin : function () {
     if (!this.selectionManager._validateSelectionOrigin(this)) {
         var lastBody = this._getLastMouseOverBody(),
             colOffset = lastBody.selectionManager.firstCol || 0;
         var row = lastBody.lastMouseOverRow || 0,
             col = lastBody.lastMouseOverCol || 0,
             record = this.getCellRecord(row, col + colOffset);
         if (this.recordIsEnabled(record, row, col + colOffset)) {
             lastBody.selectOnMouseDown(record, row, col);
         }
     }
 },

// editOnKeyPress behavior
// - modeled on spreadsheet style application editing
// - normal record selection and navigation occurs on click / arrow keypress when not currently
//   editing the grid
// - on character keypress, start editing (respecting the character typed)

_$f2:"f2",
_$Escape:"Escape",
_$Backspace:"Backspace",
_$Delete:"Delete",
_$keyPress:"keyPress",
_editOnKeyPress : function (event, eventInfo) {
    var keyName = eventInfo.keyName,
        charVal = isc.EH.getKeyEventCharacter(event);
    // We don't want to start editing if the user hit a non character key, such as a function key
    // or escape, etc
    
    if (keyName != this._$f2 && keyName != this._$Delete && keyName != this._$Backspace &&
        (keyName == this._$Escape ||
            isc.EH._nonCharacterKeyMap[keyName] || charVal == null || charVal == isc.emptyString))
    {
        return false;
    }

    var cell = this.getFocusCell(),
        row = cell[0] || 0,
        col = cell[1] || 0;
    // If we're already showing an editor just bail
    if (this._editorShowing || row < 0 || col < 0) return false;

    // on Enter / f2 keypress don't modify the value in the cell
    var undef;
    if (keyName == this._$Enter || keyName == this._$f2) charVal = null;

    var editVal;
    if (charVal != null) {
        if (keyName == this._$Delete || keyName == this._$Backspace) {
            editVal = null;
        } else if (this.autoSelectEditors) {
            editVal = charVal;
        } else {
            editVal = this.getEditedCell(row,col) + charVal;
        }
        // this flag ensures that when we focus in the item we put selection at the end, rather
        // than selecting the entire value.
        this._editorCursorAtEnd = true;
    }
    return this.handleEditCellEvent(cell[0], cell[1], this._$keyPress, editVal);

},

// getArrowKeyAction() - used by _navigateToNextRecord() to determine how the record
// should be hilighted.

// Strings used in navigation styles
_$none:"none", _$focus:"focus", _$select:"select", _$activate:"activate",
getArrowKeyAction : function () {

    var action = this.arrowKeyAction;

    // No action at all trumps everything
    if (action == this._$none) return this._$none;

    // if ctrl key is down but not shift, always just hilite / focus
    var doNotFocus = this.canSelectCells && isc.EH.shiftKeyDown();
    if (isc.EH.modifierKeyDown() && !doNotFocus) return this._$focus;

    // if an explicit arrowKeyAction has been set, respect it
    if (action != null) return action;

    // default to FOCUS if selectionAppearance is "checkbox"; SELECT otherwise
    return this.selectionAppearance == "checkbox" ? this._$focus : this._$select;
},


// In screenReader mode when putting focus onto an actual row element in the body,
// should we show normal keyboard hilite styling etc?
hiliteOnNativeRowFocus:true,

// _navigateToNextRecord()
// Called from this.bodyKeyPress() on arrow keys, to handle navigating around the listGrid.
// If step == +1, we want to navigate to the next record in the list, if step is -1, we want to
// navigate to the previous record.
// Determines which record to navigate to, and falls through to _generateCellClick() or
// _hiliteRecord() depending on the result of this.getArrowKeyAction()

_navigateToNextRecord : function (step, checkFirst, navStyle, suppressScroll, colStep) {
    // Are we going to simulate a click on the next record or just hilight it?
    var navStyle = navStyle == null ? this.getArrowKeyAction() : navStyle;

    // If keyboard navigation is disabled return true to allow processing to continue.
    if (navStyle == this._$none) return true;

    // In screenReader mode we want the ability for users to put native focus into
    // cells even when we're doing row selection (canSelectCells is false)
    // In this case the colStep passed in should be respected and passed through
    // to generate cell click, etc.
    var supportsCellFocus = isc.screenReader && this.body.canFocusInCells();

    if (colStep == null) colStep = 0;
    if (step == 0 && (colStep == 0 || !supportsCellFocus)) {
        return;
    }
    var focusCol = supportsCellFocus ? this._getNewNativeFocusCol(colStep) : null;

    // Determine which record was last hilighted or clicked
    var newSelectionIndex;

    // By default we want the last row that had keyboard focus
    
    
    newSelectionIndex = this.getFocusRow(step > 0, isc.EH.shiftKeyDown() && navStyle != this._$focus);


    // If the user hit a right or left arrow we are updating the
    // native focus target without actually updating selection or firing a click, etc.
    
    if (step == 0) {

        if (!suppressScroll) {
            this.scrollCellIntoView (newSelectionIndex, focusCol);
        }
        
        this._putNativeFocusInCell(newSelectionIndex, focusCol, this.suppressNavigationFocus);
        // returning false suppresses the normal keyboard handling - scroll on right/left arrow
        return false;
    }

    // Note: we are either going forward or backward one record - assume jumping over multiple
    // records is not supported
    //
    // Default to selecting the next record
    if (step == null) step = 1;


    // Otherwise, get the last record clicked
    if (newSelectionIndex == null) newSelectionIndex = this._lastRecordClicked;

    var originalSelection = newSelectionIndex,
        normalizedOrigSelection;
    if (!isc.isA.Number(newSelectionIndex)) {
        newSelectionIndex = this.body ? this.body._getViewportFillRows()[0] : 0;
        normalizedOrigSelection = newSelectionIndex;
    } else {
        newSelectionIndex = newSelectionIndex+(checkFirst ? 0 : step);
        normalizedOrigSelection = originalSelection;
    }

    var lastRow = this.getTotalRows() -1;
    // if we are trying to navigate past the ends just ensure the focus row is selected
    if (newSelectionIndex < 0 || newSelectionIndex > lastRow) {
        // bail if there were no records
        if (lastRow < 0) return true;

        // Ensure the original record is selected / focused
        
        newSelectionIndex = normalizedOrigSelection;

    }
    // At this point we are sure that newSelectionIndex is a number.
    // If the number is beyond the end of the list in either direction, or
    // the record is not enabled, recordIsEnabled() will return false.
    // Try the next record in the step direction, and so on until we find an enabled record or
    // hit the end of the list.

    // If the record is disabled, find the first non-disabled record (in the appropriate
    // direction)
    while (!this.recordIsEnabled(this.getCellRecord(newSelectionIndex, 0), newSelectionIndex, 0)) {
        newSelectionIndex += step;
        // if we are trying to navigate past the ends of the list, bail
        if (newSelectionIndex < 0 || newSelectionIndex > lastRow) {
            newSelectionIndex = normalizedOrigSelection;
            break;
        }
    }

    // move native focus to the selected row so that screen readers will read it
    if (isc.screenReader) {
        this._putNativeFocusInCell(newSelectionIndex, focusCol,  this.suppressNavigationFocus);
    }

    //this.logWarn("navStyle: " + navStyle + ", target index: " + newSelectionIndex);

    // Explicitly hilite the record.
    // This provides a visual cue (roll over styling) to indicate the record has
    // keyboard focus even if it is un-selectable.
    this._hiliteRecord(newSelectionIndex, focusCol);
    if (navStyle == this._$focus) {
        if (isc.screenReader) this._putNativeFocusInCell(newSelectionIndex, focusCol,  this.suppressNavigationFocus);
    } else {
    
        // if the user hit up arrow on the first row or down arrow on the last row, don't
        // actually force a click handler to fire on the row.
        // This leads to odd interactions with ListGrid editing on click as arrow down on the
        // last row will hide the editor, then arrow down again will show it on the same
        // row but the first editable col.
        // If the user does want to force a click on the current row via the keyboard
        // they can always hit space or enter.
        
        if (newSelectionIndex == originalSelection) {
            var colNum = focusCol != null ? focusCol : this._getKeyboardClickNum();
            if (colNum >= 0 && this.body.selectionEnabled()) {
                var record = this.getCellRecord(newSelectionIndex, colNum);
                if (this.canSelectRecord(record) &&
                    this.recordIsEnabled(record, newSelectionIndex, colNum))
                {
                    this.selectionManager.selectOnMouseDown(this, newSelectionIndex, colNum);
                    this.selectionManager.selectOnMouseUp  (this, newSelectionIndex, colNum);

                    // Explicitly fire the selectionUpdated notification
                    this.fireSelectionUpdated();
                }
            }
        }
        else if (navStyle == "selectOnly" || navStyle == this._$select) {
            this._generateCellClick(newSelectionIndex, focusCol, null, (navStyle == "selectOnly"));
        }
        else if (navStyle == this._$activate) {
            this._generateRecordDoubleClick(newSelectionIndex, focusCol);
        }
    }
    if (!suppressScroll) {
        this._handlingKeyboardNavigation = true;
        this.scrollRecordIntoView(newSelectionIndex)
        this._handlingKeyboardNavigation = false;
    }
    // Don't allow the keypress event handling to continue here.
    return false;
},

// In Screenreader mode, can we focus in native body cells even though
// canSelectCells is false?
_canFocusInBodyCells : function () {
    // Assertion: If we have a frozen and unfrozen body the 'canFocusInCells' logic
    // should match for both!
    return this.body && this.body.canFocusInCells();
},

// Helper method for the case where canSelectCells is false but
// body.canFocusInCells() is true, to determine which cell to put focus into
// when the user hits the right/left arrow keys

_getNewNativeFocusCol : function (colStep) {

    var focusCol = this._getKeyboardClickNum(true);
    if (colStep != null) {
        var newFocusCol = focusCol + colStep;
        if (newFocusCol >= 0 && newFocusCol < this.fields.length) {
            focusCol = newFocusCol;
        }
    }
    return focusCol;
},

// Helper to call _putNativeFocusInRow on the appropriate body for the col passed in
// By default this will force focus into the body if it doesn't already have it.
_putNativeFocusInCell : function (rowNum, colNum, suppressFocus) {
    var body = this.body, bodyColNum;
    if (colNum != null) {
        body = this.getFieldBody(colNum);
        bodyColNum = this.getLocalFieldNum(colNum);
    }
    if (body) {
        
        body._putNativeFocusInRow(rowNum, bodyColNum);
        // _putNativeFocusInrow() will remember the appropriate focus targets but 
        // won't actually focus in the GridRenderer's cell if the GR did not have focus
        // - force focus if we're in this state
        if (!suppressFocus && !body.hasFocus) body.focus();
    }
},

// Used by canSelectCells:false grids to determine which field (if any) should get a cell
// click even on keyboard navigation
// Also used to manage where to put native focus during screenReaderNavigateByCells arrow-key
// navigation
// Note the behavior differs slightly - we want to allow cells that can't be clicked to still
// be read, for example. The 'returnNativeFocusCol' param allows us to have this different
// behavior in place.
_getKeyboardClickNum : function (returnNativeFocusCol) {

    // If this.keyboardClickField was specified, return the appropriate colNum
    // Note - can be specified as a field number or field name...
    // If screenReaderNavigateByCell is true this gets updated at runtime by logic
    // in gridBody.putNativeFocusInRow()
    var kcf = this.keyboardClickField;
    if (kcf != null) {

        var kcCol;
        if (isc.isA.Number(kcf) && kcf > 0 && kcf < this.fields.length) {
            kcCol = this.fields[kcf];
        } else {
            kcCol = this.fields.find(this.fieldIdProperty, kcf);
        }
        if (kcCol && kcCol.ignoreKeyboardClicks && !returnNativeFocusCol) {
            this.logWarn("Explicitly specified keyboardClickField:" + this.keyboardClickField +
                " refers to a field which disallows keyboard click events.");
            kcCol = null;
        }
        if (kcCol != null) {
            return this.fields.indexOf(kcCol);
        }
    }
    if (isc.screenReader && (this._lastNativeFocusBody || returnNativeFocusCol)) {

        // Rely on GR.getNativeFocusColumn() to tell us where we last put native focus, so
        // we can move from that cell.
        // Note - if we have frozen fields, we need to know which body we're talking about.
        // _lastNativeFocusBody is set up by the putNativeFocusOnRow override in
        // our body/frozen body.
        var body = this._lastNativeFocusBody || this.body;
        return this.getFieldNumFromLocal(body.getNativeFocusColumn(), body);
    }
    if (this.getCurrentCheckboxField() != null) {
        return this.getCheckboxFieldPosition();
    }

    for (var i = 0; i < this.fields.length; i++) {
        if (this.fields[i].ignoreKeyboardClicks != true) return i;
    }
    // Unable to find a valid field - return -1. Calling code will have to handle this
    return -1;
},

// Simulate a click on a cell from a keyboard action
// 
_generateCellClick : function (rowNum, colNum, focus, selectOnly) {
    // Ensure we're not showing a rollOver hilite on a different row.
    if (!this.canSelectCells && this.body.lastOverRow != null &&
        this.body.lastOverRow != rowNum)
    {
        this.clearLastHilite();
    }

    // if passed a record, resolve it to an index!
    if (isc.isAn.Object(rowNum)) rowNum = this.getRecordIndex(rowNum);

    // Make sure we're not trying to select a record beyond the ends of the list.
    if (!isc.isA.Number(rowNum) || rowNum < 0) rowNum = 0;
    if (rowNum >= this.data.getLength()) rowNum = this.data.getLength() -1;

    var body, bodyColNum,
        nativeCellFocus = this.body && this.body.canFocusInCells();

    if (this.canSelectCells) {
        if (colNum == null || colNum < 0 || colNum >= this.getTotalCols()) return;
        body = focus ? this.getFieldBody(colNum) : this._lastKeyboardHiliteBody;

        var colOffset = body.selectionManager.firstCol || 0;
        bodyColNum = (colNum - colOffset);
    } else {

        if (colNum != null && isc.screenReader && nativeCellFocus) {
            body = this.getFieldBody(colNum);
        } else {
            body = this.body;
            if (colNum == null) colNum = this._getKeyboardClickNum();
        }
        // remember we artificially selected this record from a keyboard event
        body._lastHiliteRow = rowNum;
        if (colNum == -1) return;

        bodyColNum = this.getLocalFieldNum(colNum);
        body._lastHiliteCol = bodyColNum;
    }

    // Trigger the methods to perform the selection (selection.selectOnMouseDown AND
    // selection.selectOnMouseUp)
    
    var record = this.getCellRecord(rowNum, colNum),
        performSelection = this.selectOnGeneratedCellClick(record, rowNum, colNum, body);
    
    if (performSelection) {
        body.selectOnMouseDown(record, rowNum, bodyColNum, true);
        body.selectOnMouseUp(record, rowNum, bodyColNum, true);
    }

    if (nativeCellFocus) {
        this._putNativeFocusInCell(rowNum, colNum);
    }

    if (selectOnly) return;

    // explicitly fire this 'rowClick' method, passing in the additional method flagging this
    // as a keyboard generated click
    
    var record = this.getCellRecord(rowNum, colNum)
    var rv = (this.cellClick(record, rowNum, colNum, true) != false) && 
                (this.rowClick(record, rowNum, colNum, true) != false);

    return rv;

},

selectOnGeneratedCellClick : function (record, rowNum, colNum, body) {
    return (body.selectionEnabled() && this.recordIsEnabled(record, rowNum, colNum));
},

//> @method listGrid.getFocusRow() [A]
// Get the row that currently has keyboard focus.  Arrow key navigation moves relative to this
// row.
//
// @return (Integer) rowNum of the current focus row
// @visibility external
//<
// @param last (boolean) if multiple rows are selected, should we return the last row in the
//  selection (rather than the first?
// @param hiliteOnly (boolean) if true and the focus row can't be determined from the last
//  record highlighted, then just return null rather than computing a row based on selection
getFocusRow : function (last, hiliteOnly) {

    // We want the last record hilighted by the keyboard.
    // Note: If the last keyboard hilite type event was a generated record click, the
    // lastHiliteRow will match the lastRecordclicked property for this widget.
    // If the last keyboard hilite type event was a hilite (rollover style) event, the
    // lastHiliteRow will match the lastOverRow for the body.
    // If neither of these are true, we can assume a subsequent mouse event has occurred over
    // a different row, effectively invalidating the _lastHiliteRow property, so should be
    // ignored and deleted
    // (Note that if showRollOver is false but hiliteFocusRow is true we never change the
    // "lastOverRow" on mouse move events, so we would only expect to see a mismatch
    // between lastOverRow and _lastHiliteRow if showRollOver is true)
    if (this.body._lastHiliteRow != null &&
        ((this.body._lastHiliteRow == this.body.lastOverRow) ||
         (this.body._lastHiliteRow == this._lastRecordClicked)) )
    {
        return this.body._lastHiliteRow;
    }
    delete this.body._lastHiliteRow;

    if (hiliteOnly) return null;

    // If there is no valid keyboard hilite row, return a record from the end of the selection
    // We use 'direction' param to indicate whether it's more appropriate to return the
    // first or last selected record of a multiple selection
    var selection = this.getSelection();
    if (selection.length == 0) return null;
    selection = selection[(last ? selection.length -1 : 0)]
    return this.getRecordIndex(selection);

},

// Helper method to get the last keyboard hilite cell position.
getFocusCell : function (querySelectionObject) {

    if (!this.canSelectCells) {
        return [this.getFocusRow(), this._getKeyboardClickNum()];
    }

    var row, col;

    // this._lastKeyboardHiliteRow and col are only valid if they match the last row clicked, or
    // the last row hilited - otherwise some non-keyboard manipulation has occurred since the values
    // were set.
    
//this.logWarn("row/col:" + this._lastKeyboardHiliteRow + ", " + this._lastKeyboardHiliteCol);
    if (this._lastKeyboardHiliteRow != null && this._lastKeyboardHiliteCol != null) {
        var body = this._lastKeyboardHiliteBody;
        if (body != null) {
            var colOffset = body.selectionManager.firstCol || 0;
            if ((this._lastKeyboardHiliteRow == body.lastOverRow &&
                 this._lastKeyboardHiliteCol == body.lastOverCol + colOffset) ||
                (this._lastSelectedBody      == body &&
                 this._lastKeyboardHiliteRow == body._lastSelectedRow &&
                 this._lastKeyboardHiliteCol == body._lastSelectedCol + colOffset))
            {
                row = this._lastKeyboardHiliteRow;
                col = this._lastKeyboardHiliteCol;
            }
        }
    }

    // If we didn't find a keyboard cell, grab the last selected cell
    if (row == null || col == null) {
        if (querySelectionObject) {
            row = this.selectionManager.lastRow;
            col = this.selectionManager.lastCol;
        }
        var body = this._lastSelectedBody;
        if (body) {
            var colOffset = body.selectionManager.firstCol || 0;
            if (row == null || col == null) {
                row = body._lastSelectedRow;
                col = body._lastSelectedCol + colOffset;
            }
        }
    }

    // If the remembered rowNum is off the end of the grid, assume a new edit row has
    // been cleared or a record has been removed from the data. In this case the "focus cell"
    // is no longer valid
    if (row >= this.getTotalRows()) {
        row = null;
        col = null;
    }
    if (row == null || col == null) {
        var selection = this.getSelection();
        if (selection.getLength() > 0) {
            row = selection[0]._rowNum;
            col = selection[0]._colNum;
        }
    }
    return [row, col];
},

// Called from grid body keyboard event handling.
// Return values as follows
// - return false if actual rowClick etc returned false.
// - return true if a valid cell was found and the rowClick executed
// - return null if no valid cell was found
_generateFocusRecordClick : function () {
    var cell = this.getFocusCell(),
        row = cell[0],
        col = cell[1];

    if (row != null && col != null) {
        var rv = this._generateCellClick(row, col, true);
        if (rv == null) rv = true;
        return rv;
    }
    return null;
},

_generateRecordDoubleClick : function (rowNum, colNum) {
    if (colNum == null) colNum = this._getKeyboardClickNum();
    if (colNum == null || colNum == -1) return;

    // generate a double click, on the appropriate record (and field), passing in the
    // parameter flagging this as a keyboard synthesized click event.
    //this._handleRecordDoubleClick(currentRecord, colNum);
    return this.rowDoubleClick(this.getCellRecord(rowNum, colNum), rowNum, colNum, true);
},

_generateFocusRecordDoubleClick : function () {
    var cell = this.getFocusCell(),
        row = cell[0],
        col = cell[1];
    if (row != null && col != null && col >= 0) {
        var rv = this._generateRecordDoubleClick(row, col);
        if (rv == null) rv = true;
        return rv;
    }
    return null;
},

// Scrolling
// --------------------------------------------------------------------------------------------

//> @attr listGrid.scrollToCellXPosition (Alignment : "center" : IRW)
// When scrollToCell is called, this is used as defaults if xPosition weren't explicitly passed
// into the method.
// @visibility external
//<
scrollToCellXPosition: "center",

//> @attr listGrid.scrollToCellYPosition (VerticalAlignment : "center" : IRW)
// When scrollToCell is called, this is used as defaults if yPosition weren't explicitly passed
// into the method.
// @visibility external
//<
scrollToCellYPosition: "center",

//> @method listGrid.scrollRecordToTop()    (A)
// Scroll the listGrid body such that the specified row is visible at the top of the viewport.
//      @group  scrolling
//      @param  rowNum  (number)    Index of the row to scroll into view
//<
scrollRecordToTop : function (rowNum) { return this.scrollRecordIntoView(rowNum, "top"); },

//> @method listGrid.scrollRecordIntoView() (A)
// Scroll the listGrid body such that the specified row is visible close to the
// center of the viewport.
//      @group  scrolling
//      @param  rowNum  (number)    Index of the row to scroll into view
//      @param  [yPosition] (VerticalAlignment) Vertical position of scrolled row (optional)
//<
scrollRecordIntoView : function (rowNum, yPosition) {
    return this.scrollToCell(rowNum, null, null, yPosition);
},

//> @method listGrid.scrollToColumn()
// Scroll the grid to specified column such that the row appears near the center of the
// viewport.
// <P>
// See +link{listGrid.scrollToCell()} for a full description of how
// this method interacts with incremental loading and rendering of data.
// @group   scrolling
// @param   colNum  (number)    Index of the column to scroll into view
// @param   [xPosition] (Alignment) Horizontal position of scrolled column (optional)
// @visibility external
//<
scrollToColumn : function (colNum, xPosition) {
    return this.scrollToCell(null, colNum, xPosition);
},

//> @method listGrid.scrollToRow()
// Scroll the grid to specified row such that the row appears near the center of the
// viewport, loading data if necessary.
// <P>
// See +link{listGrid.scrollToCell()} for a full description of how
// this method interacts with incremental loading and rendering of data.
//
// @group scrolling
// @param   rowNum  (number)    Row index of the cell to scroll into view
// @param   [yPosition] (VerticalAlignment) Vertical position of scrolled row (optional)
// @visibility external
//<
scrollToRow : function (rowNum, yPosition, alwaysScroll) {
    this.scrollToCell(rowNum, 0, null, yPosition, alwaysScroll);
    // allow for chaining other function calls after scrollToRow()
    return this;
},

// helper callback to weed out calls to scrollToRow that should be ignored.
// we only want to perform the last call to scrollToRow() that occurs before data arrives.
scrollCellCallback : function (rowNum, colNum, xPosition, yPosition, alwaysScroll, stamp) {
    if (stamp == this._currentScrollCall) {
        // reset counter
        this._currentScrollCall = null;
        this.scrollToCell(rowNum, colNum, xPosition, yPosition, alwaysScroll);
    }
},

//> @method listGrid.scrollToCell() (A)
// Will scroll the listGrid body such that the specified cell is visible close to the
// center of the viewport.
// <P>
// This method has no effect if the cell is already visible in the viewport.
// <P>
// When scrolling vertically, this will cause data to be automatically loaded
// if +link{dataFetchMode,paging is active} and you scroll into an area of
// the data that isn't loaded.  Only rows around the target row will be
// loaded, not all intervening rows.  See also +link{ResultSet}.
// <P>
// Scrolling into an undrawn area will cause the body area of the grid to
// redraw, but this won't happen synchronously unless you explicitly call
// redraw().  Scrolling into an area of the data that is not yet loaded
// will never synchronously draw new rows, even if you call redraw() -
// wait for +link{dataArrived} to be notified when new rows have been
// loaded.
// <P>
// Calling this method with a row index larger than the
// current dataset will clamp to the end of the dataset (similarly horizontal
// scrolling will clamp to the last column).
// <P>
// If a call to this method is made while data is still loading, such
// that the last row of the dataset is not yet known the grid will attempt to compensate
// by scrolling the record into view when data arrives, if it is valid.
// For better control over scrolling, developers should consider
// calling <code>scrollToRow()</code> or <code>scrollToCell</code>
// from +link{dataArrived()} if data is still loading.
// <P>
// With mixed-height rows it will only reliably work if virtualScrolling
// is enabled.
//
// @group   scrolling
// @param   rowNum  (int)    Row index of the cell to scroll into view
// @param   colNum  (int)    Column index of the cell to scroll into view
// @param   [xPosition] (Alignment) Horizontal position of scrolled cell (optional)
// @param   [yPosition] (VerticalAlignment) Vertical position of scrolled cell (optional)
// @visibility external
//<
scrollToCell : function(rowNum, colNum, xPosition, yPosition, alwaysScroll) {
    return this.scrollCellIntoView(rowNum, colNum, xPosition, yPosition, alwaysScroll);
},

// alwaysScroll: scroll even if the cell is already in view (position it
//               according to "xPosition" and "yPosition" parameters)
scrollCellIntoView : function (rowNum, colNum, xPosition, yPosition, alwaysScroll) {
    // method arguments has been changed from (rowNum, colNum, center, alwaysCenter) so if
    // we could determine old arguments we should log warning message and convert passed values
    // to new arguments
    if (isc.isA.Boolean(xPosition) && (typeof alwaysScroll == 'undefined')) {
        isc.logWarn("Center argument had been passed to a scroll method(scrollToCell, " +
            "scrollCellIntoView, scrollToColumn or scrollRecordIntoView). This is deprecated. " +
            "See documentation for detailed information about passed arguments.");
        alwaysScroll = yPosition;
        yPosition = xPosition? "center": "top";
        xPosition = xPosition? "center": "left";
    }

    if ((isc.isAn.Array(this.data) && this.data.length == 0 && this.dataSource)
        || (isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown())) {
        // keep track of consecutive calls to scrollToRow() so we can only perform the most
        // recent one, before data arrives.
        if (!this._currentScrollCall) this._currentScrollCall = 1;
        else this._currentScrollCall += 1;
        var stamp = this._currentScrollCall;
        isc.Page.waitFor(this, "dataArrived",
            {method: this.scrollCellCallback, args: [rowNum, colNum, xPosition, yPosition, alwaysScroll, stamp],
            target:this}
        );

        return;
    }

    // if the body isn't drawn, we can't scroll the cell into view - set a flag to scroll the
    // body when it gets drawn
    var bodyDrawn = this.body && this.body.isDrawn(),
        autoFitting = this.autoFitFieldWidths == true || 
            (this.getFields() || []).getProperty("autoFitWidth").contains(true),
        autoFitPending = autoFitting && 
            (this.body && ![false, null].contains(this.body._fieldWidthsDirty))
    ;
    if (!bodyDrawn || autoFitPending) {
        this.logInfo("scrollCellIntoView() called " +
            (!bodyDrawn ? "before the body has been drawn." :
                "while a redraw() was pending.") +  
            "  Cell " + rowNum + "," + colNum + " will be scrolled into view on " +
            (!bodyDrawn ? "draw()." : "redraw().")
        );
        this._scrollCell = [rowNum, colNum, xPosition, yPosition];
        return;

    }

    // Force an immediate adjustOverflow before we calculate row / viewport size etc
    
    if (this.body._deferredOverflow || this.body._overflowQueued) {
        this.body.adjustOverflow("ScrollCellIntoView requesting size");
    }

    // Use default values scrollToCellXPosition and scrollToCellYPosition if null or incorrect
    // value has been passed
    if (xPosition != "left" && xPosition != "center" && xPosition != "right") {
        xPosition = this.scrollToCellXPosition;
    }
    if (yPosition != "top" && yPosition != "center" && yPosition != "bottom") {
        yPosition = this.scrollToCellYPosition;
    }

    var x, y, width, height, body = this.body,
        isDirty = this.isDirty() || body.isDirty()
    ;
    if (rowNum != null) {

        
        if (isDirty && this.virtualScrolling && !body._isVirtualScrolling) {
            body._updateVirtualScrolling();
        }

        if (!body._isVirtualScrolling) {
            y = body.getRowTop(rowNum);
            height = body.getRowSize(rowNum);
        } else {
            // If the row is already in the viewport, don't call scrollToTargetRow()
            // as this will shift it about which can be confusing if the user is
            // navigating through rows with the keyboard.
            var undrawn = body._firstDrawnRow == null || rowNum < body._firstDrawnRow ||
                rowNum > body._lastDrawnRow,
                inViewport = !undrawn;
            if (inViewport) {
                var rowTop = body.getRowTop(rowNum),
                    rowHeight = body.getRowHeight ?
                                    body.getRowHeight(this.getCellRecord(rowNum), rowNum, 0) :
                                    body.cellHeight,
                    scrollTop = body.getScrollTop();
                if (scrollTop > rowTop ||
                    ((body.getViewportHeight() + scrollTop) < (rowTop + rowHeight)))
                {
                    inViewport = false;
                }
            }
            if (!inViewport || 
                // _handlingKeyboardNavigation is false *and* the lastEvent was a key event
                (isc.EH.isKeyEvent(isc.EH.lastEvent) && !this._handlingKeyboardNavigation)) {
                // scrolling to a particular coordinate would be meaningless with unknown row
                // heights
                body._targetRow = rowNum;
                if (yPosition == "center") {
                    var rowHeight = body.getRowHeight ?
                            body.getRowHeight(this.getCellRecord(rowNum), rowNum, 0) :
                            body.cellHeight;
                    body._rowOffset = -1 * (body.getViewportHeight() - rowHeight) / 2;
                } else if (yPosition == "bottom") {
                    var rowHeight = body.getRowHeight ?
                            body.getRowHeight(this.getCellRecord(rowNum), rowNum, 0) :
                            body.cellHeight;
                    body._rowOffset = rowHeight - body.getViewportHeight();
                } else {
                    body._rowOffset = 0;
                }

                if (colNum != null) {
                    var cellOffset = null;
                    if (xPosition == "left") {
                        cellOffset = this.getColumnLeft(colNum);
                    } else if (xPosition == "right") {
                        cellOffset = this.getColumnLeft(colNum) +
                            this.getColumnWidth(colNum) - body.getViewportWidth();
                    } else {
                        cellOffset = this.getColumnLeft(colNum) +
                            (this.getColumnWidth(colNum) - body.getViewportWidth()) / 2;
                        
                    }
                    // Scroll horizontally.
                    // no "virtual scrolling" on the h-axis so this is just a simple number.
                    // The scrollToTargetRow call below will handle scrolling vertically
                    body.scrollTo(cellOffset);

                }
                body._scrollToTargetRow();
            }
            return;
        }
    }
    if (colNum != null) {
        if (this.frozenFields != null && colNum < this.frozenFields.length) {
            colNum = null;
        } else {
            x = this.getColumnLeft(colNum);
            width = this.getColumnWidth(colNum);
        }
    }

    // Catch the case where we're dirty, and the row being scrolled into view is not yet present
    // in our HTML (so we can't scroll into view until the redraw occurs)
    if (isDirty) {
        var mustRedraw;
        if (rowNum != null) {
            var scrollHeight = body.getScrollHeight();
            if (y+height > scrollHeight) mustRedraw = true;
        }
        if (!mustRedraw && colNum != null) {
            var scrollWidth = body.getScrollWidth();
            if (x+width > scrollWidth) mustRedraw = true;
        }
        if (mustRedraw) {
            // stash target edit cell so the correct row can be edited
            // after redraw
            if (this.alwaysShowEditors && !this._editorShowing) {
                this._editCellAfterRedraw = [rowNum, colNum];
            }
            this.redraw("scrollIntoView");
        }
    }

    //this.logWarn("ScrollIntoView passed: " + [rowNum, colNum] +
    //             ", calculated target cell position:" + [x,y] + ", size:" + [width,height]);

    body.scrollIntoView(x,y,width,height, xPosition, yPosition,
                        null, null, alwaysScroll)

},

// Header/Body Scroll Sync
// --------------------------------------------------------------------------------------------
// Note - we keep the body / header's horizontal scroll position in sync by firing
// syncHeaderScrolling when the body is scrolled, and syncBodyScrolling where the header is
// scrolled.
// We have to have these no-op if the header / body are already at the same place to avoid an
// infinite loop.

bodyScrolled : function (left, top, isFrozen) {

    if (left == null) left = isFrozen ? this.frozenBody.getScrollLeft() : this.body.getScrollLeft();
    // Assertion
    // the frozen body should never be clipping horizontally so if this was a
    // scroll from the frozen body, just sync up the vertical scroll position of the
    // unfrozen body and we're done.
    // NOTE: There's no obvious way for the user to scroll just the frozen body but this
    // could probably happen from interactions like keyboard events

    
    if (isFrozen) {
        this.body._noScrollObservation = true;
        var frozenBody = this.frozenBody;
        if (frozenBody._literalScroll) {
            var body = this.body;
                        
            
            if (frozenBody._scrollFromRedraw && body.isDirty()) {
                body.redraw("frozenBody redraw to sync draw area with body");
            }

            this.body._targetRow = frozenBody._targetRow; 
            this.body._rowOffset = frozenBody._rowOffset;
            this.body._scrollRatio = frozenBody._scrollRatio;
            this.body._scrollToTargetRow();
        } else {
            this.body.scrollTo(null, top, "scrollSync");
        }
        delete this.body._noScrollObservation

    // Unfrozen body scrolled, but we have a frozen body.
    // Vertically synch the scroll positions
    } else if (this.frozenBody != null) {
        this.frozenBody._noScrollObservation = true;
        var body = this.body,
            frozenBody = this.frozenBody;

        // virtual scrolling: The frozen body's virtual scrolling logic
        // (draw area etc) is all driven of the unfrozen body since that can detect
        // cases like "quick drag scrolling" of the scrollbars.
        // If the body is currently doing a "scrollToTargetRow", pick up the
        // stored targetRow info from the body and scrollToTargetRow ourselves
        
        if (body._literalScroll) {
        
            
            if (body._scrollFromRedraw && frozenBody.isDirty()) {
                frozenBody.redraw("frozenBody redraw to sync draw area with body");
            }

            frozenBody._targetRow = body._targetRow;
            frozenBody._rowOffset = body._rowOffset;
            frozenBody._scrollRatio = body._scrollRatio;
            frozenBody._scrollToTargetRow();
            
        } else {
            frozenBody.scrollTo(null, top, "bodyScrollSync");
        }
        delete this.frozenBody._noScrollObservation;
    }

    // Don't attempt to sync scrolling while drag-resizing.
    
    if (!this._dragResizingField) {
        this.syncHeaderScrolling(left, top, isFrozen);
        this.syncFilterEditorScrolling(left, top, isFrozen);
        this.syncSummaryRowScrolling(left,top, isFrozen);
    }

    // If we took focus from the edit form as part of a redraw and haven't restored it yet
    // restore it now
    
    if (this._editorShowing && this._editorSelection) {
        var editForm = this.getEditForm(),
            editRow = this.getEditRow(),
            editColNum = this.getEditCol(),
            editItem = editForm.getItem(this.getEditorName(editRow, editColNum));

        if (editItem) {
            if (!editItem.hasFocus &&
                (editForm.hasFocus || isc.EH.getFocusCanvas() == null))
            {
                this._restoreFocusAfterRedraw(editColNum);
            } else {
                delete this._editorSelection;
            }
        }
    }
    if (this.rowRangeDisplayStyle != "countOnly") {
        this.rowRangeDisplayValueChanged("source grid scrolled");
    }
},

syncHeaderScrolling : function (left, top, frozen) {
    var body = frozen ? this.frozenBody : this.body,
        header = frozen ? this.frozenHeader : this.header;
    if (body._ignoreHeaderScrollSync) {
        
        delete body._ignoreHeaderScrollSync;
        return;
    }

    if (left != null && header) {
        if (!this.isRTL()) {
            if (left != header.getScrollLeft()) {
                header.scrollTo(left, null, "headerScrollSync");
            }
        } else {
            
            var body = body,
                headerMaxScroll = header.getScrollWidth() - header.getViewportWidth(),
                headerScrollPos = headerMaxScroll - header.getScrollLeft(),
                bodyMaxScroll = body.getScrollWidth() - body.getViewportWidth(),
                bodyScrollPos = bodyMaxScroll - left;
            /*
            this.logWarn("scroll sync: body new left: " + left +
                         ", body max: " + bodyMaxScroll +
                         ", body pos: " + bodyScrollPos +
                         ", header current left: " + header.getScrollLeft() +
                         ", header max: " + headerMaxScroll +
                         ", header pos: " + headerScrollPos +
                         ", will scroll header to: " + (headerMaxScroll - bodyScrollPos));
            */

            if (bodyScrollPos != headerScrollPos) {
                header.scrollTo(headerMaxScroll - bodyScrollPos, null, "scrollSync");
            }
        }
    }
},

// when the header is scrolled, keep the body scrolled in sync with it!
headerScrolled : function () {
    
    if (!this._delayingBodyScrolling) {
        this._delayingBodyScrolling = this.delayCall("syncBodyScrolling");
    }
},


syncBodyScrolling : function () {
    delete this._delayingBodyScrolling;
    var left = this.header.getScrollLeft();
    if (this.body) {
        if (!this.isRTL()) {
            if (left != this.body.getScrollLeft()) this.body.scrollTo(left, null, "scrollSync");

        } else {

            var header = this.header,
                body = this.body,
                headerMaxScroll = header.getScrollWidth() - header.getViewportWidth(),
                headerScrollPos = headerMaxScroll - header.getScrollLeft(),
                bodyMaxScroll = body.getScrollWidth() - body.getViewportWidth(),
                bodyScrollPos = bodyMaxScroll - left;
            
            if (bodyScrollPos != headerScrollPos) {
                body.scrollTo(Math.max(0, bodyMaxScroll - headerScrollPos), null, "scrollSync");
            }
        }
    }
},

// if we are showing a filter editor we must keep that horizontally scrolled to the same
// position as the body
syncFilterEditorScrolling : function (left, top, frozen) {
    if (left == null) return;
    var body = frozen ? this.frozenBody : this.body,
        feBody = this.filterEditor ? 
                (frozen ? this.filterEditor.frozenBody : this.filterEditor.body) : null;
                
    if (feBody) {
        // RTL mode - account for the fact that scrolled to zero (IE hard left) on the main grid
        // body != scrolled to zero (hard left) on the filter editor since their left coords don't
        // align.
        if (this.isRTL()) {
            var offset = body.getViewportWidth() - feBody.getViewportWidth()
            left += offset;
        }

        // No op if they are already in sync to avoid an infinite loop
        if (feBody.getScrollLeft() != left)
        {
            feBody.scrollTo(left, null, "scrollSync");
        }
    }
},

syncSummaryRowScrolling : function (left,top, frozen) {
    if (left == null) return;
    var summaryRow = this.showGridSummary ? this.summaryRow : null;
    var summaryBody = summaryRow && (frozen ? summaryRow.frozenBody : summaryRow.body);
    if (summaryBody != null && summaryBody.getScrollLeft() != left)
    {
        summaryBody.scrollTo(left, null, "scrollSync");
    }
},

// RollOver
// --------------------------------------------------------------------------------------------


_hiliteRecord : function (recordNum, colNum) {
    if (colNum == null) {
         colNum = 0;
    }
    if (!isc.isA.Number(recordNum)) {
        recordNum = this.getRecordIndex(recordNum);
    }

    // Make sure we're not trying to select a record beyond the ends of the list.
    if (!isc.isA.Number(recordNum) || recordNum < 0) recordNum = 0;

    // clamp to getTotalRows(), not data.getLength() - caters for unsaved rows
    if (recordNum >= this.getTotalRows()) {
        recordNum = this.getTotalRows() - 1;
    }
    this.clearLastHilite();


    if (!this.canSelectCells) {
        // note the row number hilighted by keyboard navigation
        this.bodies.setProperty("_lastHiliteRow", recordNum);

        // set this.body.lastOverRow, so the recordStyle will be updated to the mouseOver style
        
        this.bodies.setProperty("lastOverRow", recordNum);
        this.bodies.setProperty("lastOverCol", 0);  // required to make the GR believe the mouse was over a real cell
        // no need to calculate the style - setRowStyle will achieve that
        this.bodies.callMethod("setRowStyle", recordNum);
    } else {
        var body = this.getFieldBody(colNum);
        body._lastHiliteRow = recordNum;
        body._lastHiliteCol = body.lastOverCol = this.getLocalFieldNum(colNum,body);
        body.lastOverRow = recordNum;
        body.setRowStyle(recordNum);
    }

    
    this.updateRollOverCanvas(recordNum);

},

//> @method listGrid.clearLastHilite()  (A)
// Unhilites the last hilited item.
//      @group  events, hiliting
//<
clearLastHilite : function (frozen) {
    var body = frozen ? this.frozenBody : this.body;
    if (!body) return;

    // the obvious merge of the two cases of this.canSelectCells doesn't work because
    // body.lastOverCol can be != null for the case of !this.canSelectCells
    var rowToClear = body.lastOverRow,
        colToClear;
    if (rowToClear < 0) return;
        
    // clear the pointer to the last row hilited via keyboard navigation
    var hasKeyboardHilites = false;
    if (!this.canSelectCells) {
        hasKeyboardHilites = (body._lastHiliteRow != null);
        body._lastHiliteRow = null;
        body._lastHiliteCol = null;
        if (rowToClear == null) return;
    } else {
        // make sure to clear frozen body hilites
        
        hasKeyboardHilites = (this._lastKeyboardHiliteRow != null && this._lastKeyboardHiliteCol != null);
        body._lastHiliteRow = null;
        body._lastHiliteCol = null;

        if (!frozen) this.clearLastHilite(true);
        this._lastKeyboardHiliteRow = null;
        this._lastKeyboardHiliteCol = null;
        this._lastKeyboardHiliteBody = null;
        colToClear = body.lastOverCol;
        if (rowToClear == null || colToClear == null) return;
        delete body.lastOverCol;
    }
    delete body.lastOverRow;

    // no need to calculate new styleName here - let setRowStyle determine that
    if (this.showRollOver || hasKeyboardHilites) {
        body.updateRollOver(rowToClear, colToClear);
    }
},

// Note that we basically use the body like a focusProxy - when focus() is called, focus
// will go to the body.
// o Set _useFocusProxy to false - we don't want the grid to ever have native focus
// o Set _useNativeTabIndex to false - this is done AFTER creating the body so the body can
//   pick up the '_useNativeTabIndex' as explicitly specified on the ListGrid before that
//   property gets overridden.
_useFocusProxy:false,

// Override setAccessKey to set the accessKey on the body rather than on the listGrid
setAccessKey : function (accessKey) {
    // call Super - will remember this.accessKey, (though it won't actually set it on the LV handle)
    this.Super("setAccessKey", arguments)
    if (this.body != null) this.body.setAccessKey(accessKey);
},

// Override setFocus to focus on the body rather than the ListGrid
setFocus : function (newfocus) {
    if (this.body != null) {
        this.body.setFocus(newfocus);
    }
},

// Override _canFocus() - we are focusable if the body is focusable
// Note that the body already picks up the 'canFocus' attribute from the ListGrid, if specified
// _canFocus is also overridden in gridBody to disable focus when empty, if appropriate
_canFocus : function () {
    if (this.body) return this.body._canFocus();
    return false;
},

// This allows us to deal with treating frozen and unfrozen bodies as a single tab-stop
// See GridBody.syntheticShiftFocus
alwaysManageFocusNavigation:true,

// override syntheticShiftFocus to return false
// We basically "skip over" the ListGrid itself and focus in the body (or header), or on
// shift+tab from the body, focus on the previous widget on the page
syntheticShiftFocus : function () {
    return false;
},
    
//> @attr listGrid.canFocusInEmptyGrid (boolean : true : IRA)
// If the listGrid is empty, should the user be able to put focus into the grid body by tabbing
// to it?
// <P>
// Note that if +link{editOnFocus} is true for this grid and +link{listEndEditAction} is set to next,
// having this property set to true will allow users to automatically create a new edit row by
// simply tabbing into the grid.
//
// @visibility external 
//<
canFocusInEmptyGrid:true,

// disable the focus indicator in Chrome/Safari since it's clipped at the bottom/right and looks
// odd
showFocusOutline:!isc.Browser.isSafari,

// Body Clicks
// --------------------------------------------------------------------------------------------

//> @method listGrid.recordClick()
// Executed when the listGrid receives a 'click' event on an enabled, non-separator
// record. The default implementation does nothing -- override to perform some action
// when any record or field is clicked.<br>
// A record event handler can be specified either as
// a function to execute, or as a string of script to evaluate. If the handler is defined
// as a string of script, all the parameters below will be available as variables for use
// in the script.<br>
// To do something specific if a particular field is clicked, add a recordClick
// method or string of script to that field (same parameters) when you're setting up
// the list.<br>
// <b>Notes:</b><ul>
// <li>This will not be called if the click is below the last item of the list.</li>
// <li>This method is called from the default implementation of
// +link{method:listGrid.rowClick}, so if that method is overridden
// this method may not be fired.</li></ul>
//
// @param viewer (ListGrid) the listGrid that contains the click event
// @param record (ListGridRecord) the record that was clicked on
// @param recordNum (number) number of the record clicked on in the current set of
//                                  displayed records (starts with 0)
// @param field (ListGridField) the field that was clicked on (field definition)
// @param fieldNum (number) number of the field clicked on in the listGrid.fields
//                                  array
// @param value (Any) value of the cell (after valueMap, etc. applied)
// @param rawValue (Any) raw value of the cell (before valueMap, etc applied)
// @param editedRecord (ListGridRecord) the clicked record with any unsaved
//                                   edit values overlaid (see <code>listGrid.getEditedRecord()</code>).
// @return (boolean) return false to cancel default behavior
//
// @see rowClick()
// @group events
// @visibility external
//<
// NOTE: params not needed for default no-op implementation
recordClick : function () {
    return true;
},

//> @method listGrid.onRecordClick()
// Executed when the listGrid receives a 'click' event on an enabled, non-separator
// record. The default implementation does nothing -- override to perform some action
// when any record or field is clicked.<br>
// A record event handler can be specified either as
// a function to execute, or as a string of script to evaluate. If the handler is defined
// as a string of script, all the parameters below will be available as variables for use
// in the script.<br>
// To do something specific if a particular field is clicked, add a recordClick
// method or string of script to that field (same parameters) when you're setting up
// the list.<br>
// <b>Notes:</b><ul>
// <li>This will not be called if the click is below the last item of the list.</li>
// <li>This method is called from the default implementation of
// +link{method:listGrid.rowClick}, so if that method is overridden
// this method may not be fired.</li></ul>
//
// @param viewer (ListGrid) the listGrid that contains the click event
// @param record (ListGridRecord) the record that was clicked on
// @param recordNum (number) number of the record clicked on in the current set of
//                                  displayed records (starts with 0)
// @param field (ListGridField) the field that was clicked on (field definition)
// @param fieldNum (number) number of the field clicked on in the listGrid.fields
//                                  array
// @param value (Object) value of the cell (after valueMap, etc. applied)
// @param rawValue (Object) raw value of the cell (before valueMap, etc applied)
// @param editedRecord (ListGridRecord) the clicked record with any unsaved
//                                   edit values overlaid (see <code>listGrid.getEditedRecord()</code>).
// @return (boolean) return false to cancel default behavior
//
// @see rowClick()
//
// @group events
// @visibility sgwt
//<
onRecordClick : function (viewer, record, recordNum, field, fieldNum, value, rawValue) {
    return true;
},

//> @method listGrid.recordDoubleClick()
// Executed when the listGrid receives a 'doubleClick' event on an enabled, non-separator
// record. The default implementation does nothing -- override to perform
// some action when any record or field is double clicked.<br>
// A record event handler can be specified either as a function to execute, or as a string
// of script to evaluate. If the handler is defined as a string of script, all the
// parameters below will be available as variables for use in the script.<br>
// To do something specific if a particular field is double clicked, add a
// recordDoubleClick method or string of script to that field (same parameters) when you're
// setting up the list.<br>
// <b>Notes:</b><ul>
// <li>This will not be called if the click is below the last item of the list.</li>
// <li>This method is called from the default implementation of +link{method:listGrid.rowDoubleClick},
// so if that method is overridden this method may not be fired.</li></ul>
//      @group  events
//
// @param   viewer      (ListGrid)  the listGrid that contains the doubleclick event
// @param   record      (ListGridRecord)    the record that was double-clicked
// @param   recordNum   (number)    number of the record clicked on in the current set of
//                                  displayed records (starts with 0)
// @param   field       (ListGridField) the field that was clicked on (field definition)
// @param   fieldNum    (number)    number of the field clicked on in the listGrid.fields
//                                  array
// @param   value       (Object)    value of the cell (after valueMap, etc. applied)
// @param   rawValue    (Object)    raw value of the cell (before valueMap, etc applied)
// @param editedRecord (ListGridRecord) the clicked record with any unsaved
//                                   edit values overlaid (see <code>listGrid.getEditedRecord()</code>).
// @return (boolean)    return false to cancel event bubbling
//
// @see    rowDoubleClick()
//
// @visibility external
//<
// NOTE: params not needed for default no-op implementation
recordDoubleClick : function () {},

// --------------------------------------------------------------------------------------------
// Summary row
// --------------------------------------------------------------------------------------------

// If grid.showGridSummary is true, generate a 'summaryRow' auto child to show summaries at
// the bottom of the list grid.
// Default behavior is to show totals for numeric fields

//> @attr listGrid.showGridSummary (Boolean : false : IRW)
// Should this ListGrid show a summary row beneath the last record of the grid. This summary
// row will contain per-field summary information. See +link{listGridField.showGridSummary} and
// +link{listGrid.getGridSummaryFunction()} for details on how the summary value to be displayed
// for each column will be calculated.
// <P>
// Note that the +link{listGrid.summaryRow,summaryRow autoChild} will be created to actually
// display the summary row.
// @visibility external
//<
showGridSummary:false,

//> @attr listGrid.invalidSummaryValue (String : "&nbsp;" : IRWA)
// Value to display to the user if showing summary values (through +link{listGrid.showGridSummary},
// +link{listGrid.showGroupSummary} or +link{listGridFieldType,listGridFieldType:"summary"}), and
// the summary function returns <code>"null"</code> (implying it was unable to calculate a
// valid summary value). This property will only be used in the default formatting behavior. If
// an explicit formatter has been specified - via +link{listGrid.formatCellValue} or
// +link{listGridField.formatGridSummary(),formatGridSummary()}, for example - this property has
// no effect.
// @visibility external
//<
invalidSummaryValue:"&nbsp;",

//> @attr listGrid.includeInSummaryProperty (String : "includeInSummary" : IRW)
// Property name on a record that will be checked to determine whether a record should
// be included when calculating totals for the +link{listGrid.showGridSummary,grid summary}.
// @visibility external
//<
includeInSummaryProperty:"includeInSummary",

//> @attr listGridRecord.includeInSummary (boolean : null : IRW)
// If specified as false this record should be ignored when calculating summary totals
// to be shown in the +link{listGrid.showGridSummary,summary row} for this grid.
// <P>
// Note that <code>includeInSummary</code> is the default property name for this attribute,
// but it may be modified via +link{listGrid.includeInSummaryProperty}.
// @visibility external
//<


//> @attr listGrid.gridSummaryRecordProperty (String : "isGridSummary" : IRW)
// If +link{listGrid.showGridSummary} is true, this attribute will be set to true on the
// record object representing the grid summary row.
// @visibility external
//<
gridSummaryRecordProperty:"isGridSummary",

//> @attr listGridRecord.isGridSummary (Boolean : null : IRW)
// This attribute will automatically be set to true for the record representing the
// grid-level summary row shown if +link{listGrid.showGridSummary} is true.
// <P>
// Note that <code>isGridSummary</code> is the default property name for this attribute but
// it may be modified by setting +link{listGrid.gridSummaryRecordProperty}
// @visibility external
//<

//> @attr listGrid.groupSummaryRecordProperty (String : "isGroupSummary" : IRW)
// If +link{listGrid.showGroupSummary} is true, this attribute will be set to true on each
// record object representing a group-level summary row.
// @visibility external
//<
groupSummaryRecordProperty:"isGroupSummary",

//> @attr listGridRecord.isGroupSummary (Boolean : null : IRW)
// This attribute will automatically be set to true for records representing
// group-level summary rows shown if +link{listGrid.showGroupSummary} is true.
// <P>
// Note that <code>isGroupSummary</code> is the default property name for this attribute but
// it may be modified by setting +link{listGrid.groupSummaryRecordProperty}
// @visibility external
//<

// recordApplyPluralTitleProperty
// This property may be set to an array of field-names on a record.
// If set, for each field listed, default formatting logic will apply a space, plus the
// plural title for the field (if present, otherwise the standard title).
//
// Has no effect if there is a custom formatter at the grid or field level.
//
// Used to allow us to append the plural title to field values derived from the
// "count" summary function.

recordApplyPluralTitleProperty: "applyPluralTitle",

//> @method listGrid.setShowGridSummary()
// Setter for the +link{listGrid.showGridSummary} attribute
// @param showGridSummary (boolean) new value for this.showGridSummary
// @visibility external
//<
setShowGridSummary : function (showGridSummary) {
    if (this.showGridSummary == showGridSummary) return;
    this.showGridSummary = showGridSummary;
    if (this.showGridSummary) {
        this.showSummaryRow();
    } else {
        this.clearSummaryRow();
    }
},

_getFieldDependencyTable : function () {
    
    if (this._fieldDependencyTable == null) {
        this.Super("_getFieldDependencyTable");

        var fields = this.fields,
            dependencyTable = this._fieldDependencyTable,
            summaryFields = fields.filter(function (field) { return field.type == "summary";});

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i],
                include = field.includeInRecordSummary;
            if (include == true || include != false && 
                (field.type == "integer" || field.type == "float"))
            {
                if (dependencyTable[field.name] == null) {
                    dependencyTable[field.name] = {};
                }
                var localSummaryFields = field.includeInRecordSummaryFields || summaryFields;
                for (var j = 0; j < localSummaryFields.length; j++) {
                    var summaryField = localSummaryFields[j];
                    if (isc.isA.String(summaryField)) {
                        summaryField = this.getField(summaryField);
                    }
                    dependencyTable[field.name][summaryField.name] = summaryField;
                }
            }
        }
    }
    return this._fieldDependencyTable;
},

//> @method listGrid.recalculateSummaries()
// Recalculates values for fields with
// +link{listGridField.recordSummaryFunction, summary-functions} or 
// +link{listGridField.userFormula, user formulae} defined and for values
// displayed in the +link{listGrid.showGridSummary,grid summary} and
// +link{listGrid.showGroupSummary,group summary rows}.
// @param [records] (Array of Record) Optional array of records to recalculate summaries for,
//                  or null for all records
// @param [fields] (Array of ListGridField) Optional array of fields to recalculate summaries
//                 for, or null for all fields
// <P>
// Note that the records should be from +link{listGrid.data}; thus, if the grid is grouped,
//  the records should be from the grouped data rather than +link{listGrid.originalData}.
// @visibility external
//<
recalculateSummaries : function (records, fields, suppressRedraw) {
    suppressRedraw = suppressRedraw != null ? suppressRedraw : true;
    this.calculateRecordSummaries(records, fields, true, true, suppressRedraw);
},

_recalculateSummaries : function (records, fields, calculateGroupRows, calculateSummaryRows, 
                                  redrawSummaryRow) 
{
    if (this.isGrouped          && this.showGroupSummary  && calculateGroupRows != false) {
        this.refreshGroupSummary(records, fields);
    }
    if (this.summaryRow != null && this.showGridSummary && calculateSummaryRows != false) {
        if (redrawSummaryRow && !this.isDirty()) this.markForRedraw();
        this.summaryRow._recalculateSummaries(fields);
    }
    if (this.summaryRow && this.hideEmptySummaryRow) {
        if (this.summaryRow.data && this.summaryRow.data.length > 0) {
            if (!this.summaryRow.isVisible()) {
                this.summaryRow.show();
            }
        } else {
            if (this.summaryRow.isVisible()) {
                this.summaryRow.hide();
            }
        }
    }
},

//> @method listGrid.recalculateGridSummary()
// Refresh the +link{listGrid.showGridSummary,grid summary}, by either re-calculating from
// already-loaded data or doing a new fetch from the +link{summaryRowDataSource}.
// <P>
// Note unlike +link{listGrid.recalculateSummaries()}, this method will not force a refresh of
// field-level summaries (see +link{listGridField.recordSummaryFunction}) or group level
// summaries (see +link{listGrid.showGroupSummary}).
// @visibility external
//<
recalculateGridSummary : function () {
    if (this.showGridSummary && this.summaryRow != null) {
        this.summaryRow._recalculateSummaries();
    }
},

// shouldShowGridSummary() - determines whether a field should show a grid summary
// If field.showGridSummary is specified, respect it, otherwise check for
// the presence of a field level summaryFunction, or a default summaryFunction for the field type
// NOTE: If a developer overrides getGridSummaryData(), this method does not reflect desired
// behavior - we actually want to show the value for all fields for which there are values,
// unless "showGridSummary" was explicitly set to false at the field level.
// (We don't want to check for the presence of a gridSummaryFunction for the field).

shouldShowGridSummary : function (field) {
    if (field.showGridSummary != null) return field.showGridSummary;
    return (field.getGridSummary != null || this.getGridSummaryFunction(field) != null)
},

//> @method listGrid.getGridSummaryFunction() [A]
// Determines the +link{type:SummaryFunction} to use when calculating per-field summary values
// describing multiple records in this grid.
// Used to determine the summary function to use for both +link{listGrid.showGridSummary} and
// +link{listGrid.showGroupSummary}.
// <P>
// Default implementation picks up +link{listGridField.summaryFunction} if explicitly specified,
// otherwise checks for a default summary function based on field type (see
// +link{SimpleType.setDefaultSummaryFunction()}).  Note that a default summary function will
// not be supplied if the field represents a +link{DataSourceField.primaryKey,primaryKey} or
// +link{DataSourceField.foreignKey,foreignKey}, since it would likely not be meaningful.
// @param field (ListGridField) field to check for summary function
// @return (SummaryFunction) summary function for the field in question
// @visibility external
//<

getGridSummaryFunction : function (field) {
    if (!field) return;
    // If an explicit summaryFunction is specified, pick it up.  Otherwise, if the field
    // isn't a primary or foreign key, then pick up the default based on the field type.
    var summaryFunction = field.summaryFunction;
    if (!summaryFunction && !field.primaryKey && !field.foreignKey) {
        summaryFunction = isc.SimpleType.getDefaultSummaryFunction(field.type);
    }
    return summaryFunction;
},

//> @method listGrid.getGridSummary() [A]
// When +link{listGrid.showGridSummary} is <code>true</code> this method is called for each field
// which will show a grid summary value (as described in +link{ListGridField.showGridSummary})
// to get the summary value to display below the relevant column.
// <P>
// The default implementation is as follows:
// <ul><li>If this is a databound grid and not all data is loaded, returns null for every field</li>
//     <li>Otherwise if +link{ListGridField.getGridSummary()} is defined, calls that method passing
//         in the current data set for the grid</li>
//     <li>If +link{ListGridField.getGridSummary()} is undefined, makes use of the
//          +link{listGrid.getGridSummaryFunction(),standard summary function} for the field to
//          calculate the summary based on the current data set</li>
// </ul>
// This method may return an array of values. This implies that the grid summary should show
// multiple rows. Note that if a field has more than one summaryFunction specified, this method
// will pick up values from each summary function and return them in an array, meaning
// these summaries will show up on multiple rows in the grid.
// <P>
// This method may be overridden to completely customize the summary value displayed for
// columns in this grid. An example use case would be when summary information is available on
// the client and does not need to be calculated directly from the data.
// <P>
// If you update this method after the grid has been drawn so that new summaries will be
// generated from the same data, the changes won't be reflected in any +link{redraw(),redraws}
// or other interaction until the next +link{dataChanged(),data change}, unless you call
// +link{recalculateGridSummary()}.
// <P>
// <b>Note:</b> this method will not be called if +link{listGrid.summaryRowDataSource} is
// specified.
//
// @param field (ListGridField) field for which the summary value should be returned
// @return (Any) summary value to display for the specified field.
// @visibility external
//<
getGridSummary : function (field) {

    if (!field || !this.data || (isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown()))
        return;
    var data = this.getOriginalData(),
        isRS = isc.ResultSet && isc.isA.ResultSet(data),
        isTree = isc.isA.Tree(data);

    if (isTree) {
        data = data.getDescendants(data.getRoot());
        isRS = isc.ResultSet && isc.isA.ResultSet(data);
    }

    if (isRS && !data.allMatchingRowsCached()) {
        this.logWarn("Unable to show summary values - dataset not completely loaded");
        return;
    }

    var localData = isRS ? data.getRange(0, data.getLength()) : data;

    // If we have outstanding / unsaved edits, we want to use those in our calculations
    var editRows = this.getAllEditRows();
    if (editRows != null && editRows.length > 0) {
        // ensure we don't stomp on our live data array!
        localData = localData.duplicate();
        
        for (var i = 0; i < localData.length; i++) {
            var record = localData[i];
            var rowNum = this.getEditSessionRowNum(record);
            if (rowNum != null) localData[i] = this.getEditedRecord(rowNum, null, true);
        }
        
        var totalRows = this.data.getLength();
        for (var i = 0; i < editRows.length; i++) {
            var rowNum = editRows[i];
            if (rowNum >= totalRows) {
                localData.add(this.getEditedRecord(rowNum, null, true));
            }
        }
    }

    // getGridSummary() is an override point on a listGridField which allows the developer to
    // calculate a grid summary based on the group summaries already calculated for the grid.
    // It takes an additional param -- an array of 'groupSummary' objects.
    // groupSummary contains
    // - groupName and groupValue to identify which group it belongs to
    // - for each field in the grid, the summary value for the records in the group.
    
    if (field.getGridSummary) {
        var groupSummaries;
        if (this.isGrouped && this.showGroupSummary && (this.groupTree != null)) {
            groupSummaries = this.assembleGroupSummaries();
        }
        return field.getGridSummary(localData, field, groupSummaries);
    }

    return this.getSummaryValue(localData, field);
},

//> @attr listGrid.summaryRowDataSource (DataSource : null : IRA)
// If +link{listGrid.showGridSummary} is true, by default summary values are calculated on the
// client based on the current data-set for the grid (see +link{ListGrid.getGridSummary()} and
// +link{ListGrid.getGridSummaryFunction()}).
// <P>
// In some cases however it may make sense to calculate summary values on the server and retrieve
// them via a dataSource fetch. If set, this property specifies a dataSource to fetch against for
// the summary row. The dataSource should return a single record with summary data for each
// field for which summary data should be shown. Note that specifying this property completely
// bypasses the standard client-side grid summary calculation logic.
// <P>
// The fetch may be further customized via +link{listGrid.summaryRowCriteria} and
// +link{listGrid.summaryRowFetchRequestProperties}
// @visibility external
//<
// summaryRowDataSource:null,
getSummaryRowDataSource : function () {
    return this.summaryRowDataSource;
},

//> @attr listGrid.summaryRowCriteria (Criteria : null : IRWA)
// If +link{listGrid.showGridSummary} is true, and a +link{listGrid.summaryRowDataSource} is
// specified this property may be used to specify fetch criteria to apply when retrieving
// summary data to show in the summary row. If unset, and any filter criteria have been
// specified for the grid, they will be used.
// <p>
// If this property is set, the +link{dsRequest.textMatchStyle,textMatchStyle} will default to
// "exact".  Otherwise +link{listGrid.autoFetchTextMatchStyle} will be used.  This can be
// overridden via +link{listGrid.summaryRowFetchRequestProperties}.
//
// @visibility external
//<
// summaryRowCriteria:null,
getSummaryRowCriteria : function () {
    if (this.summaryRowCriteria != null) return this.summaryRowCriteria;
    var data = this.getOriginalData();
    if (isc.ResultSet && isc.isA.ResultSet(data)) {
        return this.data.getCriteria();
    }
    return this.getInitialCriteria();
},
setSummaryRowCriteria : function (criteria) {
    this.summaryRowCriteria = criteria;
    
    if (this.dataSource) this.invalidateCache();
},

//> @attr listGrid.canSelectSummaryRows (boolean : false : IRA) 
// Whether to allow selection of the summary row, for example by clicking on the record.  The
// default is to disallow it.
// <p>
// If this property is set, further customization of selection can be made by applying the
// appropriate selection-related properties to the autochild via
// +link{listGrid.summaryRow,summaryRowProperties}.  The request to fetch the summary row(s)
// can be customized via +link{listGrid.summaryRowFetchRequestProperties}.
//
// @visibility external
//<

//> @attr listGrid.summaryRowFetchRequestProperties (DSRequest Properties : null : IRWA)
// If +link{listGrid.showGridSummary} is true, and a +link{listGrid.summaryRowDataSource} is specified
// this property may be used to customize the fetch request used when retrieving summary data
// to show in the summary row. An example use case might be specifying a
// +link{DSRequest.operationId} to perform a custom fetch operation which retrieved only summary
// values based on criteria.
// <p>
// By default, only the first +link{summaryRowCriteria,criteria} match is returned if the
// criteria matches multiple records.
//
// @see dsRequest.startRow
// @see dsRequest.endRow
// @visibility external
//<
//summaryRowFetchRequestProperties:null,
getSummaryRowFetchRequestConfig : function () {
    return isc.addProperties({
        textMatchStyle: this.summaryRowCriteria != null ? "exact" :
                            this.autoFetchTextMatchStyle,
        showPrompt: false, startRow: 0, endRow: 1
    },
    this.summaryRowFetchRequestDefaults,
    this.summaryRowFetchRequestProperties);
},

summaryRowFetchComplete : function (response, data, request) {

    this.updateFieldWidthsForAutoFitValue("gridSummary fetch complete");
    
    this._updateFieldWidths();

},

//> @method listGrid.getGridSummaryData()
// This method returns the data <smartclient>to be</smartclient> displayed in the 
// +link{summaryRow} when +link{showGridSummary} is true.
// <P>
// By default this will call +link{getGridSummary} for each field and generate an array of records
// containing the resulting values.
// <P>
// This method <smartclient>may be overridden for custom grid-summary display, and</smartclient> 
// may return multiple records if more than one summary row is desired.
//
// @return (Array of ListGridRecord) summary record(s)
// @visibility external
//<
getGridSummaryData : function (recalculate, fields) {

    if (this._gridSummaryData && !recalculate) return this._gridSummaryData;

    
    var data;
    if (this._gridSummaryData && fields != null) {
        data = this._gridSummaryData;
    } else {
        fields = this.skipHiddenGridSummaryFields ? this.fields : this.getAllFields();
        data = [];
        if (fields == null) return data;
    }
    
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i],
            attribName = field.type != this._$summary ? field.name :
                this._getRecordSummaryAttributeProperty(field)
        ;
        if (!this.shouldShowGridSummary(field)) {
             continue;
         }

        var values = this.getGridSummary(field),
            summaryFunc = this.getGridSummaryFunction(field);
        if (!isc.isAn.Array(summaryFunc)) summaryFunc = [summaryFunc];
        // getGridSummary returns either an atomic value or an array. If an array is returned
        // we map this to multiple records - this is how multiple summary functions give us
        // a multi-line result in the grid-summary.
        
        if (!isc.isAn.Array(values)) {
            values = [values]
        }
        for (var ii = 0; ii < values.length; ii++) {
            if (data[ii] == null) {
                data[ii] = {};
                // This property is used to allow summary fields to suspend the standard
                // summary from data in this record [so a standard 'grid summary' type sum etc can
                // be performed against the live grid data].
                data[ii][this.gridSummaryRecordProperty] = true;
                // this prevents the checkbox select column from showing a checkbox
                // for the summary row
                
                data[ii][this.recordCanSelectProperty] = false;

                // If this record came from a "count" summary function, set the
                // recordApplyPluralTitleProperty flag on the record.
                
                if (summaryFunc[ii] == "count") {
                    var array = data[ii][this.recordApplyPluralTitleProperty] || [];
                    array.add(field.name);
                    data[ii][this.recordApplyPluralTitleProperty] = array;
                }

            }
            data[ii][attribName] = values[ii];
        }
    }
    this._gridSummaryData = data;
    return data;
},

//> @method listGrid.getGroupSummaryData()
// If this grid is +link{listGrid.groupByField,grouped}, and +link{showGroupSummary} is true,
// this method will <smartclient>be called for each group to</smartclient> return the
//  group summary data <smartclient>to display</smartclient><smartgwt>displayed</smartgwt>
//  at the end of the group.
// <P><smartclient>
// By default this will call +link{listGridField.getGroupSummary} if defined for each field and
// generate an array of records containing the resulting values. If no explicit per-field
// getGroupSummary method is present, this method will fall back to calling the appropriate
// +link{listGridField.summaryFunction}.
// <P></smartclient>
// This method may <smartclient>be overridden for custom group-summary display, and
// may</smartclient> return multiple records if more than one summary row per group is desired.
//
// @param records (Array of Record) the records in the group, for which the summary values
//                                  are being calculated
// @param groupNode (Record) object with specified groupValue and groupName for this group
// @param [recalculate] (Boolean) if set to false and the node has existing summary data, 
//                                returns the stored summary data, rather than recalculating
//
// @return (Array of ListGridRecord) summary record(s)
// @visibility external
//<

getGroupSummaryData : function (records, groupNode, recalculate, fields) {
    return this._getGroupSummaryData(
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        this.groupSummaryRecordProperty, null, records, groupNode, fields, recalculate);
},
_getGroupSummaryData : function (
    includeInSummaryProperty, applyFormulaAfterSummary, groupSummaryRecordProperty,
    fieldsHaveUserFormulas, records, groupNode, fields, recalculate)
{
    // If `getGroupSummaryData()` is overridden by the user then we have to call it.
    if (this.getGroupSummaryData != isc.ListGrid.getInstanceProperty("getGroupSummaryData")) {
        return this.getGroupSummaryData(records, groupNode, recalculate, fields);
    }

    var summaryData;
    if (groupNode && groupNode._groupSummaryData && (fields != null || recalculate == false)) {
        if (recalculate == false) return groupNode._groupSummaryData;
        summaryData = groupNode._groupSummaryData;
    } else {
        fields = this.skipHiddenGroupSummaryFields ? this.fields : this.getAllFields();
        summaryData = [];
        if (fields == null) return summaryData;
    }

    for (var i = 0; i < fields.getLength(); i++) {
        var field = fields[i],
            attribName = field.type != this._$summary ? field.name :
                this._getRecordSummaryAttributeProperty(field),
            summaryValue;
        if (this.shouldShowGroupSummary(field)) {
            var fieldHasUserFormula = (
                    fieldsHaveUserFormulas == null ?
                        (field && field.userFormula != null) :
                        fieldsHaveUserFormulas[i]);
            summaryValue = this._getGroupSummary(
                includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula,
                records, field, groupNode);

            // handle being passed an atomic value or an array. If an array
            // is returned we show multiple summary rows.
            if (!isc.isAn.Array(summaryValue)) summaryValue = [summaryValue];

            var summaryFunc = this.getGridSummaryFunction(field);
            if (!isc.isAn.Array(summaryFunc)) summaryFunc = [summaryFunc];

            for (var ii = 0; ii < summaryValue.length; ii++) {
                var summaryRecord = summaryData[ii];
                if (summaryRecord == null) {
                    summaryRecord = summaryData[ii] = {};

                    summaryRecord.customStyle = this.groupSummaryStyle;
                    // mark as disabled so we don't respond to clicks / attempts to select etc.
                    // should have no effect on styling since customStyle is static
                    summaryRecord[this.recordEnabledProperty] = false;
                    // don't include this record in the overall grid summary row!
                    summaryRecord[includeInSummaryProperty] = false;

                    // flag the record as a groupSummary record
                    // This allows custom record summary functions to treat it
                    // differently if necessary
                    summaryRecord[groupSummaryRecordProperty] = true;

                    // If this record came from a "count" summary function, set the
                    // recordApplyPluralTitleProperty flag on the record.
                    
                    if (summaryFunc[ii] == "count") {
                        var array = summaryRecord[this.recordApplyPluralTitleProperty] || [];
                        array.add(field.name);
                        summaryRecord[this.recordApplyPluralTitleProperty] = array;
                    }
                }
                var currentVal = summaryValue[ii];
                summaryRecord[attribName] = currentVal;
            }
        }
    }
    if (groupNode) groupNode._groupSummaryData = summaryData;
    return summaryData;
},

//> @object GroupSummary
// Group Summary.
//
// @treeLocation Client Reference/Grids/ListGrid
//@visibility external
//<

//> @attr groupSummary.groupName        (String : null : IRW)
//<
//> @attr groupSummary.groupValue       (String : null : IRW)
//<
//> @attr groupSummary.customStyle      (String : null : IRW)
//<

// This method is called to put together the group level summary values and pass them
// to the getGridSummary method, so developers can look at the summaries, rather than
// necessarily calculating grid summaries based on every data record.
assembleGroupSummaries : function (node, summaries) {
    var tree = this.groupTree;
    if (!node) node = tree.getRoot();
    if (!summaries) summaries = [];

    var folders = tree.getFolders(node);
    for (var i = 0; i < folders.length; i++) {
        var headerNode = folders[i];

        if (this.groupByFieldSummaries == null ||
            this.groupByFieldSummaries.contains(headerNode.groupName))
        {

            var summaryRecords = tree.combineWithEditVals(tree.getRecordsInGroup(headerNode));
            var summaryData = this.getGroupSummaryData(summaryRecords, headerNode);

            for (var ii = 0; ii < summaryData.length; ii++) {
                var groupSummary = isc.addProperties({},summaryData[ii]);
                delete groupSummary.customStyle;
                delete groupSummary[this.recordEnabledProperty];
                delete groupSummary[this.includeInSummaryProperty];
                groupSummary.groupName = headerNode.groupName;
                groupSummary.groupValue = headerNode.groupValue;

                summaries.add(groupSummary);
            }
        }

        // make this recursive
        this.assembleGroupSummaries(folders[i], summaries);
    }
    return summaries;

},

// getSummaryValue() - generic handler to take a bunch of records and a field definition and
// return the summary value from them. Used for both grid level summaries and group-level summaries
getSummaryValue : function (records, field) {
    return this._getSummaryValue(
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        (field && field.userFormula != null), records, field);
},
_getSummaryValue : function (
    includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula, records, field)
{
    if (records == null) return null;
    
    // pull out any records where includeInSummary is false
    var includedRecords = [];
    for (var i = 0; i < records.length; i++) {
        var record = records[i];
        if (!record || (record[includeInSummaryProperty] == false)) continue;
        includedRecords[includedRecords.length] = record;
    }

    var summaryFunction = this.getGridSummaryFunction(field);
    if (summaryFunction == null) return null;

    
    if (this._shouldApplyUserFormulaAfterSummary(
            applyFormulaAfterSummary, fieldHasUserFormula, field))
    {
        return [];
    }

    if (!isc.isAn.Array(summaryFunction)) {
        summaryFunction = [summaryFunction]
    }
    var results = [];
    for (var i = 0; i < summaryFunction.length; i++) {

        var currentFunction = summaryFunction[i];
        if (currentFunction != null) {
            
            results[i] = isc.SimpleType.applySummaryFunction(includedRecords, field, 
                                                             currentFunction, this, this);
        }
    }
    return results;
},


shouldShowGroupSummary : function (field) {
    if (field.showGroupSummary != null) return field.showGroupSummary;
    return (field.getGroupSummary != null || this.getGridSummaryFunction(field) != null)
},


getGroupSummary : function (records, field, groupNode) {
    return this._getGroupSummary(
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        (field && field.userFormula != null), records, field, groupNode);
},
_getGroupSummary : function (
    includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula, records, field, groupNode)
{
    var summaryValue;
    if (field.getGroupSummary != null) {
        summaryValue = field.getGroupSummary(records, field, groupNode);
    } else {
        summaryValue = this._getSummaryValue(
            includeInSummaryProperty, applyFormulaAfterSummary, fieldHasUserFormula,
            records, field);
    }
    return summaryValue;
},

//> @method listGrid.getRecordSummary() [A]
// Provides access to the summary (see +link{listGridFieldType,summary-type} fields)
// value of the record for other fields when called from inside the body of
// +link{listGridField.getRecordSummary()} (since they're not available directly off
// the record).  The behavior is unspecified if not called from inside the
// +link{listGridField.getRecordSummary()} method.
// <P>
// @param record (ListGridRecord) record for which a summary is being generated
// @param field (ListGridField | int | ID) field, or its number or id
// @return (Any) summary value to display
// @visibility external
//<

getRecordSummary : function (recordNum, summaryField) {
    // allow the summary-type field to be specified by field position or name
    if (!isc.isAn.Object(summaryField)) summaryField = this.getField(summaryField);
    return this._getRecordSummary(null, null, recordNum, summaryField);
},
_getRecordSummary : function (fieldsHaveUserFormulas, fieldsHaveUserSummaries, recordNum, summaryField) {
    // we want to use edit vals when calculating totals
    var record = isc.isAn.Object(recordNum) ? recordNum : this.getEditedRecord(recordNum);

    // override point for a completely custom method based on the record without looking at other
    // fields, etc
    if (summaryField.getRecordSummary != null) {
        return summaryField.getRecordSummary(record, summaryField, this);
    }

    var fieldsToInclude = [],
        fields = this.fields;

    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];

        // should a field be included in this summary calculation?

        // Never include a field in its own calculation!
        if (field.name == summaryField.name) {
            // partial summary - only include fields up to this one (index < this field's index)
            if (summaryField.partialSummary) break;
            continue;
        }

        var shouldInclude = field.includeInRecordSummary;

        // If 'includeInRecordSummary' is unset, default to including numeric non summary fields
        
        var hasUserFormula = (
                fieldsHaveUserFormulas == null ?
                    (field && field.userFormula != null) : fieldsHaveUserFormulas[i]),
            hasUserSummary = (
                fieldsHaveUserSummaries == null ?
                    (field && field.userSummary != null) : fieldsHaveUserSummaries[i]);
        if (shouldInclude == null && (field.type == "integer" || field.type == "float")
            
            && (!hasUserFormula && !hasUserSummary))
        {
            shouldInclude = true;
        }

        // if 'includeInRecordSummaryFields' is explicitly set, respect it as well
        if (shouldInclude && field.includeInRecordSummaryFields != null) {
            if ((isc.isA.String(field.includeInRecordSummaryFields) &&
                     field.includeInRecordSummaryFields != summaryField.name) ||
                (isc.isAn.Array(field.includeInRecordSummaryFields) &&
                     !field.includeInRecordSummaryFields.contains(summaryField.name)))
            {
                shouldInclude = false;
            }
        }
        if (shouldInclude) {
            fieldsToInclude.add(field);
        }
    }
    var summaryFunction = summaryField.recordSummaryFunction || "sum";
    var value = isc.DataSource.applyRecordSummaryFunction(summaryFunction, record,
                                            fieldsToInclude, summaryField);
    return value;
},

// Handle formula fields the same way we handle summary fields with the added wrinkle
// that the developer can allow formula functions to apply across summary rows
shouldApplyUserFormulaBeforeSummary : function (field) {
    return field && field.userFormula != null && !this._applyFieldFormulaAfterSummary(field);
},
shouldApplyUserFormulaAfterSummary : function (field) {
    return this._shouldApplyUserFormulaAfterSummary(
        this.applyFormulaAfterSummary, (field && field.userFormula != null), field);
},
_shouldApplyUserFormulaAfterSummary : function (applyFormulaAfterSummary, fieldHasUserFormula, field) {
    return (
        fieldHasUserFormula &&
        this.__applyFieldFormulaAfterSummary(applyFormulaAfterSummary, field));
},


calculateRecordSummaries : function (records, fields, updateGroupSummaries, 
    updateGridSummaries, suppressDisplay, suppressApplyToRecords, keepUserCache)
{
    var fieldsToUpdate = this.skipHiddenUserSummaryFields ? this.fields : this.getAllFields();

    if (fields != null) {
        var grid = this;
        if (!isc.isAn.Array(fields)) fields = [fields];

        // translate field names to fields
        var resolvedFields = [];
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            if (isc.isA.String(field)) {
                field = this.getField(field);
            }
            if (field) resolvedFields.add(field);
        }
        fields = resolvedFields;

        // expand to all dependent fields if configured
        if (this.refreshDependentFieldsForSummaries) {
            fields = this._addDependentUserFields(fields);
        }
        fieldsToUpdate = fields;
    }

    // support records being a row number into this.data
    
    if (isc.isA.Number(records)) {
        var rowNum = records;
        if (this.data.getLength() > rowNum) {
            records = this.data.get(rowNum);
        } else {
            records = this._getEditValues(rowNum);
            updateGroupSummaries = false;
        }
    }

    // clear cache for specified records/fields to ensure recalculation
    if (!keepUserCache) this.invalidateUserCache(records, fields);

    // nothing to do if there are no fields to update
    if (!fieldsToUpdate) return;

    if (records != null && !isc.isAn.Array(records)) records = [records];
    var recordsToUpdate = records == null ? this.getOriginalData() : records;
    if (recordsToUpdate == null || 
        isc.isA.ResultSet(recordsToUpdate) && !recordsToUpdate.lengthIsKnown())
    {
        return;
    }

    var valuesChanged = false;

    if (!suppressApplyToRecords) {
        var summaryFields     = [],
            userFormulaFields = [];

        for (var i = 0; i < fieldsToUpdate.length; i++) {
            var field = fieldsToUpdate[i];
            
            if (field && field.type == this._$summary) {
                summaryFields.add(field);
            } else if (this.shouldApplyUserFormulaBeforeSummary(field)) {
                userFormulaFields.add(field);
            }
        }

        if (summaryFields.length > 0 || userFormulaFields.length > 0) {
            for (var i = 0; i < recordsToUpdate.getLength(); i++) {

                var record =          isc.isA.ResultSet (recordsToUpdate) || 
                    isc.ResultTree && isc.isA.ResultTree(recordsToUpdate) ? 
                    recordsToUpdate.getCachedRow(i) : recordsToUpdate.get(i);
                if (record == null) continue;

                var editVals = this.getEditValues(record),
                    hasEditVals = !isc.isAn.emptyObject(editVals),
                    editedRecord = hasEditVals ? isc.addProperties({_noCache: true}, record,
                                                                   editVals) : record;
                if (record == null) continue;
                
                for (var ii = 0; ii < summaryFields.length; ii++) {

                    var field = summaryFields[ii];

                    // Verify that we actually want to show a record summary value in
                    // this cell.
                    // This method will return false for the case where this is a summary row
                    // and we want to (for example) sum the calculated record summary shown in
                    // this column for all rows in the grid, rather than trying to perform
                    // record-summary arithmetic on the summary row itself.
                    if (!this.shouldShowRecordSummary(field, record)) {
                        continue;
                    }

                    // save the old value, write the new value, and compare them
                    var attribName = this._getRecordSummaryAttributeProperty(field),
                        oldValue = record[attribName]
                    ;
                    var summaryVal = this.getRecordSummary(editedRecord, field);
                    record[attribName] = summaryVal;

                    if (!this.fieldValuesAreEqual(field, oldValue, summaryVal)) {
                        valuesChanged = true;
                    }
                }
                for (var ii = 0; ii < userFormulaFields.length; ii++) {

                    var field = userFormulaFields[ii];
                    // Skip records where we suppress the formula (EG group summary rows)
                    if (!this.shouldShowUserFormula(field,record)) {
                        continue;
                    }

                    var oldValue = record[field.name],
                        newValue = this.getFormulaFieldValue(field, editedRecord);

                    if (!this.fieldValuesAreEqual(field, oldValue, newValue)) {
                        
                        if (hasEditVals) {
                            this.invalidateUserCache(record, [field]);
                            record[field.name] = newValue;
                        }
                        valuesChanged = true;
                    }
                }
            }
        }
    }

    // if we're showing neither group nor grid summaries we can bail here since the
    // remaining code below is strictly dealing with group and grid summary rows.
    if ((!this.isGrouped         || !this.showGroupSummary) && 
        (this.summaryRow == null || !this.showGridSummary))
    {
        return;
    }

    
    this._recalculateSummaries(records, fields,
        updateGroupSummaries != null ? updateGroupSummaries : valuesChanged,
        updateGridSummaries  != null ? updateGridSummaries  : valuesChanged, !suppressDisplay);
},


// Standard field level summary functions.
// These allow a developer to specify a field of type "summary" with summaryFunction "sum" rather
// than re-implementing the sum method on their field.
// It's basically the same list as the SimpleType registered summary functions but it
// takes different parameters - A single record and multiple fields rather than vice versa


//> @attr listGrid.recordSummaryBaseStyle (CSSStyleName : "recordSummaryCell" : IRWA)
// If showing any record summary fields (IE: fields of +link{listGridFieldType,type:"summary"}),
// this attribute specifies a custom base style to apply to cells in the summary field
// @visibility external
//<
recordSummaryBaseStyle:"recordSummaryCell",

//> @attr listGrid.summaryRow (AutoChild ListGrid : null : RA)
// Automatically generated ListGrid for displaying grid summary information (see
// +link{listGrid.showGridSummary}).
// <P>
// This component is an +link{type:AutoChild} and as such may be customized 
// <smartclient>via
// <code>listGrid.summaryRowProperties</code> and <code>listGrid.summaryRowDefaults</code>.
// </smartclient>
// <smartgwt>by calling <code>setAutoChildProperties("summaryRow", summaryRowProperties);</code>
// where <code>summaryRowProperties</code> is a ListGrid instance with the desired customizations.
// </smartgwt>
// @visibility external
//<
summaryRowConstructor:"ListGrid",

summaryRowDefaults:{
    // disable rollOver styling
    showRollOver:false,

    contributeToRuleContext: false
},


//> @attr listGrid.summaryRowHeight (int : 20 : IR)
// Default height for the +link{listGrid.summaryRow,summary row autoChild}. Note that this
// height is a minimum - the summary row has +link{listGrid.autoFitData} set to "vertical" so
// if multiple rows are visible in the grid summary, the summaryRow component
// will expand to accommodate them.
//
// @visibility external
//<
summaryRowHeight:20,

//> @attr listGrid.summaryRowStyle (CSSStyleName : "gridSummaryCell" : IRWA)
// +link{listGrid.baseStyle} for the +link{listGrid.summaryRow}
// @visibility external
//<
summaryRowStyle:"gridSummaryCell",

//> @attr listGrid.hideEmptySummaryRow (Boolean : null : IRW)
// If true, causes the +link{listGrid.summaryRow,summaryRow} component to be hidden if it has
// no data after summaries have been recalculated
// @visibility external
//<

// creates (or updates) and returns the summaryRow autoChild.
// not called directly -- call 'setShowGridSummary' instead
getSummaryRow : function (forAutoFitData) {

    if (!this.summaryRow) {

        var dataSource = this.getSummaryRowDataSource();

        var initialFields;
        if (this.completeFields) initialFields = this.completeFields.duplicate();
        else if (this.fields) initialFields = this.fields.duplicate();
        // We respond to setFields(), setFieldWidths(), showField(), hideField() etc explicitly
        // in those methods so don't worry if initialFields is null - it'll get set when required
        var height = this.summaryRowHeight;
        this.summaryRow = this.createAutoChild("summaryRow", {
        
            showEmptyMessage:false,

            warnOnReusedFields:false,
            autoDraw:false,

            width:"100%",
            height:height,
            minHeight: null,

            
            dataProperties: {
                useClientFiltering: false
            },

            selectionType: this.canSelectSummaryRows ? null : isc.Selection.NONE,

            
            dataFetchMode: this.dataFetchMode == "local" ? "local" : "basic",

            autoFitData:"vertical",
            // autoFitMaxRows etc can be specified in summaryRowProperties if desired.

            // setting bodyOverflow to hidden.
            // If we don't do this and field widths exceed grid size, we end up with
            // hscrollbars on both the listGrid and the summary row.
            
            
            bodyOverflow:"hidden",

            showHeader:false,

            getBaseStyle:function() {return this.creator.summaryRowStyle},
            alternateRecordStyles:false,

            disabled:this.disabled,
            applyFormulaAfterSummary: this.applyFormulaAfterSummary,

            // Make fetchValueMapData into a no-op. We copy our fields from
            // our creator so any optionDataSources will match up meaning we can rely on
            // the creator's fetchValueMapData / 'setValueMap()' to update our valueMap
            // rather than having to do a second fetch against optionDataSources
            _fetchValueMapData : function () {
            },

            // The default summary functions all return number or string values, even if field.type
            // is boolean. If this method returns true we'll always display a checkbox rather than
            // the expected summary value.
            
            _formatBooleanFieldAsImages : function (field) {
                return false;
            },

            // support for databinding of summary row
            dataSource:dataSource,
            // pick up data from the gridSummaryData method
            data:dataSource == null ? this.getGridSummaryData() : null,

            _recalculateSummaries : function (records, fields) {
                
                var grid = this.creator,
                    data = grid.data
                ;
                // prevent the summaryRow from fetching before the parent grid - it will fetch
                // again when the parent is ready
                if (!grid.fields || (isc.isA.ResultSet(data) && !data.lengthIsKnown())) return;

                // if we are getting data from a dataSource, simply re-fetch
                if (this.dataSource != null) {
                    var summaryRow = this;
                    this.fetchData(
                        grid.getSummaryRowCriteria(),
                        function () {
                            grid.summaryRowFetchComplete();
                            summaryRow._provideSummaryToRuleContext();
                        },
                        grid.getSummaryRowFetchRequestConfig()
                    );
                } else {
                    this.setData(grid.getGridSummaryData(true, fields));
                    this._provideSummaryToRuleContext();
                }
            },

            _provideSummaryToRuleContext : function () {
                var grid = this.creator,
                    summaryData = this.data
                ;
                if (!grid.hasStableLocalID() && grid.editNode == null) return;
                var path = grid.getLocalId() + ".summaryRecord",
                    summaryRecord = summaryData && (isc.isA.ResultSet(summaryData) ?
                                        summaryData.get(0) :
                                        summaryData.length > 0 && summaryData[0])
                ;
                grid.provideRuleContext(path, summaryRecord, grid);
            },

            fieldSourceGrid:this,
            fields:initialFields,

            // Copy formatting related properties across so _formatCellValue
            // behaves correctly
            
            recordApplyPluralTitleProperty:this.recordApplyPluralTitleProperty,
            gridSummaryRecordProperty:this.gridSummaryRecordProperty,
            invalidSummaryValue:this.invalidSummaryValue,
            emptyCellValue:this.emptyCellValue,


            // We size fields according to the main grid field-widths.
            
            skipAutoFitWidths:true,
            getFieldWidths : function () {
                return this.creator.getFieldWidths();
            },

            // We have our fields assigned from the source grid - If 'showIf' is set, evaluate it
            // on the source grid, not on this grid.
            // This ensures that the "list" param passed to that method refers to the correct grid
            
            fieldShouldBeVisible : function (field, fieldNum) {
                return this.fieldSourceGrid.fieldShouldBeVisible(field, fieldNum);
            },

            canEditCell:function () {
                return false;
            },

            // if 'screenReaderNavigateByCell' was explicitly specified in our properties
            // block, respect it. Otherwise make it match the property at the grid level.
            screenReaderNavigateByCell:(
                (this.summaryRowProperties &&
                 this.summaryRowProperties.screenReaderNavigateByCell != null) ?
                this.summaryRowProperties.screenReaderNavigateByCell : this.screenReaderNavigateByCell),
            
            // mark the summary row so we can have special handling for like checkboxField, etc
            _isSummaryRow: true
        });

    } else {
        
        var summaryRow = this.summaryRow,
            summaryRowDS = this.getSummaryRowDataSource();
        if (!summaryRowDS) summaryRow.skipNullDataSourceCheck = true;

        // update DataSource in summaryRow if it doesn't reflect summaryRowDataSource
        if (!isc.DS._equals(summaryRow.getDataSource(), summaryRowDS)) {
            summaryRow.setDataSource(summaryRowDS, this.completeFields.duplicate());
        }

        // recalculateSummaries handles moving and resizing the summary row
        // (It has to, since the number of summary rows displayed may change, changing the
        // height of the summary row grid).
        if (!forAutoFitData) this.summaryRow._recalculateSummaries();
    }
    return this.summaryRow;
},


showSummaryRow : function () {
    // Refuse to show if the gridComponents array doesn't include the s.row
    var componentIndex = this.gridComponents.indexOf("summaryRow");
    if (componentIndex == -1) {
        this.logWarn("showGridSummary set to true, but gridComponents array does not include an " +
            "entry for the summary row - not showing.");
        return;
    }
    // This will handle creating, or updating the summary row and adding it as a member
    this.updateGridComponents()
    this.syncSummaryRowScrolling(this.body.getScrollLeft(), this.body.getScrollTop);

},

// clearSummaryRow() - clears (but doesn't destroy()) the summaryRow component.
// Developers will call 'setShowGridSummary' rather than calling this method directly
clearSummaryRow : function () {
    if (this.summaryRow && this.summaryRow.parentElement == this) {
        this.removeMember(this.summaryRow);
    }
},

//> @method listGrid.isSummaryRecord()
// Returns whether the supplied record is a group or grid summary record.  Useful in conjunction
// with +link{getGroupMembers()} for determining which records are group summary records.
// @param  record (ListGridRecord)  Record object such as from +link{getGroupMembers()}   
// @return (boolean) whether record is summary
// @visibility external
//<
isSummaryRecord : function (record) {
    return record[this.gridSummaryRecordProperty] || record[this.groupSummaryRecordProperty];
},

// The method +link{listGrid.recalculateSummaries()} is ListGrid specific, so
// we can't apply it in the general case as implemented in DataBoundComponent.
_setUserField : function (field, property, value, updateSummaries, markForRedraw) {
    var grid = this;
    this.Super("_setUserField", [field, property, value,
       function (field) {
           if (updateSummaries) grid.recalculateSummaries(null, field);
           if (markForRedraw)   grid.markForRedraw();
       }
    ]);
},
_setUserFieldText : function (field, property, text, updateSummaries, markForRedraw) {
    var grid = this;
    this.Super("_setUserFieldText", [field, property, text,
       function (field) {
           if (updateSummaries) grid.recalculateSummaries(null, field);
           if (markForRedraw)   grid.markForRedraw();
       }
    ]);
},

//> @method listGrid.setUserFormula()
// Updates the user formula of the supplied field.  This method is preferred over setting the
// the field property directly since it allows any component dependencies to be updated.  If
// the formula is not passed or undefined, it is assumed it has already been updated and only
// the dependency propagation logic will run.<P> Known component dependencies are:<ul>
// <li>the cached record values of the formula for this field
// <li>the common formula variable =&gt; field name map maintained by the component for
// calls to the FormulaBuilder</ul>
// @param field (ListGridField | String) field owning the userFormula
// @param [userFormula] (UserFormula) optional formula to install
// @see listGridField.userFormula
// @visibility external
//<
setUserFormula : function (field, userFormula, updateSummaries, markForRedraw) {
    this._setUserField(field, "userFormula", userFormula, updateSummaries, markForRedraw);
},

//> @method listGrid.setUserSummary()
// Updates the user summary of the supplied field.  This method is preferred over setting the
// field property directly since it allows any component dependencies to be updated.  If the
// summary is not passed or undefined, it is assumed it has already been updated and only the
// dependency propagation logic will run.<P>
// Known component dependencies are:<ul>
// <li>the cached record values of the summary for this field</ul>
// @param field (ListGridField | String) field owning the userSummary
// @param [userSummary] (UserSummary) optional summary to install
// @see listGridField.userSummary
// @visibility external
//<
setUserSummary : function (field, userSummary, updateSummaries, markForRedraw) {
    this._setUserField(field, "userSummary", userSummary, updateSummaries, markForRedraw);
},

//> @method listGrid.setUserFormulaText()
// Updates the user formula text of the supplied field.  This method is preferred over setting
// the text property directly since it allows any component dependencies to be updated.  If the
// formula text is not passed or undefined, it is assumed it has already been updated and only
// the dependency propagation logic will run.<P> Known component dependencies are:<ul>
// <li>the cached record values of the formula for this field</ul>
// @param field (ListGridField | String) field owning the userFormula
// @param [text] (String) optional formula text to install
// @see listGridField.userFormula
// @visibility external
//<
setUserFormulaText : function (field, text, updateSummaries, markForRedraw) {
    this._setUserFieldText(field, "userFormula", text, updateSummaries, markForRedraw);
},

//> @method listGrid.setUserSummaryText()
// Updates the user summary text of the supplied field.  This method is preferred over setting
// the text property directly since it allows any component dependencies to be updated.  If the
// summary text is not passed or undefined, it is assumed it has already been updated and only
// the dependency propagation logic will run.<P> Known component dependencies are:<ul>
// <li>the cached record values of the summary for this field</ul>
// @param field (ListGridField | String) field owning the userSummary
// @param [text] (String) optional summary text to install
// @see listGridField.userSummary
// @visibility external
//<
setUserSummaryText : function (field, text, updateSummaries, markForRedraw) {
    this._setUserFieldText(field, "userSummary", text, updateSummaries, markForRedraw);
},

// --------------------------------------------------------------------------------------------
// Filter editor row
// --------------------------------------------------------------------------------------------

// When 'showFilterEditor' is true on a listGrid, it will be drawn with a RecordEditor used to
// filter the List's data.

//> @method listGrid.setShowFilterEditor()
// Setter for the +link{ListGrid.showFilterEditor} property. Allows the filter editor to be
// shown or hidden at runtime.
// @param value (boolean) true if the filter editor should be shown, false if it should be hidden
// @group filterEditor
// @visibility external
//<
setShowFilterEditor : function (value) {
    // No op is required to avoid potentially setting up duplicate FEs etc.
    if (this.showFilterEditor == value) return;
    this.showFilterEditor = value;

	

    if (value) {
        var componentIndex = this.gridComponents.indexOf("filterEditor");
        if (componentIndex == -1) {
            value = false;
            this.logWarn("setShowFilterEditor(true) called, but gridComponents array does not " +
                "include the filterEditor. FilterEditor will not be shown.");
        }
    }

    var criteria;
    if (value) {
        // if we're already drawn re-run createChildren to build the filterEditor and plug it in
        if (this.isDrawn()) {
            
            this.updateGridComponents();
        }

    // filterEditor may have never been defined if this widget has not yet been drawn
    } else if (this.filterEditor) {
        // remember if there were criteria in the filterEditor
        criteria = this.getFilterEditorCriteria();
        this.filterEditor.destroy();
        this.filterEditor = null;
    }

    // This will ensure field widths, sizes etc are all correct.
    this.layoutChildren();

	
    
    if (criteria && criteria != isc.emptyObject) {
        // if there were criteria in the filterEditor, fetchData() now - this will drop 
        // filterEditor criteria, but pick up any other criteria (implicit, eg)
        this.fetchData();
    }

    // notify that veiwState has changed
    this.handleViewStateChanged();
},

// makeFilterEditor()
// Create a RecordEditor instance as this.filterEditor.
makeFilterEditor : function () {

    var ds = this.getDataSource();
    if (this.allowFilterOperators == null && ds && ds.supportsAdvancedCriteria()) {
        // if allowFilterOperators is unset, switch it on if the DS supports advancedCriteria
        this.allowFilterOperators = true;
    }
    var filterEditorProps = isc.addProperties({
        autoDraw:false,
        warnOnReusedFields:false,
        reverseRTLAlign:this.reverseRTLAlign,

        // quicker to check this than to call isA.RecordEditor() downstream
        isFilterEditor: true,

        
        dataPath:this.dataPath,
        setDataPath : function (dataPath) {
            this.dataPath = dataPath;
        },

        // Pass the dataSource through to the filter editor - this is useful for
        // items which will pick up their options from the DS as an option dataSource
        dataSource:this.dataSource, 
        saveLocally:true,

        // Disable fetchValueMapData on the filterEditor entirely.
        // If we're showing an edit item for the field it'll have an optionDataSource
        // set on it, meaning the selectItem / comboBox etc will be responsible for issuing
        // any fetch request against the ODS if necessary.
        _fetchValueMapData : function () {
        },

        height: this.filterEditorHeight,
        // NOTE: filterEditors handle width sizing themselves

        sourceWidget: this,
        
        ID: this.getID() + isc._underscore + "filterEditor",
        
        // We built this thing ourselves so mark it as generated. Allows the AutoTest subsystem to
        // generate a locator that keeps going up the chain, potentially
        _generated:true,

        bodyConstructor: "FilterEditorBody",

        // For the FilterEditor area, let's use the headerContextMenu - it's the nearest appropriate menu
        showContextMenu: function() {
            if (this.sourceWidget.showHeaderContextMenu) {
                return this.sourceWidget.displayHeaderContextMenu();   
            } else {
                this.Super("showContextMenu", arguments);
            }            
        },

        // We have our fields assigned from the source grid - If 'showIf' is set, evaluate it
        // on the source grid, not on this grid.
        // This ensures that the "list" param passed to that method refers to the correct grid
        
        fieldShouldBeVisible : function (field, fieldNum) {
            return this.sourceWidget.fieldShouldBeVisible(field, fieldNum);
        },

        // we share field objects with the main grid.
        // This 'fieldSourceGrid' property is used to ensure we do the right thing about
        // generated fields like the selection-checkbox field etc.
        fieldSourceGrid:this,

        actionType:"filter",
        actionButtonGetHoverHTML: isc._makeFunction("return " + this.getID() + ".getFieldCriteriaHover(null,true)"),
        actionButtonProperties: isc.addProperties({ 
                hoverWrap: true,
                hoverAutoFitWidth: true, 
                hoverAutoFitMaxWidth: 300 
            }, this.filterButtonProperties),

        fetchDelay: this.fetchDelay,
        explicitfetchDelay: this.explicitFetchDelay,

        allowFilterExpressions: this.allowFilterExpressions,
        expressionDataSource: this.getDataSource(),
        
        allowFilterOperators: this.allowFilterOperators,

        // RecordEditor handles passing this through to the editForm
        useMultiSelectForValueMaps:this.useMultiSelectForFilterValueMaps,
        
        // When the user hides a field, remember the user-entered criteria for that field
        discardEditsOnHideField: false,
        useAdvancedCriteria: this.useAdvancedCriteria,

        // Configure hovers for the filter fields
        editFormProperties: {
            itemHoverHTML: isc._makeFunction("field", "return " + this.getID() + ".getFieldCriteriaHover(field)"),
            itemHoverWrap: true,
            itemHoverAutoFitWidth: true,
            itemHoverAutoFitMaxWidth: 300
        }
    }, this.filterEditorDefaults, this.filterEditorProperties);

    if (filterEditorProps.bodyDefaults == null) filterEditorProps.bodyDefaults = {};
    // Ensure if the user tabs into the body we shift focus into the edit form
    // Exception: If this came from a click, we'll already start editing the clicked cell,
    // and a call to startEditing would mess that up and jump focus to the first
    // edit item unexpectedly.
    filterEditorProps.bodyDefaults.focusChanged = function (hasFocus) {
        if (hasFocus && isc.EH.isKeyEvent()) {
            if(this.parentElement.isA("RecordEditor")) {
                this.parentElement.startEditing();
            } else {
                // maybe we are using frozen fields, in that case the RecordEditor is the grandparent
                if(this.parentElement.parentElement.isA("RecordEditor")) {
                    this.parentElement.parentElement.startEditing();
                }
            }
        }
    }

    this.filterEditor = isc.RecordEditor.create(filterEditorProps);

    this.filterEditor.setLocatorParent(this, "filterEditor");
},

// Drawn width for fields and scrollbar (if applicable)
// Used to size the filterEditor

getGridInnerContentWidth : function () {
    var horizontal = this.autoFitData != null && this.autoFitData != "vertical";
    
    if (horizontal && this.body) {
        var body = this.bodyLayout || this.body;
        return body.getWidth();
    }
    return this.getInnerContentWidth();
},



//> @method listGrid.getFilterEditorValueMap()  ([A])
//
//  If we're showing the filter (query-by-example) row for this ListGrid, this method is
//  used to determine the valueMap to display in the filter row for this field.
//  Default implementation will return the field.filterEditorValueMap if specified, or
//  field.valueMap.
//
//  @group  filterEditor
//
//  @param  field   (ListGridField)    field definition field for which we need a valueMap
//  @return         (ValueMap)  ValueMap for the edit field (or null if no valueMap required)
//  @visibility external
//<
getFilterEditorValueMap : function (field) {
    return  field.filterEditorValueMap || field.valueMap || 
        (field.filterEditorProperties && field.filterEditorProperties.valueMap);
},

//> @method listGrid.getFilterEditorType()  ([A])
// If we're showing the filter (query-by-example) row for this ListGrid, this method is
// used to determine the type of form item to display in the filter edit row for this field.
// Default implementation will return the field.filterEditorType if specified, or
// the result of +link{DynamicForm.getEditorType, form.getEditorType()} otherwise.
//
// @group filterEditor
//
// @param field (ListGridField) field definition to get the editorType for
// @return (String) the editorType to use in the filterEditor for the passed field
// @visibility external
//<
_$binary:"binary", _$file:"file", _$imageFile:"imageFile",
getFilterEditorType : function (field) {
    // Simple case: support explicit filterEditorType on the field
    if (field.filterEditorType != null) return field.filterEditorType;

    // TODO: re-implement this once RecordEditor correctly returns AdvancedCriteria
    var ds = this.getDataSource();
    if (
        (isc.SimpleType.inheritsFrom(field.type, "date") || 
         isc.SimpleType.inheritsFrom(field.type, "datetime")) && 
         ds && ds.supportsAdvancedCriteria()
        )
    {
        return "MiniDateRangeItem";
    }

    var type = field.type;
    var isFileType = (type == this._$binary || type == this._$file || 
                        type == this._$imageFile);
                    
    if (isFileType && field.editorType == null) {
        if (field.filenameSuppressed || ds && ds.getFilenameField(field.name) == null) {
            return "StaticTextItem";
        } else {
            return "TextItem";
        }
    }

    // filter editor config is basically picked up from field defaults and explicit
    // field.filterEditorProperties.
    // If a a field specifies an explicit filterEditorType or a filterEditorProperties block with
    // an explicit editor type, respect it.
    // Otherwise if a field specifies an explicit editorType, respect that
    // Otherwise generate the editor type based on data type in the normal way
    // A couple of exceptions:
    // - override canEdit with canFilter, so we don't get a staticTextItem in the field
    
    // - clear out field.length: we don't want to show the long editor type (text area) in our
    //   filter editor
    var filterEditorConfig = isc.addProperties ({}, field,
                                                 {canEdit:field.canFilter !== false,
                                                  length:null});

    // the _constructor property can come from XML -> JS conversion, and matches the
    // XML tag name for the field element.
    // Don't attempt to use this to determine DynamicForm editor type - it's likely to be
    // ListGridField or similar which shouldn't effect the generated form item type.
    if (filterEditorConfig._constructor != null) delete filterEditorConfig._constructor;
    if (field.filterEditorType != null) filterEditorConfig.editorType = field.filterEditorType;
    else if (field.editorType != null && !this.supportsFilterEditorType(field.editorType)) {
        delete filterEditorConfig.editorType;
    }
    isc.addProperties(filterEditorConfig, field.filterEditorProperties);
    var type = isc.DynamicForm.getEditorType(filterEditorConfig, this);
    return type;

},

// If field.editorType is explicitly set, it may not be valid within the filterEditor.
// If this occurs just suppress it and we'll use the default editor type based on field data type
// Devs can always get the behavior they want by explicitly specifying filterEditorType or 
// filterEditorProperties.editorType
supportsFilterEditorType : function (editorType) {
    // transform any TextAreaItems into TextItems because TextAreaItems don't make
    // sense as filters (since the return key inserts a linefeed instead of performing
    // a search)
    if (editorType == "TextAreaItem" || editorType == "textArea") return false;
    return true;
},

//> @attr listGrid.useClientFiltering (Boolean : null : IRW)
// Causes this grid to filter its data on the client where possible, eliminating trips to 
// the server when criteria becomes more restrictive, since the filter must apply to data
// which is already on the client.
// <p>
// This attribute is a shortcut to setting <code>useClientFiltering</code> on the grid's 
// +link{dataProperties} and overrides any value set there.
// <p>
// While the default value is null, the effective default is true, since 
// <code>useClientFiltering</code> is true on +link{ResultSet.useClientFiltering, ResultSet}.
// <p>
// Note that using client-filtering can avoid up to 90% of the most expensive database 
// requests, so it's critical in most cases to leave it switched on.  See the sample 
// +externalLink{https://smartclient.com/smartclient-latest/showcase/?id=adaptiveFilterFS, here}.
// <P>
// In cases where client-filtering alone is not sufficient, note the following:
// <ul>
//  <li> You can easily prevent client-side filtering for a given field by setting
//      +link{dataSourceField.filterOn, filterOn:"serverOnly"}, if you can't replicate the 
//      filtering on the client.</li>
//  <li> an override of +link{ResultSet.compareCriteria()} can be used to handle any other, 
//      more complicated differences in client- vs server-side filtering that may arise for a 
//      single grid </li>
//  <li> a custom search operator can be used if you want to create custom 
//      filtering behavior which applies to a variety of different grids & DataSources</li>
// </ul>
//
// @visibility external
//<



//> @attr listGrid.useAdvancedCriteria (Boolean : null : IRW)
// Should the +link{listGrid.showFilterEditor, filter-editor} in this grid always produce 
// +link{AdvancedCriteria}?
// @group criteriaEditing
// @visibility external
//<

//> @attr ListGrid.defaultFilterOperator (OperatorId : null : IR)
// Default +link{type:OperatorId,filter operator} to use for text-based fields in this grid's 
// +link{listGrid.filterEditor, filter editor}, when producing +link{AdvancedCriteria}.  
// When +link{listGrid.allowFilterExpressions, allowFilterExpressions} or
// +link{listGrid.allowFilterOperators, allowFilterOperators} are enabled for the grid,
// the default is +link{dataSource.translatePatternOperators,"iContainsPattern"}.  Otherwise,
// the default is "iContains".
// <p>
// Does not apply to special fields where exact match is obviously the right default
// setting, such as fields of type:"enum", or fields with a
// +link{formItem.valueMap,valueMap} or  +link{formItem.optionDataSource,optionDataSource}.
// @visibility external
//<

getFieldUIOperatorList : function (field, ds, includeHidden) {
    var ops = {};
    field = this.getUnderlyingField(field);

    
    if (!field) return ops;

    ds = isc.DataSource.get(ds) || this.getDataSource();

    // if there's a displayField, use the operators that apply to that field
    if (field.displayField) {
        var ods = field.optionDataSource;
        if (ods) ods = isc.DataSource.get(ods);

        // if valid, set displayField/ods into field/ds
        var displayField = this.getDisplayField(field);
        if (displayField) {
            if (ods) ds = ods;
            field = displayField;
        // otherwise, warn and fall back to the valueField or the original field itself
        } else {
            var valueField = ods && field.valueField && ods.getField(field.valueField);
            this.logWarn("can't find displayField '" + field.displayField + 
                "' when looking up operators; falling back to " +
                         (valueField ? "valueField '" + valueField.name + "'" :
                                            "field '" +      field.name + "'"));
            if (valueField) {
                if (ods) ds = ods;
                field = valueField;
            }            
        }
    }
                
    if (ds) {
        var form = this.getFilterEditor().getEditForm(),
            formItem = form.getItem(field.name),
            validOps = formItem ? formItem.getValidOperators() : ds.getFieldOperators(field)
        ;
        ops = ds.getFieldOperatorMap(field, null, "fieldType", null, validOps);
        if (this.allowFilterExpressions && field.allowFilterExpressions != false) {
            // only add "between" and variants if grid.allowFilterExpressions is true and the
            // field doesn't override that setting - the value has to be parsed
            isc.addProperties(ops, ds.getFieldOperatorMap(field, null, "valueRange", null, validOps));
            // the same for inSet/notInSet variants - value has to be parsed with the 
            // valueSeparator
            isc.addProperties(ops, ds.getFieldOperatorMap(field, null, "valueSet", null, validOps));
        }
        
        // blank/null variants
        isc.addProperties(ops, ds.getFieldOperatorMap(field, null, "none", null, validOps));
        // regex and pattern variants
        isc.addProperties(ops, ds.getFieldOperatorMap(field, includeHidden, "custom", null, validOps));
    }
    return ops;
},

// getFieldFilterEditorProperties - returns a block of properties to apply to the form item displayed
// in the filter row for some field.
getFieldFilterEditorProperties : function (field) {
    var result = isc.addProperties({}, field.filterEditorProperties);
    if (field.filterOperator) result.operator = field.filterOperator;
    // defaultOperator is not specifically supported on ListGridField, but it *is* supported
    // on DataSourceField, so support it here
    if (field.defaultOperator) result.defaultOperator = field.defaultOperator;

    if (field.allowFilterExpressions != null) {
        // if the field specifies allowFilterExpressions, enforce it on the item
        result.allowExpressions = field.allowFilterExpressions;
        result.enforceLength = !result.allowExpressions;
    } else if (this.allowFilterExpressions) {
        // otherwise, always allow for expression-length if the grid allow expressions
        result.enforceLength = false;
    }

    // always disable autoComplete for filterEditor fields
    result.autoComplete = "none";

    if (this.shouldAllowFilterOperators(field)) {
        // store off setCriterion and canEditCriterion if they're customized
        if (result.setCriterion && !result.custom_setCriterion) {
            result.custom_setCriterion = result.setCriterion;
            result.setCriterion = null;
        }
        if (result.canEditCriterion && !result.custom_canEditCriterion) {
            result.custom_canEditCriterion = result.canEditCriterion;
            result.canEditCriterion = null;
        }
        isc.addProperties(result, {
            lgField: field,
            // show the item in the special "inline" style - eg, textItemLiteInline
            showInlineStyle: true,
            init : function () {
                this.Super("init", arguments);

                var ds = this.grid.getDataSource();
                this._defaultOperator = this.lgField.filterOperator || this.getOperator();
                this._dsDefaultOperator = ds && ds.getFieldDefaultOperator(this.getCriteriaFieldName());
                
                if (this._dsDefaultOperator && this._dsDefaultOperator != this._defaultOperator) {
                    this.defaultOperator = this._defaultOperator;
                }
            },
            setCriterion : function (criterion) {
                // run the custom setCriterion() implementation if it's there
                if (this.custom_setCriterion) {
                    this.custom_setCriterion(criterion);
                    return;
                }
                // otherwise, potentially update the operatorIcon and call Super()
                if (this.getOperator() != criterion.operator) {
                    // operator has changed, update the operatorIcon
                    this.grid.sourceWidget.setFieldSearchOperator(field, criterion.operator, true)
                }
                // the item should always have a form, but this method can be called (for the
                // filterEditor) before the form attribute has been set, when showing a field from the 
                // Columns menu - if form is unset, set it to grid.getEditForm() (which is the filterEditor's form)
                if (!this.form && this.grid) this.form = this.grid.getEditForm();
                if (!this.form) {
                    this.grid.logWarn("setCriterion() called on filterEditor formItem '" + 
                        criterion.fieldName + "', which has no form specified.");
                    return;
                }
                this.Super("setCriterion", arguments);
            },
            canEditCriterion : function (criterion) {
                // never allow filterEditor items to edit dynamicCriteria
                if (criterion.valuePath != null) return false;
                if (this.custom_canEditCriterion) {
                    // return the result of the custom canEditCriterion() method if it's there
                    return this.custom_canEditCriterion(criterion);
                }
                // when allowing custom filter-operators, crit only needs to have the right 
                // fieldName to be considered editable
                if (criterion.fieldName != null && criterion.fieldName == this.getCriteriaFieldName()) {
                    // get the ops for the criteriaField, which might not be the actual field
                    var ds = this.grid.getDataSource();
                    if (ds != null) {
                        var field = this.grid.getUnderlyingField(criterion.fieldName);
                        // allowed if valid for the field - use getFieldOperators(), which will 
                        // include field.validOperators as necessary, rather than 
                        // getTypeOperators(), which will not
                        var ops = ds.getFieldOperators(field);
                        return ops.contains(criterion.operator);
                    }
                }
                return this.Super("canEditCriterion", arguments);
            },
            _getIconTextAlign : function (icon) { return "center"; },
            
            _getInlineLeftPadding : function (style) { return 1; },
            _getInlineRightPadding : function (style) { return 1; },
            showContextMenu : function (form, item, event) {
                
                if (event && isc.Browser.isTouch) {
                    var nativeTarget = event.nativeTarget,
                        textBox = this._getTextBoxElement();
                    if (textBox && textBox.contains && textBox.contains(nativeTarget)) {
                        return;
                    }
                }
                
                var grid = this.grid.sourceWidget,
                    items = grid.getFilterOperatorMenuItems(this.lgField, true),
                    menu = grid.filterOperatorMenu
                ;
                if (!menu) {
                    menu = grid.filterOperatorMenu = grid.createAutoChild("filterOperatorMenu");
                }
                menu.setItems(items);
                var button = grid.getFieldHeaderButton(grid.getFieldNum(this.lgField));
                menu.showContextMenu(button);
                
                return false;
            }
        });
        if (!result.icons) result.icons = [];
        else result.icons = result.icons.duplicate();
        var operatorId = result.operator;
        if (!result.icons.getProperty("name").contains("operatorIcon")) {
            result.icons.add(this.getOperatorIcon(field, result.operator));
        }
    } else {
        // these are filter-items for fields that don't support operatorIcons 
        // (select/checkbox, at least)
        isc.addProperties(result, {
            lgField: field,
            // show the item in the special "inline" style - eg, textItemLiteInline
            showInlineStyle: true,
            init : function () {
                this.Super("init", arguments);
                this._defaultOperator = this.lgField.filterOperator || this.getOperator();
            }
        });
    }

    var type = field.type;
    var isFileType = (type == this._$binary || type == this._$file || 
                        type == this._$imageFile);
    if (isFileType && !field.filenameSuppressed) {
        var ds = this.getDataSource(),
            fileNameField = ds && ds.getFilenameField(field.name);
        if (fileNameField != null) {
            result.criteriaField = fileNameField;
        }
    }

    return result;
},

// Unexposed but publicly accessible method to get a pointer to the filter editor grid

getFilterEditor : function () {
    return this.filterEditor;
},

//> @method listGrid.setFilterEditorCriteria()
// If +link{listGrid.showFilterEditor} is true, this method will update the criteria shown
// in the <code>filterEditor</code> without performing a filter.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use 
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// @param criteria (Criteria | AdvancedCriteria) New criteria to show
// @visibility external
//<
setFilterEditorCriteria : function (criteria) {
    // flag that we're in setFilterEditorCriteria() - checked when clearing filter-operators, to
    // ensure that doing so doesn't kick off a fetch - this method is doc'd as not doing that
    this._settingFilterEditorCriteria = true;
    if (this.filterEditor) {
        // Normally we either want setFilterValues to drop all criteria and replace with new
        // ones (programmatic 'filterData()'), or retain all hidden criteria and just
        // sparsely apply specified criteria to visible fields (user interactions with the
        // filter editor).
        // However if 'setFilterEditorCriteria' is called directly we want to clear
        // criteria on fields that have been explicitly hidden by the user, but are
        // present in the grid 'completeFields' definition, 
        // but still retain criteria applied to fields which aren't
        // actually present in the grid at all.
        
        var hasHiddenFields = false,
            hiddenFields = [];
        var editForm = this.filterEditor.getEditForm();
        for (var i = 0; i < this.completeFields.length; i++) {
            var field = this.completeFields[i];
            
            if (this.fieldIsVisible(field,true)) {
                // incremental rendering may cause the field not to be present in our 
                // filter editor edit-form
                // Catch the case where we have the form, but not the item for some
                // (logically) visible field.
                if (!editForm || editForm.getItem(field.name) != null) {
                    continue;
                }
            }
            
            hasHiddenFields = true;
            hiddenFields.add(field.name);
        }
        this.filterEditor.clearFilterOperators = true;
        this.setFilterValues(criteria, hasHiddenFields, hiddenFields);
        this.filterEditor.clearFilterOperators = null;
    }
    // if there is no filterEditor yet, but there will be, store as initialCriteria
    else if (this.showFilterEditor) this.initialCriteria = criteria;
    delete this._settingFilterEditorCriteria;
},

//> @method listGrid.getFilterEditorCriteria()
// If +link{listGrid.showFilterEditor} is true, this method will return the criteria currently
// displayed in the <code>filterEditor</code>. Note that these values may differ from the
// criteria returned by +link{listGrid.getCriteria()} if the filter editor values have been modified
// without performing an actual filter.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use 
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// @param [omitHiddenFields] (Boolean) By default this method will include criteria applied to
//   fields, including criteria that are not actually visible/editable in the filterEditor for the
//   grid. Pass in this parameter to get only values for visible fields returned.
// @return (Criteria | AdvancedCriteria) criteria currently displayed in the filterEditor
// @visibility external
//<
// Note: we rely on the filterEditor edit form to handle combining specified criteria with criteria
// from live items - as such calling getValuesAsCriteria() on that form will return all specified
// criteria, even for fields not visible in the grid.
// This is not always desired - it can be useful to apply additional criteria outside those
// editable by the user, and in order to repeatedly do this, we need to be able to get back a
// clean copy of *only* the criteria the user has modified. The includeHiddenFields parameter
// allows us to do this.
// - See the DynamicReporting sample for an example of this use-case:
//      isomorphic/system/reference/SmartClient_Explorer.html#dynamicReporting

getFilterEditorCriteria : function (omitHiddenFields) {
    if (this.filterEditor) {
        var form = this.filterEditor.getEditForm();
        if (!omitHiddenFields || !form) {
            
            return this.filterEditor.getValuesAsCriteria(this.autoFetchTextMatchStyle);
        } else if (form) {
            var items = form.getItems(),
                simple = true,
                criteria = {},
                advancedCriteria = {_constructor: "AdvancedCriteria",
                    operator:"and", criteria:[]}
            ;
            for (var i = 0; i < items.length; i++) {
                if (items[i].hasAdvancedCriteria()) {
                    var crit = items[i].getCriterion();
                    if (crit != null) {
                        simple = false;
                        advancedCriteria.criteria.add(crit);
                    }
                } else {
                    var value = items[i].getValue();
                    if (value != null) {
                        criteria[items[i].getCriteriaFieldName()] = value;
                    }
                }
            }
            // if a field was scrolled out of view while it had a filter-value, it's value or 
            // advanced criterion were stored in the form's _fieldCriteriaCache before the 
            // field was removed - add any cached criteria now
            var cache = form._fieldCriteriaCache;
            if (cache) {
                for (var fieldName in cache) {
                    if (!cache[fieldName] || !cache[fieldName].criteria) continue;
                    if (!this.fieldIsVisible(fieldName)) continue;
                    // valid cache entry, valid field that is not specifically hidden
                    if (cache[fieldName].advanced) {
                        simple = false;
                        advancedCriteria.criteria.add(cache[fieldName].criteria);
                    } else {
                        criteria[fieldName] = cache[fieldName].criteria;
                    }
                }
            }
            if (!simple) {
                criteria = (this.getDataSource() || isc.DS).combineCriteria(criteria, advancedCriteria);
            }
            return criteria;
        }
    }
},

//> @method listGrid.getFilterEditorCriterion()
// Extracts and returns the criteria for the passed field from the 
// +link{listGrid.showFilterEditor, filterEditor}.  The result can be an 
// +link{AdvancedCriteria}, if the field in question produces more than one restriction, such
// as separate <code>greaterThan</code> and <code>lessThan</code> criteria for a range.
// @param fieldName (String) name of the field to get the criteria for
// @return (Criterion) the passed field's filterEditor criterion
// @visibility external
//<
getFilterEditorCriterion : function (fieldName) {
    if (!fieldName || !this.showFilterEditor || !this.getDataSource()) return;

    if (this.filterEditor) {
        // if there's an editItem for this field in the filterEditor, return its criterion
        var form = this.filterEditor.getEditForm();
        if (form) {
            // if there's a form, and an item, for this field, return its item.getCriterion()
            var item = form.getItem(fieldName);
            if (item) {
                return item.getCriterion();
            }
        }
    }
    var ds = this.getDataSource();
    // get all the crit from the filterEditor
    var editorCrit = this.getFilterEditorCriteria();
    // and extract the crit for the passed field
    var result = ds.getFieldCriterion(editorCrit, fieldName);
    return result;
},

// Default setCriteria implementation will no-op if we have no data (and won't update the
// filterEditor even if we do have data) - override to ensure the FE reflects the new criteria
setCriteria : function (criteria) {
    if (this.filterEditor != null) {
        this.filterEditor.clearFilterOperators = true;
        this.setFilterValues(criteria, true);
        this.filterEditor.clearFilterOperators = null;
    }

    // If grouped we need to apply criteria to underlying ResultSet    
    var data = this.isGrouped ? this.getOriginalData() : this.data;
    if (data) {
        // if setCriteria() exists (ResultSet) call it
        if (data.setCriteria) data.setCriteria(criteria);
        else {
            // data is an array - store the criteria 
            this.initialCriteria = criteria;
            // if filterLocalData is true, pass the criteria to filterData()
            if (this.filterLocalData) this.filterData(criteria);
        }
    // if there is no data yet, set initial criteria to parameter criteria
    } else this.initialCriteria = criteria;

    this.dataSetChanged();
},
    
// setFilterValues() - helper method called when this widgets filter criteria change.
// Will store the criteria locally and call the method to update the filter editor values.
// dropExtraCriteria is passed on to filterEditor.setValuesAsCriteria() and causes it to
// drop any criteria that apply to fields which can't be edited
// The explicit fields passed in as dropCriteriaFields allows us to retain 
// values for fields which aren't defined in the grid at all, but still clear values for
// fields which are defined but hidden (so aren't represented in the edit form)
// This matches the use case of a user editing a filter value, hiding a field and then
// attempting to clear filter editor values via the clearFilter menu item.
setFilterValues : function (criteria, dropExtraCriteria, dropCriteriaFields) {

    // store this in a local var - this allows us to show and hide the filterEditor independently
    // and know what the current criteria are.
    this._filterValues = isc.addProperties({}, criteria);

    // Update initialization property to match current criteria
    this.initialCriteria = this._filterValues;

    this.updateFilterEditor(dropExtraCriteria, dropCriteriaFields);
},


// update the filter editor's values to match the current filter criteria
// Needs to happen whenever the filter criteria change or the filter editor is shown
updateFilterEditor : function (dropExtraCriteria, dropCriteriaFields) {
    var editor = this.filterEditor;
    if (!editor) return;

    var values = this._getFilterEditorValues();
    this.filterEditor.setValuesAsCriteria(values, true, dropExtraCriteria, dropCriteriaFields);

},


// _getFilterEditorValues returns the values to be shown in our filter editor (doesn't get the
// values FROM our filter editor - see getFilterEditorCriteria() for that).
// Called when the filter editor is first created, and used by updateFilterEditorValues to update
// the filterEditor when it is already showing.
// Note that developers can customize the display value via the 'updateFilterEditorValues()'
// stringMethod
_getFilterEditorValues : function () {
    var currentCriteria = isc.addProperties({}, this._filterValues);

    // Allow for a completely custom display of filterEditorValues by the developer
    if (this.updateFilterEditorValues != null) {
        
        currentCriteria = this.updateFilterEditorValues(currentCriteria, this.autoFetchTextMatchStyle);
    }



    // If we've never performed a filter, use our default filter values. Note that if we
    // explicitly filter with null or empty criteria we do NOT want to reset to defaults -
    // defaults are only used if we've never filtered this datasource. Handled by the fact
    // that setFilterValues() will always store an object, never null.
    if (currentCriteria == null || isc.isAn.emptyObject(currentCriteria)) {
        currentCriteria = {};
        for (var i = 0; i < this.completeFields.length; i++) {
            currentCriteria[this.completeFields[i].name] = this.completeFields[i].defaultFilterValue;
        }
    }

    return currentCriteria;
},


// re-set the filterEditor's values to display the defaultFilterValues.
// This will be called if the defaultFilterValues change (can happen from setFields()) [and
// no filter has yet been performed], or if we change datasources so the current filter gets
// invalidated.

clearFilterValues : function () {
    this._filterValues = null;
    this.updateFilterEditor(true);
},

handleFilterEditorSubmit : function (criteria, context, callback) {

    var ds = this.getDataSource();
    // notification method fired when the user modifies the criteria in the filter editor
    // and hits the filter button / enter key.
    var combinedCriteria = this._combineUserCriteria(criteria);
    if (this.filterEditorSubmit != null && this.filterEditorSubmit(combinedCriteria) == false) return;
    this.fireCriteriaChanged();

    // NOTE: we're passing just the filter editor criteria into filterData() - we'll re-combine
    // with filterWindowCriteria etc inside that code flow when appropriate.
    this.filterData(criteria, callback, context);
},

doInitialFetch : function () {
    // Setup allowFilterWindow property at the first data filter
    return this.Super("doInitialFetch", arguments);
},

// If we're doing an auto-fetch, apply each field's defaultFilterValue to the initialCriteria object
getInitialCriteria : function () {
    var initialCriteria = {},
        hasInitialFieldValue,
        fields = this.getFields(),
        undef;
    for (var i = 0; i < fields.length; i++) {
        if (fields[i].defaultFilterValue !== undef) {
            hasInitialFieldValue = true;
            var fieldName = this.getFieldName(fields[i]);
            initialCriteria[fieldName] = fields[i].defaultFilterValue;
        }
    }

    // allow explicitly specified initialCriteria to override the field level defaultFilterValues
    if (!hasInitialFieldValue) {
        initialCriteria = this.initialCriteria || this.getCriteria(true);
    } else {
        isc.addProperties(initialCriteria, this.initialCriteria || this.getCriteria(true));
    }
    
    if (this.implicitCriteria) {
        //initialCriteria = isc.DS.combineCriteria(initialCriteria, this.getImplicitCriteria());
    }
    
    return initialCriteria;
},


// Treat the filterEditor as a "special" peer -- keep it next to us in the page's z-order
_adjustSpecialPeers : function (newIndex) {
    if (this.filterEditor != null) this.filterEditor.setZIndex(newIndex-1);
    return this.Super("_adjustSpecialPeers", arguments);
},

//> @attr listGrid.allowFilterExpressions (boolean : null : IR)
// For use with +link{showFilterEditor}:true, allows simple search expressions to be entered
// into filter fields, as though +link{dynamicForm.allowExpressions} were true.
// <P>
// This attribute can also be set at the +link{listGridField.allowFilterExpressions, field level}.
//
// @group advancedFilter
// @visibility external
//<


// --------------------------------------------------------------------------------------------
// Inline Editing
// --------------------------------------------------------------------------------------------



// Editing kickoff
// --------------------------------------------------------------------------------------------

//> @attr listGrid.canEditFieldAttribute (String : "canEdit" : IRA)
// @include dataBoundComponent.canEditFieldAttribute
// @visibility external
//<

//> @method listGrid.canEditCell() (A)
// Can this cell be edited?
// <P>
// The default implementation of <code>canEditCell()</code> respects the various property
// settings affecting editability:
// <ul><li>+link{listGridField.canEdit,field.canEdit} can be set to disable editing
//          for a field</li>
//     <li>If the grid is bound to a dataSource, the +link{listGrid.canEditFieldAttribute} value on the
//         dataSource field may enable / disable editing</li>
//     <li>a record with the +link{listGrid.recordEditProperty,recordEditProperty} set to
//         false is not editable</li>
//     <li>disabled records are not editable</li>
// </ul>
// You can override this method to control editability on a cell-by-cell basis.  For example,
// if you had a grid that allows editing of "orders", and you had a field "shipDate" that is
// normally editable, but should not be editable if the order is already "complete", you might
// implement <code>canEditCell()</code> as follows:
// <P>
// <smartclient><pre>
//   isc.ListGrid.create({
//       ...
//       canEditCell : function (rowNum, colNum) {
//           var record = this.getRecord(rowNum),
//               fieldName = this.getFieldName(colNum);
//           if (fieldName == "shipDate" &&
//               record.orderStatus == "complete")
//           {
//               return false;
//           }
//           // use default rules for all other fields
//           return this.Super("canEditCell", arguments);
//       }
//   });
// </pre></smartclient>
// <smartgwt><pre>
//    public boolean canEditCell(int rowNum, int colNum) {
//      Record record = this.getRecord(rowNum);
//      String fieldName = this.getFieldName(colNum);
//      if (fieldName.equals("shipDate") && record.getAttribute("orderStatus").equals("complete") {
//        return false;
//      }
//      // use default rules for all other fields
//      return super.canEditCell(rowNum, colNum);
//    };
// </pre></smartgwt>    
// <P>
// Notes on providing custom implementations:
// <ul>
// <li> In order to allow complete control over editing, <code>canEditCell()</code> is called
// very frequently.  If you see delays on row to row navigation, check that your implementation
// is efficient
// <li> If you change the editability of a cell on the fly, for example, during
// +link{editorExit()} on another cell, call refreshCell() to show or hide the editor
// <li> If this ListGrid allows new records to be created, <code>canEditCell()</code> may be
// called when there is no record available, in which case getRecord() will return null.  The
// values input so far by the user are available via +link{getEditValues()}.
// </ul>
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
// <P>
// For more information on editing, see the +link{group:editing,editing overview}.
//
// @param rowNum (number) row number for the cell
// @param colNum (number) column number of the cell
// @return (boolean) Whether to allow editing this cell
//
// @group editing
// @visibility external
//<
canEditCell : function (rowNum, colNum) {
    if (this.canEdit == false) return false;
    // just return if passed bad colNum
    if (colNum < 0 || colNum >= this.fields.length) return false;

    if (this.allowRowSpanning && this.rowSpanEditMode == "first") {
        // Disallow edit of the cell if it's a spanning cell and the user is
        // attempting to edit something other than the first row in the cell
        var startRow = this.getCellStartRow(rowNum, colNum);
        if (startRow != rowNum) {
            return false;
        }
    }

    var cellRecord = this.getCellRecord(rowNum, colNum);
    // Note - we may have no cellRecord - this will occur if we're editing a new row
    if (cellRecord != null) {
        if (!this.recordIsEnabled(cellRecord, rowNum, colNum)) return false;

        // Suppress editing if we're showing an embedded editor or detailGrid for this row
        if (this._openRecord == cellRecord) return false;
    }
    // If the field is explicitly marked as disabled, disallow editing
    
    var field = this.getField(colNum);
    if (field && field.disabled) return false;

    if (field && field.type == "summary") return false;
    // otherwise check the cascaded canEdit property
    if (
        this.getCellBooleanProperty(
                "canEdit",
                rowNum,
                colNum,
                (cellRecord != null ? this.recordEditProperty : null)
        ) == false
    ) {
        return false;
    }
    // Disallow editing of formula fields by default
    if ((field.userFormula || field.userSummary) && field.canEdit == null) return false;
    return true;
},

//> @method listGrid.fieldIsEditable()
// Can the field be edited?  This method looks at +link{canEdit} for the grid as well as the
// +link{listGridField.canEdit} value, to determine whether editing is allowed. This method's
// return value is not authoritative for editibility since +link{canEditCell} could return
// a more specific value.
// <p>
// For a detailed discussion, see the documentation at +link{canEdit}.
//
// @param field (ListGridField | number | FieldName) field object, number, or name
// @return      (boolean)                            whether field can be edited
//
// @group editing
// @visibility external
//<
_$true:"true",
fieldIsEditable : function (field) {
    // A field can be edited if:
    // listGrid.canEdit is true, and field.canEdit is not set to false
    // listGrid.canEdit is unset, and field.canEdit is set to true
    // No field can be edited if listGrid.canEdit is set to false.

    if (this.canEdit == false) return false;

    if (!isc.isAn.Object(field)) field = this.getField(field);
    if (this.canEdit == true || this.canEdit == this._$true && field.canEdit != false) {
        return true;
    } else if (this.canEdit == null && field.canEdit == true) {
        return true;
    }
    return false;
},

//> @method listGrid.setCanRemoveRecords()
// Updates the +link{canRemoveRecords} property for this listGrid at runtime.
// @param canRemove (boolean) new canRemoveRecords value
// @visibility external
//<
setCanRemoveRecords : function (canRemove) {
    if (canRemove == this.canRemoveRecords) return;
    this.canRemoveRecords = canRemove;
    this.refreshFields();
},

//> @method listGrid.setCanEdit()
// Updates the canEdit property for this listGrid at runtime.
// <P>
// If setting canEdit to false, any current editing is cancelled by calling
// +link{cancelEditing}.
//
// @param (boolean) desired value of canEdit for this grid
//<
setCanEdit : function (canEdit) {
    if (canEdit == false) {
        if (this.getEditRow() != null) this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
        this.canEdit = false;
    } else {
        this.canEdit = canEdit;
    }
},

//> @method listGrid.setFieldCanEdit()
//  Updates the canEdit property for some field at runtime.
//  @param  (boolean)   desired value of canEdit for this field
//<
setFieldCanEdit : function (field, canEdit) {

    if (isc.isA.String(field)) field = this.getField(field);
    if (field == null || !this.completeFields.contains(field) || field.canEdit == canEdit) return;

    field.canEdit = canEdit;
    if (this._editorShowing) {
        var editRow = this.getEditRow(),
            fieldName = field[this.fieldIdProperty],
            colNum = this.getColNum(field);

        // If we're editing by cell and making the current edit field non editable, kill the
        // current edit
        if (this.editByCell) {
            if (!canEdit && colNum == this.getEditCol()) {
                this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
            }

        // If we're showing editors for the entire row, we need to refresh the appropriate
        // field in the edit row to display / hide the editor
        } else if (colNum >= 0) {

            // If we're hiding the current edit field, we want to shift focus to the nearest
            // edit field instead.
            // If there isn't one, just cancel the edit.
            if (!canEdit && colNum == this.getEditCol()) {

                var currentEditItem = this._editRowForm.getItem(fieldName),
                    fieldHasFocus = currentEditItem.hasFocus;

                // Try to put focus in an adjacent field - say the previous one
                // (try going backwards first, then forwards)
                var newEditCell = this.findNextEditCell(editRow, colNum, -1,
                                                        true, false, false, true);

                if (newEditCell == null || newEditCell[0] != editRow)
                    newEditCell = this.findNextEditCell(editRow, colNum, 1,
                                                        true, false, false, true);

                // If there isn't another editable cell in this row, just cancel the edit
                if (newEditCell == null || newEditCell[0] != editRow) {
                    this.cancelEditing(isc.ListGrid.PROGRAMMATIC);
                    return;
                }
                // startEditing the new cell. This will fire the editorExit handler on the
                // previous cell and save out the value if appropriate.
                // Note: don't focus in the new cell unless focus was already in the cell being
                // made un-editable.
                this.startEditing(newEditCell[0], newEditCell[1], !fieldHasFocus);
            }
            // Refresh the cell to actually display / hide the edit form item.
            this.refreshCell(this.getEditRow(), colNum);
        }
    }
},



//> @method listGrid.handleEditCellEvent()  (A)
// Handle an 'editCell' event - typically a click or double click on an editable ListGrid.
// Verifies that the cell passed in is a valid edit candidate before falling through to
// startEditing().
//
//  @group  editing
//
//  @param  rowNum      (number)    Row number of the cell to edit.
//  @param  colNum      (number)    Column number of the cell to edit.
//  @param  event       (EditCompletionEvent)   How was this edit event triggered. If
//                                      we shift focus to a new edit cell this event will be
//                                      passed to the editorExit handler(s) of the previous row.
//                                      Expected vals are "click", "doubleClick" or "focus"
//                                      (or null).
//  @param [newValue] (Any) optional new edit value for the cell
//  @return (boolean)   true if we are editing the cell, false if not editing for some reason
//<
handleEditCellEvent : function (rowNum, colNum, event, newValue) {
    // set a flag to notify us that we started this 'edit session' on keyPress
    // This is required for 'moveEditorOnArrow' behavior, which only applies to edit sessions
    // started on keypress
    // We can't use the _editorCursorAtEnd flag as that won't get set unless the value was
    // modified, and we want the moveEditorOnArrow behavior even if the user started editing
    // from an f2 keypress...
    // This flag will be cleared
    // - here if the user double clicks (etc) another cell
    // - by cellEditEnd unless the event is keyboard navigation to another cell
    if (event == this._$keyPress) this._editSessionFromKeyPress = true;
    else delete this._editSessionFromKeyPress

    // if they're trying to edit an invalid cell, return false
    if (rowNum < 0 || colNum < 0) return false;

    // if passed a logical cell that is part of a rowSpan, adjust the rowNum so we edit
    // the first spanned row
    if (this.allowRowSpanning) {
        rowNum = this.getCellStartRow(rowNum, colNum);
    }

    // can we actually edit that cell?  If not, bail.
    if (this.editByCell) {
         if (!this.canEditCell(rowNum, colNum)) return false;
    } else {
        // If the user double-clicks on a non-editable field and editByCell is
        // false assume they want to start editing the row and put focus into the closest
        // editable cell in that row.
        var editCell = this.findNextEditCell(rowNum, colNum, -1, true, true, false, true);
        if (editCell == null || editCell[0] != rowNum)
            editCell = this.findNextEditCell(rowNum, colNum, 1, true, false, false, true);

        if (editCell == null || editCell[0] != rowNum) return false;
        // Update the colNum to reflect the closest editable cell to the one clicked if the
        // row is editable.
        colNum = editCell[1];
    }
    var undef;
    if (newValue !== undef) {
        this.setEditValue(rowNum,colNum, newValue);
    }

    // startEditing will save out the value in the previous edit cell if necessary...
    return this.startEditing(rowNum, colNum, null, event);
},

//> @method listGrid.hasBeenEdited()
// Returns true if record has been edited. That is, either the row editors
// have been shown or edit values have been saved.
// <p>
// Can be used in high-call methods because the response is instantaneous.
// 
// @param rowNum (Number | Object) rowNum or record to check
//<
hasBeenEdited : function (rowNum) {
    if (rowNum == null) return false;
    rowNum = (isc.isAn.Object(rowNum) ? this.getRecordIndex(rowNum) : rowNum);
    if (rowNum == null) return false;
    var editSession = this.getEditSession(rowNum);
    if (editSession == null) return false;
    return (editSession._editorsShown || editSession._editValuesSaved);
},

// Show/Hide Inline Editor
// --------------------------------------------------------------------------------------------

//> @method listGrid.startEditing() (A)
// Start inline editing at the provided coordinates.
// <p>
// Invoked when a cell is editable and the <code>editEvent</code> occurs on that cell.  Can
// also be invoked explicitly.
// <P>
// If this method is called while editing is already in progress, the value from the current
// editCell will either be stored locally as a temporary edit value, or saved via 'saveEdits()'
// depending on <code>this.saveByCell</code>, and the position of the new edit cell.<br>
// Will update the UI to show the editor for the new cell, and put focus in it unless
// explicitly suppressed by the optional <code>suppressFocus</code> parameter.
//
//  @group  editing
//
//  @param  [rowNum]      (Integer) Row number of the cell to edit.  Defaults to first
//                                  editable row
//  @param  [colNum]      (Integer) Column number of the cell to edit.  Defaults to first
//                                  editable column
//  @param  [suppressFocus] (Boolean)   If passed this parameter suppresses the default
//                                  behavior of focusing in the edit form item when
//                                  the editor is shown.
//  @return (Boolean)   true if we are editing the cell, false if not editing for some reason
//
// @see canEditCell()
// @see editEvent
// @visibility external
//<

startEditing : function (rowNum, colNum, suppressFocus, eCe, suppressWarning) {
    
    if (this._keyboardEventsDisabled) {
        this.logInfo("call to startEditing() while keyboard events disabled (may be due to " +
                     "a component-mask blocking this grid). Ignoring", "gridEdit");
        return false;
    }

    // force editing on if it's not configured for any field, but a programmatic call is made
    if (!this.canEdit && !(this.completeFields || this.fields).getProperty("canEdit").or()) {
        this.canEdit = true;
    }

    // if setFields() has never been called, call it now.
    if (this.completeFields == null) this.setFields(this.fields);

    // Possibilities:
    // - This is an entirely new editing flow
    // - We are in an uncompleted editing flow
    // - We are currently showing an editor for another cell

    // What needs to happen?
    // - Showing a previous editor:
    //   *Save the new value from the edit cell locally into the temp set of editValues (for
    //     the appropriate record)
    //   *Hide the inline editor (unless it's another field in the same row and we're editing
    //     the whole row)
    // - Update edit info for this edit:
    //   *If we have no editFlowID, set up a new one
    //   *If there are no editValues stored for this record, store those values
    //   *Update the current editRowNum and editColNum, so we know which field is being edited

    // - show the editor:
    //   *Call 'showInlineEditor' to show the editor.  This will draw a new editor if required,
    //       or just focus in the appropriate field of the existing editor.

    // default to editable row / col
    var noRow = (rowNum == null),
        noCol = (colNum == null);
    if (noRow || noCol) {
        var testRow = (noRow ? 0 : rowNum),
            testCol = (noCol ? 0 : colNum);
        var newCell = this.findNextEditCell(testRow, testCol, 1, noCol, true);
        if (newCell == null) {
            this.logInfo("startEditing() passed bad cell coordinates:" + [rowNum, colNum],
                "gridEdit");
        } else {
            this.logInfo("startEditing() using derived coordinates:"+ newCell, "gridEdit");
            rowNum = newCell[0];
            colNum = newCell[1];
        }
    }

    // Legal coordinates are
    // - any rowNum within the dataSet
    // - any rowNum for which we already have editValues (even if the record has not been saved)
    // - one rowNum past our last row (== this.getTotalRows()). In this case we'll be creating
    //   a new row on the end of the list.
    // Bail if the coordinates are not legal.
    
    if ((rowNum == null || rowNum < 0 || rowNum > this.getTotalRows()) ||
        (colNum == null || colNum < 0 || colNum > this.fields.length)) 
    {
        //>DEBUG
        // SuppressWarning param passed in when alwaysShowEditors is true and we blindly call
        // 'startEditing()' with no coordinates.
        // In this case we expect to fail to start the edit if there's no data or no visible,
        // editable cells.
        if (!suppressWarning) {
            this.logWarn("startEditing() passed bad cell coordinates:" + [rowNum, colNum] +
                        ", can't edit" + this.getStackTrace(), "gridEdit");
        }
        //<DEBUG
        return false;
    }

    if (!this.canEditCell(rowNum, colNum)) {
        //>DEBUG
        this.logInfo("startEditing(): cell " + [rowNum, colNum] +
                     " is non editable. Returning.", "gridEdit");
        //<DEBUG
        return false;
    }

    // at this point we have a valid cell to start editing.
    // If we're showing an editor, allow 'changeEditCell()' to handle saving out the
    // previous cell value, etc. - otherwise just call _startEditing() to start the edit
    // process
    if (this._editorShowing) {
        this._changeEditCell((eCe || isc.ListGrid.PROGRAMMATIC),
                             this.getEditRow(), this.getEditCol(), rowNum, colNum);
    } else {

        // Punt it over to _startEditing to handle the actual editing
        this._startEditing(rowNum, colNum, suppressFocus);
    }

    // return true to indicate editing has begun
    
    return true;
},

isEditingCell : function (rowNum, colNum) {
    return this._editorShowing && this.getEditRow() == rowNum && this.canEditCell(rowNum, colNum) &&
           (!this.editByCell || this.getEditCol() == colNum);
},


// _changeEditCell()
// Internal method used by both 'startEditing' and 'cellEditEnd' to complete editing one cell
// and start editing another.
// This method will fire user event / change handlers, and save out the edit values if
// appropriate.
// Falls through to _startEditing() to handle updating the display (hides this editor and shows
// the new one), and setting up the editValues for the new edit row.
_changeEditCell : function (editCompletionEvent, currentRowNum,
                            currentColNum, newRowNum, newColNum)
{
    // Note that the getEditValue() method will automatically pick up the current value
    // of the form item and store it in the edit-values
    // Note - this will fire the 'editorChange()' handler if the value has changed.
    var newValue = this.getEditValue(currentRowNum, currentColNum);

    // if we never fired 'editorEnter' avoid firing editor exit.
    
    var fieldName = this.getFieldName(currentColNum),
        editForm = this._editRowForm,
        editItem = editForm ? editForm.getItem(fieldName) : null,
        shouldFireEditorExit = editItem ? !editItem._cellEnterOnFocus : true
    ;
    if (editItem) {
        // If the edit item never got focused, the 'enterOnFocus' tags will still be present
        // just clean these up since we'll reset them if necessary (if focus goes back to the row)
        delete editItem._cellEnterOnFocus;
        delete editItem._rowEnterOnFocus;

        
        if (this._shouldParkFocus(editItem, currentRowNum, newRowNum, newColNum)) {
            this._parkFocus(editItem, currentColNum);
        }
    }

    // determine whether we need to validate or save on this cell transition
    // Use _getEditValues() - we already updated the editValue if necessary
    var leavingRow = (newRowNum != currentRowNum),
        newValues = this._getEditValues(currentRowNum, currentColNum);
        
    // Fire any developer defined handlers to fire when the user attempts to exit the edit cell
    // Stop if 'editorExit' handlers returned false.
    if (shouldFireEditorExit) {
        var editKilled = !this._handleEditorExit(editCompletionEvent,
                                                 currentRowNum, currentColNum, newValue);
        if (leavingRow && !editKilled) {
            editKilled = !this._handleRowEditorExit(editCompletionEvent, currentRowNum, newValues);
        }

        if (editKilled) {
            // If the editorExit handlers didn't already cancel this edit, or start a new one, force
            // focus back into the current edit field.
            // This is required as focus may not be in this form field
            
            if (editCompletionEvent == isc.ListGrid.EDIT_FIELD_CHANGE) {
                var newFieldName = this.getFieldName(newColNum);
                if (editItem && editForm.getItem(newFieldName).hasFocus) {
                    editItem.focusInItem();
                }
            }
            return false;
        }
    }
    
    
    var undef;
    if (newValue !== undef && !leavingRow && editItem && !this.editByCell) {
        var atomicVal = this._getEditValue(currentRowNum, currentColNum);
        var formattedVal = this._formatEditorValue(
                            atomicVal, this.getCellRecord(currentRowNum, currentColNum), 
                            currentRowNum, currentColNum);
        editItem.setValue(formattedVal);
    }
    
    var saveNow = (this.autoSaveEdits &&
                    ((leavingRow &&
                     this.shouldSaveOnRowExit(currentRowNum, currentColNum, editCompletionEvent)) ||
                     this.shouldSaveOnCellExit(currentRowNum, currentColNum, editCompletionEvent)));

    // The 'neverValidate' property effectively disables validation for form items.
    // Otherwise:
    // - If we're saving, we avoid validating here, since saving will auto-validate for us.
    // - otherwise perform cell or row validation based on this.validateByCell / this.autoValidate

    if (!saveNow && this._validationEnabled()) {
        var validationFailed,
            validateRow = leavingRow &&
                          this.shouldValidateByRow(currentRowNum, currentColNum, editCompletionEvent);
        // Note that if we're working with cellRecords we call validateCell() directly
        // if we should validate the row
        if (validateRow && !this.usingCellRecords) {
            validationFailed = !this.validateRow(currentRowNum);
        // If we're not validating the entire row, determine whether we should validate the
        // cell individually
        } else {
            if (validateRow ||
                this.shouldValidateByCell(currentRowNum, currentColNum, editCompletionEvent))
            {
                validationFailed = !this.validateCell(currentRowNum, currentColNum);
            }
        }

        // Suppress navigation if validation failed. No need to show error to user - already
        // handled by the validation methods.
        if (this.stopOnErrors && validationFailed) return false;
    }

    // At this point the old editor is still showing, but values have been updated, and
    // handlers fired.  Fall through to _startEditing to handle hiding this editor and showing
    // the new one.
    
    if (saveNow) {
        this._saveAndStartEditing(newRowNum, newColNum, editCompletionEvent);
    } else {
        // proceed immediately to next cell
        this._startEditing(newRowNum, newColNum);
    }

    // If the user changed the grouped value of an edit row, regroup.
    // Exception - if we're saving, locally, we will have already saved at this point, which
    // already handles regrouping.
    if (leavingRow && this.isGrouped && (!saveNow || !this.shouldSaveLocally())) {
        this._updateGroupForEditValueChange(currentRowNum);
    }
},

// If the user edits a grouped tree, and changes a value within the groupBy field we
// may need to regroup.
// Determine this from rowNum by looking at the current editValues / record values for the
// groupBy field[s] and the current position in the group tree.
//
// We call this when the user is done editing a row, so from
// - user moving from one edit row to another - _changeEditCell()
// - editor being dismissed - saveAndHideEditor()
//   [NB: that method doesn't actually save if autoSaveEdits is false]
// We do not call this if either of these actions tripped a local save since that
// occurs synchronously and handles regrouping automatically.


_updateGroupForEditValueChange : function (rowNum) {
    if (!this.isGrouped || !isc.isA.Tree(this.data)) return;
    var node = this.data.get(rowNum),
        groupNode = node,
        shouldRegroup = false;
    // passed a bad rowNum
    if (node == null) return;

    var groupFields = this.getGroupByFields();

    if (!isc.isAn.Array(groupFields)) groupFields = [groupFields];

    
    var curVals = this.getEditedRecord(rowNum,null, true);

    for (var i = groupFields.length-1; i >=0; i--) {
         var fieldName = groupFields[i],
            groupNode = this.data.getParent(groupNode);

        if (groupNode == null || groupNode.groupName != fieldName) {
            this.logWarn("error updating group for edit value change - unexpected group " +
                "tree structure. Regrouping.");
            shouldRegroup = true;
            break;
        }

        var value = curVals[fieldName],
            field = this.getUnderlyingField(fieldName);

        // trasnform raw value of the group field (potentially) 
        value = this._getGroupValue(value, curVals, field, fieldName);
        if (groupNode.groupValue != value) {
            shouldRegroup = true;
            break;
        }
    }

    if (shouldRegroup) {
        
        this._incrementalRegroup(node, node);
        this._remapEditRows();

        this.markForRedraw();
    }
    return shouldRegroup;
},


_shouldParkFocus : function (editItem, currentRowNum, newRowNum, newColNum) {
    
    if (!isc.Browser.isIE) return false;

    // If current focus is in a non-text-based item we don't need to park focus - selection
    // will update as appropriate.
    var textBasedFocusItem = (isc.isA.PopUpTextAreaItem(editItem) &&
                              // in a difficult-to-reproduce case, editItem._popupForm can end up
                              // undefined when hiding columns while editing.  This check
                              // prevents a JS error, but may still cause focus to skip
                              editItem._popupForm && editItem._popUpForm.hasFocus) ||
                             (editItem.hasFocus && isc.FormItem._textBasedItem(editItem));
    //if (!textBasedFocusItem) return false;

    // If we will not be removing the current item from the DOM, we don't need to park focus.
    
    if (!this.editByCell && newRowNum == currentRowNum) return false;

    // If the new item is text-based - no need to park focus
    var newEditorType =
        this.getEditorType(this.getField(newColNum), this.getCellRecord(newRowNum, newColNum));
    return !(newEditorType == null || isc.FormItem._textBasedItem(newEditorType, true));

},

// Internal method to unconditionally start editing a rowNum / colNum.
// This method will
//  - hide the current editor (if appropriate)
//  - set up edit values for the new cell
//  - show the editor for the new cell (and focus unless suppressFocus param passed)
// o Does not check for validity of rowNum / colNum
// o Does not save / modify pending edit values for some other cell/row
_startEditing : function (rowNum, colNum, suppressFocus) {
    
    if (rowNum == "delayed") {
        // we're firing from a timer for a delayed edit

        // another call to startEditing happened while we were waiting for the timer to fire,
        // and its params took precedence
        var params = this._delayedStartEditing;
        if (params == null) return;

        rowNum = params[0];
        colNum = params[1];
        suppressFocus = params[2];

        

    } else if (this.isDrawn() &&
                (!this.body.readyToRedraw() ||
                 (this.frozenBody && !this.frozenBody.readyToRedraw())))
    {
        // set a timer if we have not already set one, otherwise, just update the parameters
        // for the delayed edit
        if (!this._delayedStartEditing) {
            this.delayCall("_startEditing", ['delayed'],0);
        }
        this._delayedStartEditing = [rowNum, colNum, suppressFocus];
        
        return;
    }

    // we're starting editing now, we don't need the delayed edit params (the current
    // startEditing invocation overrides them)
    delete this._delayedStartEditing;

    // Remember which cell we're currently editing as the last "keyboard hilite" cell.
    // This ensures that if the user hides the editor, then re-displays it, editing
    // will recommence at the same spot.
    if (!suppressFocus) {
        this._lastKeyboardHiliteRow = rowNum;
        this._lastKeyboardHiliteCol = colNum;
        this._lastKeyboardHiliteBody = this.getFieldBody(colNum);
        // If we're selecting on edit, also update the "lastSelected" cell.
        // This can also be used in determining the "focusCell"
        
        if (this.selectOnEdit && this._lastKeyboardHiliteBody != null) {
            this._lastSelectedBody = this._lastKeyboardHiliteBody;
            this._lastSelectedBody._lastSelectedRow = rowNum;
            var bodyColNum = this.getLocalFieldNum(colNum);
            this._lastSelectedBody._lastSelectedCol = bodyColNum;
        }
    }


    var changingRow = this.getEditRow() != rowNum;

    // On a call to startEditing the current editRow / col, just put focus into the
    // field editor in question

    if (!changingRow && !suppressFocus && (this.getEditCol() == colNum)) {
        this.getEditForm().focusInItem(this.getEditorName(rowNum, colNum));
        return;
    }
    //>DEBUG
    this.logInfo("Starting editing at row " + rowNum + ", colNum " + colNum, "gridEdit");
    //<DEBUG

    // if we currently have an embedded editor showing, dismiss it
    if (this._openRecord != null) this.closeRecord();
    if (this._editorShowing) {
        // if we're changing rows, or only editing one cell at a time, hide the current editor,
        // as it has no overlap with the old editor
        if (this.editByCell || changingRow) {

            // hide the editor (but don't focus back in the body), and don't hide the CM as
            // we're about to show another editor.
            
            this.hideInlineEditor(false, true);
        }
    }



    // We're in a new edit flow if
    // - this._editingFlowID is null
    // - saveByCell is false
    // - we're editing a cell in a different row.
    // Otherwise this method is just showing the editor for a different cell
    
    var newEditFlow = (this._editingFlowID == null)  ||
                      changingRow ||
                      this.saveByCell;

    if (newEditFlow) {
        this._editingFlowID = this._getNextEditFlowID();
    }

    //this.logWarn("about to start editing, editValues for row: " + rowNum + " are now: " +
    //             this.echo(this.getEditValues(rowNum)));
    var record = this.getCellRecord(rowNum, colNum);
    if (record == Array.LOADING) {
        // DO not edit temporary 'loading' records
        return true;
    }

    // Set up initial empty edit vals
    
    var displayNewValues = this._editorShowing && (this.getEditRow() == rowNum)
    this.initializeEditValues(rowNum, colNum, displayNewValues, true);

    // At this point - we are definitely going to start editing the new row, and the editValues
    // have been set up.
    // If 'selectOnEdit' is true, select the row.
    
    if (this.selectOnEdit && record != null) this.selectRecordForEdit(record, rowNum, colNum);


    // ModalEditing (and edit event 'click') - in this case we show a click mask so won't
    // update rollovers when the user moves over other rows in the grid.
    // If they then click another record we'll start editing there, but never have cleared the
    // current 'over' row.
    // This can lead to the over styling getting left around until editing is complete.
    // Resolve this by explicitly clearing the hilite here:
    if (this.modalEditing) this.clearLastHilite();

    // If this is a new record, and 'addNewBeforeEditing' is true, we want to create the new
    // edit record BEFORE we start editing it - we do this via the standard 'saveEdits()'
    // method - this will save out the newly created editValues.
    // The save, which may be asynchronous, may modify the values of the saved record, setting
    // up default field values, etc.  We want to reflect these changes in the edit data for
    // the record.
    // Handle this by having a method _updateNewEditRowValues() update the edit values for the
    // row with the values taken from the record.
    // We continue to show the editor on the newly created row, either now, or if wait for save
    // is true, after the save occurs.
    if (record == null && this.addNewBeforeEditing) {
        // Hang onto the editRow / col, so we know what cell we're currently editing
        // This is usually done in 'showInlineEditor' but we need this for the saveEdits call
        // in this case
        this._editRowNum = rowNum;
        this._editColNum = colNum;
        var waitForSave = this.shouldWaitForSave();

        
        var callback = "this._updateNewEditRowValues(" + waitForSave + "," + suppressFocus + ")" ;
        this.saveEdits(isc.ListGrid.PROGRAMMATIC, callback);
        if (waitForSave) return;
        else {
            // The 'saveEdits()' call above may have changed the edit row's position.
            rowNum = this._editRowNum;
            colNum = this._editColNum;
        }
    }
    // - show the editor:
    //      - if the editor is showing for the same row, this will just focus
    //      - if another row, or editByCell, this will update the edit form, and show it in
    //        the right place
    // Note that 3rd param is always true - we'll be calling showInlineEditor to show the
    // same cell in this method.
    this.showInlineEditor(rowNum, colNum, true, changingRow, suppressFocus);

    // When showing editor the first time or when changing rows update rule context
    if (changingRow && !suppressFocus) this._provideEditRecordToRuleContext();

    // Set flag on row editSession to indicate editors have been shown for this record.
    // Used by ListGrid.hasBeenEdited().
    var editSession = this.getEditSession(rowNum, colNum);
    if (editSession) {
        editSession._editorsShown = true;
    }

    return true;

},

// Select the record about to be edited
selectRecordForEdit : function (record, recordNum, colNum) {
    // perf: avoid updating the row we're about to draw editors into anyway
    
    if (!this.editByCell) record._ignoreStyleUpdates = true;
    
    if (this.canSelectCells) {
        var cell = this.getRecordCellIndex(record, colNum);
        this.selectionManager.selectSingleCell(cell[0],cell[1]);
        this.fireSelectionUpdated();
    } else if (this.selectionManager != null && 
                        (!this.selectionManager.isSelected(record, recordNum) ||
                          this.selectionManager.multipleSelected()))
    {
        // we want a selection similar to select on mouse down: If we're using simple selection
        // select the record in addition to whatever else is selected - otherwise do a
        // single selection
        if (this.selectionType == isc.Selection.NONE) {
            // shouldn't see this as we disable selectOnEdit when selectionType is none
            this.logInfo("selectOnEdit is true, but this.selectionType is set to 'none'." +
                " Unable to perform a selection on edit.", "gridEdit");

        } else {
            var selectionType = this.getEditSelectionType();
            // Unlikely to see selection type set to "none" but if we do
            // treat it as we would selectOnEdit:false
            var selectionChange = true;
            if (selectionType == isc.Selection.NONE) {
                selectionChange = false;
            } else if (selectionType == isc.Selection.MULTIPLE) {
                this.selectionManager.select(record, recordNum);
            } else if (selectionType == isc.Selection.SIMPLE) {

                this.selectionManager.setSelected(
                    record, 
                    !this.selectionManager.isSelected(record, recordNum),
                    recordNum
                );
            // standard is to perform single selection
            } else {
                this.selectionManager.selectSingle(record, recordNum);
            }
            if (selectionChange) this.fireSelectionUpdated();
        }
    }
    delete record._ignoreStyleUpdates;

},

getEditSelectionType : function () {
    if (this.editSelectionType == null) {
        if (this.selectionType == isc.Selection.SIMPLE) {
            return isc.Selection.MULTIPLE;
        }
        return isc.Selection.SINGLE;
    } else {
        return this.editSelectionType;
    }
},

// For text-based editors, update selection on focus
// The behavior we want is:
// - if the user started editing via editOnKeyPress (they started typing in the cell), put focus
//   at the end of the value so they don't wipe out what they already typed
// - otherwise respect this.autoSelectEditors
// We achieve this via a temporary flag set when we start editing a cell via 'editOnKeyPress'
_updateEditorSelection : function (item) {
    // applies only to text items (and subclasses)
    if (!isc.isA.TextItem(item) && !isc.isA.TextAreaItem(item) &&
        !(isc.isA.TimeItem(item) && item.useTextField!=false) &&
        !(isc.isA.DateItem(item) && item.useTextField)) return;

    // set up when form item.refocusAfterRedraw() fires, and
    // when form.restoreFocusForClickMaskHide() fires.
    if ((item.form && item.form._suppressGridTextSelection) || item._suppressGridTextSelection) return;
    
    var inputItem = isc.isA.DateItem(item) ? item.dateTextField :
                    isc.isA.TimeItem(item) ? item.textField : item;
    var element = inputItem.getDataElement();
    if (!element) return;
    if (this._editorCursorAtEnd || !this.autoSelectEditors) {
        var val = element.value || "";
        inputItem.setSelectionRange(val.length, val.length);
        // Assertion: we only want this special behavior of putting the cursor at the end after
        // the first 'focus()' on the item the user typed in, so clear out the flag here
        delete this._editorCursorAtEnd;
    } else {
        if (inputItem._showingLoadingDisplayValue) {
            
            inputItem._selectAfterLoading = true;
        } else {
            inputItem.selectValue();
        }
    }
},

// Helper method to update the edit row values for the special case where we have saved out a
// new record before editing it due to 'addNewBeforeEditing'

_updateNewEditRowValues : function (showEditor, suppressFocus) {

    var rowNum = this._editRowNum,
        colNum = this._editColNum,
        record = this.getCellRecord(rowNum, colNum);

    if (record != null && record != "loading") {
        
        var values = this.getEditValues(rowNum, colNum);
        for (var i in record) {
            
            if (record[i] != null && values[i] == null) {
                values[i] = record[i];
            }
        }
    }

    if (showEditor) this.showInlineEditor(rowNum, colNum, true, true, suppressFocus);
    else this.updateEditRow(rowNum);
    // Note - no need to explicitly focus in the editor here - this will be handled by
    // showInlineEditor if we're showing a new editor - and if we're already showing the
    // editor we don't need to modify it's focus
},

//> @method listGrid.editField() (A)
//
//  Start editing a specific field.  This will save the current edit if appropriate.
//
//  @group  editing
//
//  @param  fieldName   (String)    Field to start editing
//  @param  [rowNum]  (number)  Optional row to start editing - if null defaults to the current
//                              edit row.
//  @return (boolean)   true if we are editing the cell, false if not editing for some reason
//
// @see canEditCell()
// @see editEvent
//<
editField : function (fieldName, rowNum) {
    // If this grid has not yet been drawn, this.fields may not have been set up yet
    if (this.completeFields == null) this.setFields(this.fields);

    var colNum;
    if (isc.isA.Number(fieldName)) colNum = fieldName;
    else colNum = this.fields.findIndex(this.fieldIdProperty, fieldName);
    if (rowNum == null) {
        rowNum = this.getEditRow();
        // It's legal to pass in no rowNum param, but if we're not already editing a row,
        // bail with a warning.
        if (rowNum == null) {
            this.logWarn("editField(): unable to determine which row to edit - returning.",
                        "gridEdit");
            return;
        }
    }
    // Fall through to startEditing() to handle performing the edit.
    return this.startEditing(rowNum, colNum);
},

// create or update the editForm to reflect the editable and visible fields around the given
// coordinate, and show editors.
// Focuses in the target cell unless suppressed.
// internal: assumes we are logically set up to edit this row (editValues created)
// Application developers would call 'startEditing()' instead of this method

// this method is also responsible for firing editorEnter handlers when focus goes to the
// new edit cell - handled by setting up a flag to be checked by the form item's focus()
// handler.
showInlineEditor : function (rowNum, colNum, newCell, newRow, suppressFocus) {
    // This method is called in the following circumstances:
    // - we need to re-set focus to the current edit cell (example: setFields, redraw of body, etc)
    // - we need to move focus to a new cell that is already showing (called from startEditing())
    // - The editor is currently hidden and we need to show it (and put focus into the
    //   appropriate cell).
    // It is not expected to be called when the editor is currently showing for another
    // row (or for editByCell grids, another cell) - this method should not have to handle
    // hiding the edit form just showing it (if necessary) and assigning focus.
    //
    // NOTE: if we're doing full-row editing and the editForm is already showing, we assume the
    // current edit field's value has already been updated / saved by 'startEditing' call
    // whenever appropriate.
    if (this._editorShowing) {
        // Catch the case where we're showing the edit form for another row
        if (rowNum != this.getEditRow() || (this.editByCell && colNum != this.getEditCol())) {
            this.logWarn("Unexpected call to 'showInlineEditor' during another edit " +
                         "- cancelling previous edit", "gridEdit");
            this.cancelEditing();
            this.startEditing(rowNum, colNum);
            return;
        }
    }
    // Set a flag to note that we're in the process of setting up the editor.
    // This will avoid infinite loops if showInlineEditor is called directly from
    // anything called by this method - EG: the redraw triggered by scrolling the
    // cell into view
    
    if (this._settingUpEditor && this._settingUpEditor[rowNum] == rowNum
        && this._settingUpEditor[colNum] == colNum)
    {
        return;
    }
    this._settingUpEditor = [rowNum,colNum];
    
    var suppressScroll = (this.suppressEditScrollIntoView || suppressFocus ||
                          
                          (this.ns.EH._handlingTouchEventSequence() &&
                           (isc.EH.getTarget() == this.getEditForm()))
                          );
                          
    this.logDebug("showing inline editor at: " + [rowNum, colNum] +
                  ", will focus: " + !suppressFocus, "gridEdit");                          

    
    var scrollBeforeShowing = this.body && (!this.body.shouldShowAllColumns() || !this.body.showAllRows);
    if (scrollBeforeShowing && !suppressScroll) {
        // set scrollRedrawDelay to zero before scrolling into view. This ensures that the body will
        // be marked dirty instantly if a redraw is required, which in turn makes sure we set up the
        // correct set of form items
        var srd = this.body.scrollRedrawDelay;
        this.body.scrollRedrawDelay = 0;
        this.scrollToCell(rowNum, colNum, "left", "top");
        this.body.scrollRedrawDelay = srd;
    }

    // If we're showing the rollOver canvases, clear them now
    var refRollOverCanvas = this.currentRollOverCanvas || this.currentRollUnderCanvas;
    if (refRollOverCanvas != null && refRollOverCanvas._currentRowNum == rowNum) {
        this.updateRollOverCanvas(refRollOverCanvas._currentRowNum,
                                  refRollOverCanvas._currentColNum, true);
    }

    var forceRedraw;

    // Do we need to show or update the edit form?
    
    var updateEditItems = !this._editorShowing;
    if (!updateEditItems) {
        var items = this.getEditForm().items,
            drawnFields = this.getDrawnFields();
        if (items.length != drawnFields.length) updateEditItems = true;
        else {
            for (var i = 0; i < items.length; i++) {
                if (items.find("name", drawnFields[i].name) == null) {
                    updateEditItems = true;
                }
            }
        }
    }

    if (updateEditItems) {
        // create or update the editForm used to display editors for the fields.
        var rebuiltForm = this.makeEditForm(rowNum, colNum);
        if (this._alwaysShowEditors() && rebuiltForm) {
            // if the edit form items actually changed (rather than just having
            // new properties applied to them in place), we'll need a full redraw
            // since the inactiveHTML currently written into all other rows will
            // not be associated with the new set of live items
            this.logInfo("Edit Form rebuilt with alwaysShowEditors:true, requires full redraw",
                         "inactiveEditorHTML");
            forceRedraw = true;
        }
    }
    // If the user is shifting focus forward we want to focus "at the start" of the
    // edit item, otherwise at the end, if supported.
    
    var focusAtEnd = this._editColNum != null && (colNum < this._editColNum);

    // Update the remembered editColNum
    this._editRowNum = rowNum;
    this._editColNum = colNum;

    // Also update the stored "lastRecordClicked".
    // This is used for keyboard navigation when the editor isn't showing.
    // Setting this will ensure that we don't mysteriously jump to whatever was previously
    // recorded as the last record clicked once the editor is dismissed and the user hits
    // the up or down arrow key
    
    this._lastRecordClicked = rowNum;

    // write the editor form items into the DOM
    this._showEditForm(rowNum, colNum, forceRedraw);

    // Clear the settingUpEditor flag here
    
    this._settingUpEditor = null;

    
    if (updateEditItems) this._startTrackingEditFieldUpdates();

    // Ensure the edit cell is visible in the viewport
    
    if (this.body && !suppressScroll) {
        var mustScroll;
        if (!scrollBeforeShowing) mustScroll = true;
        else {
            var body = this.body,
                rowTop = body.getRowTop(rowNum),
                rowHeight = body.getRowSize(rowNum),
                scrollTop = body.getScrollTop(),
                portHeight = body.getViewportHeight();
            mustScroll = (rowTop < scrollTop) || (rowTop + rowHeight > scrollTop + portHeight);
        }
        if (mustScroll){
            this.scrollToCell(rowNum, colNum, "left", "top");
        }
    }

    // Don't show the click mask, or focus in the form item if we're not drawn.
    if (!this.isDrawn()) {
        return;
    }
    this._showEditClickMask();
    var focusItemName = this.getEditorName(rowNum, colNum),
        focusItem = this._editRowForm.getItem(focusItemName);
    // focusItem should be present since we've just scrolled it into view, but perform
    // check for safety anyway
    if (focusItem == null) {
        this.logWarn("ListGrid showing inline editor. Unable to get a pointer to the edit " +
                        "form item for field:"+ focusItemName);
    } else {

        // If this is a shift to a new cell, we'll want to fire editorEnter.
        // If a new row, we'll want to fire rowEditorEnter.
        // [Otherwise this method could be a refresh / refocus of current edit cell]
        

        
        if (newCell) focusItem._cellEnterOnFocus = true;
        if (newRow) focusItem._rowEnterOnFocus = true;
        // focus in the field being edited if appropriate
        if (!suppressFocus) {
            if (isc.Browser.isMoz) {
                
                var handle = this.body.getClipHandle(),
                    beforeFocus = handle.scrollTop;
            }

            
            var lastEvent = isc.EH.lastEvent;
            var delayFocus = false;
            if (isc.Browser.isIE && lastEvent.eventType == isc.EH.MOUSE_DOWN) {
                var target = lastEvent.target;
                if (target != this._editRowForm) {
                    delayFocus = true;
                    var ciCanvii = this._editRowForm.getCanvasItemCanvii();
                    for (var i = 0; i < ciCanvii.length; i++) {
                        if (ciCanvii[i] == target || ciCanvii[i].contains(target)) {
                            delayFocus = false;
                            break;
                        }
                    }
                }
            }
            
            if (isc.Browser.isIE) {
                var focusParkForm = isc.ListGrid._focusParkForm;
                if (focusParkForm &&
                    (focusParkForm.hasFocus || focusParkForm.itemHasFocus())) delayFocus = true;
            }

            
            if (isc.Browser.isSafari && this.alwaysShowEditors) {
                delayFocus = true;
            }

            if (delayFocus) {
                var item = this._editRowForm.getItem(focusItemName);
                this._delayedFocusEvent = item.delayCall("focusAtEnd", [!focusAtEnd]);

            } else {
                
                if (isc.Browser.isMoz && this.body.overflow == isc.Canvas.VISIBLE) {
                    this.adjustOverflow();
                }
                var item = this._editRowForm.getItem(focusItemName);
                item.focusAtEnd(!focusAtEnd);
            }
        }
    }
},

// Write the editor form items into the cells in the ListGrid body, by redraw or refresh
// Re-evaluates canEditCell(), so may hide editors or show new editors.
// Internal: purely a helper to showInlineEditor
_showEditForm : function (rowNum, colNum, forceRedraw) {
    var editorWasShowing = this._editorShowing;
    this._editorShowing = true;
    if (!this.isDrawn() || !this.body) return;
    
    if (!editorWasShowing) this.updateEditFormTabPosition();

    // The edit form has been created, and we need to show its items in the DOM.
    // 3 cases to catch:
    //  - Some edit form items are already showing for the edit row:
    //     If editByCell is false, it's possible that the 'canEditCell' criteria have changed
    //     for some currently visible edit cells.
    //     Need to refresh any cells where this is the case to show / hide form items.
    //  - No edit form items are showing
    //    - if the edit row is beyond the end of the list, we need to redraw the body to
    //      display the new edit row.
    //    - Otherwise for each cell where canEditCell is true, we must refreshCell() to write
    //      the form item into the DOM.

    // If we're showing the editor for a new edit row at the end of the list that's not currently
    // in the DOM redraw the body
    // Note: if this._editorShowing was true at the start of this method, we know we're
    // editing a new cell in the current edit row (_startEditing will hide the inline editor
    // if we're editing a different row). In this case we only need to redraw the body if it's
    // already been marked as dirty.

    
    var newRow = this.isEmpty() ||
                 (!editorWasShowing &&
                    (rowNum >= this.data.getLength()) &&
                    (this.shouldShowNewRecordRow() ||
                     
                     (this.body.getTableElement(rowNum) == null)));

    // If we're showing embedded component(s) for the row force a redraw
    // This'll place them properly
    
    var record = this.getCellRecord(rowNum,colNum);
    if (record && this._hasEmbeddedComponents(record)) {
        
        //forceRedraw = true;
    }

    // clear out any formitem._hadFocusBeforeRedraw flags under the edit form
    if (this._editRowForm) this._clearCachedEditItemFocus(this._editRowForm);

    // figure out which cells are going to show editors now.
    this._cacheCurrentEditCells();

    if (forceRedraw || newRow || this.isDirty() || this.body.isDirty() ||
        (this.frozenBody && this.frozenBody.isDirty()) ) {
        
        var redrawTarget = this.isDirty() ? this : 
                            (this.bodyLayout ? this.bodyLayout : this.body);
        
        this._inShowEditForm = true;
        redrawTarget.redraw("Showing editor");        
        delete this._inShowEditForm;
        return;
    }

    // Drawing of edit items can trip a server fetch to pick up optionDataSource data
    // use a queue to minimize client-server transactions where possible
    
    var wasQueuing = isc.RPCManager && isc.RPCManager.startQueue();
    
    // Set the flag to avoid refreshCell / refreshRow calling 'canEditCell()' unnecessarily
    this._inShowEditForm = true;

    // otherwise, editor is showing for the same row
    if (this.editByCell) {

        // We need to refresh the entire row if
        // - frozenFields is non null -- this ensures the height of the row in both
        //   bodies matches
        // - we're using explicit tall vs normal base style -- ensure we switch to tall base
        //   style while the editor is showing
        var refreshRow = (this.frozenFields != null) || (this.baseStyle == null);
        // editing by cell - just refresh the edit cell to show the editor.
        if (refreshRow) this.refreshRow(rowNum);
        else this.refreshCell(rowNum, colNum);

    } else {
        // editing whole row - draw editors into the currently visible cells

        

        // use getDrawnFields() to retrieve the set of drawn fields (takes care of frozen fields and
        // incremental rendering)
        var fields = this.getDrawnFields();
        // Check the 'canEdit' status of each cell in the edit row and refresh to show (or hide)
        // editors as appropriate.

        var changedItemVisibility = false;
        for (var i = 0; i < fields.length; i++) {
            if (this.isCheckboxField(fields[i])) continue;
            var field = fields[i],
                fieldName = fields[i][this.fieldIdProperty],
                formItem = this._editRowForm.getItem(fieldName),
                colNum = formItem.colNum,
                
                formItemVisible = !!(editorWasShowing && formItem.isDrawn()),
                canEditCell = this._shouldShowEditCell(rowNum, colNum);
  
            if (formItemVisible != canEditCell) {
                
                formItem._gridRefresh = true;


                this.refreshCell(rowNum, colNum);
                delete formItem._gridRefresh;
                changedItemVisibility= true;
            }
            // For cells we are not redrawing, we need to update the cellStyle if:
            // - This is the last over row - need to clear the current 'over' style since we
            //   will not be showing  rollovers for the edit row.
            // - ensure the row shows up in the 'selected' state if selectOnEdit is true
            else if (this.selectOnEdit || this.lastOverRow) {
                var body = (field.frozen && !this._suppressedFrozenFields) ? this.frozenBody : this.body;
                body._updateCellStyle(this.getCellRecord(rowNum, colNum), rowNum, colNum);
            }
        }
        // If we have variable row heights and frozen fields, we may need to refresh the
        // special "rowHeightSpacer" cells
        
        if (changedItemVisibility && this.frozenFields &&
            !this.fixedRecordHeights &&
            this.matchFrozenRowHeightsApproach == "rowHeightSpacerHTML") 
        {
        
        
        var frozenRow = this.frozenBody.getTableElement(rowNum),
            frozenSpacerCell = frozenRow 
                            ? frozenRow.cells[this.frozenFields.length] : null,
            unfrozenRow = this.body.getTableElement(rowNum),
            unfrozenSpacerCell = unfrozenRow 
                            ? unfrozenRow.cells[this.fields.length
                                         - this.frozenFields.length] : null,
            record = this.getCellRecord(rowNum, colNum);
        
        if (frozenSpacerCell) {
            frozenSpacerCell.innerHTML = 
                this.frozenBody._getRowHeightSpacerCellValue(record, rowNum);
        }
        if (unfrozenSpacerCell) {
            unfrozenSpacerCell.innerHTML = 
                this.body._getRowHeightSpacerCellValue(record, rowNum);   
        }
        
                
            var frozenRow = this.frozenBody.getTableElement(rowNum),
                frozenSpacerCell = frozenRow 
                        ? frozenRow.cells[this.frozenFields.length] : null,
                unfrozenRow = this.body.getTableElement(rowNum),
                unfrozenSpacerCell = unfrozenRow 
                        ? unfrozenRow.cells[this.fields.length - this.frozenFields.length] 
                        : null,
                record = this.getCellRecord(rowNum, colNum);
            if (frozenSpacerCell) {
                frozenSpacerCell.innerHTML = 
                    this.frozenBody._getRowHeightSpacerCellValue(record, rowNum);
            }
            if (unfrozenSpacerCell) {
                unfrozenSpacerCell.innerHTML = 
                    this.body._getRowHeightSpacerCellValue(record, rowNum);
            }
        }
    }

    delete this._inShowEditForm;

    if (!wasQueuing && isc.RPCManager) isc.RPCManager.sendQueue();
    
},

// Helper to locally cache the array of cells that will be shown in edit mode, as
// determined by considering editByCell or 'canEditCell()' status for each cell in the
// edit row.

_cacheCurrentEditCells : function (rowNum,colNum) {
    var editRowNum = this._editRowNum;
    // If we were passed an explicit cell to consider, simply cache it's current
    // "canEditCell" status (useful for calls to 'refreshCell()' to show or hide a single
    // edit item)
    if (rowNum != null && colNum != null) {
        // Don't wipe the current cache if it exists
        if (!this._currentEditCells) this._currentEditCells = [];
            
        var canEdit = (rowNum == editRowNum) && this.canEditCell(rowNum, colNum),
            currentIndex = this._currentEditCells.findIndex([rowNum,colNum]);
        if (canEdit) {
            if (currentIndex == -1) {
                this._currentEditCells.add([rowNum, colNum]);
            }
        } else {
            if (currentIndex != -1) {
                this._currentEditCells.removeAt(currentIndex);
            }
        }

    // Default behavior - remember all the cells that will show an editor
    } else {
        this._currentEditCells = [];
        var rowNum = this._editRowNum;
        if (rowNum != null) {
            if (this.editByCell) {
                this._currentEditCells[0] = [this._editRowNum, this._editColNum];
            } else {
                for (var i = 0; i < this.fields.length; i++) {
                    if (colNum == this._editColNum || this.canEditCell(rowNum, i)) {
                        this._currentEditCells.add([rowNum, i]);
                    }
                }
            }
        }
    }
},

// Should we write out edit-item HTML for this cell - uses the
// cache set up in cacheCurrentEditCells()

_shouldShowEditCell : function (rowNum, colNum) {
    
    if (this._editorShowing && this._currentEditCells == null) {
        
        return this._editorShowing && rowNum == this._editRowNum && this.canEditCell(rowNum,colNum);
    }
    return (this._editorShowing && rowNum == this._editRowNum &&
            (this._currentEditCells.findIndex([rowNum,colNum]) != -1));
},





_clearCachedEditItemFocus : function (canvas) {
    // if canvas is form, clear flag from items
    if (isc.isA.DynamicForm(canvas)) {
        var items = canvas.items;
        if (items) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                delete item._hadFocusBeforeRedraw;
                // recurse to handle canvas for a canvasItem
                if (isc.CanvasItem && isc.isA.CanvasItem(item)) {
                    this._clearCachedEditItemFocus(item.canvas);
                }
            }
        }
    }
    // look at tree under canvasItem canvas for DF
    var children = canvas.children;
    if (children) {
        for (var i = 0; i < children.length; i++) {
            this._clearCachedEditItemFocus(children[i]);
        }
    }
},

// initialize/clear edit field tracking map
_startTrackingEditFieldUpdates : function () {
    var editForm = this._editRowForm;
    
    if (editForm) editForm._updatedFields = {};
},

// clear out the edit field tracking map
_stopTrackingEditFieldUpdates : function () {
    var editForm = this._editRowForm;
    
    if (editForm) editForm._updatedFields = null;
},

// We have form items' tab index driven by their parent form, but 
// we are rendering the items inside a different containerWidget here.
// Explicitly shift the form in the Tab-Tree under our body so the
// order behaves as you'd expect.

updateEditFormTabPosition : function () {
    isc.TabIndexManager.moveTarget(this._editRowForm.ID, this.body.ID, 0);
},

// show the clickmask to catch clicks outside the editors, which means we're done editing
// the row (and should save) if this.modalEditing is true.

_showEditClickMask : function () {

    //!DONTCOMBINE
    // only show the C.M. if this.modalEditing is true.
    if (!this.modalEditing) {
        // Note - if a hover is showing, or pending on the body, clear it now.
        
        if (this.canHover) this.stopHover();
        return;
    }

    // if the editRowForm CM is already up, no need to show it.
    if (!this._editRowForm.clickMaskUp()) {
        if (!this._editClickMaskFunction)
            this._editClickMaskFunction =
                isc._makeFunction(this.getID() + "._handleClickOutsideEditor()");

        var unmasked = [this._editRowForm];
        if (isc.ListGrid._focusParkForm != null) {
            unmasked.add(isc.ListGrid._focusParkForm);
        }

        this._editRowForm.showClickMask(this._editClickMaskFunction,
                                    // If this.stopOnErrors is true, always cancel the
                                    // 'mouseDown' that dismisses the clickMask.
                                    // [technically this should only be required if there
                                    //  actually *are* errors, but since errors may come
                                    //  back from an async save it's appropriate to always
                                    //  cancel here].
                                    (this.stopOnErrors ? isc.EH.SOFT_CANCEL : isc.EH.SOFT),
                                    // pass in the editForm to ensure that the form items
                                    // are not masked
                                    unmasked);
    }
},

//> @method listGrid.editExistingRecord() (A)
// Start inline editing at a record identified by criteria. If the criteria matches more than
// one record, the first matched record is edited. Additionally, if the record to be edited is 
// not visible, the record will be scrolled into view.
// <p>
// Note that the record to be matched must already be loaded in the grid - no fetch will be
// performed.
//
// @group  editing
//
// @param  [criteria]  (Criteria) Criteria identifying the existing row to edit
//
// @see startEditing()
// @visibility external
//<
editExistingRecord : function (criteria) {
    if (!this.isDrawn()) {
        this.logWarn("An existing record cannot be edited because the grid is not drawn");
        return;
    }
    // Find matching records using Grid's DataSource if applicable
    var ds = this.getDataSource(),
        data = (isc.isAn.Array(this.data) ? this.data :
                (isc.isA.Tree(this.data) ? this.data.getAllNodes() :
                this.data.getAllCachedRows())),
        matchedRecords
    ;
    if (ds) {
        matchedRecords = ds.applyFilter(data, criteria);
    } else {
        // Note that this filter does not handle date comparisons correctly because there
        // is no schema to indicate date fields.
        matchedRecords = isc.DS.applyFilter(data, criteria);
    }
    if (!matchedRecords || matchedRecords.length == 0) {
        this.logWarn("no loaded record was found to match criteria. edit request ignored.");
        return;
    }

    // Found record to edit. Always edit the first matched record if multiple
    var record = matchedRecords[0];

    // Make sure record is visible because all parent nodes are open
    var data = this.data;
    if (isc.isA.Tree(data)) {
        var parents = data.getParents(record);
        if (parents) {
            data.openFolders(parents);
        }
    }

    // Scroll to record if not in view
    var rowNum = this.getRowNum(record),
        visibleRows = this.getVisibleRows()
    ;
    if (rowNum <= visibleRows[0] || visibleRows[1] <= rowNum) {
        this.scrollToRow(rowNum);
    }

    // Edit the matched record
    this.startEditing(rowNum);
},

//> @method ListGrid.stopHover()
// Notification that the user is no longer hovering over some cell. Hides the current hover canvas
// if one is showing.
// @visibility external
//<
// Implemented at the Canvas level. Gets called on mouseOut.

stopHover : function () {
    if (this._editorShowing && isc.EH.getTarget() == this.getEditForm()) return;
    return this.Super("stopHover", arguments);

},

// shouldWaitForSave()
// Should we block user interactions during save, or allow the user to keep editing.
// If this function returns true, we wait for a save to return successfully before moving to
// a new edit cell, or hiding the current editor.
// This depends on this.waitForSave, and this.stopOnErrors.
// Note that we can't really support stopOnErrors = true / waitForSave = false, as we will not
// know if we have validation errors from server logic until a save has completed (performing
// a server round trip), and stopOnErrors implies we want to leave the editor up (as well as
// alerting the error messages).
shouldWaitForSave : function () {
    if (this.stopOnErrors && !this.waitForSave) {
        var message =
            "Note: ListGrid initialized with 'waitForSave' false, and 'stopOnErrors' true." +
            " In this case user input will be be blocked during save, to allow server side " +
            " errors to be determined before the editor is hidden. Setting 'waitForSave' to true.";

        // Log this at the info level rather than the warning level unless waitForSave has
        // explicitly been set to 'false', as it is very likely to occur
        if (this.waitForSave == false) this.logWarn(message, "gridEdit");
        else this.logInfo(message, "gridEdit");

        // actually update 'waitForSave' -- this will avoid us showing this log repeatedly
        // when this method is run.
        // Note - if we want to support modifying these values on the fly
        // ("setStopOnErrors" / "setWaitForSave") we will have to take this modification into
        // account too.
        this.waitForSave = true;
    }

    
    return !!(this.waitForSave || this.stopOnErrors);
},

// Hide the editor(s) for the current edit row.  Internal

hideInlineEditor : function (focusInBody, suppressCMHide, shiftFocus) {
    // focusInBody is intended to restore focus to the body after hiding the (focused) editor
    // Therefore check for whether the body or the edit form currently has focus and only
    // refocus if so
    if (focusInBody) {
        if (!this.hasFocus && !(this.body && this.body.hasFocus) &&
            !(isc.ListGrid._focusParkForm && isc.ListGrid._focusParkForm.hasFocus))
        {
            var editForm = this.getEditForm();
            if (editForm == null) {
                focusInBody = false;
            } else if (!editForm.hasFocus) {
                // focus may be in a CanavsItem canvas [or descendant thereof]
                // force focus in body if the current focus target is a child of our
                // body.
                
                var focusCanvas = isc.EH.getFocusCanvas();
                if (!focusCanvas || !this.body || !this.body.contains(focusCanvas)) {
                    focusInBody = false;
                }
            }
        }
    }

    
    if (isc.Browser.isFirefox) {
        var editForm = this.getEditForm();
        if (editForm != null) {
            var item = editForm.getFocusItem();
            if (item != null && item.hasFocus) {
                var element = item._getCurrentFocusElement();
                if (element && element.blur) element.blur();
            }
        }
    }

    // - clear out the flags marking the editor as being visible
    // - If we're showing the editor for a new temporary edit row, who's values have been
    //   cleared, but we're still showing the row in the DOM, redraw the body to clear the row
    //   from the DOM
    // - otherwise call 'refreshCell()' for each cell currently showing a form item to clear
    //   it from the DOM.

    // If we aren't currently editing a row, no-op
    if (!this._editorShowing) return false;

    
    this._editorShowing = null;

    // clear _editorSelection flag - ensures we don't inappropriately refocus in the edit form
    // after redraw if we subsequently re show the editor.
    this._editorSelection = null;

    var editRow = this._editRowNum,
        editField = this._editColNum;
    this._editRowNum = this._editColNum = null;

    

    // ensure that the clickmask gets taken down after edit
    // We suppress this step when we're hiding an editor, then reshowing - for example on
    // ListGrid redraw / cell navigation.
    
    if (!suppressCMHide) this._editRowForm.hideClickMask();

    // At this point, if we have edit values for the row, but they match the underlying
    // data values, just drop them.
    
    if (this.getEditValues(editRow, editField) != null &&
        (!this._savingEdits || !this._savingEdits[this.getEditValuesID(editRow, editField)]) &&
        !this.recordHasChanges(editRow, editField, null, false) &&
        // recordHasChanges will return false for a row that has been submitted
        // (save not yet completed), without further edits. In this case we of course want
        // to retain the edit vals
        !this.hasSubmittedEditValues(editRow, editField) &&
        // clearing edit values drops removed flag. Unlikely to really hit this
        // case on a removed record since it's non interactive so won't show an editor, but
        // sanity check that the record isn't marked for removal before clearing edit vals
        !this.recordMarkedAsRemoved(editRow) &&
        // Don't clear edit values if we have outstanding errors
        !this.rowHasErrors(editRow, editField))
    {
        this.logInfo("hideInlineEditor for row with no edits - dropping edit values", "gridEdit");
        // Don't hang onto the empty edit values for the row
        this._clearEditValues(editRow, editField);
    }

    if (!suppressCMHide) {
        this._provideEditRecordToRuleContext();
    }

    this._stopTrackingEditFieldUpdates();

    if (!this.body) return true;

    // update the visible cells.  Now that editRow/Field is unset, they'll revert to normal
    // display.  NOTE: don't bother updating if we're already slated to redraw the body
    
    var editForm = this._editRowForm;

    if (editForm.hasFocus) {
        editForm.blur();
    }
    if (isc.Browser.isIE) {
        var focusItem = editForm.getFocusSubItem(),
            unconfirmedBlur = isc.EH._unconfirmedBlur;
        if (editForm.hasFocus ||
            (unconfirmedBlur &&
                ((unconfirmedBlur == editForm) || (isc.EH._unconfirmedBlur.form == editForm)) ) )
        {
            
            focusItem.elementBlur();

            // Another artifact of IE's asynchronous focus handling behavior is that
            // if 'blur()' is called on a text item, then the item is cleared from the DOM
            // before onblur fires, and 'focus()' is called on another item in the DOM, when the
            // user hits a key, focus will be pulled from the new focus item for no good reason.
            // We work around this here by putting focus in the 'focus park form'.
            
            this._parkFocus(focusItem, editField);
        }
    }

    

    // If we're showing embedded component(s) for the row force a redraw
    // This'll place them properly
    
    var record = this.getCellRecord(editRow,editField),
        forceRedraw = false;
    if (record && this._hasEmbeddedComponents(record)) {
        forceRedraw = true;
    }

    // if focusItem is a canvasItem, blur it and interior items
    
    if (editForm != null) {
        var item = editForm.getFocusItem();
        if (isc.CanvasItem && isc.isA.CanvasItem(item)) {
            this._blurCanvasItemforEditorHide(item);
        }
    }

    if (!this.body.isDirty() && (!this.bodyLayout || !this.bodyLayout.isDirty()) &&
        !this.isDirty())
    {
        if (forceRedraw || editRow >= this.getTotalRows()) {
            var widget = this.bodyLayout || this.body;
            widget.markForRedraw("Editor Hidden");
        } else {
            if (this.editByCell) {
                var refreshRow = (this.frozenFields != null) || (this.baseStyle == null);
                if (refreshRow) this.refreshRow(editRow);
                else this.refreshCell(editRow, editField);
            }
            else this.refreshRow(editRow);
            
            // force a refresh of the group-summary row if one is showing.
            
            this.refreshGroupSummary(editRow);
        }
    }

    if (focusInBody) {

        if (shiftFocus != null) {
            // shiftFocus: This would come from a Tab/Shift+Tab keypress -- in this case
            // move focus forward to the next focusable widget.
            
            isc.TabIndexManager.shiftFocusAfterGroup(this.body.getID(), 
                (shiftFocus > 0 ? true : false));
        } else {
            // return focus to the body
            // -- ensure we don't editOnFocus via the 'suppressEditOnFocus' flag
            //    (will get cleared out by _focusChanged on the body)
            
            this._suppressEditOnFocus = true;
            
            this.body.focus();
        }
    }

    // Editor is hidden so it cannot have focus
    this._provideEditFocusToRuleContext(null);
    
    this.markForRedraw();

    return true;
},


_blurCanvasItemforEditorHide : function (canvasItem) {

    // if canvasItem's canvas doesn't have focus, get the focusCanvas from the EventHandler
    
    var canvas = canvasItem.canvas;
    if (canvas && !canvas.hasFocus) canvas = isc.EH.getFocusCanvas();

    while (canvas != null) {
        // blur the focusItem of any form
        
        if (isc.isA.DynamicForm(canvas)) {
            canvas.blurFocusItem(true);
        }
        // blur the focused canvas
        if (canvas.hasFocus) canvas.blur();

        // if we're at the root canvasItem, we're done
        var item = canvas.canvasItem;
        if (item == canvasItem) return;

        // otherwise, chain to parent canvas or canvasItem
        canvas = item ? item.form : canvas.parentElement;
    }

    // we should always reach the root canvasItem!
    
},

_parkFocus : function (focusItem, editField) {
    
    
    if (isc.isA.TextItem(focusItem) || isc.isA.TextAreaItem(focusItem) ||
        isc.isA.PopUpTextAreaItem(focusItem))
    {
        var focusParkForm = isc.ListGrid._focusParkForm;

        // If the hidden text item we use for managing focus doesn't exist, create it
        // here.
        if (!focusParkForm) {
            focusParkForm = isc.ListGrid._focusParkForm = isc.DynamicForm.create({

                // Ensure that if this gets destroy'd we also clear up the pointer to it
                pointersToThis:[{object:isc.ListGrid, property:"_focusParkForm"}],
                getFocusParkItem : function () {
                    return this.getItem(0);
                },
                autoDraw:false,
                _redrawWithParent:false,
                ID:"_ListGrid_focusParkForm",
                _generated:true,
                selectOnFocus:true,
                tabIndex:-1,
                numCols:1,
                items:[
                    {name:"focusPark", type:"text", title:isc.nbsp,
                        // Suppress all key event handling - this will avoid the user from
                        // being able to tab out of this focus parking form (temporarily
                        // putting focus somewhere else on the page)
                        handleKeyPress:function(){return false;}
                    }
                ],
                width:1, height:1, overflow:isc.Canvas.HIDDEN,
                
                itemHasFocus : function () {
                    var item = this.getFocusParkItem();
                    if (item.hasFocus) return true;
                    if (isc.Browser.isIE && this.isDrawn() && this.isVisible() &&
                        (this.getActiveElement() == this.getFocusParkItem().getFocusElement()))
                            return true;
                    return false;
                },
                redraw : function () {
                    var forceRefocus = false;
                    //this.logWarn("redrawing fpf");
                    if (this.itemHasFocus()) forceRefocus = true;
                    this.Super("redraw", arguments);
                    if (forceRefocus) this.focusInItem(this.getFocusParkItem());
                },
                // If the clickMask gets shown / hidden while the focus is parked
                // don't manipulate focus / store as the current "masked focus target"
                // If we don't do this, we can get bugs whereby we 'park' focus while
                // the clickMask is up, then when the clickMask hides, focus gets put
                // back in the focus-park form rather than being left alone
                
                _ignoreClickMaskFocus:true
            })
        }

        // We'll position the form under the target cell
        // Avoids any unexpected native scrolling issues with focus change.
        if (focusParkForm.isVisible()) focusParkForm.hide();

        focusParkForm.moveTo(
            Math.max(this.body.getPageLeft(), this.getColumnPageLeft(editField)),
            this.getPageTop() + Math.min(
                ((this.showHeader ? this.getHeaderHeight() : 0) + this.getRowTop(this.getEditRow())
                        - this.body.getScrollTop()),
                this.getScrollHeight()-1
            )
        );

        focusParkForm.sendToBack();
        // focusParkForm must be visible to receive focus
        focusParkForm.show();

        // If we're showing the edit clickMask, unmask the focusParkForm wrt that so we don't
        // dismiss the editor when it receives focus
        
        if (this._editRowForm.clickMaskUp()) focusParkForm.unmask(this._editRowForm.getID());

        // Put focus into the text item.
        focusParkForm.getFocusParkItem().focusInItem();

        // Ensure the editRowForm is aware it doesn't have focus any more
        
        focusItem.form.hasFocus = false;
    }
},


// Create inline editing form and items
// --------------------------------------------------------------------------------------------

// create a DynamicForm for inline editing.  This form manages FormItems embedded in GR cells,
// but does not actually draw them.
// It's up to the calling function to handle displaying these edit form items in the DOM.
updateEditorItemsInPlace:true,

makeEditForm : function (rowNum, colNum) {
    var record = this.getCellRecord(rowNum, colNum),
        // get the values for the form
        
        values = this.getEditDisplayValues(rowNum, colNum),
        updateItemsInPlace = false
    ;
    // If we're already showing an edit form and the set of editable fields
    // hasn't changed we may be able to update the items in place (changing just
    // rowNum, colNum, record, valueMap, etc) rather than performing a full
    // setItems(...) with new items on the DynamicForm
    // If 'alwaysShowEditors' is true this is going to mean we can avoid a full
    // redraw, since the currently drawn inactiveEditorHTML for other records in
    // the grid will already point to the existing form items and have appropriate
    // 'inactiveEditorContext' set allowing us to respond to events properly
    if (this._editRowForm != null) {
        if (this.updateEditorItemsInPlace) {
            updateItemsInPlace = true;

            var editFields = this.editByCell ? [this.getField(colNum)] : this.getDrawnFields();
            if (editFields) {
                if (editFields.length != this._editRowForm.getItems().length) {
                    updateItemsInPlace = false;
                } else {
                    for (var i = 0; i < editFields.length; i++) {
                        var editField = editFields[i],
                            fieldName = this.getEditorName(rowNum, editField),
                            liveItem = this._editRowForm.getItem(fieldName);

                        if (liveItem == null ||
                            (this.getEditorType(editField, values) !=
                            this._editRowForm.getEditorType(liveItem)))
                        {
                            updateItemsInPlace = false;
                            break;
                        }
                    }
                }
            }
        }
        if (updateItemsInPlace && editFields) {
            var widths = this.getDrawnFieldWidths(record, editFields);

            for (var i = 0; i < editFields.length; i++) {
                var editField = editFields[i],
                    editColNum = this.getColNum(editField),
                    fieldName = this.getEditorName(rowNum, editField),
                    liveItem = this._editRowForm.getItem(fieldName),
                    record = this.getRecord(rowNum),
                    editedRecord = this.getEditedRecord(rowNum),
                    props = this.getEditItem(editField, record, editedRecord,
                                            rowNum, editColNum, widths[i], true);
                liveItem.setProperties(props);
                liveItem._size = null;
                if (editField.frozen) {
                    liveItem.containerWidget = this.frozenBody;
                } else {
                    liveItem.containerWidget = this.body;
                }
            }

        } else {
            // get currently visible items
            var items = this.getEditRowItems(record, rowNum, colNum, this.editByCell);

            // just update the items array and current values if the form already exists
            //this.logWarn("rebuilding editRowForm");// + this.getStackTrace());
            this._editRowForm.setItems(items);
        }
        this._editRowForm.setValues(values);

    } else {
        var items = this.getEditRowItems(record, rowNum, colNum, this.editByCell);
        // create the editForm.  Done once only per grid lifetime
        var properties = isc.addProperties({},
            this.editFormDefaults, {
            // keep track of the listGrid
            grid:this,
            // Editor form shares same ruleScope as grid to support formulas
            ruleScope:this.ruleScope,
            // Edit form should not populate the shared context (i.e. DS.<fields>)
            _populateSharedRuleContext:false,

            
            dataPath:this.dataPath,
            
            showErrorIcons:this.showErrorIcons,
            
            // Override hasFieldErrors/getFieldErrors: 
            // We don't apply the validation errors directly
            // to the form but we do need this method to return the appropriate errors
            // if showErrorStyle etc gets set to true for the item itself
            hasFieldErrors : function (fieldName) {
                var grid = this.grid;
                if (grid) {
                    var item;
                    if (isc.isAn.Object(fieldName)) {
                        item = fieldName;
                        fieldName = item.name;
                    }
                    var rowNum = this._determineRowNum(item || fieldName);
                    return grid.cellHasErrors(rowNum, fieldName);
                }
                return this.Super("hasFieldErrors", arguments);
            },
            getFieldErrors : function (fieldName) {
                var grid = this.grid;
                if (grid) {
                    var item;
                    if (isc.isAn.Object(fieldName)) {
                        item = fieldName;
                        fieldName = item.name;
                    }
                    var rowNum = this._determineRowNum(item || fieldName);
                    return grid.getCellErrors(rowNum, fieldName);
                }
                return this.Super("getFieldErrors", arguments);
            },
            
            addFieldErrors : function (fieldName, errorMessage, showErrors) {
                var grid = this.grid;
                if (grid) {
                    var item;
                    if (isc.isAn.Object(fieldName)) {
                        item = fieldName;
                        fieldName = item.name;
                    }
                    var rowNum = this._determineRowNum(item || fieldName);
                    return grid.addFieldErrors(fieldName, errorMessage, showErrors, rowNum);
                }
                return this.Super("addFieldErrors", arguments);                
            },
            _determineRowNum : function (fieldName) {
                var grid = this.grid;
                var item;                    
                // handle being passed the item rather than the fieldName                   
                if (isc.isAn.Object(fieldName)) {
                    item = fieldName;
                    fieldName = item.name
                } else {
                    item = this.getItem(fieldName);
                }
                var rowNum;
                // Determining the rowNum: we need to handle the standard
                // case (getting HTML for the edit row) and the case where we're
                // writing out inactive editor HTML [used for 'alwaysShowEditors']
                                
                if (item && item._retrievingInactiveHTML) {
                    var context = item.getInactiveContext(item._currentInactiveContext);
                    rowNum = context.rowNum;
                } else {
                    rowNum = grid.getEditRow();
                }
                return rowNum;
            },

            // pass it this widget's datasource too
            dataSource:this.dataSource,
            // suppressAllDSFields - this ensures that if we are created without any
            // specified items we *won't* pick up all the DS fields as items by default.
            // useful for alwaysShowEditors case / recordEditors where the editForm may
            // be created *before* draw so getEditRowItems returns an empty array - in 
            // this case we'll update with the correct items when draw occurs.
            suppressAllDSFields:true,

            autoComplete:this.autoComplete,
            uniqueMatch:this.uniqueMatch,
            // Avoid autoFocus - we explicitly focus and blur when appropriate.
            autoFocus:false,

            // Override _useDisplayFieldValue to avoid using the display field if
            // displayValueFromRecord is false
            _useDisplayFieldValue : function (field) {
                if (!this.Super("_useDisplayFieldValue", arguments)) return false;
                
                var gridField = field != null ? this.grid.getSpecifiedField(field.name) : null;
                if (gridField && gridField.displayValueFromRecord === false) return false;
                return true;
            },

            // Override focus change methods on edit form to provide current
            // focus field in ruleScope
            setFocusItem : function (item) {
                this.Super("setFocusItem", arguments);
                this.grid._provideEditFocusToRuleContext(this.isFocused() ? item : null);
            },
            clearFocusItem : function () {
                this.Super("clearFocusItem", arguments);
                this.grid._provideEditFocusToRuleContext(null);
            },
            
            // setting alwaysManageFocusNavigation to true ensures that 
            // a tab-keypress will be intercepted and passed to the TabIndexManager
            // shiftFocus() API rather than relying on standard native tab-order navigation.
            // This is required to allow us to perform a cellEditEnd() and shift edit-focus
            // to the next cell in the grid.
            // We achieve this by reacting to the undocumented 'tabGroupExit' event 
            // at the item level and doing the appropriate thing.
            // This allows arbitrary custom editing UI to be used in grid editing provided
            // the documented recommendations about intercepting tab key events and 
            // checking TabIndexManager.useExplicitFocusNavigation(...) / calling
            // TabIndexManager.shiftFocus(...) are followed.
            alwaysManageFocusNavigation:true,
            
            // Override _restoreFocusForClickMaskHide to avoid interfering with
            // normal text-field selection
            _restoreFocusForClickMaskHide : this._editForm_restoreFocusForClickMaskHide

            
            //items:items,
            //values:values

        }, this.editFormProperties);

        if (this.dateFormatter != null && properties.dateFormatter == null) {
            properties.dateFormatter = this.dateFormatter;
        }
        if (this.datetimeFormatter != null && properties.datetimeFormatter == null) {
            properties.datetimeFormatter = this.datetimeFormatter;
        }
        if (this.timeFormatter != null && properties.timeFormatter == null) {
            properties.timeFormatter = this.timeFormatter;
        }

        
        properties.disableUnboundCacheSync = true;
        this._editRowForm = isc.DynamicForm.create(properties);

        this._editRowForm.setLocatorParent(this, "editRowForm", "_editRowForm");

        this._editRowForm.setItems(items);
        this._editRowForm.setValues(values, true);
    }

    if (this.logIsDebugEnabled("gridEdit")) {
        this.logDebug("editRowForm created with values: " +
                      this.echo(this._editRowForm.getValues()), "gridEdit");
    }
    
    // The return value will indicate whether we actually rebuilt the form
    // (as opposed to just modifying the existing items in place)
    // We use this to determine whether a full redraw is required in the
    // alwaysShowEditors case
    return !updateItemsInPlace;
},

//> @method listGrid.getEditForm() [A]
// Method to retrieve the live edit form for an +link{listGrid.canEdit,editable} ListGrid.
// This is the automatically generated DynamicForm used to manage the per field edit items.
// <P>
// Note that this is an advanced method and developers should be aware of the following issues:
// <ul><li>The edit form is only present while the user is actually editing a record and this
// method will return null if no editor is currently showing.</li>
// <li>Live edit items may be retrieved by calling <code>getItem(<i>someFieldName</i>);</code>
// but items are only created for fields that are visible and being written out into the grid.
// This means with +link{showAllColumns} set to false an item may not be created until the
// user scrolls the column in question into view</li>
// <li>The editForm's values are managed by the ListGrid through the edit-values subsystem.
// If you want to change an edit value for a field, call +link{listGrid.setEditValue()} and the
// grid will handle updating the value in the live item if necessary. You should not need to call
// <code>setValue();</code> directly on the form or item and doing so will not always update the
// edit value for the grid.
// </li></ul>
// In general - bear in mind that this is an advanced usage and if there is an equivalent API
// available on the ListGrid it is always preferable to use that.
// @return (DynamicForm) the live edit form, or null if the grid is not currently showing any editors.
// @visibility internal
//<
// currently unexposed - getEditFormItem() is much more likely to be needed.
getEditForm : function () {
    return this._editorShowing ? this._editRowForm : null;
},


// These helpers are required to allow rowNum / colNum based edit values management
// rather than fieldName based valuesManagement.


//> @method listGrid.getEditFormItem() [A]
// Method to retrieve a live edit form item for an +link{listGrid.canEdit,editable} ListGrid.
// This is the automatically generated editor displayed in a cell while editing the grid.
// <P>
// Note that this is an advanced method and developers should be aware of the following issues:
// <ul><li>Edit form items are created automatically as necessary and their lifecycle is
// managed by the grid. Items may be created or destroyed as a result of fields being
// shown and hidden, horizontal scrolling with +link{showAllColumns,incremental rendering},
// row or cell transitions, configuration changes, and other circumstances.
// This method will return null when an item is not present.<br>
// Developers should therefore be aware that:
//  <ul><li>There may not be a live item for a field while a cell is not currently editable and 
//   visible to the user.</li>
//  <li>The item returned from a call to <code>getEditItem()</code> can become invalid
//   as the user interacts with a grid. Even if the user is currently editing the field in 
//   question, this method may return a different live item if invoked later in the
//   application flow. Therefore application code should avoid holding onto references 
//   to the items returned by this method, and instead invoke the method directly
//   to dynamically retrieve the current edit item as required.</li>
//  <li>If you change configuration of an edit item created by the grid, your changes will
//   be lost if the item is destroyed and re-created</li>
//  </ul>
// </li>
// <li>EditFormItems can be thought of as +link{group:autoChildren}. They should be configured via
// +link{listGridField.editorProperties}  (or +link{listGridField.editorProperties} for the
// +link{listGrid.showFilterEditor,filter editor} edit items), rather than by setting properties
// on the live items directly.
// <li>The items' values are managed by the ListGrid through the edit-values subsystem.
// If you want to change an edit value for a field, call +link{listGrid.setEditValue()} and the
// grid will handle updating the value in the live item if necessary. You should not need to call
// <code>setValue();</code> directly on the item and doing so will not always update the
// edit value for the grid.
// </li></ul>
// In general - bear in mind that this is an advanced usage and if there is an equivalent API
// available on the ListGrid it is always preferable to use that.
// @param field (String | Integer) fieldName or colNum to get the edit item for.
// @return (FormItem) the live edit item for the current edit row and specified field, or null if the grid is not currently showing any editors.
// @visibility external
//<
// NOTE: this differs from getEditItem() - it's retrieving an existent item in the edit form
// for a cell -- not retrieving the properties to create a form item object
getEditFormItem : function (colNum) {

    var editForm = this.getEditForm();
    if (!editForm) return null;
    // getEditorName() already handles being passed a fieldName or colNum
    var fieldName = this.getEditorName(this.getEditRow(), colNum),
        item = editForm.getItem(fieldName);
    // sanity check - if item.colNum != the colNum passed in assume the editorName is reused for
    // multiple fields
    if (!isc.isA.Number(colNum) || (item && item.colNum == colNum)) return item;
},

getEditFormValue : function (colNum) {
    var item = this.getEditFormItem(colNum);
    return (item ? item.getValue() : null);
},

// helper: sets edit form items to latest editValues (including reverting to original record
// values if editValues have been cleared)
// Called from setEditValues()
_updateEditItemValues : function () {
    if (!this._editRowForm) return;

    var rowNum = this.getEditRow(), colNum = this.getEditCol(),
        values = this.getEditDisplayValues(rowNum, colNum);
    this._editRowForm.setValues(values);
},


// Helper method to get all the values for the edit form at once
getEditDisplayValues : function (rowNum, colNum, dontCheckForChanges) {
    var editValues = dontCheckForChanges ? this._getEditValues(rowNum, colNum) 
                                        : this.getEditValues(rowNum, colNum),
        record = this.getCellRecord(rowNum, colNum),
        values = {};
    if (record != "loading") {
        for (var fieldName in record) {
            values[fieldName] = record[fieldName];
        }
    }
    
    for (var fieldName in editValues) {
        values[fieldName] = editValues[fieldName];
    }

    for (var fieldName in values) {
        var fieldNum = this.getFieldNum(fieldName);
        // call the edit formatter (if defined) for all visible cells
        if (fieldNum >=0 && this._formatEditorValue != null) {
            values[fieldName] = this._formatEditorValue(values[fieldName], record, rowNum, fieldNum);
        }
    }

    return values;
},

// Method to get the horizontal space available for the form items for each column
// (Note this is not a 1:1 mapping to form items, as not every field is editable, and we
// incrementally create form items for columns as they are rendered out)
// Overridden by TreeGrid to account for indentation in tree field.
getEditFormItemFieldWidths : function (record) {
    var widths = [];
    for (var i =0; i<this.fields.length; i++) {
        var colNum = this.getLocalFieldNum(i),
            field = this.fields[i],
            body = (!this._suppressedFrozenFields && field.frozen) ? this.frozenBody : this.body;
        widths[i] = body.getInnerColumnWidth(colNum);
    }
    return widths;
},

//> @method listGrid.getEditorValueMap()  ([A])
//
//  Returns the valueMap to display for a field when it is displayed in the editor while
//  editing some record.<br>
//  Called when a user starts to edit a field, or whenever the field valueMap is updated via
//  a call to +link{listGrid.setValueMap()} or +link{listGrid.setEditorValueMap()}.
//  Default implementation will return the <code>field.editorValueMap</code> if specified, otherwise
//  <code>field.valueMap</code> - can be overridden to provide a
//  different specific valueMap for some field based on the record/field data.
//
//  @group  editing
//
//  @param  field   (ListGridField)    field definition field for which we need a valueMap
//  @param  values  (Object)    Field values for record being edited. Note that this will include
//                              the current edit values for fields that have not yet been saved.
//                              May be null, if editing a new record.
//  @return         (ValueMap)  ValueMap for the edit field (or null if no valueMap required)
//  @visibility external
//<

//> @method listGridField.getEditorValueMap()
// Optional stringMethod to get a +link{listGridField.valueMap} for a specific field.
// If present this method will be called from +link{listGrid.getEditorValueMap()} and the resulting
// valueMap will be used instead of any static specified valueMap for the field.
// @param values (Object) Field values for record being edited. Note that this will include
//                        the current edit values for fields that have not yet been saved.
//                        May be null, if editing a new record.
// @param field (ListGridField) pointer to the listGridField
// @param grid (ListGrid) pointer back to this ListGrid instance.
// @return (ValueMap) ValueMap for the field (or null if no valueMap required)
// @visibility external
//<

// Undocumented "item" parameter - this is used to catch the case where a custom
// 'getEditorProperties()' implementation supplied an explicit valueMap
getEditorValueMap : function (field, values, item) {

    
    if (item && item._dynamicPropsValueMap != null) {
        return item._dynamicPropsValueMap;
    }

    if (field.getEditorValueMap != null) {
        
        isc.Func.replaceWithMethod(field, "getEditorValueMap", "values,field,grid");
        return field.getEditorValueMap(values,field,this)
    }
    
    if (field.editorValueMap != null) {
        return field.editorValueMap;
    }
    if (field.editorProperties && field.editorProperties.valueMap) {
        return field.editorProperties.valueMap;
    }
    return field.valueMap;
},


//> @method listGrid.getEditorValueIcons()
// Returns the valueIcons for a field when it is displayed in the editor while editing some
// record. Default implementation will return +link{ListGridField.editorValueIcons} if specified
// otherwise +link{ListGridField.valueIcons}
// @param field (Object) field definition
// @param values (Object) current edit values for the record
// @return (Object) valueIcons for the editor
// @visibility external
// @group imageColumns
//<
getEditorValueIcons : function (field, values) {
    return  field.editorValueIcons || field.valueIcons;
},

//> @method listGrid.getEditorValueIconWidth()
// Returns the width for any valueIcon for a field when it is displayed in the editor
// while editing some record.<br>
// Returns +link{listGridField.editorValueIconWidth} if specified - otherwise
// +link{listGridField.valueIconWidth} or +link{listGridField.valueIconSize}
// @param field (Object) field definition
// @return (number) width for the value icon to show in the editor
// @visibility internal
// @group imageColumns
//<
// Don't return listGrid.valueiconWidth / size - this is just a default and likely to break
// form items with standard valueIconSizes, such as checkboxes.
getEditorValueIconWidth : function (field) {
    if (field.editorValueIconWidth != null) return field.editorValueIconWidth;
    return (field.valueIconWidth != null ? field.valueIconWidth : field.valueIconSize);
},

//> @method listGrid.getEditorValueIconHeight()
// Returns the height for any valueIcon for a field when it is displayed in the editor
// while editing some record.<br>
// Returns +link{listGridField.editorValueIconHeight} if specified - otherwise
// +link{ListGridField.valueIconHeight} or +link{listGridField.valueIconSize}
// @param field (Object) field definition
// @return (number) height for the value icon to show in the editor
// @visibility internal
// @group imageColumns
//<
getEditorValueIconHeight : function (field) {
    if (field.editorValueIconHeight != null) return field.editorValueIconHeight;
    return field.valueIconHeight != null ? field.valueIconHeight : field.valueIconSize;
},

//> @method listGrid.setEditorValueMap() ([A])
//
// Set a valueMap to display for this field while editing.<br>
// This method sets the +link{ListGridField.editorValueMap, field.editorValueMap} property -
// note that if  +link{ListGrid.getEditorValueMap()} has been overridden it may not make use
// of this property.
// @group editing
// @param  fieldID  (Object | number | FieldName)  field object, number, or name
// @param  map      (Object)                       ValueMap to apply to the field
// @visibility external
//<
setEditorValueMap : function (fieldID, map) {
    var fieldNum = this.getColNum(fieldID),
        field = this.getField(fieldID),
        fieldName = field[this.fieldIdProperty];
    field.editorValueMap = map;
    if (this._editorShowing) {
        var rowNum = this.getEditRow(),
            editRecord = this.getEditedRecord(rowNum, fieldNum);
        
        var editItem = this._editRowForm.getItem(fieldName);
        if (editItem) delete editItem._dynamicPropsValueMap;
            
        // Apply the valueMap to the edit form field - note that we retrieve it via the
        // getter method in case it has been overridden.
        this._editRowForm.setValueMap(fieldName, this.getEditorValueMap(field, editRecord));
    }

},

//> @method listGrid.getEditorType()  ([A])
//
//  Returns the form item type (Class Name) to display for a field when it is displayed in the
//  editor while editing some record.<br>
//  Default implementation will return field.editorType if specified.
//  If not specified, the default form item for the appropriate data type will be displayed
//  - can be overridden to provide a different specific form item type for some field based on
//  the record/field data.
//
//  @param  field   (ListGridField)    field definition field for which we need a valueMap
//  @param  values  (Object)    current edit values for the record (may be null, if editing a
//                              new record)
//  @return         (String)  form item type for the edit field
//
//  @group editing
//  @see getEditorProperties
//  @visibility external
//<
getEditorType : function (field, values) {

    var isNewRecord = values == null || isc.isAn.emptyObject(values);
    if (!isNewRecord && this.getDataSource() != null) {
        var keyFieldNames = this.getDataSource().getPrimaryKeyFieldNames();
        for (var i = 0; i < keyFieldNames.length; i++) {
            if (values[keyFieldNames[i]] == null) {
                isNewRecord = true; 
                break;
            }
        }
    }
    var idx = isNewRecord ? -1 : this.getRecordIndex(values);
    
    // determining type: editorProperties, being most specific, wins.  Otherwise
    // field.editorType, otherwise, you get the default editor picked
    // for field.type (which is the field's *data* type, not editor type).
    // NOTE: editorProps.type will always refer to the form item type, not the data type.
    // NOTE: "formItemType" is a legacy synonym of "editorType"
    
    var props = this.getEditorProperties(field, values, idx);
    var editorProperties = isc.addProperties({}, field, field.editorProperties, props);

    // Use the static method on DynamicForm to get the editorType for this field.
    // Pass this ListGrid in as a parameter so the method can examine
    // this.longTextEditorThreshold and this.longTextEditorType.
    return isc.DynamicForm.getEditorType(editorProperties, this);
},

//> @method listGrid.getEditorProperties()
// Get the default properties for editor form items displayed while editing some field.
// Overriding this method allows developers to dynamically customize the form item displayed in
// an editable grid, based on the cell being edited.
// <P>
// Note: you should set +link{formItem.editorType,editorType} in the returned properties to
// control the type of form item that is used.
// 
// @param field (ListGridField) field whose properties are needed
// @return      (Object) default properties for the field
//
// @see getEditorType
// @visibility external
//<
// Overridden in RecordEditor


getEditorProperties : function (editField, editedRecord, rowNum) {
    return isc.addProperties({}, this.editorProperties, editField.editorProperties);
},

//> @method listGrid.getEditRowItems()  (IA)
//
//      Given a record to edit, return an appropriate array of dynamicForm item init blocks
//
//  @group  editing
//
//  @param  record  (Object)    Record to be edited
//  @param  rowNum  (number)    index of the row being edited
//  @param  fieldNum (number)   index of the field on which the 'startEditing' occurred (typically
//                              used as a focus field)
//  @return         (Array)     Array of DynamicForm item object instantiation blocks
// @visibility internal
//<
// Note: if editByCell is false, and we're incrementally rendering, we only create form items
// for the visible set of fields.

getEditRowItems : function (record, rowNum, fieldNum, singleCell) {
    var body = this.body;
    // if we haven't created the body yet, don't create any form items - they'll get set up
    // at draw, and updated at redraw.
    if (body == null) return [];

    // The set of fields for the form is basically this.fields, with some custom properties, such
    // as 'editorType'
    var firstEditable, lastEditable,
        widths = [],
        items = [];

    var editedRecord = this.getEditedRecord(rowNum, fieldNum);

    // create an array of the fields we want to work with
    var editFields;
    if (singleCell) editFields = [this.getField(fieldNum)]
    else editFields = this.getDrawnFields();

    widths = this.getDrawnFieldWidths(record, editFields);
    if (editFields != null) {
        for (var i = 0; i < editFields.length; i++) {

            // (Set up each item as a property-value map)
            
            
            var colNum = this.getColNum(editFields[i]);
            var item = this.getEditItem(editFields[i], record, editedRecord, rowNum, colNum, widths[i])
            if (item == null) continue;

            items[items.length] = item;
        }
    }
    return items;

},

getDrawnFields : function () {

    if (!this.body) return null;

    var drawnFields = [], body = this.body;
    var ff = this.frozenFields, fLeft = this.freezeStart();

    if (ff && fLeft) {
        // this assumes that we are not dealing with incremental column rendering of frozen
        // fields (should be true as not scrollable)
        drawnFields.addList(ff);
    }

    var firstVisible, lastVisible;
    
    if ((body._firstDrawnCol == null) || !body.isDrawn() || body.isDirty() || body._redrawing) {
        var drawnRange = body.getDrawArea();
        firstVisible = drawnRange[2];
        lastVisible = drawnRange[3];
    } else {
        firstVisible = body._firstDrawnCol;
        lastVisible = body._lastDrawnCol;
    }
    if (ff && fLeft) {
        firstVisible += ff.length;
        lastVisible += ff.length;
    }
    for (var i = firstVisible; i <= lastVisible; i++) {
        drawnFields.add(this.fields[i]);
    }

    if (ff && !fLeft) {
        drawnFields.addList(ff);
    }
    return drawnFields
},

getDrawnFieldWidths : function (record, fields) {
    // Allow the developer to pass in the fields to return widths for
    if (!fields) fields = this.getDrawnFields();

    if (!fields) return null;
    // apply the width from the fieldWidths array
    var completeWidths = this.getEditFormItemFieldWidths(record),
        widths = [];
    for (var i = 0; i < fields.length; i++) {
        widths[i] = completeWidths[fields[i].masterIndex];
    }
    return widths;
},

// getEditItem()
// returns an individual property block for edit-form form item.

// Helper methods to be applied to pop up text area items to specially process keydown and
// keypress events.  Fired in the scope of the pop up text area

_popUpTextAreaItemKeyPress : function (item, keyName, characterValue) {
    return this.grid.editorKeyPress(this, keyName, characterValue);
},
_popUpTextAreaItemKeyDown : function (item, keyName, characterValue) {
    return this.grid.editorKeyDown(this, keyName, characterValue);
},

// On focus in a pop up text area item, ensure that we have updated the current edit cell info.
// This handles the case where we got no elementFocus on the PUTA directly - happens if the
// PUTA has no focusable element itself.

_popUpTextAreaItemFocus : function () {
    var form = this.form, lg = this.grid,
        rowNum, colNum, fieldName, fieldChanged;
    if (lg._editorShowing) {
        rowNum = lg._editRowNum;
        // don't worry about editByCell case- for the pop up textareaitem to have got focus we
        // must have already shown it, meaning we must already know which field is being edited
        if (!lg.editByCell) {
            rowNum = lg._editRowNum;
            fieldName = this.getFieldName(),
            colNum = lg.fields.findIndex(lg.fieldIdProperty, fieldName);

            fieldChanged = (lg._editColNum != colNum);
            // If the user has clicked in another field in the edit form, fire editField on
            // the appropriate field
            if (fieldChanged) {
                // store the new edit cell
                lg.setNewEditCell(rowNum, colNum);
                // fire 'cellEditEnd' to save / validate before moving to the new cell
                lg.cellEditEnd(isc.ListGrid.EDIT_FIELD_CHANGE);

            }
        }
    }
},

_getPopUpTextAreaTop : function () {
    var grid = this.grid,
        fieldName = this.getFieldName(),
        rowNum = grid.getEditRow(),
        style = grid.getCellStyle(grid.getRecord(rowNum), rowNum, grid.getColNum(fieldName)),
        rowTop = grid.getRowPageTop(rowNum) +
                 isc.Element._getTopBorderSize(style) + isc.Element._getTopPadding(style);
    return rowTop;
},

_checkboxClick : function (a,b,c,d) {
    if (!this.hasFocus) {
        var lg = this.grid;
        lg.setNewEditCell(this.rowNum, this.colNum);
        lg.cellEditEnd(isc.ListGrid.EDIT_FIELD_CHANGE);
        // and force cellEnterOnFocus, so when the (delayed) focus
        // handler fires, we get a cellEnter
        this._cellEnterOnFocus = true;
    }
    return this.Super("handleClick", arguments);
},



// handleEditorChanged()
// Fired when the changed() handler fires for any of our edit items.
// Allows us to perform validation on change
handleEditorChanged : function (item) {
    
    if (this._drawingItem == item) return;
    var fieldName = item.getFieldName(),
        field = this.getField(fieldName),
        validateOnChange;
    
    if (field && field.validateOnChange != null) validateOnChange = field.validateOnChange;
    else validateOnChange = this.validateOnChange;
    
    var rowNum = this.getEditRow();
    if (rowNum == null || rowNum != item.rowNum) {
        return;
    }

    if (validateOnChange) {

        // Note: we don't always update the editValue for the cell when the change handler
        // fires on the edit item - instead we usually update when the user moves to a new cell.
        // However, validateCell(), like most other APIs that interact with the editValues,
        // will update the edit value for the cell if it's stale before performing validation.
        this.validateCell(rowNum, fieldName, false, true);

    // We support form items changing their value after they've lost focus - EG:
    // delayed "Tab" autoComplete for databound comboBoxItems.
    // In this case if we're validating or saving by cell we need to perform an update now
    // (as we won't get an editor exit event to react to).
    } else if (!item.hasFocus && !this.editByCell) {

        if (item.isDrawn() && item.isVisible()) {

            this.storeUpdatedEditorValue(false, item.colNum);

            if (this.saveByCell && this.autoSaveEdits) {
                // Essentially we're saving for the same reason as if the user had
                // taken focus from the field.
                var editCompletionEvent = isc.ListGrid.EDIT_FIELD_CHANGE;
                this.saveEdits(editCompletionEvent, null, rowNum, item.colNum);
            } else if (this.validateByCell) this.validateCell(rowNum, fieldName);

        }
    } else {

        // Update the ruleContext
        var contextValues = {};
        contextValues[fieldName] = item.getValue();
        this._provideEditRecordToRuleContext(contextValues);
    }
},

// Override for the (internal) handleChanged method so we can be notified when the
// user changes an edit cell's form item value.
_editorHandleChangedOverride : function (a,b,c,d) {
    
    this.invokeSuper(null, "handleChanged", a,b,c,d);

    if (!this.destroyed) this.grid.handleEditorChanged(this);

},

_editorGetAutoComplete : function () {
    var grid = this.grid;
    // This would imply something like a destroyed form item - so just ignore it.
    if (!grid) return null;

    var field = grid.getField(this.getFieldName());
    if (field.autoComplete != null) return field.autoComplete;
    if (grid.autoComplete != null) return grid.autoComplete;
    return this.Super("_getAutoCompleteSetting", arguments);
},


_timeEditorTypes:{time:true, TimeItem:true},
_$time:"time",
_dateEditorTypes:{date:true, DateItem:true},
_datetimeEditorTypes:{datetime:true, dateTime:true, DatetimeItem:true, DateTimeItem:true},
_$date:"date",
_$datetime:"datetime",

popUpTextAreaEditorTypes:{popUpTextArea:true, PopUpTextAreaItem:true},
_checkboxEditorTypes:{checkbox:true, CheckboxItem:true},
_$boolean:"boolean",
_$checkbox:"checkbox",
_$CycleItem:"CycleItem",
_selectEditorTypes:{select:true, SelectItem:true},


_commonEditorStringMethodsFromField:["change", "changed", "defaultDynamicValue"],
_commonEditorStringMethods:["change", "changed", "defaultDynamicValue",
                            "keyPress", "click",
                            // Not sure if showIf / enableIf would be set on editors - more
                            // likely to set canEdit:false for the cell
                            "showIf", "enableIf"],
// getEditItem()
// returns a config block for an item to be displayed in the edit form.
// 'updateOnly' parameter implies we're going to take the returned properties and
// apply them to an existing form item, so no need to include standard handlers
// or properties that wouldn't be applied to a live item such as editorType

getEditItem : function (editField, record, editedRecord, rowNum, colNum, width, updateOnly) {
    var item = {};

    item.width = width;
    // Hang some properties onto the form item so keypress handers (etc.) written onto
    // the form item can readily access details about the edit:
    item.record = record;
    item.rowNum = rowNum;

    item.colNum = colNum;

    // the error icons will be written directly into the form item (so no need to
    // adjust the size of the edit item to account for them).

    // Set the "name" of the item
    var fieldName = this.getEditorName(rowNum, editField);
    item[this.fieldIdProperty] = fieldName;

    // Also copy the dataPath across if present
    var dataPath = this.getEditorName(rowNum, editField, true);
    if (dataPath && dataPath != fieldName) {
        item.dataPath = dataPath;
    }

    // copy the title (won't be visible but needed for ARIA)
    if (editField.title != null) item.title = editField.title;
    // Use the accessor function to get the valueMap for the item
    // This allows override of visible options on a per cell basis
    // Note that we pass in the edit values, rather than the record's saved values - we want
    // the valueMap to update as edits are performed
    
    
    item.valueMap = this.getEditorValueMap(editField, editedRecord);
    // if "multiple" is set on the field, apply it directly to the item.
    // Of course if multiple were set on the DataSource field it'd get picked up by the item
    // automatically.
    if (editField.multiple != null) item.multiple = editField.multiple;

    if (editField.disabled != null) item.disabled = editField.disabled;

    // If the field has a specified optionDataSource, pass that through to the editor too,
    // along with the valueField / displayField properties
    
    
    if (editField.valueField != null) item.valueField = editField.valueField
    if (editField.displayField != null) item.displayField = editField.displayField
    if (editField.optionDataSource) item.optionDataSource = editField.optionDataSource
    if (editField.optionFilterContext) item.optionFilterContext = editField.optionFilterContext
    if (editField.optionCriteria) item.optionCriteria = editField.optionCriteria
    if (editField.optionOperationId != null) item.optionOperationId = editField.optionOperationId;

    
    if (editField.escapeHTML     != null) item.escapeHTML     = editField.escapeHTML;

    var skipLineBreaks = this.shouldSkipLineBreaks(editField);
    if (skipLineBreaks != null) item.skipLineBreaks = skipLineBreaks;

    // apply valueIcons and related properties to the editor
    // Note that we allow different value icons in the editor from the icons displayed in the
    // static cell
    item.valueIcons = this.getEditorValueIcons(editField, editedRecord);
    
    var valueIconWidth = this.getEditorValueIconWidth(editField),
        valueIconHeight = this.getEditorValueIconHeight(editField);
    if (valueIconWidth) item.valueIconWidth = valueIconWidth;
    if (valueIconHeight) item.valueIconHeight = valueIconHeight;
    
    if (editField.valueIconClick != null) {
        item.valueIconClick = this._editorValueIconClickFunction;
    }
    
    item.imageURLPrefix = (editField.editorImageURLPrefix || editField.imageURLPrefix);
    item.imageURLSuffix = (editField.editorimageURLSuffix || editField.imageURLSuffix);
    // back compat only:
    item.baseURL = editField.baseURL;
    item.imgDir = editField.imgDir;
    // Pick up icon-related properties from the edit field (if any set)
    // (most of these will be undef, so pick up standard defaults from item type)
    var undef;
    if (editField.icons !== undef) item.icons = editField.icons;
    if (editField.showPickerIcon !== undef) item.showPickerIcon = editField.showPickerIcon;
    if (editField.pickerIconSrc !== undef) item.pickerIconSrc = editField.pickerIconSrc;
    if (editField.pickerIconWidth !== undef) item.pickerIconWidth = editField.pickerIconWidth;
    if (editField.pickerIconHeight !== undef) item.pickerIconHeight = editField.pickerIconHeight;

    // Generic icon properties are unlikely to be set on a per-field basis, but handle them anyway
    if (editField.defaultIconSrc !== undef) item.defaultIconSrc = editField.defaultIconSrc;
    var iconHeight = (editField.editorIconHeight || editField.iconHeight);
    if (iconHeight !== undef) item.iconHeight = iconHeight
    var iconWidth = (editField.editorIconWidth || editField.iconWidth);
    if (iconWidth !== undef) item.iconWidth = iconWidth;
    if (editField.iconPrompt !== undef) item.iconPrompt = editField.iconPrompt;
    if (editField.iconHSpace !== undef) item.iconHSpace = editField.iconHSpace;
    if (editField.iconVAlign !== undef) item.iconVAlign = editField.iconVAlign;

    // Allow hint to be directly specified on grid field for convenience
    if (editField.editorHint) {
        item.hint = editField.editorHint;
        item.showHintInField = true;
    }

    // ValueIcons properties:
    // Setting showValueIconOnly before getting editor type ensures we get back a cycle item
    // if appropriate rather than a select.
    if (this.showValueIconOnly(editField)) {
        if (editField.editorProperties == null) editField.editorProperties = {};
        editField.editorProperties.showValueIconOnly = true;
    }

    // If pickListWidth / fields is defined on the field object, pass it through to the item:
    if (editField.pickListWidth != null) item.pickListWidth = editField.pickListWidth;
    if (editField.pickListFields != null) item.pickListFields = editField.pickListFields;

    // Apply editor[Text]Formula to item
    if (editField.editorFormula != null) item.formula = editField.editorFormula;
    if (editField.editorTextFormula != null) item.textFormula = editField.editorTextFormula;

    // Set textAlign to match field alignment (required so text within text items etc reflects
    // horizontal alignment even though the item will be sized to take up all the space in the
    // cell).
    item.textAlign = this.getFieldCellAlign(editField, this.isRTL())

    
    if (editField.editorProperties != null) {
        for (var i = 0; i < this._commonEditorStringMethods.length; i++) {

            var prop = this._commonEditorStringMethods[i],
                value = editField.editorProperties[prop];
            // convert both "action" objects and strings
            if (value != null && !isc.isA.Function(value)) {
                var stringMethodReg = isc.FormItem._stringMethodRegistry;
                editField.editorProperties[prop] =
                    value = isc.Func.expressionToFunction(stringMethodReg[prop], value);
            }
            if (value != null) editField.editorProperties[prop] = value;
        }
    }

    // This block applies field.change, field.changed, and field.defaultDynamicValue
    for (var i = 0; i < this._commonEditorStringMethodsFromField.length; i++) {

        var prop = this._commonEditorStringMethodsFromField[i];
        if (editField.editorProperties && editField.editorProperties[prop] != null) {
            continue;
        }
        var value= editField[prop];
        if (value != null) {
            if (editField.editorProperties == null) editField.editorProperties = {};
            if (!isc.isA.Function(value)) {
                var stringMethodReg = isc.FormItem._stringMethodRegistry;

                value = isc.Func.expressionToFunction(stringMethodReg[prop], value);
            }
            editField.editorProperties[prop] = value;
        }

    }

    item.valueIconLeftPadding = this.getValueIconLeftPadding(editField);
    item.valueIconRightPadding = this.getValueIconRightPadding(editField);

    // A re-used FormItem should not retain the internal last formula calculation value  
    item._lastFormulaValue = null;
    
    // Propagate the date format
    item.format = editField.format;

    // Propagate decimalPad/Precision for float fields
    if (editField.decimalPrecision != null) item.decimalPrecision = editField.decimalPrecision;
    if (editField.decimalPad != null) item.decimalPad = editField.decimalPad;

    // if we're updating an existing item in place we don't need to reapply standard handlers,
    // or any properties which can't be updated on the fly (like editorType)
    if (!updateOnly) {
        // Pick up autoCompletion settings from the grid in preference to any default settings
        // on the form item
        item._getAutoCompleteSetting = this._editorGetAutoComplete;
        item.autoCompleteCandidates = editField.autoCompleteCandidates;
        item.uniqueMatch = editField.uniqueMatch;

        // containerWidget should point to the ListGrid body (or frozen body if appropriate)
        // this ensures that 'formItem.isVisible()' tests the visibility of this widget, rather than
        // the DynamicForm managing the form's values.
        item.containerWidget = (!this._suppressedFrozenFields && editField.frozen)
                                ? this.frozenBody : this.body;

        item.grid = this;
        
        
        item.tabGroupExit = function (forward) {
        
            this.logDebug("Attempting to tab out of editItem " + this + 
                ". This will fire 'cellEditEnd()' with an appropriate editEvent", 
                 "syntheticTabIndex");
            var editEvent = forward ? isc.ListGrid.TAB_KEYPRESS
                                        : isc.ListGrid.SHIFT_TAB_KEYPRESS;
            
            if (isc.EH.clickMaskUp()) {
                isc.EH.setMaskedFocusCanvas(null, isc.EH.clickMaskRegistry.last());
            }

            // Fire cellEditEnd to handle saving out the value / moving to the next cell as
            // appropriate
            this.grid.cellEditEnd(editEvent);
            return false;
            
        };  

        
        // validateOnChange: validation of edits is performed by the grid, not the editForm.
        // Override the internal 'handleChanged()' method to notify us if the edit item value
        // is changed by the user. The grid then checks for validateOnChange, and if appropriate
        // performs validation of the cell.
        item.handleChanged = this._editorHandleChangedOverride;

        // Apply a keyDown handler to all items.
        // Allows us to kill native tab navigation in Safari
        item.keyDown = function (item, form, keyName) {
            // check if form is still valid. It could happen that the startEditing() has moved
            // the editor to a new row, but the browser is sending the "keyPress" notification
            // after this has happened
            if (this.form == null) return;

            return this.form.grid.editorKeyDown(item, keyName);
        }

        // Apply an inactiveEditorHTML handler for mouseDown so we can switch edit rows on mouseDown
        // on inactive editor HTML.
        // This handles switching edit rows when alwaysShowEditors is true and the user mouseDowns
        // on a row other than the current edit row.
        
        item.inactiveEditorMouseDown = function (inactiveContext, itemInfo) {
            if (inactiveContext && (inactiveContext.grid == this.form.grid.getID()) &&
                inactiveContext.rowNum != null && inactiveContext.colNum != null)
            {
                // check first if form is still valid. It could happen that the startEditing() has moved
                // the editor to a new row, but the browser is sending the notification
                // after this has happened
                if (this.form == null) return;

                this.form.grid.startEditing(inactiveContext.rowNum, inactiveContext.colNum);
            }
        }

        
        item.handleMouseDown = function () {
            var rv = this.Super("handleMouseDown", arguments);
            
            var cell = this._setLGEditCellForFocus();
            this._fireLGEditorEnter(cell[0], cell[1]);
            return rv;
        }
        
        // show the item in the special "inline" style - eg, textItemLiteInline
        item.showInlineStyle = true;

        item.type = editField.type;
        // pick a form item type appropriate for embedded editing

        // explicit specification
        item.editorType = this.getEditorType(editField, record);
        var eT = item.editorType;

        
        item.browserAutoCorrect = false;

        // Pass specified "displayFormat", "dateFormatter" and "timeFormatter" through to the
        // edit item verbatim - FormItem knows how to handle these.
        if (editField.dateFormatter != null) item.dateFormatter = editField.dateFormatter;
        if (editField.timeFormatter != null) item.timeFormatter = editField.timeFormatter;
        if (editField.displayFormat != null) item.displayFormat = editField.displayFormat;

        var inputFormat = this._getDateInputFormat(editField);
        if (inputFormat) item.inputFormat = inputFormat;

        
        item.getIconBackgroundColor = function (icon, over, disabled, focused) {

            if (this.isInactiveHTML() && isc.isA.ColorItem(this)) {
                var inactiveContextID = this._currentInactiveContext;
                if (this._inactiveDirectory && inactiveContextID &&
                    this._inactiveDirectory[inactiveContextID]) 
                {
                    var inactiveContext = this._inactiveDirectory[inactiveContextID];
                    return this.grid.getEditedCell(inactiveContext.rowNum, inactiveContext.colNum);
                }

                return null;
            }
            return this.Super("getIconBackgroundColor", arguments);
        }


        // for date items, use the text field rather than the 3 selects
        if (this._dateEditorTypes[eT] == true || this._datetimeEditorTypes[eT] == true ||
            (editField.type == this._$date && eT == null))
        {
            item.editorType = (this._datetimeEditorTypes[eT] == true? this._$datetime : this._$date);
            item.useTextField = true;

            
            item.selectOnFocus = true;
            
            // This improves the appearance for this item type
            item.cellPadding = 0;
            // Don't apply a style to the sub items' cells - we don't want padding, etc.
            item.itemCellStyle = null;
            // have the picker icon butt up against the text box.
            item.pickerIconHSpace = 0;

        }

        if (this._timeEditorTypes[eT] == true) {
            item.editorType = this._$time;
            var ds = this.getDataSource();
            if (ds && ds.allowAdvancedCriteria == false) item.allowExpressions = false;
            
            
            item.selectOnFocus = true;
        }

        //>PopUpTextAreaItem
        // For pop-up textArea type editors, apply the keyPress handling code to the textArea<b></b>
        if (this.popUpTextAreaEditorTypes[eT] == true) {
            // PopUpTextAreaItems are a subclass of staticTextItems. Override the default textBoxStyle
            // to match the hack - suppress "over" styling when getting the cell style since we
            // always suppress it on the edit row once the editor is showing
            // directly set showOver:false to prevent FormItem over styling
            item.showOver = false;
            item.getTextBoxStyle = function () {
                var grid = this.grid,
                    record = grid.getCellRecord(this.rowNum,this.colNum);
                this.textBoxStyle = grid.getCellStyle(record, this.rowNum,this.colNum);
                return this.Super("getTextBoxStyle", arguments);
            }

            // notification when the grid's cell style changed so we can update our textBoxStyle
            item.gridCellStyleChanged = function (record, rowNum, colNum, newStyle) {
                var textBox = this._getTextBoxElement();
                if (textBox) {
                    textBox.className = this.textBoxStyle = newStyle;
                }
            }

            // suppress doubled borders etc
            
            item.textBoxCellCSS = isc.Canvas._$noStyleDoublingCSS

            // Apply the custom keydown & keypress handlers to the pop up text area's textArea
            item.textAreaKeyDown = this._popUpTextAreaItemKeyDown;
            item.textAreaKeyPress = this._popUpTextAreaItemKeyPress;
            // Override getTextAreaTop() - rather than sticking to the top of the form item (which
            // may not line up with other items), stick to the top of the cell.
            item.getTextAreaTop = this._getPopUpTextAreaTop;
            // default popUpOnEnter to true.
            if (item.popUpOnEnter == null) item.popUpOnEnter = true;

            // react to text area focus as we would to item focus for other items
            // so we know what cell the user is editing
            item.textAreaFocus = this._popUpTextAreaItemFocus;
        }
        //<PopUpTextAreaItem

        // Don't show label for checkboxes by default.
        if (this._checkboxEditorTypes[eT] == true || (editField.type == this._$boolean && eT == null)) {
            if (item.showLabel == null) item.showLabel = false;
            // Also verify that the item has focus on click.
            // Required for IE where focus is asynchronous and would occur after the click changed
            // the value
            
            if (item.handleClick == null) {
                item.handleClick = this._checkboxClick;
            }
        }

        // Default to overflow:"auto" for richTextItem editors. Otherwise we find they typically
        // overflow into the next column
        if (eT == "RichTextItem" || eT == "richText") {
            if (item.overflow == null) item.overflow = "auto";
        }

        item.elementFocus = this._editFormItem_elementFocus;
        item._setLGEditCellForFocus = this._editFormItem_setLGEditCellForFocus;
        item._fireLGEditorEnter = this._editFormItem_fireLGEditorEnter;

        // override 'focusInItem' to manage selection
        // - we need more complicated behavior than the standard 'selectOnFocus'.
        //   If we started editing via editOnKeypress we will have updated the value of the item
        //   so should set the cursor at the end of the item value. Otherwise, just select on focus.
        // refocusAfterRedraw override prevents this from clobbering selection when its a straight
        // redraw of the item and it already has a meaningful selection set.
        item.focusInItem = this._editFormItem_focusInItem;
        item._refocusAfterRedraw = this._editFormItem_refocusAfterRedraw;
    }

    // Allow for developer specified defaults / properties for this field
    
    var propertyDefaults = this.getEditorProperties(editField, record, rowNum);
    // If the dynamic method returned a custom valueMap, remember that so it doesn't get
    // wiped out by editField.valueMap, etc in downstream code
    if (propertyDefaults.valueMap != null && 
        propertyDefaults.valueMap != item.valueMap) 
    {
        item._dynamicPropsValueMap = propertyDefaults.valueMap;
    }
    isc.addProperties(item, propertyDefaults);

    // Explicitly set item.canEdit to true if it wasn't set as part of
    // field.editorProperties or the result of a custom getEditorProperties() method
    
    if (item.canEdit == null) item.canEdit = true;

    // if this grid is databound, any other properties specified in the DS will be picked
    // up by the form during databinding
    return item;
},


// A method to be applied to edit items as "valueIconClick"
_editorValueIconClickFunction : function (form,item,value) {
    var field = this.grid.getField(this.name);
    var rowNum = this.grid.getEditRow(), colNum = this.grid.getEditCol();
    var record = this.grid.getCellRecord(rowNum, colNum);
    isc.Func.replaceWithMethod(field, "valueIconClick",
                                     "viewer,record,recordNum,field,rawValue,editor");
    var returnVal = field.valueIconClick(this.grid, record, rowNum, field, value, this);
    if (returnVal == false) return false;
    // Handle the case where a formItem subclass has a meaningful valueIconClick installed
    // directly.
    return this.Super("valueIconClick", arguments);
},
    


// focusInItem override for edit form items.
_editFormItem_focusInItem : function () {
    this.Super("focusInItem", arguments);
    this.grid._updateEditorSelection(this);
},

// Override _restoreFocusForClickMaskHide (on the FORM) to avoid
// forcing full selection in editor via _updateEditorSelection
_editForm_restoreFocusForClickMaskHide : function () {
    this._suppressGridTextSelection = true;
    this.Super("_restoreFocusForClickMaskHide", arguments);
    this._suppressGridTextSelection = false;    
},

// Override _refocusAfterRedraw() (on the ITEM)
// This handles setting the selection on the item to whatever it was before redraw().
// Don't allow this to get clobbered by _updateEditorSelection
_editFormItem_refocusAfterRedraw : function () {
    this._suppressGridTextSelection = true;
    this.Super("_refocusAfterRedraw", arguments);
    this._suppressGridTextSelection = false;
},

// helper to return the editItem name for some cell
getEditorName : function (rowNum, editField, returnDataPath) {
    // accept a colNum or a field object
    editField = this.getField(editField);
    if (!editField) return null;
    if (returnDataPath && editField.dataPath) {
        return editField.dataPath;
    }
    return editField[this.fieldIdProperty];
},

getTrimmedFieldDataPath : function (field) {
    // convert whatever we were passed (object, string, index) to a field object
    var fieldObj = this.getField(field);
    // If the conversion failed assume we were passed a string we can just use.
    if (fieldObj == null) return field;
    if (fieldObj.dataPath) {
        return this._trimDataPath(fieldObj.dataPath);
    } else {
        return field.name;
    }
},


_editItemStringMethodCache:{},

//> @method listGrid.refreshCell()
//  @include    gridRenderer.refreshCell()
//  @example calculatedCellValue
//<
// override refreshCell just to pass the additional params through to refreshCellValue()
refreshCell : function (rowNum, colNum, refreshingRow, allowEditCellRefresh) {
    if (rowNum == null) {
        
        this.logInfo("ListGrid.refreshCell(): first parameter rowNum not present, returning");
        

        return;
    }
    if (!this.isDrawn() || !this.body) return;

    // If refreshCell() was called from outside 'showEditForm()' determine whether
    // this cell is going to show an editor and update the 'currentEditCells' cache
    if (!refreshingRow && this._editorShowing && !this._inShowEditForm) {
        this._cacheCurrentEditCells(rowNum,colNum);
    }

    var body = this.getFieldBody(colNum);

    // If the body is already marked for redraw, allow that to handle updating the cell
    if (body.isDirty()) {
        // If the _redrawing flag is set, we're inside a body redraw, before Super has been invoked,
        // so we can assert that the DOM has not yet been updated, but will be updated synchronously 
        // by upstream code in this thread.
        
        if (body._redrawing) {
            this.logDebug("refreshCell called while body redraw is in progress - ignoring.", "gridEdit");
            return false;
        }

        this.logDebug("refresh cell redrawing body", "gridEdit");
        body.redraw("refresh cell");
        // return false to indicate that we did not update the cell in place, but forced a
        // redraw (used to make 'refreshRow' more efficient.
        return false;
    }

    var bodyColNum = this.getLocalFieldNum(colNum);
    body._clearCachedCellValueForRefreshCell(rowNum,bodyColNum);

    if (this._alwaysShowEditors(this.getField(colNum),true)) {
        this._clearingInactiveEditorHTML(rowNum,colNum);
    }

    body.refreshCellStyle(rowNum, bodyColNum);
    // refresh the value too unless it's already been refreshed as part of styling
    if (!body.shouldRefreshCellHTML()) {
        this.refreshCellValue(rowNum, colNum, refreshingRow, allowEditCellRefresh);
    }

},


_pendingCellRefreshDelay: 100,
_pendingCellRedrawThreshold: 0.2,
markCellForRefresh : function (rowNum, colNum) {
    if (rowNum == null) {
        
        this.logInfo("ListGrid.refreshCell(): first parameter rowNum not present, returning");
        

        return;
    }
    if (!this.isDrawn() || !this.body) return;

    // no need for incremental strategy if body is already dirty
    var body = this.getFieldBody(colNum);
    if (body.isDirty()) return;

    var grid = this;

    
    if (!this._pendingCellsToRefresh) this._pendingCellsToRefresh = [];
    var pendingCells = this._pendingCellsToRefresh;

    // add the new cell to our pending list of cells to refresh
    var foundCell = false;
    for (var i = 0; i < pendingCells.length; i++) {
        var cell = pendingCells[i];
        if (cell[0] == rowNum && cell[1] == colNum) {
            foundCell = true;
            break;
        }
    }
    if (!foundCell) pendingCells.add([rowNum, colNum]);

    // if a callback is already set up, we're done; otherwise set it up
    if (this._pendingCellRefreshTimer) return;
    this._pendingCellRefreshTimer = isc.Timer.setTimeout(function () {
        // clear state up front; use closure variables below
        delete this._pendingCellRefreshTimer;
        delete this._pendingCellsToRefresh;

        if (body.isDirty()) return;

        // if a lot of cells must be refreshed, just redraw the entire GridBody instead
        var drawArea = body.getDrawArea();
        if (isc.isAn.Array(drawArea)) {
            var nTotalCells = (drawArea[1] - drawArea[0] + 1) *
                              (drawArea[3] - drawArea[2] + 1);
            if (pendingCells.length > nTotalCells * grid._pendingCellRedrawThreshold) {
                return body.redraw("markCellForRefresh");
            }
        }

        for (var i = 0; i < pendingCells.length; i++) {
            var cell = pendingCells[i];
            grid.refreshCell(cell[0], cell[1]);
        }

    }, this._pendingCellRefreshDelay);
},

cancelPendingCellRefresh : function () {
    isc.Timer.clear(this._pendingCellRefreshTimer);
    delete this._pendingCellRefreshTimer;
    delete this._pendingCellsToRefresh;
},

// refreshCellValue overridden to handle refreshing cells within the edit row
// If we are showing an edit form item for this cell:
// - if the form item is present in the DOM, and has focus:
//   - we must save out it's element value (may be dirty)
//   - blur the item without firing the handler
// - rewrite the HTML for the cell (including the form item)
// - inform the form item that it has been written out / redrawn in the DOM
// - reset the element value
// - if the item had focus, re-set focus (and selection).

refreshCellValue : function (rowNum, colNum, refreshingRow, allowEditCellRefresh) {
    if (!this.isDrawn() || !this.body) return;

    var body = this.getFieldBody(colNum),
        bodyColNum = this.getLocalFieldNum(colNum);

    body.refreshCellValue(rowNum, bodyColNum, refreshingRow, allowEditCellRefresh);
},

// Refresh record components for a row. Called during refreshRow() and can
// suppress any cell refreshes arising from updating the actual components as we're about
// to refresh the relevant cells
_updateRecordComponentsForRefreshRow : function (rowNum, frozenFields) {

    if (this.showRecordComponents) {
        var cellsToRefresh = [];
        if (frozenFields) {
            for (var i = 0; i < this.frozenFields.length; i++) {
                cellsToRefresh.add([rowNum, this.getFieldNum(this.frozenFields[i])]);
            }
        }
    
        var firstVisible = this.body._firstDrawnCol,
            lastVisible = this.body._lastDrawnCol;
    
        for (var i = firstVisible; i <= lastVisible; i++) {
            var colNum = this.getFieldNumFromLocal(i, this.body);
            cellsToRefresh.add([rowNum,colNum]);
        }
        // Now actually update the components
        for (var i = 0; i < cellsToRefresh.length; i++) {
            var rowNum = cellsToRefresh[i][0],
                colNum = cellsToRefresh[i][1];

            if (this.logIsDebugEnabled("recordComponents")) {
                this.logDebug("refreshCell calling refreshRecordComponent(" + 
                    rowNum + ", " + colNum + ") ",
                    "recordComponents");
            }
            this.refreshRecordComponent(rowNum, colNum, true);
        }
    }
},

//> @method listGrid.refreshRow()
// @include gridRenderer.refreshRow()
//<
refreshRow : function (rowNum, updateRecordComponents) {
    if (!this.body || !this.isDrawn()) return;
    // If refreshRow() was called from outside 'showEditForm()' refresh the
    // cache of cells which should show editors
    if (this._editorShowing && !this._inShowEditForm) this._cacheCurrentEditCells();


    // If the body is already dirty, allow the redraw to handle updating the row.
    var frozenFields = this.frozenFields && this.frozenFields.length > 0;
    // If deriveVisibleFields is called, and then this method fires before the grid has redrawn
    // we won't  have created the frozen body. Treat this case like frozenFields is false;
    if (frozenFields && !this.frozenBody) frozenFields = false;

    
    //var dirty = this.body.isDirty() ||
    //            frozenFields ? (this.frozenBody.isDirty() || this.bodyLayout.isDirty()) : false;
    var dirty = false;
    if (this.body.isDirty()) dirty = true;
    if (frozenFields && !dirty) {
        if (this.frozenBody.isDirty() || this.bodyLayout.isDirty()) dirty = true;
    }

    if (dirty) {
        var bodyWidget = frozenFields ? this.bodyLayout : this.body;
        var result =  bodyWidget.redraw("refresh row");
        if (updateRecordComponents) {
            // if requested, run the record through updateRecordComponent() before bailing
            this._updateRecordComponentsForRefreshRow(rowNum, frozenFields);
        }
        return result;
    }

    if (this._editorShowing && this._editRowForm != null) {
        this.logInfo("refresh row: " + rowNum, "gridEdit");
    }

    // Update all record components before we actually refresh cell content
    if (updateRecordComponents) {
        this._updateRecordComponentsForRefreshRow(rowNum, frozenFields);
    }

    // just call 'refreshCell' on all drawn cells
    if (frozenFields) {
        for (var i = 0; i < this.frozenFields.length; i++) {
            this.refreshCell(rowNum, this.getFieldNum(this.frozenFields[i]), true);
        }
    }

    var firstVisible = this.body._firstDrawnCol,
        lastVisible = this.body._lastDrawnCol;

    for (var i = firstVisible; i <= lastVisible; i++) {
        var colNum = this.getFieldNumFromLocal(i, this.body);
        this.refreshCell(rowNum, colNum, true);
    }
    
    // If we have variable row heights and frozen fields, also refresh the
    // special "rowHeightSpacer" cells
    if (this.frozenFields &&
        !this.fixedRecordHeights &&
        this.matchFrozenRowHeightsApproach == "rowHeightSpacerHTML") 
    {
        var frozenRow = this.frozenBody.getTableElement(rowNum),
            frozenSpacerCell = frozenRow 
                            ? frozenRow.cells[this.frozenFields.length] : null,
            unfrozenRow = this.body.getTableElement(rowNum),
            unfrozenSpacerCell = unfrozenRow 
                            ? unfrozenRow.cells[this.fields.length
                                         - this.frozenFields.length] : null,
            record = this.getCellRecord(rowNum, colNum);
        
        if (frozenSpacerCell) {
            frozenSpacerCell.innerHTML = 
                this.frozenBody._getRowHeightSpacerCellValue(record, rowNum);
        }
        if (unfrozenSpacerCell) {
            unfrozenSpacerCell.innerHTML = 
                this.body._getRowHeightSpacerCellValue(record, rowNum);   
        }
    }
},

// Should any cells be refreshed on selection change?
// We need to refresh the checkbox field cell if selectionAppearance is checkbox
// overridden in TreeGrid to refresh the tree cell if showSelectedIcon and related
// properties are set

getCellsToRefreshOnSelectionChange : function (rowNum) {
    var checkboxField = this.getCheckboxFieldPosition();
    if (checkboxField >= 0) {
        return [[rowNum, checkboxField]];
    }
},

//> @method listGrid.startEditingNew() (A)
//
// Start editing a new row, after the last pre-existing record in the current set of data.
// <P>
// This new row will be saved via the "add" +link{group:dataSourceOperations,DataSource
// operation}.
// <P>
// See the +link{group:editing,Grid Editing overview} and also the
// +link{group:unsavedRecords,Editing Unsaved Records overview} for context about how unsaved
// records behave.
// <P>
// You can optionally pass <code>newValues</code> which are the initial values for the newly
// added record.  See also +link{listGridField.defaultValue} as a means of setting default
// values every time the user begins editing a new record, for instance, by pressing downArrow
// on the last normal record in the grid when +link{listEndEditAction} is "next".
// <P>
// If editing is already underway elsewhere in the grid, startEditingNew() behaves just like
// +link{startEditing()}.
//
// @group  editing
//
// @param  [newValues] (Map | Record)  Optional initial set of properties for the new record
// @param  [suppressFocus] (Boolean) Whether to suppress the default behavior of moving focus
//                                   to the newly shown editor.
// @see    startEditing()
// @visibility external
//<
startEditingNew : function (newValues, suppressFocus) {

    // force editing on if it's not configured for any field, but a programmatic call is made
    if (!this.canEdit && !(this.completeFields || this.fields).getProperty("canEdit").or()) {
        this.canEdit = true;
    }

    
    if (isc.isAn.Array(this.data) && this.data.length == 0 &&
        this.dataSource && !this.shouldSaveLocally())
    {
        this.fetchData(null, null, {_suppressFetch:true});
        this.data.setFullLength(0);
    }

    // The new row will be added to the end of the current set of rows
    
    
    var newRowNum = this.body ? this.body.getTotalRows() : this.getTotalRows();

    // If we're showing the 'edit new record' row, ensure we insert the record over that row,
    // rather than inserting after that row.
    if (this.shouldShowNewRecordRow()) newRowNum -= 1;

    if (!this.useCellRecords && newValues != null) {
        // if this grid is using rowRecords (ListGrid), set the edit values before calling
        // findNextEditCell - rowRecords only need the rowNum to store editValues and doing 
        // that first for LG means the new values are made available to getEditedRecord()
        // immediately (eg, before findNextEditCell(), below, starts calling canEditCell())
        this.setEditValues(newRowNum, isc.addProperties({}, newValues), true);
    }

    var newEditCell = this.findNextEditCell(newRowNum, 0, 1, true, true, true);

    // newEditCell can be null if canEditCell returned false for all fields!
    if (newEditCell == null) {
        this.logInfo("startEditingNew() failed to find any editable fields in this grid.",
                     "gridEdit");
        if (!this.useCellRecords && newValues != null) {
            // setEditValues() was called above, but there were no fields to edit - clear 
            // the editSession
            this._clearEditValues(newRowNum, null, false);
        }
        return;
    }

    if (this.useCellRecords && newValues != null) {
        // Suppress displaying the new edit values - handled by 'startEditing', which will show
        // the edit form for the row.
        this.setEditValues(newEditCell, isc.addProperties({}, newValues), true);
    }

    // fall through to 'startEditing()' -- handles any current edit in another cell.
    this.startEditing(newEditCell[0], newEditCell[1], suppressFocus);
},

//> @method listGrid.updateEditRow()  (IA)
//
// Internal method to update the set of form fields written into the ListGrid body's
// currently editable row (after a call to editRow()).
// - Updates the values of the form items
// - Focuses in the appropriate item
//
//  @group  editing
//
//  @param  rowNum      (number)    Row number to update.
//
//  @visibility internal
//<
updateEditRow : function (rowNum) {
    // if updateEditRow is called on a delay, by the time this update occurs, we may have moved
    // on to another row.
    if (this._editRowNum != rowNum || !this._editRowForm) {
        //this.logWarn("updateEditRow bailing, update was for row: " + rowNum +
        //             " current editRow is " + this._editRowNum);
        return;
    }

    
    this._stopTrackingEditFieldUpdates();

    // update the item values of the edit form.
    
    this._editRowForm.setItemValues();
    // Clear out the _setValuesPending flag
    delete this._editRowForm._setValuesPending;
    this._editRowForm._waitingOnUpdate = false;

    this._startTrackingEditFieldUpdates();
},

// shouldFixRowHeight()
// Internal method allowing 'fixedRecordHeights' to be overridden for individual rows in the
// GridRenderer.
// Currently only used for row-level editing.
// When row-level editing is enabled, we want to allow the row showing the embedded editor to
// expand to accommodate it's contents regardless of this.fixedRecordHeights
//

shouldFixRowHeight : function (record, rowNum) {

    // if this row is being edited, don't vertically clip
    // (Note check for != false rather than == true, as if lg.canEdit is unset, we support
    // editing on fields where canEdit is explicitly set to true)
    if (this.canEdit != false && this._editorShowing && rowNum == this._editRowNum) {
       return false;
    }
    return this.fixedRecordHeights;
},

//--- helpers for edit flow methods

// Provide unique identifiers to be used to identify the edit flow.

_getNextEditFlowID : function () {
    if (this.__lastEditFlowID == null) this.__lastEditFlowID = isc.timeStamp();
    return this.__lastEditFlowID ++;
},

// internal helper method for click outside editor - avoids us having to determine the appropriate
// cell's value in a click-mask event handler type stringMethod.
_handleClickOutsideEditor : function () {

    // If the user clicked the remove field, remove the row without attempting to save
    // the edits.
    

    // If we're modal editing and the user clicked on the grid body, remember the
    // cell coordinates of the click.
    // This ensures that if the row-height changes when we hide the editor, we still 
    // treat this as a click on the appropriate target cell (which may have jumped to a new position)
    
    if (isc.EH.mouseIsDown()) {
        var target = isc.EH.getTarget();
        if (target == this.body || target == this.frozenBody) {
            var rowNum = target.getEventRow(),
                colNum = target.getEventColumn();
            
                if (this.canRemoveRecords && (rowNum == this.getEditRow())) {
                var field = this.getField(colNum);
                if (field && field.isRemoveField) {
                    // Validate before removing. This means if we are auto-save-edits:false, 
                    // and have a bad field value, we'll show it if the user clicks the
                    // remove-record field again to undo the remove and make the field "active"
                    this.validateRow(rowNum, true);
                    return this.removeRecordClick(rowNum,colNum);
                }
            }

            if (this.modalEditing) {
                target._maskedMouseDownCell = [rowNum, colNum];
            }

        }
    }
    
    this.cellEditEnd(isc.ListGrid.CLICK_OUTSIDE);
},

// Retrieving / updating editValues.
// We store copies of edited values locally for multiple records in the _editSessions
// object.  This allows us to hang onto edit values for more than one edited record at a time
// - required for records that have been edited but not yet saved, either because a save is
// in process, but hasn't returned from the server, and 'waitForSave' is false, or because a
// save failed with validation errors, and stopOnErrors is false.



// value to display in a cell for which there may be edit values present.

// Note: optional 'record' parameter passed by 'getEditDisplayValues' only.
getEditDisplayValue : function (rowNum, colNum, record) {
    
    var undef;
    // If 'record' is not passed, determine it from rowNum, colNum now.
    if (record === undef) record = this.getCellRecord(rowNum, colNum);

    // use the edit value for the cell if present
    var value = this._getEditValue(rowNum, colNum);
    if (value === undef) {
        if (record != null) {
            
            value = this.getRawCellValue(record, rowNum, colNum);
        }
    }
    // If a formatter is defined for the editor values, apply it now
    value = this._formatEditorValue(value, record, rowNum, colNum);
    return value;
},

// Internal method to fire developer defined 'formatEditorValue' methods at either the Grid or
// Field level.

_formatEditorValue : function (value, record, rowNum, colNum) {
    // If this is a new row, the record passed in will be null -
    // In this case pass the edit values to the formatter instead
    
    if (record == null) record = this._getEditValues(rowNum, colNum);

    // If a field-level formatter is defined, apply it.
    var field = this.fields[colNum];

    if (field && field.formatEditorValue != null) {
        
        isc.Func.replaceWithMethod(field, "formatEditorValue",
                                            "value,record,rowNum,colNum,grid");
        value = field.formatEditorValue(value, record, rowNum, colNum, this);
    // Only apply a Grid-level formatter if no formatter exists at the field level.
    } else if (this.formatEditorValue != null) {
        value = this.formatEditorValue(value, record, rowNum, colNum);
    }
    return value;
},

//> @method listGrid.getEditValuesID()
//
//  Given either a rowNum, a set of primary key values,
//  returns a unique identifier for the set of temporary locally stored edit values for some
//  record being edited.
//  If passed the editValuesID, it will just be returned.
//
//  @group  editing
//  @visibility advancedInlineEdit
//  @param  ID (number | Object | String)    Identifier for editValues for which we need to
//                                           return the unique editValuesID.
//  @return (String)   Unique identifier for the set of editValues.
//<

getEditValuesID : function (ID) {
    if (ID == null || this._editSessions == null) return null;

    if (isc.isA.String(ID) && this._editSessions[ID] != null) return ID;

    // rowNum (common case)
    if (isc.isA.Number(ID)) {
        return this._editRowMap[ID];
    }

    // handle primary keys object OR the edit data object itself
    for (var i in this._editSessions) {
        var data = this._editSessions[i];
        if (data == ID) return i;
        var pk = data._primaryKeys;
        if (pk && this.comparePrimaryKeys(pk, ID)) {
            return i;
        }
    }

    return null;
},

// getEditSession - returns the edit data object for some row.
// This contains the editValues, the rowNum (if known), any validation errors, and primary
// keys for the edited record.
getEditSession : function (editDataID, colNum) {
    // editDataID can be a rowNum, a primary key or an editValuesID string.
    if (this._editSessions == null) return null;

    if (!isc.isA.String(editDataID)) editDataID = this.getEditValuesID(editDataID, colNum);
    return this._editSessions[editDataID];
},

// getEditSessionRowNum   - given an edit data object, or an ID for an edit data object, returns
// the rowNum of the record associated with the data.
// May be null if we're editing a new row on the end of the list, or with a paged result-set
// if we don't yet know the rowNum for the record.
getEditSessionRowNum : function (editDataID) {
    editDataID = this.getEditSession(editDataID);
    return (editDataID != null ? editDataID._rowNum : null)
},

getEditSessionColNum : function (editDataID) {
    editDataID = this.getEditSession(editDataID);
    // Note that the _colNum will be unset if we have 1 record per row
    return (editDataID != null ? editDataID._colNum : null)
},

//> @method listGrid.getAllEditRows()
// Returns an array of every rowNum for which we have pending (unsubmitted) edits.
// This will return records that have been marked as removed (see +link{listGrid.markRecordRemoved()}
// as well as records with unsaved changes to field values.
//  @group  editing
//  @visibility external
//  @return (Array of int) Array of rowNums for rows with edit values pending submission.
//<

getAllEditRows : function (getIds) {
    return this.getAllEditCells(getIds, true);
},


getAllEditCells : function (getIds, rowsOnly) {
    var registry = this._editSessions,
        cells = [];
    if (!registry) return cells;

    if (getIds) return isc.getKeys(this._editSessions);

   
    for (var i in registry) {
        var rowNum = registry[i]._rowNum;
        // Convert "1" to 1, etc.
        
        rowNum = parseInt(rowNum);
        if (rowNum == null || rowNum < 0 || isNaN(rowNum)) continue;
        if (rowsOnly) cells[cells.length] = rowNum
        else {
            var colNum = registry[i]._colNum;
            // If rowNum only was stored on the cell, use the special getRowEditColNum() to
            // figure out the colNum in question
            if (colNum == null) {
                colNum = this._editorShowing && (rowNum == this.getEditRow())
                                    ? this.getEditCol() : this.getRowEditColNum(rowNum);
            }
            if (colNum != null && !isc.isA.Number(colNum)) colNum = parseInt(colNum);
            cells[cells.length] = [rowNum, colNum];
        }
    }
    return cells;
},

//> @method listGrid.getEditValues()
// Returns the current set of unsaved edits for a given row being edited.
//
//  @param  valuesID (number | Object)  rowNum of the record being edited, or an Object
//                                      containing values for all the record's primary keys
//  @return (Object)   Current editValues object for the row.  This contains the current
//                     edit values in {fieldName1:value1, fieldName2:value2} format.
//  @group  editing
//  @visibility external
//<
//  @param [colNum] (number) colNum of the record being edited. Only required if valuesID
//                           is passed in as a rowNum, and we're displaying one record per cell
//                          as in a +link{CubeGrid}

getEditValues : function (valuesID, colNum) {
    if (valuesID == null) {
        return this.logWarn("getEditValues() called with no valuesID. "
                + (this.logIsDebugEnabled("gridEdit") ? this.getStackTrace() : ""));
    }

    
    
    if (this._initializingEditValues) {
        return {};
    }

    // handle being passed a 2 element array [rowNum,colNum] since this is the format we
    // accept for setEditValues()
    if (colNum == null && isc.isA.Array(valuesID)) {
        colNum = valuesID[1];
        valuesID = valuesID[0];
    }

    // If we're showing an editor for this row, ensure that the current value in the
    // edit field is present in the editValues we return.
    
    var rowNum = (isc.isA.Number(valuesID) ? valuesID : this.getEditSessionRowNum(valuesID));
    if (this._editorShowing && (this.getEditRow() == rowNum)) {
        this.storeUpdatedEditorValue();
    }

    
    var values = {};
    this.combineRecords(values,this._getEditValues(valuesID, colNum));
    if (values != null) {
        delete values[this.recordRemovedProperty];
    }
    return values;
},

// Retrieve the stored edit values for some row (or null)
// Unlike the public method, this will not first update the editVals with the current value
// from the editForm (if showing)
_getEditValues : function (valuesID, colNum) {
    // we may be passed the editValues object, in which case we're passing it back again,
    var editSession = this.getEditSession(valuesID, colNum);
    return editSession != null ? editSession._editValues : null;
},

//> @method listGrid.getEditedRecord()
// Returns the combination of unsaved edits (if any) and original values (if any) for a given
// row being edited.
// <P>
// The returned value is never null, and can be freely modified.
//
// @param  valuesID (number | Object)  rowNum of the record being edited, or an Object
//                                      containing values for all the record's primary keys
// @return (Object) A copy of the record with unsaved edits included
// @group  editing
// @visibility external
//<

getEditedRecord : function (rowNum, colNum, suppressUpdate) {
    if (rowNum == null) return this.logWarn("getEditedRecord() called with no valuesID");

    // the valuesID allows for rowNum independent data storage - if passed a valuesID
    // determine resolve to rowNum/colNum here so we can get a pointer to the record object
    if (!isc.isA.Number(rowNum)) {
        rowNum = this.getEditSessionRowNum(rowNum);
        colNum = this.getEditSessionColNum(rowNum);
    }

    var record = this.getCellRecord(rowNum, colNum),
        // respect the parameter to avoid checking the edit form for updates
        editValues = suppressUpdate ? this._getEditValues(rowNum, colNum)
                                    : this.getEditValues(rowNum, colNum);

    // don't hang the "removed" flag onto the record.
    if (editValues != null) {
        
        //delete editValues[this.recordRemovedProperty];
    }

    var rtn = {},
        baseRecordCopy = {};
    // Combine a recursive copy of the base data, not the base data itself; if we don't do this,
    // the combined record includes pointers to any sub-objects in the base data, so values in
    // the base data will get overwritten by the combination process.  Note, this.getEditForm()
    // may well return null for some uses of this method, but it's OK because 
    // DBC._duplicateValues() now copes with being passed a null component (it just performs a 
    // straight schemaless dup)
    isc.Canvas._duplicateValues(this.getEditForm(), record, baseRecordCopy, null, 
                                this.keepNativeJavaObjs !== false, this.getDataSource());
    this.combineRecords(rtn, baseRecordCopy);
    this.combineRecords(rtn, editValues);
    if (rtn.__ref) rtn.__ref = null;
    
    return rtn;
},

//> @method listGrid.getEditedCell()
// Returns the current value of a cell. If the cell has an outstanding edit value, this will
// be returned, otherwise the underlying value of the record will be returned.
//
// @param  record (number | Object)  rowNum of the record being edited, or an Object
//                                      containing values for all the record's primary keys
// @param field (number | String) colNum or fieldName of the cell
// @return (Any) Current edit value, or underlying value for the cell
// @group  editing
// @visibility external
//<
getEditedCell : function (record, field) {
    if (record == null || field == null)
        return this.logWarn("getEditedCell() called with no record / field parameter");

    var editValues = this.getEditValues(record, field),
        rowNum = isc.isA.Number(record) ? record : this.getEditSessionRowNum(record),
        colNum = isc.isA.Number(field) ? field : this.getFieldNum(field),
        record = this.getCellRecord(rowNum, colNum);

    var editFieldName = this.getEditorName(rowNum, this.getField(colNum))
    var undef;

    if (editValues && editValues[editFieldName] !== undef) return editValues[editFieldName];
    return record ? record[editFieldName] : null;
},

// When we attempt to save an edit remember the edit values
// We use this to perform intelligent change detection while pending a save on the server
rememberSubmittedEditValues : function (valuesID, colNum) {
    
    var editSession = this.getEditSession(valuesID);
    if (editSession != null) {
        editSession._submittedValues = isc.addProperties({}, editSession._editValues);
    }
},

// retrieve the last set of editValues submitted to the server.
getSubmittedEditValues : function (valuesID, colNum) {
    var editSession = this.getEditSession(valuesID, colNum);
    return editSession != null ? editSession._submittedValues : null;
},

hasSubmittedEditValues : function (valuesID, colNum) {
    var vals = this.getSubmittedEditValues(valuesID, colNum);
    return vals != null && !isc.isA.emptyObject(vals);
},

// Clear the stored "submitted edit values"
// called from editFailedCallback method - oldValues object is required so we don't clear
// the submitted editValues if they have been modified since the (failed) save was committed
// a case we can only hit if 2 overlapping saves have been kicked off.
clearSubmittedEditValues : function (valuesID, oldValues) {
    var editSession = this.getEditSession(valuesID);
    if (editSession == null) return;
    var submittedVals = editSession._submittedValues;
    if (!submittedVals) return;

    for (var field in oldValues) {
        if (submittedVals[field] == oldValues[field]) delete submittedVals[field];
    }
    if (isc.isA.emptyObject(submittedVals)) editSession._submittedValues = null;
},



//> @method listGrid.createEditValues()
//
// This method creates a new set of editValues for a row at the end of the list, and returns
// the editValuesID which can subsequently be passed to any of the following methods as a
// unique identifier (in place of the 'rowNum' parameter where appropriate):
// 'setEditValue()', 'getEditValues()', 'getEditValue()', 'getEditValues()', 'clearEditValue()'
// and 'clearEditValues()'.<br>
// The new edit values will be displayed at the end of the list.
//
//  @param  values       (Any)       New values for the row
//  @visibility advancedInlineEdit
//<

createEditValues : function (values) {
    var rowNum = this.body.getTotalRows();
    // set up the edit values, and display them in the listGrid (don't pass the
    // suppressDisplay param)
    
    this.setEditValues(rowNum, values);
    return this.getEditValuesID(rowNum);
},



// initializeEditValues() - helper method to set up empty edit vals for some
// record
initializeEditValues : function (rowNum, colNum, displayNewValues, recalculateSummaries) {
    // If we don't have edit values for this record, set them up.
    // (we can use the internal method - we know we don't have outstanding edits in the
    // edit form at this point, as the editor should have been hidden)
    if (this._getEditValues(rowNum, colNum) == null) {
        this._initializingEditValues = true;
        // *If* this is a new record, pick up any specified 'initialValues' per field
        
        var initialVals = {};
        if (this.getCellRecord(rowNum, colNum) == null) {
        
            var gridFields = this.getAllFields();
            for (var i = 0; i < gridFields.length; i++) {
                if (gridFields[i] && gridFields[i].initialValue != null) {
                    
                    isc.Canvas._saveFieldValue(gridFields[i].dataPath || gridFields[i].name, null,
                                              gridFields[i].initialValue, initialVals, this, true);
                }
            }
        }
        this.setEditValues([rowNum, colNum], initialVals, !displayNewValues, !recalculateSummaries);
        delete this._initializingEditValues;
        //this.logWarn("editValues for row: " + rowNum + " are now: " + this.echo(this.getEditValues(rowNum)));
    }
},


//> @method listGrid.setEditValues()
//
// This method sets up a set of editValues for some row / cell.  It differs from
// 'setEditValue()' in that:<br>
// &nbsp;- it takes values for multiple fields<br>
// &nbsp;- it clears out any previous edit values for the record<br>
//
//  @param rowNum (number) Row number for the record being edited
//  @param values (Object) New values for the row
//
// @visibility external
//<
// @param   suppressDisplay (boolean)   Additional internal parameter to suppress updating the
//                                      affected row to display the new edit values.
// Note that the first param may be a 2 element array of rowNum, colNum for one record-per-cell
// data models (documented in CubeGrid)

setEditValues : function (rowNum, editValues, suppressDisplay, suppressSummaryRecalc) {

    var colNum;
    if (isc.isAn.Array(rowNum)) {
        colNum = rowNum[1];
        rowNum = rowNum[0];
    }

    // Don't allow a rowNum more than 1 slot beyond the end of the grid
    // (1 slot beyond is ok - this will create a new edit row, without introducing invalid
    // gaps)
    if (!isc.isA.Number(rowNum) || rowNum < 0 || (rowNum > this.getTotalRows()) ) {
        this.logWarn("setEditValues() called with bad rowNum: " + this.echo(rowNum));
        return;
    }

    // Default to an empty set of values - if the user wants to entirely clear an editValues
    // object, they should use 'clearEditValue(s)' instead.
    if (editValues == null) editValues = {};

    var record = this.getCellRecord(rowNum, colNum),
        oldEditSession = this.getEditSession(rowNum, colNum);
    var isNewEditSession = oldEditSession == null,
        addedRow = record == null && isNewEditSession;

    var oldEditValues, changedFields;
    if (!suppressDisplay) {
        if (record == null) record = {};

        oldEditValues = this.getEditValues(rowNum, colNum);
        changedFields = isc.addProperties({}, oldEditValues);
        for (var i in changedFields) {
            changedFields[i] = record[i];
        }

        isc.addProperties(changedFields, editValues);

        // At this point changedFields will be a mapping of the new edit display values for
        // each field that has been changed.
    }

    if (this.logIsInfoEnabled("gridEdit")) {
        if (!isNewEditSession) {
            this.logInfo("establishing new edit session at row: " + rowNum +
                         (colNum != null ? ", col:" + colNum : "") +
                         (this.logIsDebugEnabled("gridEdit") ?
                         " with values: " + this.echo(editValues) :
                         ""), "gridEdit");
        }

    }
    // If we were marked as removed afore this method ran, continue to keep us marked as removed
    // If the user wants to drop that they can explicitly call 'discardEditValues()' or
    // 'unmarkRecordRemoved'.
    var markedAsRemoved = this.recordMarkedAsRemoved(rowNum);
    if (markedAsRemoved) editValues[this.recordRemovedProperty] = true;

    // store the new edit value
    this._storeEditValues(rowNum, colNum, editValues);
    var hasModifiedValues = changedFields != null && !isc.isAn.emptyObject(changedFields);
    if (suppressDisplay || !this.isDrawn() || !this.body) {
        if (hasModifiedValues && !suppressSummaryRecalc) {
            // unless explicitly prohibited, if suppress display is passed we do still want to
            // redraw the summary row if there is one since the calling code never handles that
            if (this.summaryRow && this.showGridSummary) this.summaryRow._recalculateSummaries()
        }
        return;
    }

    if (hasModifiedValues) {
        // don't refresh display when recalculating summaries - we'll refresh the row and
        // the grid summary if necessary.
        this.calculateRecordSummaries(rowNum, null, true, true, true);
    }

    // values shown in the cells for this row are now stale (whether each cell is being edited
    // or not), so refresh.

    // if totalRows changed, it indicates that that a new edit row is being created at the end
    // of the body, hence we need to redraw to add the row to the DOM
    var shouldRedrawBody =  (addedRow || this.body.isDirty());

    if (shouldRedrawBody) {
        var editorShowing = this.isEditingRecord(rowNum, colNum) && this._editRowForm != null

        
        if (editorShowing) this._updateEditItemValues();

        this.body.markForRedraw(
            
        );
        if (hasModifiedValues && this.summaryRow && this.showGridSummary) {
            this.summaryRow.markForRedraw();
        }

    } else {
        this._displayNewEditValues(rowNum, colNum, changedFields);
    }
},


_displayNewEditValues : function (rowNum, colNum, changedFields, errors) {
    if (!changedFields || isc.isAn.emptyObject(changedFields)) {
        return;
    }

    var editorShowing = this.isEditingRecord(rowNum, colNum) && this._editRowForm != null
    // update each cell effected by the change, either by setting the form item value or
    // refreshing the cell
    
    var hasVisibleChanges = false;
    for (var fieldName in changedFields) {
        var fieldColNum = this.getColNum(fieldName);

        // If we're showing an edit item for the cell, set it's value rather than
        // refreshing the cell (and rewriting the form item HTML completely)
        var editItemDrawn;
        if (editorShowing) {
            var editItem = this._editRowForm.getItem(fieldName);
            editItemDrawn = (fieldColNum >=0 && editItem && this.canEditCell(rowNum, fieldColNum));
            
            var value = editItem ? 
                    this._formatEditorValue(
                            changedFields[fieldName], this.getCellRecord(rowNum, colNum), 
                            rowNum, fieldColNum) : 
                    changedFields[fieldName];
            
            this._editRowForm.setValue(fieldName, value);

        }
        // undrawn cell - just continue to the next field
        // [note do this after modifying edit form values]
        if (fieldColNum == -1) continue;
        
        // If we're in the middle of handle dataChanged, no need to refresh any cells -
        // We'll mark for redraw at the end of dataChanged
        if (this._handlingDataChanged) continue;
        hasVisibleChanges = true;

        if (!editItemDrawn) {
            this.refreshCell(rowNum, fieldColNum);
        } else if (errors && errors[fieldName]) {
            this.showCellErrors(rowNum, fieldColNum);
        }
    }
    if (hasVisibleChanges && this.summaryRow && this.showGridSummary) {
        this.summaryRow._recalculateSummaries();
        // refresh the group summary!
        this.refreshGroupSummary(rowNum);
    }
    return hasVisibleChanges;
},


// Internal helper method for 'setEditValues' - actually stores the editValues object for the
// row
// Call 'setEditValues()' rather than calling this method directly.
// NOTE: editValuesId is a *highly internal* param that allows creating of a new editSession
// with a predictable ID


_storeEditValues : function (rowNum, colNum, editValues, editValuesId) {
    // Get the record for this row.  Note that this might be null as we may be adding a new
    // edit row to the end of the list.
    var record = this.getCellRecord(rowNum, colNum);

    // Assertion - if we don't have the edit data for this rowNum, we don't have the
    // edit data for this record, since 'getRecord()' will always associate the edit data
    // for some record with the appropriate rowNum, if required.
    var editSession = this.getEditSession(rowNum, colNum) ||
            this.createEditSession(rowNum, colNum, record, editValuesId);
    // Always add the primary keys to edit values for databound lists, so that they are
    // available to identify the record in saveEditedValues().  Non-databound lists are
    // expected to use object identity.
    if (this.dataSource != null) {
        // set the 'newRecord' marker on loading rows to indicate that there's no associated
        // record (and we don't have PKs for the row
        if (record == "loading") {
            editSession._newRecord = true;
        } else if (record != null) {
            var ds = this.getDataSource(),
                pkArray = ds.getPrimaryKeyFieldNames();

            for (var i = 0; i < pkArray.length; i++) {
                // do not overwrite primary key value in editValues with NULL value;
                if (record[pkArray[i]] != null) editValues[pkArray[i]] = record[pkArray[i]];
            }
        }
    }

    // set the _newRecord flag for each row without an associated record
    if (record == null) {
        editSession._newRecord = true;

        // if we have any fields with a specified default value, pick it up as a default
        // edit value.
        // (true even if the field is hidden)
        
        // If we are showing any 'enum' type fields, and
        var fields = this.completeFields || this.fields || [],
            undef;

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i],
                fieldName = field[this.fieldIdProperty];
            if (editValues[fieldName] === undef) {
                var defaultValue = this.getDefaultEditValue(fieldName, field);
                if (defaultValue != null) {
                    editValues[fieldName] = defaultValue;
                }
            }
        }
    }

    // clear out any stored editValues and copy the passed editValues into place, preserving
    // the same instance.
    for (var i in editSession._editValues) {
        delete editSession._editValues[i];
    }
    for (var i in editValues) {
        editSession._editValues[i] = editValues[i];
    }

    // Cache the last edit row - used by 'getTotalRows()'.  This value will also be
    // updated by 'clearEditValues()'
    
    
    if (this._lastEditRow != null && rowNum >= this._lastEditRow) {
        this._lastEditRow = rowNum
    }

    // Update the ruleContext
    if (this._editorShowing && this.getEditRow() == rowNum) {
        this._provideEditRecordToRuleContext(editValues);
    }

    // Set flag on row editSession to indicate editValues have been saved for this record.
    // Used by ListGrid.hasBeenEdited().
    var editSession = this.getEditSession(rowNum, colNum);
    if (editSession) {
        editSession._editValuesSaved = true;
    }
},

// Helper method - gets the default value to show in an editor for a field (if no explicit value
// was specified).
getDefaultEditValue : function (fieldName, field) {
    var defaultValue = field.defaultValue;
    if (defaultValue == null && this.enumCriteriaAsInitialValues &&
        field.type == "enum" && this._filterValues != null&&
        this._filterValues[fieldName] != null)
    {
        // We could check the value against this.getEditorValueMap(fieldName, null)?
        defaultValue = this._filterValues[fieldName];
    }
    return defaultValue;
},

//> @method listGrid.createEditSession() (I)
//
//  Internal method to initially set up internal, temporary edit values (and old, pre edit values)
//  for a record.
//  This method doesn't store these editValues - use 'setEditValues()' for that
//  These get updated as the record is edited, and cleared out when the edit is complete.
//
//  @group  editing
//  @visibility internal
//<

createEditSession : function (rowNum, colNum, record, editValuesID) {

    var editSession = {};
    if (record != null && record != Array.LOADING) {
        editSession._primaryKeys = this.getPrimaryKeys(record);
    }

    // A null primary key will imply we're editing a new record.
    // Assertion: when initializing edit data we will always be passed a rowNum
    
    editSession._rowNum = rowNum;
    if (this.useCellRecords) {
        editSession._colNum = colNum;
        
        if (this.getCellFacetValues) editSession._facetValues = this.getCellFacetValues(rowNum, colNum);
    }

    editSession._editValues = {};

    if (this._editSessions == null) this._editSessions = {};

    // generate an editValuesId if not passed one
    if (editValuesID == null) {
        if (this._currentEditValuesID == null) this._currentEditValuesID = 0;
        editValuesID = "_" + this._currentEditValuesID++;
    }

    this._editSessions[editValuesID] = editSession;

    // editRowMap used for retrieving edit sessions / row
    if (this._editRowMap == null) this._editRowMap = {};
    this._editRowMap[rowNum] = editValuesID;
    return editSession;
},


//> @method listGrid.setEditValue()     ([A])
//
//  Modifies a field value being tracked as an unsaved user edit.<P>
//  Use for suggested or reformatted values for edits that remain unsaved.
//
//  @group  editing
//  @visibility external
//
//  @param  rowNum      (number)    Row number (or edit values ID)
//  @param  colNum      (number | String)    Column number of cell, or name of field
//                                           having editValue updated
//  @param  value       (Any)       New value for the appropriate field.
//<


setEditValue : function (rowNum, colNum, newValue, suppressDisplay, suppressChange, 
                         suppressSummaryRecalc, atomicValue)
{
    if (isc.isA.String(rowNum)) {
        this.logWarn("Warning: first parameter rowNum is a string, expecting a number");
        // bail if we have a bad rowNum
        return false;
    }

    // if unset, default suppressSummaryRecalc based on updateSummariesDuringEditing
    if (suppressSummaryRecalc == null) {
        suppressSummaryRecalc = !this.updateSummariesDuringEditing;
    }
    
    
    // We can be passed a colNum or a field name
    // Normalize to the appropriate field
    // Note: If a dataPath is specified on the field, pick that up rather than the "name"
    // of the field
    var field,
        fieldName,
        dataPath;
        
    if (isc.isA.Number(colNum)) {
        field = this.getUnderlyingField(colNum);
        fieldName = field ? field[this.fieldIdProperty] : null
        
        dataPath = this.getEditorName(rowNum, field, true);
    } else {
        // Passed a field name - find the associated field
        var fieldName = colNum,
            field = this.getUnderlyingField(fieldName);
        if (field != null) {
            // convert to datapath for values management if necessary
            dataPath = this.getEditorName(rowNum, field, true);
            colNum = this.fields.indexOf(field);
        // Assume we were passed a field name which isn't associated with a field
        } else {
            dataPath = fieldName;
            colNum = -1
        }
    }
    
    dataPath = this._trimDataPath(dataPath);
    
    // store the new edit value
    
    var changed = this._storeEditValue(rowNum, colNum, dataPath, newValue,
                           isc.CubeGrid && isc.isA.CubeGrid(this) ? true : suppressDisplay,
                                       suppressChange, suppressSummaryRecalc, atomicValue);
    // only proceed if there was a change
    if (!changed) {
        return false;
    }
    // If we were passed an atomic value, pick up the "opaque" equivalent now if necessary.
    if (atomicValue) newValue = this._getEditValue(rowNum, colNum, true);
    
    // If this is an edit value for a field with a specified displayField, and no
    // optionDataSource (so we're picking up the field's display value from the 'displayField' value
    // of the record), also update the edit value of the displayField on the record.
    
    
    if (field && this._useDisplayFieldValue(field)) {
        var hasDisplayValue = false,
            displayValue;
        // Pick up the display value associated with this data-value from the edit-item if
        // possible.
        var editForm = this.getEditForm(),
            editItem = editForm ? editForm.getItem(fieldName) : null;

        if (editItem && this.getEditRow() == rowNum &&
            this.fieldValuesAreEqual(field, editForm.getValue(fieldName), newValue))
        {
            hasDisplayValue = true;
            displayValue = editItem._getDisplayValue(newValue);
        }
        // Otherwise, if we're looking at data from our own dataSource, reach into our
        // data array and see if we can find a record to lazily perform a mapping with
        // no fetch.
        if (!hasDisplayValue &&
            (field.valueField == null || field.valueField == fieldName) &&
            (!field.optionDataSource ||
                isc.DS.get(field.optionDataSource) == this.getDataSource()) )
        {

            var data = this.data;
            if (isc.ResultSet && isc.isA.ResultSet(data)) data = data.localData;
            if (data) {
                var record = data.find(fieldName, newValue);
                if (record) {
                    hasDisplayValue = true;
                    displayValue = record[field.displayField];
                }
            }
        }
        if (hasDisplayValue) {
            // update the display field value on the edit form as well as storing out
            // the new value. This means that if allowEditFormValueManipulation
            // is true (so we pick up values from other fields) we won't clobber this with
            // the original value for that field.
            if (this._editRowForm && this.getEditRow() == rowNum) {

                // if displayValue was set to {formItem}.emptyDisplayValue, this means that data 
                // value is empty (i.e. is null). {formItem} here stands for items that support 
                // emptyDisplayValue, like SelectItem/ComboBoxItem/etc, for other items this check 
                // would be always false, since emptyDisplayValue would be undefined.
                // So, we do not want to save emptydisplayValue (which can be set to some string as 
                // part of UI) as displayField value if data value is empty (null), therefore we save 
                // null as value for displayField as well.
                if (editItem && displayValue == editItem.emptyDisplayValue) displayValue = null;

                this._editRowForm.setValue(field.displayField, displayValue);
            }
            this.setEditValue(rowNum, field.displayField, displayValue, suppressDisplay, true);
        // Couldn't get a display value back. Log a warning so developers understand why the
        // displayValue doesn't show up.
        } else {
            if (this.warnOnUnmappedValueFieldChange) {
                this.logWarn("Edit value updated for field:" + fieldName
                    + ". This field has 'displayField' attribute specified as '"
                    + field.displayField
                    + ((field.optionDataSource == null ||
                        isc.DataSource.get(field.optionDataSource) == this.getDataSource())
                         ? "', and no unique optionDataSource, "
                         : "', ")
                    + "so display value is derived from the "
                    + "current record. In order to ensure the display value is updated to "
                    + "reflect the new edit-value for this field, developers can explicitly update the "
                    + "edit value for the display-field on this record. To avoid seeing this method "
                    + "set listGrid.warnOnUnmappedValueFieldChange to false.");
            }
        }
    }
    // If we're not supposed to update the display we're done.
    
    if (suppressDisplay) {
        if (!suppressSummaryRecalc) {
            // unless explicitly prohibited, if suppressDisplay is passed we do still want to
            // recalculate the summaries if present since the calling code never handles that
            this.calculateRecordSummaries(rowNum, null, true, true, true);
        }
        return true;
    }
    // Remember which field was most recently modified - this will be passed to callbacks as
    // the 'colNum' param
    this.setRowEditFieldName(rowNum, fieldName);

    if (!isc.isA.Number(rowNum)) {
        colNum = this.getEditSessionColNum(rowNum);
        rowNum = this.getEditSessionRowNum(rowNum);
    }
    var vals = {};
    
    vals[fieldName] = newValue;
    if (this._displayNewEditValues(rowNum, colNum, vals)) {
        
        if (!suppressSummaryRecalc) this.calculateRecordSummaries(rowNum, null, false, false);
    }
    return true;
},

// store an edit value, firing editorChange() notification if there was a change.
// internal helper: call setEditValue() instead


_storeEditValue : function (rowNum, colNum, fieldName, newValue, suppressDisplay, 
                            suppressChange, suppressSummaryRecalc, atomicValue)
{
    
    var changed = true, saveEqual = false,
        editSession, editValues, oldValue,
        undef;

    var dataPath = fieldName;
    // If we're working with a datapath, trim it (handles absolute dataPath being applied to field)

    if (dataPath.contains(isc.Canvas._$slash)) {
        dataPath = this._trimDataPath(dataPath);
    }

    editSession = this.getEditSession(rowNum, colNum);
    if (editSession != null) {
        editValues = editSession._editValues;
        // using getFieldValue() will allow us to use dataPath
        oldValue = isc.Canvas._getFieldValue(dataPath, null,
                                editValues, this, true, "edit");
    } else {
        // create a new set of edit values as necessary
        this.logInfo("creating new edit values for row: " + rowNum, "gridEdit");
        this.initializeEditValues(rowNum, colNum, !suppressDisplay, !suppressSummaryRecalc);
        editSession = this.getEditSession(rowNum, colNum);
        editValues = editSession._editValues;
    }

    // if there's no previous editValue, the old value is the original value from the
    // dataset
    if (oldValue === undef) {
        var record = this.getCellRecord(rowNum, colNum);
        oldValue = record ? isc.Canvas._getFieldValue(dataPath, null, record, this, true, "edit")
                          : null;
    
    } else saveEqual = true;

    
    
    var oldAtomicValue = oldValue, newAtomicValue = newValue;

    var field = this.getUnderlyingField(fieldName);
    if (field && field.type) {
        var simpleType = isc.SimpleType.getType(field.type);
        if (simpleType && simpleType.getAtomicValue != null) {
            oldAtomicValue = simpleType.getAtomicValue(oldValue, "compare");
            if (!atomicValue) newAtomicValue = simpleType.getAtomicValue(newValue, "compare");
        }
    }

    if (this.fieldValuesAreEqual(field, oldAtomicValue, newAtomicValue)) changed = false; 
        // indicate no change

    // store the changed value
    // Note: If newValue was not passed in, clear the field value instead
    
    if (newValue === undef) {
        isc.Canvas._clearFieldValue(fieldName, editValues, this, true);
    } else if (saveEqual || changed) {
        // Don't pass the field in - we don't want to run any conversion based on type - the
        // value passed in is the actual value we want to save.
        isc.Canvas._saveFieldValue(dataPath, (atomicValue ? field : null),
                                              newValue, editValues, this, true);

        // If we were passed an atomic value, pick up the raw value we actually stored
        // before firing the change handler
        
        if (atomicValue) {
            
            newValue = isc.Canvas._getFieldValue(dataPath, null, record, this, true);
        }
    }

//     this.logWarn("edit value changed: oldValue: " + this.echo(oldValue) +
//                   ", new value: " + this.echo(newValue) +
//                   ", save equal?:" + saveEqual +
//                   " updated edit vals:" + this.echo(editValues), "gridEdit");
    // fire the change notification.
    if (changed && !suppressChange){
        this._editorChange(rowNum, colNum, newValue, oldValue);
    }

    // Update the ruleContext

    if (changed && this._editorShowing && this.getEditRow() == rowNum) {
        var contextValues = {};
        contextValues[fieldName] = newValue;
        this._provideEditRecordToRuleContext(contextValues);
    }

    return changed; // indicate change
},

// setRowEditFieldName() - used to track which field was last being edited for some set of edit values
setRowEditFieldName : function (rowNum, fieldName) {

    var editSession = this.getEditSession(rowNum);
    // Set up empty edit values if necessary
    if (!editSession) {
        var colNum = this.getColNum(fieldName);
        this.setEditValues([rowNum, colNum], null, true);
        editSession = this.getEditSession(rowNum);
    }

    if (isc.isA.Number(fieldName)) fieldName = this.getFieldName(fieldName);
    editSession._lastField = fieldName;
},

// getEditField() - given an edited row / valuesID, return the name of the last field being
// edited for that row
getRowEditFieldName : function (editValuesID) {
    var editSession = this.getEditSession(editValuesID);
    return (editSession ? editSession._lastField : null);
},

// getRowEditColNum - returns the colNum for the last edited field within some edit row
getRowEditColNum : function (editValuesID) {
    var fieldName = this.getRowEditFieldName(editValuesID);
    return fieldName ? this.getColNum(fieldName) : null;
},


//> @method listGrid.getEditValue()
//
// Returns the current temporary locally stored edit value for some field within a record
// being edited.
//
// @param  rowNum  (number)    index of the row for which the editValue should be returned
// @param  colNum (number | String) index of the field, or fieldName, for which value should be
//                              returned
// @return (Any)   edit value for the field in question
// @group  editing
// @visibility external
//<

getEditValue : function (rowNum, colNum) {

    var colID = colNum
    if (isc.isA.String(colNum)) colNum = this.getColNum(colNum);
    if (this._editorShowing &&
        (this.getEditRow() == rowNum) && (this.getEditCol() == colNum))
    {
        this.storeUpdatedEditorValue();
    }
    // Note pass the original column ID (colNum or fieldName) on to the _getEditValue() method
    // since there may be no column associated with the fieldName passed in
    return this._getEditValue(rowNum, colID, true);
},

// Retrieve the stored edit value for some row / field
// (unlike the public method, this will NOT first check for the value present in the editor
// if showing)
// returnOpaqueValue parameter: If the field for which we want the edit value is of a
// simpleType with a 'getAtomicValue()' method, should we call that and extract the atomic
// value or return the raw complex object.
// Most internal usage cares about the atomic value so by default we return that, but if
// this param is passed we'll return the complex object.
_getEditValue : function (rowNum, colNum, returnOpaqueValue) {
    // Note: Edit values are a case where the distinction between a value being unset and
    // being set to null is important... One case implies the user has not edited a cell,
    // the other implies the user has cleared out an edit value from a cell...
    var vals = this._getEditValues(rowNum, colNum);
    // Return undefined rather than explicit null if the edit row doesn't have any stored
    // values
    if (vals == null) return;

    var field = this.getField(colNum);
    // pass the field to _getFieldValue() so that method can apply the 'getAtomicValue' method
    // if necessary
    if (field && !returnOpaqueValue) {
        return isc.Canvas._getFieldValue(null, field, vals, this, true, "edit");
    } else {

        // Convert the colNum to a fieldName to get the value
        var fieldID = this.getTrimmedFieldDataPath(field || colNum);
        return isc.Canvas._getFieldValue(fieldID, null, vals, this, true, "edit");
    }
},



//> @method listGrid.clearEditValue()   ([A])
//
//  Clear a field value being tracked as an unsaved user edit.<P>
//  The saved record value will be displayed in the the appropriate cell instead.
//  Will also discard any validation errors for the specified field / row.
//  <P>
//  Note that for edits to an existing record, clearing all edit values will drop the edit session
//  for the row altogether (it will no longer be returned by 
//  +link{listGrid.getAllEditRows()}). This is the not the case for unsaved
//  +link{startEditingNew(),new edit rows} - for these rows edit values will be retained
//  even if they are empty. To explicitly discard a new edit row, use
//  +link{listGrid.discardEdits()} instead.
// 
//  @group  editing
//  @visibility external
//
//  @param  editValuesID (number | Object)    Row number, primary keys object for the record,
//                                              or editValues object
//  @param  colNum (number | String)    Column number, or Name of field for which
//                                      the value is to be cleared
//<
// @param   suppressDisplay (boolean)   Optional internal parameter to avoid updating the
//                                      affected cell to display the field value for the record
//                                      rather than the cleared out edit value.

// Note that in LGs the second parameter can be a fieldName
// If we're dealing with a 1 record / cell data model (EG CubeGrid) we need to
// be passed either a true editValuesId as the first parameter OR a colNum and a rowNum
clearEditValue : function (editValuesID, colNum, suppressDisplay, dontDropAll) {
    var rowNum = (isc.isA.Number(editValuesID) ? editValuesID
                                               : this.getEditSessionRowNum(editValuesID));
    var fieldName = colNum;
    if (isc.isA.Number(fieldName)) fieldName = this.getEditorName(rowNum, fieldName);
    else colNum = this.getColNum(fieldName);

    // If the user is currently editing this field, ensure the current value in the edit form
    // item is stored in this.editValues before clearing it, (so that the focused field is
    // successfully cleared!)
    if (this._editorShowing) {
        if (this.getEditRow() == rowNum && this.getEditFieldName() == fieldName) {
            // Suppress change - we're about to clear the value anyway!
            this.storeUpdatedEditorValue(true);
        }
    }

    //
    // This method will remove the edit value from the appropriate editValues object
    // If that was the last editValue in the object, fall through to clearEditValues to remove
    // the entire object
    // Otherwise, if suppressDisplay is not passed:
    // - if the field had validation errors, re-style the affected cell to hide the validation
    //   style (by default a red outline)
    // - if there is an editRowForm item for the effected cell, update it's value to reflect
    //   the value of the record
    // - otherwise call refresh cell to update the static innerHTML for the cell

    var editSession = this.getEditSession(editValuesID, colNum);
    //this.logWarn("clearEditValue got editSession: " + this.echo(editSession));

    if (editSession == null) return;

    var editValues = editSession._editValues,
        hasChanges = false,
        submittedValues = editSession._submittedValues,
        gridHadErrors = this.hasErrors(),
        errors = editSession._validationErrors,
        hadErrors = errors && errors[fieldName],
        rowNum = editSession._rowNum;

    if (editValues != null) {
        var record = rowNum == null ? null : this.getRecord(rowNum);
        hasChanges = isc.propertyDefined(editValues, fieldName) &&
                     ((rowNum == null || record == null) ||
                         !this.fieldValuesAreEqual(this.getField(fieldName),
                                                   editValues[fieldName], record[fieldName]));

        delete editValues[fieldName];
        if (submittedValues) delete submittedValues[fieldName];
        if (errors != null) delete errors[fieldName];

        // If there's nothing in the editValues, clear the vals for the whole row if there's
        // an existing record
        
        if (!dontDropAll && 
                !(record == null && 
                    (!this.discardEmptyEditValuesForNewRows || 
                        (this._editorShowing && this.getEditRow() == rowNum))) && 
                isc.isAn.emptyObject(editValues)) 
        {
            this.logDebug("no edit values left for row, discarding editSession", "gridEdit");
            return this._clearEditValues(editValuesID, colNum, suppressDisplay);
        }
    }

    // If this field has a specified 'display' field, we track edit values on that field that
    // match the record with the editValue specified for this field.
    // Drop the value on the display field as well.
    
    var field = this.getField(fieldName);
    if (field && this._useDisplayFieldValue(field) && (field.displayField != fieldName)) {
        this.clearEditValue(editValuesID, field.displayField, suppressDisplay, dontDropAll)
    }

    // If the edit val isn't displayed in a cell in this grid, we're done
    // otherwise continue to update the value if it changed, and clear any errors from the
    // cell.
    
    if (suppressDisplay || rowNum == null) return;

    // Update the display:
    // - If the edit form is showing for the row always set its value for the field
    // - If the cell is visible, but we're not showing an edit form item for it, refresh the
    //   cell to display the value of the record
    // Otherwise if we had errors, refresh the cell to hide the error icons
    if (hasChanges) {
        var editItemDrawn;
        if (this._editorShowing && this.getEditRow() == rowNum) {
            var newVal = record ? record[fieldName] : null;
            this._editRowForm.setValue(fieldName, newVal);
            editItemDrawn = colNum >= 0 && this.canEditCell(rowNum, colNum) &&
                            this._editRowForm.getItem(fieldName);
        }

        if (colNum >= 0 && !editItemDrawn) this.refreshCell(rowNum, colNum);

    // If we had validation errors for the cell, call 'refreshCellStyle' to clear the
    // error hilight from the cell (only necessary if we didn't refresh the entire cell)
    } else if (hadErrors && colNum >= 0) {
        if (hadErrors) this.showCellErrors(rowNum, colNum);
    }
    this._updateGridHasErrorsInRuleScope(gridHadErrors);
},

//> @method listGrid._clearEditValues()
//
//  Clear a whole row of values being tracked as an unsaved user edit.<P>
//  This should not be used for clearing out the edit values for some row after a save
//  has completed.  When a save has been successfully confirmed for some set of cell values,
//  the stored values should be cleared cell by cell using 'clearEditValue()', rather than
//  this method.
//
//  @group  editing
//  @visibility internal
//
//  @param  editValuesID      (number | Object)    Identifier for the editValues to clear.
//                                                  This can be a rowNum, or a set of
//                                                  editValues (or a primary key)
//<
//  @param [colNum] (number) colNum of the record being edited. Only required if valuesID
//                           is passed in as a rowNum, and we're displaying one record per cell
//                          as in a +link{CubeGrid}
// @param   dontRefresh (boolean)   Optional internal parameter. If passed, don't update any
//                                  affected cells to display the removed edit values

_clearEditValues : function (editValuesID, colNum, dontRefresh) {
    // This method must
    // - update the central editSessions object to remove the specified set of edit values
    // - update the editRowMap if these values were mapped to a row.
    // - if this was a row beyond the end of the data for the List, shuffle subsequent
    //   temporary edit values down a rowNum
    // if refreshing to display the change:
    //   - if this was a row beyond the end of the list, it must be removed from the list:
    //      - if the editRowForm is showing for the row, it must be hidden
    //      - the body must be redrawn.
    //   - otherwise for each cell for which there was an edit value before this method must
    //     be updated.
    //      - if an edit form item is showing for the field
    //          - its value should be updated to show the record's value
    //          - if there were any validation errors for the row, the style of the relevant
    //            cells should be updated
    //      - otherwise the cell should be refreshed to show the record's value as static HTML.

    if (editValuesID == null) {
        
        return;
    }


    // If we're passed a rowNum, or primary keys, resolve to an editValuesID
    if (!isc.isA.String(editValuesID)) editValuesID = this.getEditValuesID(editValuesID, colNum);
    var editSession = this.getEditSession(editValuesID);
    

    // Bail if we can't get the object (not necessarily an error - may have already been
    // cleared)
    if (editSession == null) return;

    var rowNum = editSession._rowNum;
    if (rowNum != null) delete this._editRowMap[rowNum];
    // for cellRecords, ensure we have a valid rowNum and colNum
    if (colNum == null) colNum = editSession._colNum;

    var valuesObj = this._editSessions[editValuesID];

    // clear the object from the array
    delete this._editSessions[editValuesID];

    // Clear out the cached last edit row. Will be recalc'd lazily when required
    
    var lastRow = this._getLastEditRow();
    delete this._lastEditRow;
    // If this is a new record (not yet saved in the dataset), and we have any subsequent new
    // edit rows, we have to shuffle them down to fill the gap left by this record.
    if (rowNum != null && editSession._newRecord) {
        var editRow = this.getEditRow();

        for (var i = rowNum+1; i <= lastRow; i++) {
            var newRowObject = this.getEditSession(i);
            var oldRow = newRowObject._rowNum;
            newRowObject._rowNum = i-1;

            //this.logWarn("clearEditValues reordering temp rows." +
            //             " editSession: " + this.echo(newRowObject) +
            //             " was at row: " + oldRow);

            // No danger of putting this over another edit record, since we have already moved
            // every one.
            this._editRowMap[i-1] = this._editRowMap[i];
            delete this._editRowMap[i];
        }
        // If we're currently showing an editor for a subsequent temp-row, shift it up one row
        if (editRow != null && editRow > rowNum) this._editRowNum -= 1;

        //this.logWarn("clearEditValues: editRow was at: " + editRow +
        //             " now at: " + this._editRowNum);

        // We're clearing out edit values for an additional row beyond the end of the grid's data
        // refresh the UI if necessary
        if (!dontRefresh) {
            if (this._editorShowing) {
                    // if we're showing the inline editor for this row hide it now.
                    if (rowNum == editRow) this.hideInlineEditor();
                    // Otherwise if the edit row was AFTER this row, shuffle it up by 1 row to
                    // account for this row going away
                    else {
                        if (rowNum < editRow) this._moveEditor(editRow-1, null, "Earlier temp edit row removed");
                    }
            }
            // Redraw the body to hide the additional row.
            if (this.body) {
                var bodyContainer = this.frozenBody != null ? this.bodyLayout : this.body;
                bodyContainer.markForRedraw("clear edit values, remove row");
            }
        }

    } else if (rowNum != null && !dontRefresh && !isc.isAn.emptyObject(valuesObj._editValues)) {
        // _displayNewEditValues takes an object describing the new edit values to display
        // Explicitly pass in the vals from the underlying record object so we update the
        // edit-form items
        var changedVals = {},
            record = this.data.get(rowNum);
        for (var fieldName in valuesObj._editValues) {
            changedVals[fieldName] = record ? record[fieldName] : null;
        }
        this._displayNewEditValues(rowNum, colNum, changedVals,
                                   valuesObj._validationErrors);
   }
},






//> @method listGrid.newRecordForEditValues()
// Internal method to associate a set of pending edit values with a new record in the
// dataset.<br>
// This method is required to handle the saving of a new edit row on the end of a list.
// When the save returns we need to associate the edit values with the record in the dataSet
// (which may also change the rowNum of the record).
// With background saving (waitForSave:false), after the attempted save was submitted to the
// server, further editing may have taken place.  This method will make sure any further edits
// get associated with the new record.
//
// @param editValuesId (Identifer) id for the editValues which have been saved as a new record
// @param rowNum       (number) index of the newly saved record
// @visibility internal
//<


newRecordForEditValues : function (editValuesId, record) {

    
    var oldEditSession = this.getEditSession(editValuesId),
        editValues = oldEditSession._editValues;
    oldEditSession._primaryKeys = this.getPrimaryKeys(record);
    var pkFields = this.getDataSource().getPrimaryKeyFieldNames();
    for (var i = 0; i<pkFields.length; i++) {
        var field = pkFields[i];
        editValues[field] = record[field];
    }
    delete oldEditSession._newRecord;
},




// Re-associate all editValues with the appropriate rowNums for the records.
// Fired in response to dataChanged().
// This will be fired when the data is re-sorted, re-filtered, modified asynchronously from
// the server, or scrolled such that the cache is dropped when we have a partial cache.
// In any of these cases, the rowNums for each record can change (and in some cases rows can
// be entirely removed from the data cache)
// This method will attempt to match the editValues to the cached records after dataChanged()
// and update the rowNums as appropriate.  It will also take any editValues that represent
// newly created records and renumber them so they are past the new end of the dataset.
// If a record can't be found for some editValues object, there are a couple of possibilities:
// - If we have a complete cache (or local data), we know the record has gone from the dataSet
//   so we warn the user and clear out the editValues for that record
// - If we have a partial cache, the record may have gone from the resultSet (filter change,
//   for example), or it may be available in the resultSet, but not loaded in the client-side
//   cache (scrolled out of view).
//   In this case we keep the editValues around and set the _hasUnmatchedEdits flag on the
//   ListGrid.  getCellRecord() will then compare each record with the unmatched edits whenever
//   it is called, so we will re-associate the editValues with the appropriate rowNum as soon as
//   it is scrolled into view.
//   Note that editing will be dismissed if the record that was being edited vanishes in this
//   way.



// This method returns a boolean - true if any edit sessions were left intact and shifted to
// new rows, false otherwise.
_remapEditRows : function (dontMoveEditor) {
    // clear out the _lastEditRow and _hasUnmatchedEdits flags
    // - lastEditRow can get recalc'd lazily when required.
    // - we'll update _hasUnmatched edits below if required.
    delete this._lastEditRow;
    delete this._hasUnmatchedEdits;
    if (this._editSessions == null) return false;

    var remappedSession = false;

    var oldEditRow = this.getEditRow(),
        oldEditCol = this.getEditCol(),
        foundOldRecord = false;

    var lastRowNum = this.data.getLength(),
        editRowMap = {};

    // getKeys() first to avoid possible problems with key deletion during for..in (never
    // observed)
    var sessionList = isc.getKeys(this._editSessions);

    for (var i = 0; i < sessionList.length; i++) {


        var editValuesId = sessionList[i],
            editSession = this._editSessions[editValuesId];
        var oldRowNum = editSession._rowNum;

        var newCell = this._calculateEditCell(editSession, lastRowNum);
        // increment the lastRowNum if we added a row
        
        if (editSession._primaryKeys == null) lastRowNum ++;
        
        // newCell == null -> notification that we totally dropped an empty edit session
        if (newCell == null) continue;

        var newRowNum = newCell[0],
            newColNum = newCell[1];

        if (newRowNum != null && newRowNum >= 0) {

            if (newRowNum != oldRowNum) remappedSession = true;

            // we found the corresponding record in the modified dataset (or it was an unsaved,
            // newly created record)

            // Is this the current edit record?
            if (oldEditRow != null && oldEditRow == editSession._rowNum &&
                (!this.useCellRecords || (oldEditCol == editSession._colNum)))
            {
                foundOldRecord = true;
                // moveEditor will shift the edit form if necessary
                if (!dontMoveEditor) this._moveEditor(newRowNum, newColNum, "remapEditRows")
            }

            editRowMap[newRowNum] = editValuesId;

            editSession._rowNum = newRowNum;
            if (this.useCellRecords) editSession._colNum = newColNum;

        } else {

            if (oldRowNum != null && oldRowNum >= 0) remappedSession = true;

            var liveData = this.getOriginalData();
            var localSave = !this.dataSource || this.shouldSaveLocally() ||
                (isc.ResultSet && isc.isA.ResultSet(liveData) && liveData.allRowsCached());

            // drop the edit if the record being edited was clearly deleted
            // Don't blindly drop the record if we're grouped or data is a tree,
            // it may have just been hidden (folder closed) - in which case the rowNum
            // would be -1 -- use 'find' to see if the node is present in the tree
            // at all.
            if (localSave && !isc.isA.Tree(this.data) &&
                    (!this.isGrouped || !this.data.find(editSession._primaryKeys))
                )
            {
                // Don't log a warning if this was a successful remove - in that case
                // we expect the record to be gone
                if (!(editSession._editValues && 
                    editSession._editValues[this.recordRemovedProperty] &&
                    editSession._editValuesSaved) )
                {
                    this.logWarn("Record:" + this.echo(editSession._primaryKeys) +
                       ", is no longer present in this List. " +
                       "Clearing edit values for this record.", "gridEdit");
                }
                
                delete this._editSessions[this.getEditValuesID(editValuesId)];

            } else {
                // the record could be either truly gone, or just not in the cache.  Hold onto
                // the edits hoping the record reappears (in which case we'll re-associate the
                // edit values with the record).
                // Note: If we're working with a paged result set, the data will typically have
                // disappeared because it has been scrolled out of view (due to data resort,
                // etc.) In this case it will reappear with scrolling.
                // However the data may have disappeared as it no longer matches the current
                // filter criteria.
                // We could also add a check for 'data.allMatchingRowsCached()' and handle the
                // case where we have loaded all the records for the current filter criteria
                // differently. We're much more likely to encounter the case of having loaded
                // all rows that match some criteria than caching every row in the data set.
                
                this.logInfo("Record:" + this.echo(editSession._primaryKeys) +
                    (localSave ? ", hidden in grouped tree data. " :
                                ", lost from local cache in paged result set. ") +
                    "Pending edits for this record will be maintained.", "gridEdit");
                    
                    
                delete editSession._rowNum;
                delete editSession._colNum;
                this._hasUnmatchedEdits = true;
            }
        }
    }
    // store the new editSession locations
    this._editRowMap = editRowMap;

    
    if (oldEditRow != null && !foundOldRecord && !dontMoveEditor) {
        this.hideInlineEditor(true);
    }
    return remappedSession;
},

// helper method called from dataChanged() to re-associate embeddedComponents stored in the
// grid body with the appropriate records
_remapEmbeddedComponents : function () {

    if (!this.body || this.body._embeddedComponents == null) return;

    if (this.showRecordComponents && this.recordComponentPoolingMode != "data") {
        this._remapVisibleEmbeddedComponents();
        return;
    }

    var components = this.body._embeddedComponents,
        componentCount = components ? components.length : 0,
        removeThese = [];

    // reset the _expandedRecordCount - we'll increment it if a currentRowNum is detected below,
    // and component.isExpansionComponent:true, rather than decrementing it if
    // the row is NOT present.  This handles the case of records eliminated from cache by
    // filtering.
    this._expandedRecordCount=0;
    
    var totalRows = this.getTotalRows();
    for (var i = 0; i < componentCount; i++) {
        // get the keys for the record associated with the embeddedComponent
        var component = components[i],
            embeddedRecord = component.embeddedRecord,
            recordKeys = this.getPrimaryKeys(embeddedRecord),
            currentRowNum = component._currentRowNum,
            // if this method runs from dataChanged, the currentRowNum on selection/rollOver 
            // canvases may now exceed totalRows - don't run get() in that case
            currentRecord = currentRowNum == null || currentRowNum >= totalRows ? null :
                this.data.get(currentRowNum),
            getRecord = false
        ;

        if (!(currentRecord === embeddedRecord)) {
            // only call findRowNum if the record has moved or changed
            currentRowNum = this.findRowNum(recordKeys);
            getRecord = true;
        }

        if (currentRowNum >= 0) {
            // only call data.get() for a second time if findRowNum was also called - otherwise
            // we already have the correct currentRecord
            if (getRecord) currentRecord = this.data.get(currentRowNum);
            // the record is present in the cache, rebuild the association between the record
            // and the embeddedComponent
            if (currentRecord && !this._hasEmbeddedComponents(currentRecord) ||
                    !this._getEmbeddedComponents(currentRecord).contains(component))
            {
                component._currentRowNum = currentRowNum;
                component.embeddedRecord = currentRecord;
                this._addEmbeddedComponent(currentRecord, component);
                
                if (component.isExpansionComponent) {
                    if (this.maxExpandedRecords == null ||
                        (this._expandedRecordCount < this.maxExpandedRecords))
                    {
                        this._expandedRecordCount++;
                        this._setExpanded(currentRecord, true);
                        this._setExpansionComponent(currentRecord, true);
                        if (!this.canExpandMultipleRecords) this._currentExpandedRecord = currentRecord;
                    } else {
                        // remove the 'expanded' marker from the row, and
                        // fire 'removeEmbeddedComponent' to clear up "embeddedComponent"
                        // markers on the record, etc.
                        // This will also clear the component - we still may want to
                        // destroy it below so also add to the "removeThese" list.
                        this._setExpanded(currentRecord, false);
                        this._setExpansionComponent(currentRecord, false);

                        this.removeEmbeddedComponent(currentRecord, component, true);
                        removeThese.add(component);
                        continue;
                    }
                } else {
                    // re-add to the "_recordComponents_" array on the record
                    this._addRecordComponent(currentRecord, component._currentFieldName, component);
                }
            }
        } else {
            // Note - even if indexOf returned -1,
            // the embeddedRecord may actually be non null here - either having been
            // dropped from this.data, or being a node in a closed parent in a tree.
            // Clear up the flags on the record object in this case as well.
            
            if (isc.isA.Tree(this.data)) {
                var pkVals;
                if (isc.ResultTree && isc.isA.ResultTree(this.data)) {
                    var pks = this.data.getDataSource().getPrimaryKeyFieldNames();
                    pkVals = isc.applyMask(embeddedRecord, pks);
                } else {
                    pkVals = embeddedRecord;
                }
                currentRecord = this.data.find(pkVals);
            }
            if (currentRecord == null) currentRecord = embeddedRecord;

            if (this._shouldRetainEmbeddedComponents == false ||
                    (this.showRecordComponents && this.recordComponentPoolingMode == "data") ||
                    
                    (component.isExpansionComponent)
            ) {
                if (currentRecord != null) {
                    // This is essentially a dup of code form _removeEmbeddedComponent:
                    var ids = currentRecord[this._$embeddedComponentsPrefix + this.ID];
                    if (ids != null && ids.length > 0) {
                        ids.remove(component.getID());
                    }
                    if (ids && ids.length == 0) {
                        currentRecord[this._$embeddedComponentsPrefix + this.ID] = null;
                    }
                    // remove the 'expanded' marker from the row
                    if (component.isExpansionComponent) {
                        this._setExpanded(currentRecord, false);
                        this._setExpansionComponent(currentRecord, false);
                    }
                }
                // remove the embeddedComponent from the grid body and rehash the properties
                // that track expandedRecords
                removeThese.add(component);
            }
        }

    }
    if (removeThese.length>0) {
        // get rid of any embeddedComponents that no longer map to a cached row and update the
        // associated props that track expandedRecords
        for (var i = 0; i < removeThese.length; i++) {
            var item = removeThese[i];

            // only affect expandedRecord values if we're using expansionComponents - this loop
            // now also runs for recordComponents
            if (this.canExpandRecords) {
                if (this._currentExpandedRecord && this._currentExpandedRecord == item.embeddedRecord)
                    delete this._currentExpandedRecord;
            }
            this.body._embeddedComponents.remove(item);
            if (this.shouldDestroyOnUnembed(item, this._$dataChanged)) {
                item.markForDestroy();
            } else {
                item.deparent();
            }
        }
    }
},

// helper method called from remapEmbeddedComponents() when recordComponentPoolingMode is not "data"
_remapVisibleEmbeddedComponents : function () {

    var debugLog = this.logIsDebugEnabled("recordComponents");

    if (!this.body || this.body._embeddedComponents == null) return;

    var allComponents = this.body._embeddedComponents,
        removeThese = [],
        drawArea = this.getDrawArea(),
        rowRange = [ drawArea[0], drawArea[1] ]
    ;

    if (rowRange[0] == null && rowRange[1] == null) return;

    // reset the _expandedRecordCount - we'll increment it if a currentRowNum is detected below,
    // and component.isExpansionComponent:true, rather than decrementing it if
    // the row is NOT present.  This handles the case of records eliminated from cache by
    // filtering.
    this._expandedRecordCount=0;

    var remappedCount = 0,
        inPlaceCount = 0
    ;

    if (debugLog) {
        this.logDebug("START _remapVisibleEmbeddedComponents - rowRange is: " + rowRange);
    }

    for (var i=rowRange[0]; i<=rowRange[1]; i++) {
        var record = this.data.get(i),
            recordEntries = record ? this._getRecordComponents(record) : null,
            components = recordEntries ? isc.getValues(recordEntries) : null
        ;

        if (components) {
            for (var j=0; j<components.length; j++) {
                var component = components[j];
                if (!component || component.isNullMarker) continue;
                if (component._currentRowNum == i) {
                    if (debugLog) {
                        this.logDebug(component.ID + " remains at rowNum " + i + ": no action");
                    }
                    // record is still in the same place - just ignore it
                    component._detectedInLoop = true;
                    inPlaceCount++;
                    continue;
                }

                component._currentRowNum = i;
                this._addEmbeddedComponent(record, component);
                component._detectedInLoop = true;
                remappedCount++;
                
                if (component.isExpansionComponent) {
                    if (this.maxExpandedRecords == null ||
                        (this._expandedRecordCount < this.maxExpandedRecords))
                    {
                        if (debugLog) {
                            this.logDebug("ExpansionComponent " + component.ID + " added at " +
                                "row " + i,
                                "recordComponents");
                        }
                        this._expandedRecordCount++;
                        this._setExpanded(record, true);
                        this._setExpansionComponent(record, true);
                        if (!this.canExpandMultipleRecords) this._currentExpandedRecord = record;
                    } else {
                        if (debugLog) {
                            this.logDebug("Removed expansionComponent " + component.ID + 
                                " from row " + i + ": too many expanded records", 
                                "recordComponents");
                        }
                        // remove the 'expanded' marker from the row, and
                        // fire 'removeEmbeddedComponent' to clear up "embeddedComponent"
                        // markers on the record, etc.
                        // This will also clear the component - we still may want to
                        // destroy it below so also add to the "removeThese" list.
                        this._setExpanded(record, false);
                        this._setExpansionComponent(record, false);

                        this.removeEmbeddedComponent(record, component, true);
                        removeThese.add(component);
                        continue;
                    }
                } else {
                    if (debugLog) {
                        this.logDebug("recordComponent " + component.ID + " added at row " + i, 
                            "recordComponents");
                    }
                }
            }
        }

    }

    if (this.recordComponentPoolingMode != "data") {
        for (var i = 0; i < allComponents.length; i++) {
            var c = allComponents[i];
            if (c._detectedInLoop) delete c._detectedInLoop;
            else {
                // don't remove rollOver/UnderCanvas
                if (c == this.currentRollOverCanvas || c == this.currentRollUnderCanvas) continue;
                if (c.isBackgroundComponent || c.isExpansionComponent) {
                    // if this is an expansion component, only remove the component if the
                    // stored record is no longer in the grid - prevents us from removing
                    // components because an expanded record was scrolled out of view
                    var r = this.getRecordIndex(c.embeddedRecord);
                    if (r >= 0) {
                        if (c.isExpansionComponent) this._expandedRecordCount++;
                    } else {
                        if (c.isExpansionComponent && c.embeddedRecord) {
                            // the component is from a record which is no longer present -
                            // remove expansionComponent references
                            this._setExpanded(c.embeddedRecord, false);
                            this._setExpansionComponent(c.embeddedRecord, false);
                        }
                        removeThese.add(c);
                    }
                } else if (c.isRecordComponent) {
                    if (debugLog) {
                        this.logDebug("adding recordComponent " + c.ID + " to remove list ", 
                            "recordComponents");
                    }

                    removeThese.add(c);
                }
            }
        }
    }

    if (removeThese.length>0) {
        // get rid of any embeddedComponents that no longer map to a cached row and update the
        // associated props that track expandedRecords
        for (var i = 0; i < removeThese.length; i++) {
            var item = removeThese[i];

            // for recordComponents, ensure we remove the component from the "liveRecordComponents" list
            // so updateRecordComponents() doesn't get confused about whether this
            // item is currently actively visible in the grid.            
            var lrc = this._liveRecordComponents,
                lrcObj = this._liveRecordComponentsObj;
            if (lrcObj && lrcObj[item.ID] != null) {
                delete lrcObj[item.ID];
                lrc.remove(item);
            }

            // only affect expandedRecord values if we're using expansionComponents - this loop
            // now also runs for recordComponents
            if (this.canExpandRecords) {
                if (this._currentExpandedRecord && this._currentExpandedRecord == item.embeddedRecord)
                    delete this._currentExpandedRecord;
            }
            if (item.isRecordComponent && this.recordComponentPoolingMode == "recycle") {
                if (debugLog) {
                    this.logDebug("_remapVisibleEmbeddedComponents() about to clean up " +
                        " recordComponent " + item.ID,
                        "recordComponents");
                }
                this._cleanUpRecordComponent(item);
            } else {
                this.body._embeddedComponents.remove(item);
                if (this.shouldDestroyOnUnembed(item, this._$dataChanged)) {
                    if (debugLog) {
                        this.logDebug("_remapVisibleEmbeddedComponents() calling " +
                            " markForDestroy() on component " + item.ID,
                            "recordComponents");
                    }
                    item.markForDestroy();
                } else {
                    if (debugLog) {
                        this.logDebug("_remapVisibleEmbeddedComponents() deparenting " +
                            "component " + item.ID,
                            "recordComponents");
                    }
                    item.deparent();
                }
            }
        }
    }

    //this.logWarn("remappedCount = " + remappedCount + "\ninPlaceCount = " + inPlaceCount);
    if (debugLog) {
        this.logDebug("END _remapVisibleEmbeddedComponents:\n\t" + 
            "remappedCount = " + remappedCount + 
            "\n\tinPlaceCount = " + inPlaceCount,
            "recordComponents");
    }
},

// Helper method to update all per-cell embedded components' "_currentColNum" based on the stored
// field name for the component
// Called per body when we reorder fields, show/hide fields etc.
// Note: this method updates all embedded components. It doesn't re run any specific
// recordComponent logic to re-create recordComponents on column reorder, or to re-pool components
// that are no longer visible. This is all handled by updateRecordComponents() which fires on
// redraw.
_$columnRemap:"column remap",
_remapEmbeddedComponentColumns : function (body) {

    if (body._embeddedComponents == null) return;
    
    var debugLog = this.logIsDebugEnabled("recordComponents");
    
    var components = body._embeddedComponents,
        fieldMap = {},
        changes = false;
    for (var i = 0; i < body.fields.length; i++) {
        fieldMap[body.fields[i].name] = i;
    }
    // clear embedded components that are no longer visible once we've iterated through
    // this loop to avoid the array length being effected.
    var componentsToClear = [];
    for (var i = 0; i < components.length; i++) {
        var fieldName = components[i]._currentFieldName;
        // this is expected - it's not a per-cell component.
        if (fieldName == null) {
            continue;
        }
        var colNum = fieldMap[fieldName];
        

        // If the field has been hidden just remove the embedded component.
        
        if (colNum == null) {
            componentsToClear[componentsToClear.length] = components[i];
        } else {
            if (components[i]._currentColNum != colNum) {
                changes = true;
                components[i]._currentColNum = colNum;
            }
        }
    }
    if (componentsToClear.length > 0) {
        for (var i = 0; i < componentsToClear.length; i++) {
            var comp = componentsToClear[i];
            if (comp.isRecordComponent && this.recordComponentPoolingMode == "recycle") {
                if (debugLog) {
                    this.logDebug("_remapEmbeddedComponentColumns() about to clean up " +
                        " recordComponent " + comp.ID,
                        "recordComponents");
                }
                this._cleanUpRecordComponent(comp);
                changes = true;
            } else if (comp.removeOnHideField) {
                body.removeEmbeddedComponent(comp.embeddedRecord, comp);
                if (this.shouldDestroyOnUnembed(comp, this._$columnRemap)) {
                    comp.markForDestroy();
                }
                // already cleared by removeEmbeddedComponent() so no need to clear() or
                // deparent() here if we didn't mark for destroy
            } else {
                
                changes = true;
            }
        }
    }

    if (changes) {
        body._placeEmbeddedComponents();
    }
},

// calculateCell - helper for remapEditRows - given an editSession determine which cell it
// currently belongs to so we can update editSession._rowNum/colNum etc
_calculateEditCell : function (editSession, lastRowNum) {
    var newRowNum, newColNum,
        pk = editSession._primaryKeys;
    // in the case of a new edit row, we want to just make sure the rowNums are off the
    // end of the data...
    if (pk == null) {
        newRowNum = lastRowNum;

    } else {

        // if the editValues consist of just primary keys, drop them unless this is the
        // editSession for the current editRow
        
        var editValues = editSession._editValues,
            hasEdits = false,
            undef;
        if (editSession._validationErrors != null &&
            !isc.isA.emptyObject(editSession._validationErrors_))
        {
            hasEdits = true;
        } else {
            for (var val in editValues) {
                if (editValues[val] != pk[val] || pk[val] === undef) {
                    hasEdits = true;
                    break;
                }
            }
        }

        if (!hasEdits && editSession._rowNum != null &&
            !this.isEditingRecord(editSession._rowNum, editSession._colNum))
        {
            this.logInfo("dropping empty editSession", "gridEdit");
            delete this._editSessions[this.getEditValuesID(editSession)];
            return null;
        }

        // look for a row with matching primary keys
        newRowNum = this.findRowNum(pk, editSession);
        // colNum will only apply when the data model shows 1 record/cell (EG CubeGrid);
        newColNum = this.findColNum(pk, editSession);
    }

    return [newRowNum,newColNum];
},

// Override _filter
// - if we have pending edits, changing the filter criteria means that the
//   edited rows may not show up in the returned set of values.
//   For windowed result sets this is true even if we're broadening our criteria, as the edited
//   row may not be in our viewport.
//   In this case if confirmDiscardEdits is true, show a dialog giving the user a chance to
//   save or discard unsaved edits.
// - if we are showing a filterEditor, update the filterEditor values to show the new criteria
_filter : function (type, criteria, callback, requestProperties, doneSaving) {

    // call setFields() for the first time, if it hasn't already been done
    // This will "complete" databinding -- Ensure that we combine our DataSource's
    // field attributes with live specified field attributes for issuing a server request.
    if (this.completeFields == null) this.setFields(this.fields);

    if (!doneSaving 
            && (this.confirmDiscardEdits || this.autoConfirmSaveEdits) 
            && this.dataSource != null)
    {
        var data = this.getOriginalData();

        if (this.hasChanges() &&
            // If the criteria is unchanged, the filter will be a no-op. In this case
            // no need to drop edit values
            
            !(isc.ResultSet && isc.isA.ResultSet(data) &&
                  data.compareCriteria(criteria, data.getCriteria()) == 0) )
        {
            this._filterArgs = {
                type:type, criteria:criteria, callback:callback,
                requestProperties:requestProperties
            }
            this.showLostEditsConfirmation({target:this, methodName:"_continueFilter"},
                                           {target:this, methodName:"_cancelFilter"});
            return;
        }
    }
    // Apply criteria to filterEditor.
    
    // If passed a filter component, resolve to actual filter values!
    var criteriaValues = criteria;
    if (isc.isA.Class(criteriaValues)) {
        criteriaValues = isc.DynamicForm.getFilterCriteria(criteriaValues);
    }

    var ds = this.getDataSource();

    if ((ds || isc.DS).isAdvancedCriteria(criteriaValues)) {
        // if the criteria is advanced, compress it - walks the entire criteria, flattens and 
        // removes unnecessary wrapper criteria - improves what can be edited in the 
        // filterEditor
        criteriaValues = isc.DS.compressNestedCriteria(criteriaValues);
    }

    
    this.setFilterValues(criteriaValues, true);

    // Combine any other user-edited criteria before performing the actual filter
    criteria = this._combineUserCriteria(criteria);

    return this.Super("_filter", [type,criteria,callback,requestProperties], arguments);
},

// "User Criteria" may come from
// - filter editor / filterData(...) call [passed into this method as an arg]
// - filter window
// - search form
// Helper to combine these into a single advancedCriteria object
// Note that these may be combined with implicitCriteria downstream 
// [see dataBoundComponent._filter and dataSource.dbcImplicitCriteria]
_combineUserCriteria : function (criteria) {
    var ds = this.getDataSource();

    if (this.filterWindowCriteria) {
        criteria = (ds || isc.DS).combineCriteria(criteria, this.filterWindowCriteria, "and", this.autoFetchTextMatchStyle);
    }

    
    // this method lazily resolves a string-ID in lg.searchForm 
    this.checkForSearchForm();
    if (this.searchFormCriteria) {
        criteria = (ds || isc.DS).combineCriteria(criteria, this.searchFormCriteria, "and", this.autoFetchTextMatchStyle);
    }
    return criteria;

},

// Completes a filter after the user has been prompted to save or discard pending edits.
_continueFilter : function () {
    var args = this._filterArgs,
        type = args.type, criteria = args.criteria, callback = args.callback,
        requestProperties = args.requestProperties;
    delete this._filterArgs;
    this._filter(type, criteria, callback, requestProperties, true);
},

// Fired when a user cancelled a filter to resolve pending edits.
_cancelFilter : function () {
    delete this._filterArgs;
},

// showLostEditsConfirmation() - this method is fired from sort / filter if there are
// outstanding unsaved edits that may be otherwise lost by the sort/filter action.
// Shows the user a dialog with options to save, discard, or cancel.
showLostEditsConfirmation : function (continueCallback, cancelCallback) {
    // these callbacks will be fired, then cleared up when the callback fries from the
    // global warn dialog.
    this._continueCallback = continueCallback;
    this._cancelCallback = cancelCallback;

    if (this.autoConfirmSaveEdits) {
        this.lostEditsCallback("save", null);
    } else {
        isc.confirm(this.confirmDiscardEditsMessage,
                    "if(window[this.targetGridID])window[this.targetGridID].lostEditsCallback(value, this);",
                    {   targetGridID:this.getID(),


                        // Show "OK", "Save" and "Cancel" buttons
                        buttons:[isc.Dialog.OK,
                                 {title:this.discardEditsSaveButtonTitle, width:75,
                                  click:"this.hide();this.topElement.returnValue('save');"},
                                 isc.Dialog.CANCEL]
                    });
    }
},

// Fired as a callback from the user selecting ok/save/cancel from the dialog displayed in
// showLostEditsConfirmation().
// Will save or discard edits as appropriate, and call any callback (used to fire the action
// after the values have been saved / discarded).
lostEditsCallback : function (value, dialog) {
    var continueCallback = this._continueCallback,
        cancelCallback = this._cancelCallback;
    delete this._continueCallback;
    delete this._cancelCallback;

    // CancelClick
    if (value == null) {
        this.fireCallback(cancelCallback);

    // Ok click
    } else if (value == true) {
        this.discardAllEdits();
        this.fireCallback(continueCallback);

    // save click
    } else if (value == "save") {
        // Pass continueCallback into saveAllEdits - we want to allow the
        // original action to continue after the save completes
        this.saveAllEdits(null, continueCallback);
    }

    // clear out the targetGrid pointer from the global warn dialog
    if (dialog) dialog.targetGrid = null;
},

// Given the primary keys for some record, return the rowNum.

findRowNum : function (primaryKeys) {

    var dataSource = this.getDataSource(),
        isAnArray = isc.isA.Array(this.data);

    // If a DataSource is present and the data object is an Array, and the 
    // target has primary key values, use findByKeys on the
    // DataSource to compute index; otherwise, call indexOf on the data.
    if (dataSource && isAnArray) {
        var pkFields = dataSource.getPrimaryKeyFields(),
            hasPKs = false;
            
        if (pkFields) {
            // getPrimaryKeyFields() returns a map of fieldName to field-object
            for (var key in pkFields) {
                if (primaryKeys[key] == null) {
                    hasPKs = false;
                    break;
                }
                hasPKs = true;
            }
        }
        // Having no primary keys is valid in some cases - a dataSource where editing
        // (to the DS) is disallowed may not have primary keys defined [and we could still allow
        // in-grid editing of local data], or we could be dealing with special data which
        // is lacking PKs for some other reason - for example a batch of new records
        // pending submission in bulk as in the BatchUploader 'preview grid'.
        // Typically this implies saveLocally will be true - log a warning if this flag is
        // not set as we may just be dealing with bad target record data
        if (!hasPKs) {
            if (!this.shouldSaveLocally()) {
                this.logWarn("findRowNum(): Attempt to find row number on dataBound grid. " +
                             "Target record has no primary keys. Typically this is only supported " +
                             "where listGrid.saveLocally is true. Specified primaryKeys are :" +
                             this.echo(primaryKeys));
            }
            // indexOf will use object identity
            return this.data.indexOf(primaryKeys);
        } else {
            return dataSource.findByKeys(primaryKeys, this.data);
        }
    }

    // ResultSet / ResultTree indexOf will look up data by PK rather than object identity
    // automatically
    return this.data.indexOf(primaryKeys);
},

// Given the primary keys for some record return the colNum of the cell displaying the
// record
// Required to support 1 record / cell data model (EG cubeGrid)
findColNum : function (primaryKeys) {
    // ListGrids never show 1 record/cell so just return -1
    return -1;
},




_moveEditor : function (rowNum, colNum, reason) {

    if (!this._editorShowing || rowNum == this._editRowNum) {
        return;
    }

    var previousRow = this._editRowNum;

    this.logInfo(reason + ": editSession: " + this.getEditValuesID(rowNum) +
                 " with values: " + this.echo(this._getEditValues(rowNum, colNum)) +
                 " was being edited at row: " + previousRow +
                 ", will now edit at row: " + rowNum, "gridEdit");
    this._editRowNum = rowNum;

    var editForm = this._editRowForm,
        items = editForm ? editForm.getItems() : null;
    if (items) {
        for (var i = 0; i < items.length; i++) {
            items[i].rowNum = rowNum;
        }
    }

},

//> @method listGrid.rowEditNotComplete()
//  Given a rowNum, return true if we have locally stored editValues for the row.  This implies
//  that it is the current edit row (an editor is showing in that row), or that it has not been
//  saved since it was edited - likely due to save / validation errors.
//  @group  editing
//  @visibility internal
//  @param  rowNum (number) index of row for which we want to determine 'edit status'
//  @return (boolean)   true if we still have edit values for the row
//<

rowEditNotComplete : function (rowNum) {
    return (this._editRowMap != null && this._editRowMap[rowNum] != null);
},

// ---------------------------------------------------------------------------------------

_editorChange : function (rowNum, colNum, newValue, oldValue) {
    
    var record = this.getCellRecord(rowNum, colNum);
    if (this.editorChange != null) this.editorChange(record,newValue,oldValue,rowNum,colNum);
    //>!BackCompat 2004.12.10
    var fieldName = this.getFieldName(colNum);
    if (this.editValueChanged != null)
        this.editValueChanged(rowNum, fieldName, newValue, oldValue);
    //<!BackCompat


    // If we are providing dynamic edit item value maps for any fields, they may return a
    // different value since their value may be dependent on the edited field.
    // Therefore we go through and determine whether we need to update the valueMap for any
    // form items visible in the rowEditForm.
    
    if (this._editorShowing && this.isEditingRecord(rowNum, colNum) && this.fields != null) {
        record = isc.addProperties({}, this._getEditValues(rowNum, colNum), record);
        var fields = !this.editByCell ? this.fields : [this.getEditField()];


        for (var i =0; i < fields.length; i++) {
            var field = fields[i],
                formItem = this._editRowForm.getItem(field[this.fieldIdProperty]);

            // We don't create form items for un-rendered fields if we're incrementally rendering
            if (formItem == null) continue;

            var valueMap = this.getEditorValueMap(
                            field, this.getEditedRecord(rowNum, colNum, true), formItem);
            

            if (formItem.valueMap != valueMap) {
                var changed = true;
                if (isc.isAn.Array(valueMap) && isc.isAn.Array(formItem.valueMap)) {
                    changed = !valueMap.equals(formItem.valueMap);

                } else if (isc.isAn.Object(valueMap) && isc.isAn.Object(formItem.valueMap)) {
                    if (isc.getKeys(valueMap).equals(isc.getKeys(formItem.valueMap))) {
                        changed = false;
                        for (var key in valueMap) {
                            if (valueMap[key] != formItem.valueMap[key]) {
                                changed = true;
                                break;
                            }
                        }
                    }
                }
                // we're rerunning getEditorValueMap on every change of the item.
                // Its very likely that the vm will be a different object but meaningfully unchanged
                // - check for this since we don't want to call setValueMap() if unnecessary.
                // This causes a side-effect where if a multiple:true pickList is showing it'd
                // appear to auto-dismiss on every selection change.
                if (changed) formItem.setValueMap(valueMap);
            }
        }
    }
},


//> @method listGrid.getEditRow()
// Returns the index of the row being edited or <smartclient>null</smartclient>
// <smartgwt>-1</smartgwt> if there is no current edit row.
//
// @return (int) index of the current edit row
// @group  editing
// @visibility external
//<
getEditRow : function () {
    return this._editRowNum;
},

//> @method listGrid.getEditCol()
// Returns the index of the column being edited or <smartclient>null</smartclient>
// <smartgwt>-1</smartgwt> if there is no current edit column.
//
// @return (int) index of the current edit column
// @group  editing
// @visibility external
//<
getEditCol : function () {
    return this._editColNum;
},

//> @method listGrid.getEditField()
//
//  Returns the field object associated with cell currently being edited
//
//  @group  editing
//  @visibility external
//
//  @return (Object)    Field object definition
//<
getEditField : function () {
    return this.getField(this.getEditCol());
},

//> @method listGrid.getEditFieldName()
//
//  Returns the field name for the current edit field
//
//  @group  editing
//  @visibility internal
//
//  @return (String) Field name
//<
getEditFieldName : function () {
    return this.getFieldName(this.getEditCol());
},


//> @method listGrid.getEditRecord()
//
//  Returns the record object currently being edited
//
//  @group  editing
//  @visibility internal
//
//  @return (Object)    Current edit record object
//<
getEditRecord : function () {
    return this.getCellRecord(this.getEditRow(), this.getEditCol());
},

//> @method listGrid.cancelEditing()
//
//  Cancel the current edit without saving.
//
//  @group  editing
//  @visibility external
//<
// Called directly from cellEditEnd with escape keypress, etc.
// Exposed so may also be called programmatically by developers
cancelEditing : function (editCompletionEvent) {
    if (!this._editorShowing) return;

    // fall through to 'discardEdits' to drop the edit values and hide the editor
    // Note: that method also catches the case where alwaysShowEditors is true and avoid hiding
    // the editor.
    this.discardEdits(this.getEditRow(), this.getEditCol(), false, editCompletionEvent);

},

//> @method listGrid.cellEditEnd()
//
//  Method called on when editing ends for a cell as a result of a user interaction.
//  <P>
//  Editing may continue in another cell or row or end entirely, depending on the
//  editCompletionEvent, which represents what action the user took to end editing.
//  <P>
//  If this.shouldCancelEdit(rowNum, colNum, editCompletionEvent) returns true, the edit is
//  cancelled.
//  <P>
//  Otherwise the edit will be saved, and we'll proceed to a new cell to edit based on
//  getNextEditCell(rowNum, colNum, editCompletionEvent).
//  <P>
//  Return false from this method to notify the caller that the intended behavior failed -
//  typically this cancels the cell edit end (restoring focus to the appropriate edit-field).
//
//  @group  editing
//  @visibility internal
//
//  @param  editCompletionEvent (EditCompletionEvent)  Edit completion event constant
//                                                          indicating how edit was
//                                                          completed
//  @param  [newValue]    (Any)   New Value for the edited cell. If not passed will be derived
//                                from current editor value for the edited cell.
//  @return (boolean)    False if the user should still be editing the current cell.
//<
cellEditEnd : function (editCompletionEvent, newValue) {
    // delete the _editSessionFromKeypress flag when editing completes unless the user is
    // simply using the keyboard to shift to another cell
    if (this._editSessionFromKeyPress &&
        editCompletionEvent != isc.ListGrid.TAB_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.SHIFT_TAB_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.UP_ARROW_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.DOWN_ARROW_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.LEFT_ARROW_KEYPRESS &&
        editCompletionEvent != isc.ListGrid.RIGHT_ARROW_KEYPRESS) delete this._editSessionFromKeyPress

    var rowNum = this.getEditRow(),
        colNum = this.getEditCol();
    if (rowNum == null && colNum == null) return;

    // If we were passed a new value, store it as an editValue
    // (Otherwise the next call to getEditValue() / getEditValues()
    //  [changeEditCell / saveAndHideEditor] will pick up the current edit value
    //  from the form item)
    if (arguments.length >= 2) {
        this.setEditValue(rowNum, colNum, newValue);
    }

    //this.logInfo("cellEditEnd: editValues: " + this.echo(this.getEditValues(rowNum)) +
    //             ", old values: " + this.echo(this.getRecord(rowNum)), "gridEdit");

    
    var fieldName = this.getFieldName(colNum),
        shouldCancelEdit = this.shouldCancelEdit(rowNum, colNum, editCompletionEvent);
    if (shouldCancelEdit) return this.cancelEditing(editCompletionEvent);

    

    // get the next editCell (if null, we're done with the edit)
    var nextEditCell = this.getNextEditCell(rowNum, colNum, editCompletionEvent);
    // The 'newEditCell' is used by getNextEditCell.  Clear it out now, since we've determined
    // which cell we'll be editing.
    this.clearNewEditCell();

    // if we've no next cell to go to, we're done editing
    if (nextEditCell == null) {
        //>DEBUG
        this.logInfo("cellEditEnd: ending editing, completion event: " + editCompletionEvent,
                     "gridEdit"); //<DEBUG
        this._saveAndHideEditor(editCompletionEvent);
        return;
    }

    // prevent editing of the loading marker.  Can happen with rapid tabbing / shift-tabbing
    // with non-blocking row loading
    if (Array.isLoading(this.getCellRecord(nextEditCell[0], nextEditCell[1]))) {
        //this.logWarn("prevented edit of loading row at: " + nextEditCell);
        return false;
    }
    this._changeEditCell(editCompletionEvent, rowNum, colNum, nextEditCell[0], nextEditCell[1]);
},


// getUpdatedEditorValue()
// Retrieves the value from the current edit cell editor item
// NOTE: returns the parsed version [can be saved as a raw value to the record]
getUpdatedEditorValue : function () {

    // If we're not showing an editor return undefined - there is no edit value to save.
    if (!this._editorShowing) return;

    var editItem = this._editRowForm.getItem(this.getEditFieldName()),
        editField = this.getEditField(),
        value;
    if (editItem) {

        if (editItem._itemValueIsDirty()) editItem.updateValue();
        value = editItem.getValue();
        return this._parseEditorValue(value, editField,this.getEditRow(), this.getEditCol());

    } else {
        // no edit item, just return the saved value
        return this.getEditDisplayValue(this.getEditRow(), this.getEditCol());
    }
},

// undocumented flag: If a developer modifies the values of the editRowForm directly
// should we save out those changes.


allowEditFormValueManipulation:true,

//> @attr listGrid.updateSummariesDuringEditing (boolean : true : IRW)
// Should the +link{showGridSummary,summary row} or +link{showGroupSummary,group summaries} be
// updated during editing of grid records?  This can be set false to improve performance when a
// large number of +link{ListGridField,ListGridFields} or +link{DataSourceField,
// DataSourceFields} are present for the grid.
// <P>
// Note that summaries will always be updated when the edits are saved, so to avoid
// recalculation overhead when a row or cell edit is completed, you must also set
// +link{autoSaveEdits}: false.  Summaries will then be updated upon your manual save, such as
// +link{saveAllEdits()}.
// @see recalculateSummaries()
// @visibility external
//<
updateSummariesDuringEditing: true,

// storeUpdatedEditorValue()
// Retrieves the value from the current edit cell editor item and stores it as an edit value
// for the appropriate row.

storeUpdatedEditorValue : function (suppressChange, editCol) {

    if (!this.isDrawn() || !this._editorShowing) return;
    
    var editRow = this.getEditRow();
    
    if (editCol == null) editCol = this.getEditCol();

    
    var editField = this.getField(editCol),
        editForm = this._editRowForm,
        editItem = this.getEditFormItem(editCol),
        value;
    if (editItem) {
        if (editItem._itemValueIsDirty()) {
            editItem.updateValue();
        } else {
            
            if (editItem.defaultValue != null && editItem.getValue() == null) editItem.setValue(null);
        }
        
        var itemValue = editItem.getValue();
        value = this._parseEditorValue(itemValue,
                                         editField, editRow, editCol);
        // Convert undefined to explicit null so we actually clear out the value
        // for the field if appropriate.

        var undef;
        if (value === undef) value = null;

        
        var oldVal = this._getEditValue(editRow, editCol),
            undef;
        if (oldVal === undef || !this.fieldValuesAreEqual(editField, oldVal, value)) {
            var type = isc.SimpleType.getType(editField.type);
            if (type && type.getAtomicValue != null) {
                // calling form.getValue(fieldName) rather than item.getValue() will give
                // us the opaque value - what we actually want to store.
                var opaqueValue = editForm.getValue(editItem.name);
                // If parseEditorValue changed it, we'll have to apply the change to this
                // opaqueValue of course.
                
                if (itemValue != value && type.updateAtomicValue != null) {
                    type.updateAtomicValue(value, opaqueValue);
                }
                value = opaqueValue;
            }
            this.setEditValue(editRow, editCol, value, true, suppressChange);
        }
    }
    // Pick up the entire values object from the form in case developer code directly
    // manipulated the edit-form values without going through setEditValue()
    
    if (this.allowEditFormValueManipulation) {
        var undef, changed = false,
            completeFields = this._completeFieldNamesMap,
            formValues = editForm.getChangedValues(true),
            editValues = this._getEditValues(editRow, editCol),
            record = this.getCellRecord(editRow, editCol)
        ;

        // Form fields with defaultValues will be changed from undef to the default
        // but don't show up in the result of 'getChangedValues()'
        // loop through the form values and pick this up explicitly
        var editItems = editForm.getFields();
        for (var i = 0; i < editItems.length; i++) {
            var itemName = editItems[i].name,
                itemValue = editItems[i].getValue();
            if (itemValue != null && editValues[itemName] == null && editItems[i].isSetToDefaultValue()) {
                formValues[itemName] = itemValue;  
            }
        }

        for (var fieldName in formValues) {

            if (editValues && (fieldName in editValues) || record && (fieldName in record)) {
                // We already pulled the value from the current focused edit item.
                if (editField && fieldName == editField.name) continue;

                var field = this.getSpecifiedField(fieldName),
                    fieldVal = formValues[fieldName];
            
                // Skip anything which is unpopulated in the "changed" form values object
                if (fieldVal === undef) continue;
            
                if (editForm.getItem(fieldName) != null && field) {
                    fieldVal = this._parseEditorValue(fieldVal,
                                   field, editRow, this.getFieldNum(fieldName));
                }
                // do not propagate differences in user formula/summary fields
                if (field && (field.userFormula || field.userSummary ||
                              field.type == this._$summary))
                {
                    continue;
                }

                var currentValue = fieldName in editValues ? editValues[fieldName] :
                                                                record[fieldName];
                var fieldNum = this.getFieldNum(fieldName);
                // call the edit formatter (if defined) for all visible cells
                if (fieldNum >=0 && this._formatEditorValue != null) {
                    currentValue = this._formatEditorValue(currentValue, record, editRow,
                                                           fieldNum);
                }                

                // if the value is unchanged, carry on.
                if (this.fieldValuesAreEqual(this.getUnderlyingField(fieldName), fieldVal,
                                             currentValue))
                {
                    continue;
                }

                // if the field and value appear to be a local scribbling, skip it
                if (completeFields[fieldName] == null && fieldVal === undef) {
                    continue;
                }

                // No need to worry about converting from atomic to opaque value - the
                // "values" object on the form should already be the opaque version.
                
                
                changed |= this.setEditValue(editRow, fieldName, fieldVal, 
                                             true, true, true) != false;

            // Handle any field-values specified directly on the form which weren't
            // present in the original record object.
            } else {

                // do not propagate changes to the user field caches!
                if (fieldName == null || fieldName == "_cache_" + this.ID) continue;

                var value = formValues[fieldName];
                // if the value is unchanged, carry on.
                if (this.fieldValuesAreEqual(this.getUnderlyingField(fieldName), value, undef))
                {
                    continue;
                }

                // if the field and value appear to be a local scribbling, skip it
                if (completeFields[fieldName] == null && value === undef) continue;
                changed |= this.setEditValue(editRow, fieldName, value, 
                                             true, true, true) != false;
            }
        }
        
        if (changed && this.updateSummariesDuringEditing) {
            this.calculateRecordSummaries(editRow, null, true, true, true);
        }
    }
},

// Internal handler to fire user-defined editorExit handler functions
_handleEditorExit : function (editCompletionEvent, rowNum, colNum, newValue) {
    var record = this.getCellRecord(rowNum, colNum),
        field = this.getField(colNum),
        editFieldName = this.getEditorName(rowNum, field),
        returnVal = true;

    var item = this._editRowForm.getItem(editFieldName);
    //>PopUpTextAreaItem         If this is a pop-up text area, ensure the T.A. is hidden.
    if (isc.isA.PopUpTextAreaItem(item)) {
        
        if (item._popUpForm && item._popUpForm.isDrawn()) item.hidePopUp();
    }
    //<PopUpTextAreaItem

    // clear any selection if we're in a CubeGrid
    if (isc.CubeGrid && isc.isA.CubeGrid(this) && this.selectionManager &&
            this.selectionManager.anySelected()) this.selectionManager.deselectAll();

    var topMask = isc.EH.clickMaskRegistry.last();

    // NOTE: field can be null if hiding focused field
    
    if (field && field.editorExit != null) {
        isc.Func.replaceWithMethod(field, "editorExit",
                                     "editCompletionEvent,record,newValue,rowNum,colNum,grid");
        returnVal =
            (field.editorExit(editCompletionEvent, record, newValue, rowNum, colNum, this)
             != false);
    }
    if (returnVal && this.editorExit != null) {
        returnVal = 
            this.editorExit(editCompletionEvent, record, newValue, rowNum, colNum) != false;
    }
    if (!returnVal) this._restoreEditClickMask(topMask);

    return returnVal;
},

// fired when the user leaves a row
_handleRowEditorExit : function (editCompletionEvent, rowNum, newValues) {
    if (this.rowEditorExit == null) return true;

    var record = this.getRecord(rowNum),
        topMask = isc.EH.clickMaskRegistry.last()
    ;
    var returnVal = this.rowEditorExit(editCompletionEvent, record, newValues, rowNum) != false;
    if (!returnVal) this._restoreEditClickMask(topMask);
    return returnVal;
},


_restoreEditClickMask : function (oldTopMask) {
    if (oldTopMask == isc.EH.clickMaskRegistry.last()) this._showEditClickMask();
    else if (this.modalEditing) {
        isc.logWarn("If you return 'false' from an editor exit check in which you raise a " +
                    "modal dialog, we won't re-raise the modal edit mask", "gridEdit");
    }
},

// Internal handler to fire user-defined editorEnter handler functions
_handleEditorEnter : function (editorItem, rowNum, colNum, value) {

    var record = this.getCellRecord(rowNum, colNum),
        fieldName = this.getFieldName(colNum),
        field = this.getField(colNum),
        returnVal = true;


    //>PopUpTextAreaItem
    // If this is a pop-up textArea editor, show the pop-up if appropriate
    
    if (isc.isA.PopUpTextAreaItem(editorItem) && editorItem.popUpOnEnter) {
        // pass in the param to put focus into the pop-up
        editorItem.showPopUp(true);
    }   //<PopUpTextAreaItem

    
    if (field && field.editorEnter != null) {
        isc.Func.replaceWithMethod(field, "editorEnter", "record,value,rowNum,colNum,grid");
        returnVal = field.editorEnter(record, value, rowNum, colNum, this) != false;
    }
    if (returnVal && this.editorEnter != null)
        returnVal = this.editorEnter(record, value, rowNum, colNum) != false;
    return returnVal;
},

_handleRowEditorEnter : function (editorItem, rowNum, editValues) {
    var record = this.getRecord(rowNum);
    if (this.rowEditorEnter != null)
        return this.rowEditorEnter(record, editValues, rowNum) != false;
    return true;
},

_validationEnabled : function () {
    if (!isc.DS) return false;
    var ds = isc.DS.get(this.dataSource);
    return !this.neverValidate &&
                    
                      !(ds && ds.useLocalValidators != null &&
                        ds.useLocalValidators == false);
},

// These methods determine what action should be taken on cell edit completion

//> @method listGrid.shouldSaveOnCellExit()
//  When a user exits a field within the current row being edited, but does not exit the edit
//  row, should a save be performed?<br>
//  Default behavior is <br>
//  - Never saveCellOnExit if this is a new edit row (has no corresponding record)<br>
//  - return this.saveByCell if defined, otherwise return true if the user is editing
//    individual cells, false if the entire row is editable (set via the editByCell property).
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @return (boolean)    true if the value should be saved when moving to a different field within
//                       the edit row.
//  @see saveByCell
//  @see editByCell
//<
shouldSaveOnCellExit : function (rowNum, colNum) {
    if (this.getCellRecord(rowNum, colNum) == null) return false;
    return (this.saveByCell != null ? this.saveByCell : this.editByCell);
},

//> @method listGrid.shouldSaveOnRowExit()
//
//  When a user exits the current edit row, should a save be performed.
//  Always returns true.
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @param  editCompletionEvent (EditCompletionEvent) what caused the edit completion
//  @return (boolean)    true if the value should be saved when moving to a different field within
//                       the edit row.
//<
shouldSaveOnRowExit : function (rowNum, colNum, editCompletionEvent) {
    return true;
},

//> @method listGrid.shouldValidateByCell()
//
//  When a user exits a field within the current row being edited, but does not exit the edit
//  row, should validation be performed.<br>
//  Default behavior is to return this.validateByCell if defined, otherwise return true if
//  the user is editing individual cells, false if the entire row is editable (set via the
//  editByCell property).<br>
//  Note that all edit-validation will be suppressed if listGrid.neverValidate is set to
//  true.
//
//  @group gridValidation
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @return (boolean)    true if validation should be performed when moving to a different field
//                       within the edit row.
//  @see listGrid.validateByCell
//  @see listGrid.autoValidate
//<
shouldValidateByCell : function (rowNum, colNum, editCompletionEvent) {
    var field = this.getField(colNum);
    if (field && field.validateByCell != null) return field.validateByCell;

    return (this.validateByCell != null ? this.validateByCell : this.editByCell);
},


//> @method listGrid.shouldValidateByRow()
// Should we perform validation on the current edit row when the user navigates away from it,
// even if the row is not being saved (due to +link{listGrid.autoSaveEdits} being false)?
// Default implementation returns +link{listGrid.autoValidate}.
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @return (boolean)    true if validation should be performed when moving to a different field
// @group gridValidation
// @see listGrid.autoValidate
// @see listGrid.autoSaveEdits
//<
shouldValidateByRow : function (rowNum, colNum, editCompletionEvent) {
    // Note: Method will only be called if _validationEnabled() returned true, so we
    // don't need to check this.neverValidate.
    return this.autoValidate;
},

//> @method listGrid.shouldCancelEdit()
//
//  On completion of an edit via some editCompletionEvent, should the edited values be discarded,
//  rather than being saved.
//  Default implementation returns true if the editCompletionEvent was a keypress on the escape
//  key and the escapeKeyEditAction was set to cancel.
//  Override for different cancellation behavior.
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the row being edited
//  @param  colNum      (number)    Index of the column being edited
//  @param  editCompletionEvent (EditCompletionEvent)  Event that completed the edit
//  @return (boolean)    true if the save should be cancelled
//  @see getNextEditCell()
//<
shouldCancelEdit : function (rowNum, colNum, editCompletionEvent) {
    if (editCompletionEvent == isc.ListGrid.ESCAPE_KEYPRESS) {
        var field = this.getField(colNum),
            action = field.escapeKeyEditAction || this.escapeKeyEditAction;
        if (action == "cancel") return true;
    }
    return false;
},

// Also see 'getNextEditCell()'


// --  Methods to perform the mechanics of saving / validation / etc.

//> @method listGrid._killEdit()
//
//  Complete editing by hiding the cell editor, and clearing out any edit information.
//  Public API for this is 'cancelEditing()'
//
//  @group  editing
//  @visibility internal
//
//  @param  editingFlowID   (number)    Unique ID for the edit flow to quit.  We take this parameter
//                                      to avoid this method from attempting to quit an edit-flow
//                                      that has already ended (likely to cause a valid new edit-flow
//                                      to close.
//  @param  editCompoletionEvent (EditCompletionEvent) Event that caused the cancellation
//                                      of the edit.
//  @param  [confirmed]   (boolean)     If confirmCancelEditing is true, when the user
//                                      dismisses the confirmation dialog we call this method
//                                      back, with this additional parameter indicating
//                                      yes or no click.
//  @see cancelEditing()
//<
_killEdit : function (editingFlowID, editCompletionEvent, confirmed) {
    if (this._editingFlowID != editingFlowID) return;

    if (this.confirmCancelEditing) {
        if (confirmed == null) {
            var callback =
                    this.getID() + "._killEdit('" + editingFlowID + "','"
                                                 + editCompletionEvent + "',value);";

            isc.ask(this.cancelEditingConfirmationMessage, callback);
            
            var yesButton = isc.Dialog.Warn.toolbar.getButton(0);
            if (yesButton.isDrawn()) yesButton.focus()
            else isc.Timer.setTimeout({target:yesButton, methodName:"focus"}, 0);
            return;
        } else if (confirmed == false) return;
    }

    // If editorExit / rowEditorExit returns false, don't allow the cancellation
    var rowNum = this.getEditRow(), colNum = this.getEditCol(),
        newVal = this.getUpdatedEditorValue(),
        newVals = this.getEditValues(rowNum, colNum);
    if (!this._handleEditorExit(editCompletionEvent, rowNum, colNum, newVal) ||
        !this._handleRowEditorExit(editCompletionEvent, rowNum, newVals))
    {
        return;
    }
    // We're going to kill the temp-edit value, but we don't want to update any visible form
    // items' values since we're then going to hide the form items anyway.
    // Therefore track any cells that have no form item showing, but DO have edit values, so
    // we can refresh them individually.
    var mustRedraw,
        cellsToRedraw = [],
        editRowNum = this._editRowNum,
        editValues = this.getEditValues(editRowNum, colNum),
        // if undrawn set start/end col such that we don't attempt to redraw any cells
        drawnArea = this.body ? this.body.getDrawArea() : [null,null,1,0],
        startCol = drawnArea[2], endCol = drawnArea[3],
        undef;
    if (editValues != null) {
        // if the user is editing a new record (no underlying data value) we have to redraw
        // the whole body as the total length will change by discarding the edit
        if (this.isNewEditRecord(editRowNum, colNum)) {
            if (this.isDrawn()) this.body.markForRedraw("clearing extra edit row");
            mustRedraw = true;
        } else {
            for (var i = startCol; i <= endCol; i++) {
                if ( editValues[this.getFieldName(i)] !== undef &&
                     ((this.editByCell && this._editColNum != i) ||
                      !this.canEditCell(editRowNum, i)) )
                {
                    cellsToRedraw.add(i);
                }
            }
        }
        // Kill the temporary edit values for the row (passing in the additional parameter to avoid
        // refreshing the effected cells)
        this._clearEditValues(this._editRowNum, colNum, true);
        // Grouping: If we just cleared an edit value that'd need a regroup we need to
        // handle it
        // (This automatically requests a redraw)
        if (this.isGrouped && this._updateGroupForEditValueChange(editRowNum)) {
            mustRedraw = true;
            // no need to markForRedraw - already handled by updateGroupForEditValueChange(...)
        }

    }

    if (this.body) {
        // hide the editor and put focus back in the body
        this.hideInlineEditor(true);
        if (this.isDrawn()) {
            if (!mustRedraw) {
                for (var i = 0 ; i < cellsToRedraw.length; i++) {
                    this.refreshCell(editRowNum, cellsToRedraw[i]);
                }
            }
        }
    }
    
    this._provideEditRecordToRuleContext();
},

isNewEditRecord : function (rowNum) {
    var editData = this.getEditSession(rowNum);
    return editData && editData._newRecord
},

//> @method listGrid.endEditing()
//
// Complete the current edit by storing the value and hiding the inline editor. Note that
// if +link{ListGrid.autoSaveEdits} is true, the value will be saved to the server.
//
//  @group  editing
//  @visibility external
//  @see startEditing()
//<
endEditing : function () {
    if (this.getEditRow() != null) this._saveAndHideEditor(isc.ListGrid.PROGRAMMATIC);
},

// Called from cellEditEnd when the user completes and edit with an enter keypress / click
// outside saves the values locally and hides the editor. If autoSaveEdits is true, it will
// also actually save the outstanding set of edits.

_saveAndHideEditor : function (editCompletionEvent) {

    // If we're always showing editors, just call 'saveEdits' and refuse to hide
    
    if (this._alwaysShowEditors()) {
        this.saveEdits(editCompletionEvent);
        return;
    }
    
    if (editCompletionEvent == isc.ListGrid.ESCAPE_KEYPRESS &&
            this.escapeKeyEditAction == "ignore")
    {
        return;
    }

    
    var shiftFocus = (editCompletionEvent == isc.ListGrid.TAB_KEYPRESS) ? 1 : 
                        (editCompletionEvent == isc.ListGrid.SHIFT_TAB_KEYPRESS) ? -1 : null;

    var rowNum = this.getEditRow(),
        colNum = this.getEditCol(),
        // Note getEditValue() will pick up the updated value from the form (and store in
        // this.editValues)
        newValue = this.getEditValue(rowNum, colNum),
        newValues = this.getEditValues(rowNum, colNum);


    // If editorExit or rowEditorExit returns false, don't save and quit.
    if (!this._handleEditorExit(editCompletionEvent, rowNum, colNum, newValue) ||
        !this._handleRowEditorExit(editCompletionEvent, rowNum, newValues)) return;

    // Closing the editor: If waitForSave is false we will kick off the save and then close
    // the editor without waiting to see if the save completed successfully.
    // If waitForSave is true - we will pass a callback into the saveEdits method that will
    // close the editor when the save returns.
    // We'll use the "success" parameter to determine whether a validation error occurred
    // on the attempted save. If so, we'll look at this.stopOnErrors to determine whether
    // the navigation should continue
    var waitForSave = (this.autoSaveEdits && this.shouldWaitForSave()),
        stopOnErrors = (this.autoSaveEdits && this.stopOnErrors),
        saveCallback;

    // It is possible that the current edit flow will have been completed, and another begun when
    // the callback function fires for this save (true for any saveEdits call).
    // If this is the case we want to no-op, rather than close the new edit flow.
    // Note - we fire this in the scope of the ListGrid via 'apply'
    if (waitForSave) saveCallback = "if((success||!this.stopOnErrors)&&" +
                                        "(this._editingFlowID==" + this._editingFlowID + "))" +
                                            "this.hideInlineEditor(true, null, " + shiftFocus + ");";

    
    var cancelling = (editCompletionEvent == isc.ListGrid.ESCAPE_KEYPRESS &&
                        this.escapeKeyEditAction == "exit"),
        saving = this.autoSaveEdits && !cancelling;

    if (saving) {
        this.saveEdits(editCompletionEvent, saveCallback);
    } else {

        var fieldName = this.getFieldName(colNum);

        // Note: no need to call 'storeUpdatedEditorValue()'here
        // this has already been handled by getEditValue() above
        var validateNow = !cancelling && this._validationEnabled() &&
                          (this.shouldValidateByCell(rowNum, colNum, editCompletionEvent) ||
                           this.shouldValidateByRow(rowNum, colNum, editCompletionEvent));
        if (validateNow) {
            var validationFailed;
            if (this.useCellRecords) {
                validationFailed = !this.validateCell(rowNum, colNum);
            } else {
                validationFailed = !this.validateRow(rowNum);
            }

            if (this.stopOnErrors && validationFailed) return false;
        }

        // drop empty edit sessions, normally accomplished by saving
        
        
        if (!this.recordHasChanges(rowNum, colNum, false, false) &&
            !this.hasSubmittedEditValues(rowNum, colNum)
            // If the row has errors, we also need to hang onto the edit session
            && !this.rowHasErrors(rowNum, colNum)
           ) 
        {
            this.logInfo("editor hiding at " + [rowNum,colNum] +
                         ", no actual changes, dropping editSession", "gridEdit");
            // Don't hang onto the empty edit values for the row
            this._clearEditValues(rowNum, colNum);
        }
    }

    // If we not blocking interaction during save, we want to hide the inline editor here.
    // However, we _killEdit to clear our editValues only after saving, since if there are
    // validation errors, etc. we may yet require the editValues
    if (!waitForSave) this.hideInlineEditor(true, null, shiftFocus);
    // Otherwise put the click mask back in place until save completes.
    // This also means if stopOnErrors is true and a failure is reported
    // the mask will be ready for editing still in progress.
    else this._showEditClickMask();

    // If we're currently grouped, and the value of the grouping field changed, should we
    // regroup here?
    //
    // If we're actually saving:
    // - if the save is local we'll already have regrouped. In this case definitely don't
    //    attempt to regroup again since the rowNum for the data may have changed, etc.
    // - otherwise, we will regroup when the save successfully completes, but regrouping here
    //   will essentially just update the tree to show the edit values in the new position
    //   while the save is occurring (desirable).
    //
    // If we're not saving, (autoSaveEdits is false, or the user hit "escape"), we do need
    // to regroup to put the edit values in their new position.
    if (this.isGrouped && (!saving || !this.shouldSaveLocally())) {
        this._updateGroupForEditValueChange(rowNum);
    }

    this._updateGridHasErrorsInRuleScope(false);
},

//> @method listGrid.saveAndEditNewCell()
//
//  Save the current edit, and start editing another cell (may be in another row).
//
//  @group  editing
//  @visibility internal
//
//  @param  newRowNum   (number)    Index of new row to edit.
//  @param  newColNum   (number)    Index of new column to edit.
//  @param  editCompletionEvent (EditCompletionEvent)  How was the edit completed?
//  @see editNewCell()
//<

saveAndEditNewCell : function (newRowNum, newColNum, editCompletionEvent) {
    if (editCompletionEvent == null) editCompletionEvent = isc.ListGrid.PROGRAMMATIC;

    this._saveAndStartEditing(newRowNum, newColNum, editCompletionEvent);

},

// _saveAndStartEditing.  Saves the current edit, and starts editing the new cell passed in
_saveAndStartEditing : function (newRowNum, newColNum, editCompletionEvent) {
    
    var waitForSave = this.shouldWaitForSave(),
        saveCallback;
    if (waitForSave) {
        saveCallback = "if((success||!this.stopOnErrors)&&" +
                         "(this._editingFlowID==" + this._editingFlowID + "))" +
                          "this._startEditing(" + newRowNum + "," + newColNum + ");";
    }

    this.saveEdits(editCompletionEvent, saveCallback);
    if (!waitForSave) {
        this._startEditing(newRowNum, newColNum);
    }

},


// Internal helper method to save the current cell and move to the next one in some direction.
_saveAndEditNextCell : function (direction, stepThroughCells) {
    var rowNum = this.getEditRow(), colNum = this.getEditCol(),
        editCompletionEvent = isc.ListGrid.PROGRAMMATIC,

        nextEditCell = this.findNextEditCell(rowNum, colNum, direction, stepThroughCells, false);

    this._saveAndStartEditing(nextEditCell[0], nextEditCell[1], editCompletionEvent);
},

//> @method listGrid.saveAndEditNextCell()
//
//  Save the current edit, and edit the next editable cell, found by stepping through each field
//  in the current row (and possibly subsequent rows, depending on this.rowEndEditAction).
//
//  @group  editing
//  @visibility internal
//<
saveAndEditNextCell : function () {
    this._saveAndEditNextCell(1, true);
},

//> @method listGrid.saveAndEditPreviousCell()
//
//  Save the current edit, and edit the previous editable cell, found by stepping through each field
//  in the current row (and possibly subsequent rows, depending on this.rowEndEditAction).
//
//  @group  editing
//  @visibility internal
//<
saveAndEditPreviousCell : function () {
    this._saveAndEditNextCell(-1, true);
},

//> @method listGrid.saveAndEditNextRow()
//
//  Save the current edit, and edit the same field in the next editable row.
//
//  @group  editing
//  @visibility internal
//<
saveAndEditNextRow : function () {
    this._saveAndEditNextCell(1, false);
},

//> @method listGrid.saveAndEditPreviousRow()
//
//  Save the current edit, and edit the same field in the previous editable row.
//
//  @group  editing
//  @visibility internal
//<
saveAndEditPreviousRow : function () {
    this._saveAndEditNextCell(-1, false);
},

// Editing Navigation: finding next cell or record
// --------------------------------------------------------------------------------------------

//> @method listGrid.getNextEditCell()
//
//  Given a current edit cell, and an edit completion event, return the next cell to be edited,
//  or null if there is no next cell to edit.<br>
//  Default implementation:<ul>
//  <li>return null (editing complete), if the edit completion event was an enter keypress,
//      a click outside the editor, or an escape keypress</li>
//  <li>return the result of 'getNewEditCell()' if the edit completion event was
//      ListGrid.EDIT_FIELD_CHANGE or PROGRAMMATIC.  This relies on 'setNewEditCell()' having
//      been called earlier to specify the next cell to edit.</li>
//  <li>return the next editable cell in the same column moving up or down rows if the edit
//      completion event was an up or down arrow keypress<li>
//  <li>return the next editable cell in the same row, or if there is none, and
//      this.rowEndEditAction is "next", in subsequent rows, if the edit was
//      completed with a Tab or Shift+Tab keypress.</li>
//  </ul>
//
//  @group  editing
//
//  @param  rowNum      (number)    Index of record edited
//  @param  colNum      (number)    Index of field edited
//  @param  editCompletionEvent (EditCompletionEvent)    Edit completion event constant
//  @return (Array)  2 element array specifying next editable rowNum, colNum.  Will
//                   return null if the edit should be completed without navigating to
//                   another cell.
//  @visibility internal
//<

getNextEditCell : function (rowNum, colNum, editCompletionEvent) {

    switch (editCompletionEvent) {
        case isc.ListGrid.CLICK_OUTSIDE :
        // unlikely to see this case, since this is a 'cancellation' by default, but treat as
        // not attempting to navigate elsewhere
        case isc.ListGrid.ESCAPE_KEYPRESS :
            return null;

        case isc.ListGrid.ENTER_KEYPRESS :
            var field = this.getField(colNum),
                navStyle = field.enterKeyEditAction || this.enterKeyEditAction;
            if (navStyle == "done") return null;
            else if (navStyle == "nextCell")
                return this.findNextEditCell(rowNum, colNum, 1, true, false);
            else if (navStyle == "nextRow")
                return this.findNextEditCell(rowNum, colNum, 1, false, false);
            else if (navStyle == "nextRowStart") {
                var listEndAction = this.listEndEditAction || "done";
                if (rowNum+1 < this.getTotalRows() || listEndAction == "next") {
                    // either there are more record or we're allowed to create new records by
                    // navigating off the end of the list, proceed
                    return this.findNextEditCell(rowNum +1, 0, 1, true, true);
                } else {
                    // we've hit Enter on the last row, and we're not allowed to create new
                    // rows.
                    // if we're supposed to "stop", we should return the current coordinates,
                    // so we can't call findNextEditCell with rowNum+1 since it wouldn't know
                    // the current coordinates.
                    if (listEndAction == "stop") return [rowNum, colNum];
                    return null; // "done"
                }
            }

        case isc.ListGrid.EDIT_FIELD_CHANGE :
        case isc.ListGrid.PROGRAMMATIC :
        // In this case we have an explicit cell to move to - should have been saved as
        // 'newEditCell'
            return this.getNewEditCell();

        case isc.ListGrid.UP_ARROW_KEYPRESS :
            return this.findNextEditCell(rowNum, colNum, -1, false, false);

        case isc.ListGrid.DOWN_ARROW_KEYPRESS :
            return this.findNextEditCell(rowNum, colNum, 1, false, false);

        case isc.ListGrid.TAB_KEYPRESS :
        case isc.ListGrid.RIGHT_ARROW_KEYPRESS :
            var field = this.getField(colNum);
            if (field.nextTabColNum != null) {
                return this.findNextEditCell(rowNum +1, field.nextTabColNum, 1, true, true);
            } else {
                return this.findNextEditCell(rowNum, colNum, 1, true, false);
            }
        case isc.ListGrid.SHIFT_TAB_KEYPRESS :
        case isc.ListGrid.LEFT_ARROW_KEYPRESS :
            var field = this.getField(colNum)
            if (field.previousTabColNum != null) {
                return this.findNextEditCell(rowNum -1, field.previousTabColNum, -1, true, true);
            } else
                return this.findNextEditCell(rowNum, colNum, -1, true, false);
    }

    this.logWarn("getNextEditCell(): Passed unrecognized editCompletionEvent type:" +
                editCompletionEvent + ", returning null");
    return null;
},

//> @method listGrid.findNextEditCell()
//
// Method to find the next editable cell given a starting row/col, and a direction,
// either iterating through fields within each row, or checking the same field in each row.
// <p>
// Note, this is potentially an expensive method.  For example, consider a listGrid where the 
// user can add rows but not edit any existing rows; in this case, <code>canEditCell()</code>
// would inspect and reject every row in the dataSet before returning true for the last row.
// Consider this before making use of this method on grids with large dataSets
//  @group  editing
//
//  @param  rowNum      (Number)    Index of starting row
//  @param  colNum      (Number)    Index of starting column
//  @param  direction   (Number)    +1 if searching forward for the next edit cell, -1 if
//                                  searching backwards
//  @param  stepThroughFields   (boolean)   true if we should check every field in each row -
//                                          false if we should check the same field in each
//                                          row.
//  @param  [checkStartingCell] (boolean)   Should we check whether the cell passed in is
//                                          editable? Default behavior WILL check that cell -
//                                          pass false to suppress checking that cell.
//  @return (Array)  2 element array specifying next editable rowNum, colNum, or null if 
//                   this method fails to find an editable cell.
//  @visibility external
//<
// @param [checkPastListEnd]    Optional, internal parameter forces this method to check beyond
// the end of the list if necessary, even if this.listEndEditAction is not "next"
// @param [dontCheckPastRowEnd] Optional, internal parameter suppresses checking beyond the end
// of the row. We use this in handleEditEvent(click) to avoid iterating through the entire grid
// if there's no editable cell in a row!
// @param [ignoreFocus] optional, internal parameter - if we can't focus in an item

findNextEditCell : function (rowNum, colNum, direction, stepThroughFields, checkStartingCell,
                                checkPastListEnd, dontCheckPastRowEnd, ignoreFocus) {

    var newRow = rowNum,
        newCol = colNum,
        lastRow,
        totalCols = this.getFields().length;
    // no columns --> no way to get a valid cell
    if (totalCols == 0) return;

    // We want to look at every row up until the last drawn row.
    // IF listEditAction is "next", we will also check one row beyond the last drawn record
    // - this allows the user to tab beyond the end of the list and create a new edit row.
    // If we are passed a rowNum greater than the last drawn row, we will check every field
    // within that row (even if it's after the current last drawn row).  This allows the
    // programmatic editing of rows beyond the end of the list via 'startEditingNew()'.
    // In cases where there is no record associated with a row, canEditCell() checks
    // editability based on the field definitions.
    
    lastRow = (dontCheckPastRowEnd ? newRow :
                (this.listEndEditAction == "next" || checkPastListEnd) ? this.getTotalRows()
                                                                       : this.getTotalRows() -1);
    if (newRow > this.getTotalRows()) lastRow = newRow;

    // Note: If we have an editable field with a non focusable editor, always skip it.
    // This method is typically called when the user hits Tab to shift focus to the next
    // editable cell, etc.
    // If editing by row, skipping non-focusable fields is intuitive - the focus jumps over
    // the non editable field. If editing by cell it means that editor actually won't show up unless
    // the user double-clicks the cell (which seems acceptable since if you tabbed into it you'd
    // be unable to tab out again anyway).
    // ignoreFocus param disables this check - used whenever we need to find the next editable
    // cell and for some reason don't care about focus. Example use case: Finding the first
    // edit cell with a RecordEditor.

    // canEditCell calls can be lengthy so limit the number of calls where possible
    var canEditStartingCell = this.canEditCell(newRow, newCol);

    // check whether we can edit at the starting coordinates, unless that is being
    // explicitly suppressed
    // Note: The cell passed in may be off the end of the list or past the end of the fields,
    //       since we blindly add 1 to a newRow / colNum in some cases.
    if (  (checkStartingCell != false || direction == 0) &&
          newRow <= lastRow && newRow >=0 && newCol < totalCols && newCol >=0 &&
          canEditStartingCell &&
          (ignoreFocus || this._canFocusInEditor(newRow, newCol))
        )
    {
        return [newRow, newCol];
    }

    // direction will be either -1 or 1.
    // check for other values is unnecessary so long as this method remains internal, but
    // check for zero anyway, since that would cause real problems!
    if (direction == 0) return null;

    canEditStartingCell = canEditStartingCell && this._canFocusInEditor(newRow, newCol);
    var firstRow = dontCheckPastRowEnd ? newRow : 0;

    if (stepThroughFields) {
        var style = this.rowEndEditAction || "next";
        while (newRow < (lastRow+1) && newRow >= firstRow) {

            // special case - break if we hit a loading row.
            // Exception: for newly added, as yet unsaved rows, rowIsLoaded
            // will return false, so accept these -- we won't go past "lastRow"
            // anyway.
            
            if (isc.ResultSet && isc.isA.ResultSet(this.data)) {
                if (newRow < this.data.getLength() && !this.data.rowIsLoaded(newRow)) return null;
            }
            newCol += direction;

            // If we've looped through the editable cells for this row, and are back at the
            // initial col return the starting row if it's editable.
            if (style == "same" && colNum == newCol) {
                return canEditStartingCell ? [rowNum, colNum] : null;
            }
            // if we hit the end of the row, check the rowEndEditAction to determine whether
            // to move to the next record, etc.
            if (newCol < 0 || newCol >= totalCols) {
                if (style == "done" || isc.isA.RecordEditor(this)) return null;
                if (style == "stop") return (canEditStartingCell ? [rowNum, colNum] : null)
                // if we're looping through the same row, set the newCol to be off the end
                // since we add / subtract one before checking for canEdit()
                else {
                    newCol = (direction > 0 ? -1 : totalCols);
                    if (style == "next") newRow += direction;
                }
            } else if (this.canEditCell(newRow,newCol) &&
                        (ignoreFocus || this._canFocusInEditor(newRow, newCol)))
            {
                return [newRow, newCol];
            }
        }
        // reached the end of the list without finding an editable cell.
        // If the end action is stop, or we're trying to move past the start of the list and
        // the end action is 'next', start editing the same cell again
        // - otherwise return null to stop editing
        if (this.listEndEditAction == "stop" ||
            (this.listEndEditAction == "next" && newRow < firstRow))
        {
            if (canEditStartingCell) return [rowNum, colNum];
            else return null;
        // default behavior - rowEndEditAction is "done"
        } else {
            return null;
        }

     } else {
        newRow += direction;
        while (newRow >= firstRow && newRow <= lastRow) {

            if (this.canEditCell(newRow, newCol) &&
                (ignoreFocus || this._canFocusInEditor(newRow, newCol))) {
                return [newRow, newCol];
            }
            newRow += direction;
        }
        // reached the end of the list without finding an editable cell.
        // If listEndEditAction is stop, or "next" - and we're trying to navigate past the
        // beginning of the list, return the cell passed in - otherwise return null to stop
        // editing
        if (this.listEndEditAction == "stop" ||
            (this.listEndEditAction == "next" && newRow < firstRow))
        {
            return canEditStartingCell ? [rowNum, colNum] : null;
        }
        return null;
     }
},

_canFocusInEditor : function (rowNum, colNum) {

    var fieldName = this.getFieldName(colNum),
        
        editForm = this.getEditForm();
    var fieldID = fieldName || colNum;

    if (editForm == null) {
        this.makeEditForm(rowNum, colNum);
        editForm = this._editRowForm;
    }

    var editItem = editForm ? editForm.getItem(fieldID) : null;
    // editItem can still be null since we may be editing by cell in which case
    // we only populate with a single item.
    if (editItem) return editItem._canFocus();

    var field = this.getField(fieldID);
    if (field.canFocus != null) return field.canFocus;
    var editorType = this.getEditorType(field, this.getEditedRecord(rowNum));

    // call getItemClassName on FormItemFactory to actually get a SmartClient class from
    // the editor type (required to get SelectItem from SelectOtherItem, etc)
    editorType = isc.FormItemFactory.getItemClassName(field, editorType, null, true);

    // Resolve to an actual class
    var editorClass = editorType = isc.FormItemFactory.getItemClass(editorType);


    // This could potentially be broken by an override to _canFocus() which required looking
    // at a live instance.
    
    
    if (editorClass) {
        
        var _prototype = editorClass.getPrototype(),
            canFocus = _prototype.canFocus;
        if (canFocus != null) return canFocus;

        // Special case: If this is a CanvasItem, assume it's a custom implementation
        // and editable.
        if (isc.isA.CanvasItem(editorClass)) {
            return true;
        }
        if (_prototype._canFocus) return _prototype._canFocus();
    }
    return false;
},

//> @method listGrid.setNewEditCell() (I)
//
//  Internal method to record an explicit 'new edit cell'.  This can be retrieved (as an array)
//  via getNewEditCell();
//  Currently used when focus is put into a new cell by clicking in a field in a visible
//  (row-style) edit form, and by editField.
//
//  @group  editing
//  @visibility internal
//
//  @param  rowNum      (number)    Index of the new row to edit
//  @param  colNum      (number)    Index of new field to edit
//<
setNewEditCell : function (rowNum, colNum) {
    this._newEditCell = [rowNum, colNum];
},

//> @method listGrid.getNewEditCell() (I)
//
//  Internal method to retrieve the 'new edit cell', previously stored by setNewEditCell.
//
//  @group  editing
//  @visibility internal
//
//  @return (Array)    2-element array indicating the stored rowNum and coNum
//<
getNewEditCell : function () {
    if (this.canEditCell(this._newEditCell[0], this._newEditCell[1])) return this._newEditCell;
    return null;
},

//> @method listGrid.clearNewEditCell() (I)
//
//  Internal method to clear the 'new edit cell' stored by setNewEditCell.
//
//  @group  editing
//  @visibility internal
//<
clearNewEditCell : function () {
    this._newEditCell = null;
},


//> @method listGrid.discardAllEdits() (A)
//
// Cancel outstanding edits, discarding edit values, and hiding editors for the record[s] passed
// in if appropriate.
// <P>
// If no rows are passed in, all outstanding edit values will be dropped.  This will <b>not</b>
// automatically end editing; call +link{endEditing()} <b>before</b> calling discardAllEdits()
// if you also want to end editing.
// <P>
// Note that this also clears the +link{listGrid.markRecordRemoved,removed} state of any records
// that have been marked as removed.
//
// @param  [rows] (Array of Number) allows you to specify which row(s) to drop edits for
// @param   [dontHideEditor]    (boolean)   By default this method will hide the editor if
//                              it is currently showing for any row in the grid. Passing in
//                              this parameter will leave the editor visible (and just reset
//                              the edit values underneath the editor).
// @visibility external
// @group editing
//<
discardAllEdits : function (rows, dontHideEditor) {
    
    if (rows == null) rows = this.getAllEditRows(true);
    else {
        // Convert numeric rows to edit-values IDs
        for (var i = 0; i < rows.length; i++) {
            if (isc.isA.Array(rows[i])) rows[i] = this.getEditValuesID(rows[i][0], rows[i][1]);
            if (isc.isA.Number(rows[i])) rows[i] = this.getEditValuesID(rows[i]);
        }
    }
    if (rows == null) return;

    // call discardEdits()
    // Note that we're passing in an editValuesID rather than a rowNum / colNum here
    for (var i = 0; i < rows.length; i++) this.discardEdits(rows[i], null, dontHideEditor);
},

//> @method listGrid.discardEdits() (A)
//
// Cancel outstanding edits for the specified rows, discarding edit values, and hiding editors
// if appropriate.
// <P>
// Note that if this method is called on a new edit row (created via
// +link{listGrid.startEditingNew()} for example), which has not yet been saved, this method
// will remove the row entirely.
// <P>
// Also note that this method will clear the +link{listGrid.markRecordRemoved,removed} state
// of records that have been marked as removed.
//
// @param  rowNum (int) Row to cancel
// @param colNum (int) Column to cancel. Note that this parameter is ignored in ListGrids but
//                        may be required in subclasses of ListGrid where each cell represents
//                        one record in the data set (EG CubeGrid)
// @param   [dontHideEditor]    (Boolean)   By default this method will hide the editor if
//                              it is currently showing for the row in question. Passing in
//                              this parameter will leave the editor visible (and just reset
//                              the edit values underneath the editor).
// @group  editing
// @visibility external
//<
discardEdits : function (rowNum, colNum, dontHideEditor, editCompletionEvent) {
    if (rowNum == null) return;

    // if passed an ID rather than a rowNum, figure out the rowNum, so we can
    // easily see if its the current edit row.
    var ID;
    if (isc.isA.Number(rowNum)) {
        ID = this.getEditValuesID(rowNum, colNum);
    } else {
        ID = rowNum;
        rowNum = this.getEditSessionRowNum(ID, colNum);
    }
    var markedAsRemoved = this.recordMarkedAsRemoved(rowNum),
        gridHadErrors = this.hasErrors();

    // If alwaysShowEditors is true, suppress hiding the editor
    // unless we have no data and are showing a single new edit row.
    if (!dontHideEditor && this._alwaysShowEditors() &&
        (!(this.getTotalRows() == 1 && rowNum == 0)))
    {
        this.logInfo("Refusing to hide editor on 'discardEdits' [editCompletionEvent:" +
                editCompletionEvent + "] due to alwaysShowEditors settings", "inactiveEditorHTML");
        dontHideEditor = true;
    }

    if (!dontHideEditor && this._editorShowing && this.getEditRow() == rowNum) {

        if (editCompletionEvent == null) editCompletionEvent = isc.ListGrid.PROGRAMMATIC;
        this._killEdit(this._editingFlowID, editCompletionEvent);
        
    } else {
        // Ensure the stored edit value matches the value in the edit form item before we clear it
        // This is required to refresh the edit item value
        
        if (this._editorShowing && this.getEditRow() == rowNum) {
            this.storeUpdatedEditorValue(true);
        }
        this._clearEditValues(ID, colNum);
        
        this._provideEditRecordToRuleContext();
        // If marked as removed, explicitly refresh the row so we reset to normal styling
        if (markedAsRemoved) this.refreshRow(rowNum);
    }
    // Refresh summaries if the edit session rowNum is valid (otherwise nothing to do)
    if (rowNum != null) {
        this.calculateRecordSummaries(rowNum, null, true, true, true);
    }
    this._updateGridHasErrorsInRuleScope(gridHadErrors);
},

// Saving Inline Edits
// --------------------------------------------------------------------------------------------


//> @method listGrid.saveEdits() (A)
//
// Validates and saves edits within the row currently being edited (or another row with unsaved
// edits, if indicated).
// <P>
// This method can be called to manually trigger saves if the default mechanisms of
// +link{saveByCell,cell by cell} or row by row saving are not suitable.
// <P>
// The 'callback' parameter provides a notification when the save attempt completes, which is
// likely to be asynchronous for databound grids.  Cases under which the callback will fire are:
// <ul><li>Save completed successfully</li>
// <li>No changes to the edited row, so save not required</li>
// <li>Validation failure occurred on the client or on the server</li></ul>
// Note that if this method was unable to determine the row to be saved, the callback will NOT
// fire - in this case, the method is a no-op.
// <P>
// Other, standard callbacks such as +link{editComplete()}, +link{editFailed()} and
// +link{cellChanged()} will fire normally.
// <P>
// Note this method does not hide the inline editors if they are showing - to explicitly save
// and end editing, use the method 'endEditing()'
// <P>
// If this method is called for a row which has been marked for deletion
// (see +link{listGrid.markRecordRemoved}) it will cause the record to be removed from the
// data-set.
// <P>
// For more information on editing, see the +link{group:editing,editing overview}.
//
//  @group  editing
//  @visibility external
//
//  @param  [editCompletionEvent] (EditCompletionEvent) Event used to complete cell editing.
//          Optional, and defaults to <code>"programmatic"</code>.  Can be used by the
//          <code>callback</code> method to perform custom actions such as navigation when the
//          save completes.
//  @param  [callback]    (Callback)  Callback to fire on completion of the saving process.
//                                    If no edits were made or client-side validation fails
//                                    the callback will be fired synchronously at the end of this
//                                    method.<br>
//                                    Takes the following parameters:
//                                    <br>- rowNum <i>(Number) edited row number</i>
//                                    <br>- colNum <i>(Number) edited column number</i>
//                                    <br>- editCompletionEvent <i>(EditCompletionEvent) event
//                                      passed in (defaults to <code>"programmatic"</code>)</i>
//                                    <br>- success <i>(boolean) false if the save was unable to
//                                      complete due to a validation failure or server-side
//                                      error.</i>
//  @param  [rowNum] (number) Which row should be saved. If unspecified the current edit row
//                            is saved by default. Note that if there is no current edit row
//                            this method will no op.
//  @see    endEditing()
//<
// parameter 'validateOnly' is used internally to avoid actually saving if validation
// succeeds - just return true to indicate success


// parameter 'skipValidation' used internally to suppress client side validation and allow the
// save to proceed. This is helpful for the case where we've validated the record in the same
// thread and want to avoid re-running validators unnecessarily
saveEdits : function (editCompletionEvent, callback, rowNum, colNum, validateOnly, skipValidation) {
    // Since this is being exposed as a public method (allowing saving while leaving
    // the editor visible), default to a "PROGRAMMATIC" editCompletionEvent.
    if (editCompletionEvent == null) editCompletionEvent = isc.ListGrid.PROGRAMMATIC;

    if (rowNum == null) {
        rowNum = this.getEditRow()
        colNum = this.getEditCol();
    } else if (colNum == null) {
        // this will not apply to cubeGrid editing
        
        colNum = (rowNum == this.getEditRow() ? this.getEditCol() : this.getRowEditColNum(rowNum));
    }
    // clicking rapidly from one row to another when the editEvent is 'CLICK', and editOnFocus
    // is true can sometimes cause this method to get fired before the editRow / col has been
    // set up.  Just bail if this happens.
    if (rowNum == null) return false;

    // If this is a removal, we want to remove rather than update.
    if (this.recordMarkedAsRemoved(rowNum)) {
        
        if (validateOnly) {
            return true;
        }

        var newRow = this.isNewEditRecord(rowNum, colNum);
        // new row - by dropping edit values we discard the row entirely.
        
        if (newRow) {
            this.discardEdits(rowNum);
            this._fireSaveCallback(callback, rowNum, colNum, editCompletionEvent, true);
            return;
        } else {
            // Drop the edit values other than the "removed" flag.
            // This just avoids us attempting to sync unsaved edits with the row once the
            // update succeeds.
            var editVals = [];
            editVals[this.recordRemovedProperty] = true;
            this.setEditValues(rowNum, editVals,true,true);

            // wrap the callback passed in in a ds callback,
            // using closure to access the various params we want
            var _this = this;
            var dsCallback = function (response,data,request) {
                _this.fireCallback(callback, "rowNum,colNum,editCompletionEvent,success",
                        [rowNum,colNum,editCompletionEvent,true]);
            };
            this.removeData(this.getCellRecord(rowNum, colNum), dsCallback, null, true);
            return;
        }
    }

    // If we're actually showing the editor, getEditValues() will ensure any changes are
    // saved in the editValues object for the row.
    var newValues = this.getEditValues(rowNum, colNum),
        record = this.getCellRecord(rowNum, colNum),
        editValuesID = this.getEditValuesID(rowNum, colNum);
    // don't pass the actual record as oldValues; allows downstream code to modify it freely
    var oldValues;
    if (record != null && !Array.isLoading(record)) {
        if (isc.isA.Tree(this.data)) {
            
            oldValues = this.data.getCleanNodeData(record, false);
        } else {
            oldValues = isc.addProperties({}, record);
        }
        
        if (oldValues && this.selectionManager) {
            delete oldValues[this.selectionManager.selectionProperty];
        }
    }
    // Assemble the edit information into a single object to be passed to callback
    // methods.
    // We use this object if we have to call editCompleteCallback or editFailedCallback
    // directly from this method - otherwise we'll re-create this object in
    // saveEditedValues() / updateRecordsReply()
    var editInfo = {
            // Note: rowNum / colNum are basically available for callbacks, and for special
            // handling if a user overrides this method
            rowNum:rowNum,
            colNum:colNum,
            oldValues:oldValues,
            editValuesID:editValuesID,
            values:newValues,
            editCompletionEvent:editCompletionEvent,
            newRecord:(rowNum > this.data.getLength())
    };
    //>DEBUG
    if (this.logIsDebugEnabled("gridEdit")) {
        this.logDebug("change detection: newValues: " + this.echo(newValues) +
                      ", oldValues: " + this.echo(oldValues), "gridEdit");
    } //<DEBUG

    
    var haveChanges = this.recordHasChanges(rowNum, colNum, false, false);

    // perform validation on the edited row before saving
    // NOTE: we always save, and validate the whole row, even if saveByCell is true
    // as saveByCell really governs when the save is kicked off rather than what is
    // to be saved.
    if (!skipValidation && this._validationEnabled()) {

        // if changes are present, we must perform validation
        if (haveChanges) {
            
            this._skipServerValidation = (validateOnly || haveChanges);

            var validationFailed;
            if (this.useCellRecords) {
                validationFailed = !this.validateCell(rowNum, colNum);
            } else {
                validationFailed = !this.validateRow(rowNum);
            }
            this._skipServerValidation = null;

            if (validationFailed) {
                if (!validateOnly) this._editFailedCallback(editInfo, callback);
                return false;
            }

        // no changes - clear any validation errors if present
        
        } else {
            if (this.useCellRecords) {
                if (this.cellHasErrors(rowNum, colNum)) this.clearFieldError(rowNum, colNum);
            } else {
                if (this.rowHasErrors(rowNum)) this.clearRowErrors(rowNum);
            }
        }
    }
    // If we're only validating return true here to indicate that validation passed.
    if (validateOnly) return true;
    if (!haveChanges) {
        this.logInfo("saveEdits: no actual change, not saving", "gridEdit");
        // haveChanges will return false if we're pending a save and further edits haven't
        // been made.
        // In this case, retain the edit values.
        // Otherwise they are basically empty / match the record values, so remove 'em
        if (!this.hasSubmittedEditValues(editValuesID, colNum)) {
            this._clearEditValues(editValuesID, colNum);
        }
        // fire the saveCallback to finish flow (eg move to next cell, end editing..)
        
        this._fireSaveCallback(callback, rowNum, colNum, editCompletionEvent, true);
        return;
    }

    // get refreshed editValues since validation converts values to declared types, and we need
    // to store with correct types
    newValues = this._getEditValues(rowNum, colNum);

    //>DEBUG
    this.logInfo("Saving newValues '" + isc.echoAll(newValues) + "'", "gridEdit");
    //<DEBUG

    // remember this set of editValues as the "last submitted" for this row - this is used
    // for change detection while any save is pending.
    
    this.rememberSubmittedEditValues(rowNum, colNum);

    // NOTE: dupe the new values because they can be the live "editValues" for a row, and the
    // save implementation might integrate them directly into the data set with no copy
    newValues = isc.addProperties({}, newValues);

    // call the 'saveEditedValues' method to actually perform the save.
    var attempted = this.saveEditedValues(rowNum, colNum, newValues, oldValues,
                          editValuesID, editCompletionEvent, callback);

    // If saveEditedValues() returns explicit false, we abandoned the save attempt because
    // we're offline at the moment
    if (attempted === false) {
        this._editFailedCallback(editInfo, callback);
        return false;
    }

    // return true to indicate we're (attempting to) save the value
    // (If we're saving to the server, this does not indicate success, the server could still
    // give validation errors back to the asynchronous callback function - don't fire
    // _editCompleteCallback until we know the edit either went through or failed)
    return true;
},

//> @method listGrid.rowHasChanges()
// If this listGrid can be edited, this method will return true if the row passed in has been
// edited, but the edits have not yet been saved to the ListGrid's data object.
// <P>
// Note this method will not return true if a record has been marked as
// +link{markRecordRemoved,removed}, but has no other changes. Developers can use
// +link{listGrid.recordMarkedAsRemoved()} to check for this case.
// <P>
// Note that if this grid is bound to a +link{listGrid.dataSource,dataSource}, and 
// an asynchronous save has been submitted, this method will compare the local edit values 
// against the submitted values by default, returning false
// (no changes), if they match. This is useful for detecting whether the user is actively
// editing values and hasn't yet committed them.
// <P> 
// The <code>ignorePendingValues</code> parameter may be used by
// developers who want to ignore this case and simply compare edit values
// against the record in the local data set.
// 
// @param rowNum (int) index of row to check for changes
// @param [ignorePendingValues] (Boolean) If true, this method will compare the current edit
//  values against the underlying record in the dataset, not taking pending edit values into account
// @return (Boolean) true if the row has changes.
// @visibility external
// @group editing
//<


rowHasChanges : function (rowNum, ignorePendingValues, checkEditor) {
    // call recordHasChanges
    // Ignore the 2nd parameter - this method is not supported in 1 record/cell editing
    // pattern (IE CubeGrid)
    return this.recordHasChanges(rowNum, null, ignorePendingValues, checkEditor);
},

// this one is documented at the CG level where it should be used instead of rowHasChanges
recordHasChanges : function (rowNum, colNum, ignorePendingValues, checkEditor) {
    if (checkEditor == null) checkEditor = true;

    var changes = false,
        newValues = (checkEditor ? this.getEditValues(rowNum, colNum)
                                 : this._getEditValues(rowNum, colNum)),
        oldValues = this.getCellRecord(rowNum, colNum),
        submittedValues = ignorePendingValues ? null : this.getSubmittedEditValues(rowNum, colNum);

    // If there is no record for this row, we're editing a new row.
    // In this case we always want to save the values out (even empty values)
    if (!oldValues && !submittedValues) return true;
    

    // determine whether any changes have occurred by looking at the oldValues.
    // If the record is pending a save, compare the last submitted edit values to the new
    // values rather than looking at the underlying record values.
    
    var testValues = isc.addProperties({}, oldValues, submittedValues);
    var fields = this.getFields().duplicate();

    // Replace LGF definitions with the corresponding FormItems wherever this is possible. 
    // This ensures that we will pick up any customized compareValues() impl on the FormItem
    for (var i = 0; i < fields.length; i++) {
        fields[i] = this.getEditFormItem(fields[i].name) || fields[i];
    }

    // Merge in any DS fields that do not have corresponding LGFs
    if (isc.DataSource && isc.isA.DataSource(this.getDataSource())) {
        var dsFields = this.getDataSource().getFields(),
            fieldNames = this._completeFieldNamesMap,
            dataPaths = this._completeDataPathsMap
        ;
        for (var key in dsFields) {
            var dsField = dsFields[key];
            if (dsField.dataPath) {
                if (!dataPaths[dsField.dataPath]) fields.add(dsField);
            } else if (dsField.name) {
                if (!fieldNames[dsField.name]) fields.add(dsField);
            }
        }
    }

    var pathsProcessed = {},
        undef;
    
    // Compare the merged set of fields (note, it is important that the dsFields come after
    // the component fields, because it means that a specific field bound to dataPath
    // foo/bar/baz will prevent us from comparing the super objects foo/bar/ and foo/ as 
    // fields (they may still get compared as data objects downstream, but that is expected)
    for (var i = 0; i < fields.length; i++) {
        if (fields[i].name == this.removeRecordProperty) continue;
        var dataPath = fields[i].dataPath || fields[i].name;
        if (dataPath != null) {  // If null, field has neither a name nor a dataPath - ignore it
            if (pathsProcessed[dataPath] && !isc.isA.FormItem(fields[i])) {
                continue;
            }
            pathsProcessed[dataPath] = fields[i];
            var oldFieldValue = isc.Canvas._getFieldValue(dataPath, null, testValues, null, true, "compare", true);
            var newFieldValue = isc.Canvas._getFieldValue(dataPath, null, newValues, null, true, "compare", true);
            var partialPaths = dataPath.split('/');
            if (partialPaths.length > 1) {
                var pPath = "";
                for (var j = 0; j < partialPaths.length; j++) {
                    if (j > 0) pPath += "/";
                    pPath += partialPaths[j];
                    if (!pathsProcessed[pPath]) {
                        pathsProcessed[pPath] = fields[i];
                    }
                }
            }
            
            if (newFieldValue === undef) continue;
            if (!this.fieldValuesAreEqual(fields[i], oldFieldValue, newFieldValue)) {
                return true;
            }
        }
    }
    
    // Now look for differences in the two valuesets that are not bound to fields, unless this 
    // additional step is inhibited
    if (this.canChangeNonFieldValues !== false) {
        for (var attrName in newValues) {
            if (pathsProcessed[attrName]) continue;
            if (attrName == this.removeRecordProperty) continue;
            var oldValue = testValues[attrName],
                newValue = newValues[attrName];

        // Use custom comparator to catch things like Dates where '==' check is not sufficient
            if (!this.fieldValuesAreEqual(attrName, oldValue, newValue)) {
            // this.logWarn("field: " + fieldName +
            //              " changed from '" + this.echo(oldFieldValue) +
            //              "' to '" + this.echo(newFieldValue) + "'");
            changes = true;
            break;
        }
    }
    }
    //  this.logWarn("newValues:" + this.echoAll(newValues) +
    //      ", compared against oldValues:" + this.echo(testValues) +
    //      " and .. combined with submitted:" + this.echo(testValues));
    return changes;
},

//> @method listGrid.hasChanges()
// Whether the grid as a whole has any unsaved edits, in any row. Note that this method will return
// true if any rows are +link{markRecordRemoved,marked as removed} in addition to any rows that have
// unsaved edits.
// <P>
// Note that if this grid is bound to a +link{listGrid.dataSource,dataSource}, and 
// an asynchronous save has been submitted, this method will compare the local edit values 
// against the submitted values by default, returning false
// (no changes), if they match. This is useful for detecting whether the user is actively
// editing values and hasn't yet committed them.
// <P> 
// The <code>ignorePendingValues</code> parameter may be used by
// developers who want to ignore this case and simply compare edit values
// against the record in the local data set.
// 
// @param [ignorePendingValues] (Boolean) If true, this method will compare the current edit
//  values against the underlying records in the dataset, not taking pending edit values into account
//
// @return (Boolean) returns true of any unsaved edits are present
// @group editing
// @visibility external
//<

hasChanges : function (ignorePendingValues, checkEditor) {
    var editRows = this.getAllEditRows();
    if (editRows != null) {
        for (var i = 0; i < editRows.length; i++) {
            if (this.recordMarkedAsRemoved(editRows[i])) return true;
            if (this.rowHasChanges(editRows[i], ignorePendingValues, checkEditor)) return true;
        }
    }
    return false;
},

//> @method listGrid.cellHasChanges()
// If this listGrid can be edited, this method will return true if the cell passed in has been
// edited, but the edits have not yet been saved to the ListGrid's data object.
// @param rowNum (int) index of row to check for changes
// @param colNum (int) index of the col to check for changes
// @return (Boolean) returns true if the cell has unsaved edits
// @group editing
// @visibility external
//<
// Additional checkEditor param: Should we check for changes in the editor which have not yet been
// stored in our editValues?
// If unset, assumed to be true.
// Useful as when we use this method internally we're typically in the process of writing out
// CSS text, etc for the cell, so if the editor is showing we know the user hasn't had a
// chance to modify it.
cellHasChanges : function (rowNum, colNum, checkEditor) {
    return this._cellHasChanges(rowNum, colNum, checkEditor, false);
},
_cellHasChanges : function (rowNum, colNum, checkEditor, ignoreSubmittedVals) {

    if (rowNum == null || colNum == null) return false;
    var newValues = (checkEditor ? this.getEditValues(rowNum, colNum)
                                 : this._getEditValues(rowNum, colNum));
    // No new edit values - therefore no changes
    if (!newValues) return false;

    var savedValues = this.getCellRecord(rowNum, colNum);
    // No record, therefore this is a new row so every cell has a new value
    if (!savedValues) return true;

    var field = this.getField(colNum);
    // presumably field being null implies a bad colNum
    if (field == null) return false;

    
    var dataPath = !field.dataPath && isc.CubeGrid && isc.isA.CubeGrid(this) ?
        this.getValueProperty(rowNum, colNum) : null;

    // Pass the field directly into _getFieldValue()
    
    var newValue = isc.Canvas._getFieldValue(dataPath, field, newValues, this, true, "compare");

    var undef;
    // Edit values are sparse, so if undef, assume no edit value for the cell
    if (newValue === undef) return false;

    // If we have issued a save, don't report the cell as having changes 
    // unless the field was re-edited since the save was kicked off
    // This matches recordHasChanges behavior
    
    var submittedValues = ignoreSubmittedVals ? null : this.getSubmittedEditValues(rowNum, colNum),
        oldValue;
    if (submittedValues) {
        oldValue = isc.Canvas._getFieldValue(dataPath, field, submittedValues, this, true, "compare");
    }
    if (oldValue == null) {
        oldValue = isc.Canvas._getFieldValue(dataPath, field, savedValues, this, true, "compare");
    }
    if (oldValue == null) {
        oldValue = isc.Canvas._getFieldValue(dataPath, field, submittedValues, this, true, "compare");
    }
    return !this.fieldValuesAreEqual(field, oldValue, newValue);
},

//> @method ListGrid.saveAllEdits()
// Save a number of outstanding edits for this ListGrid. If no rows are specified, all
// outstanding edits will be saved.
// <P>
// Note that if +link{listGrid.saveRequestProperties} is specified and the grid is performing
// a databound save, these properties will be applied to each generated DSRequest.
//
// @param [rows] (Array of Number) optionally specify which rows to save
// @param [saveCallback] (Callback) If specified this callback will be fired on a successful save
//  of the specified rows. Note that if there are no pending edits to be saved this callback will
//  not fire - you can check for this condition using +link{ListGrid.hasChanges()} or
//  +link{ListGrid.rowHasChanges()}.  Use +link{editFailed} to find out about failures
//  encountered during saving (on a per-row basis).
// @return (boolean) true if a save has been initiated (at least one row had changes, passed
//                   client-side validation, and a save has been attempted).  False otherwise
// @group editing
// @visibility external
//<

_saveAllEditsFlow:0,
saveAllEdits : function (rows, saveCallback) {
    this._saveAllEditsPendingRows = this._saveAllEditsPendingRows || {};
    this._saveAllEditsRemoveRows = this._saveAllEditsRemoveRows || {};
    this._saveAllEditRowsCallback = this._saveAllEditRowsCallback || {};

    if (rows == null) rows = this.getAllEditCells();
    if (rows == null) return false;

    // handle being passed just a rowNum
    if (!isc.isAn.Array(rows)) rows = [rows];

    // We're going to iterate through our set of edited rows twice - the first time we'll
    // just perform validation. This allows us to bail if stopOnErrors is true.
    // The second time we iterate through the rows that didn't fail validation only, performing
    // the actual saves.
    if (this._validationEnabled()) {
        for (var i = 0; i < rows.length; i++) {

            // for the cube, each entry in "rows" can be a two-element array of rowNum, colNum
            var rowNum = isc.isAn.Array(rows[i]) ? rows[i][0] : rows[i],
                colNum = isc.isAn.Array(rows[i]) ? rows[i][1] : null;

            // call saveEdits with a flag telling it just to perform client-side validation.
            // Note this also prevents editFailed() from being called (it would normally be
            // called for a client-side validation failure)
            // Suppress this for records marked as removed.
            
            var validated = this.recordMarkedAsRemoved(rowNum) ||
                            this.saveEdits(null, null, rowNum, colNum, true);
            if (!validated) {
                if (this.stopOnErrors) return false;
                // don't save rows that failed client validation
                // Also suppress the callback from firing (just clear it) as firing would indicate
                // success
                else {
                    rows[i] = null; //
                    saveCallback = null;
                }
            }
        }
    }

    var shouldQueue = (this.dataSource != null && !this.shouldSaveLocally()),
        startedQueue = false;
    if (shouldQueue) startedQueue = !isc.RPCManager.startQueue();

    // If a callback was provided, we want to fire if we know every row saved successfully.
    // We handle this by tracking the set of rows committed with each 'saveAllEdits()' call and
    // only firing the callback once we've seen a callback tripped from every row committed.
    // The 'flowNum' logic is required to allow more than one 'saveAllEdits' call to be kicked
    // off before the response from the server without us clobbering info
    // (and therefore failing to fire the callback) from earlier calls to the method.
    
    var flowNum = this._saveAllEditsFlow ++,
        savingRows = this._saveAllEditsPendingRows[flowNum] = [],
        removingRows = this._saveAllEditsRemoveRows[flowNum] = [];

    this._saveAllEditRowsCallback[flowNum] = saveCallback;

    var saveAttempted = false;

    // We only want to fire the 'saveCallback' when we know every row committed has been
    // successfully saved. This is handled by _saveAllEditsRowCallback()
    var callback = ["this._saveAllEditsRowCallback('",,"',rowNum," + flowNum +
                                                        ",colNum,editCompletionEvent,success)"];

    var removedRowNums = [];
    for (var i = 0; i < rows.length; i++) {

        // any rows that failed validation have been removed from the array.
        if (rows[i] == null) continue;

        var rowNum = rows[i],
            colNum;
        if (isc.isAn.Array(rowNum)) {
            colNum = rowNum[1];
            rowNum = rowNum[0];
        }

        // Adjust the rowNum to account for previously removed rows.
        
        var offset = 0;
        if (removedRowNums && removedRowNums.length > 0) {
            for (var k = removedRowNums.length; k--; ) {
                if (rowNum > removedRowNums[k]) {
                    ++offset;
                }
            }
        }
        rowNum -= offset;
        var newRow = this.isNewEditRecord(rowNum, colNum);
        var removing = this.recordMarkedAsRemoved(rowNum);
        if ((!shouldQueue || newRow) && removing) {
            removedRowNums.push(rowNum);
        }

        // Don't call saveEdits() for an unchanged row, as it will synchronously call the
        // callback and hose tracking of committed changes.
        if (!this.recordHasChanges(rowNum,colNum) && !removing) {
            continue;
        }

        saveAttempted = true;
        var editValuesID = this.getEditValuesID(rowNum, colNum);
        callback[1] = editValuesID;
        if (removing) {
            removingRows[removingRows.length] = editValuesID;
        } else {
            savingRows[savingRows.length] = editValuesID;
        }
        // pass in the skipValidation param - we already validated earlier in this thread.
        this.saveEdits(null, callback.join(""), rowNum, colNum, false, true);
    }

    // If we're queuing, send the queue now
    
    if (startedQueue) {
        isc.RPCManager.sendQueue(null,null,null,true);
    }
    // return true to indicate we're (attempting to) save the value unless every save attempt
    // gave a validation error
    // (If we're saving to the server, this does not indicate success, the server could still
    // give validation errors back to the asynchronous callback function - don't fire
    // _editCompleteCallback until we know the edit either went through or failed)
    return saveAttempted;
},

_saveAllEditsRowCallback : function (editValuesID, rowNum, flowNum, colNum, editCompletionEvent, success) {
    if (!success) {
        // Clean up the stored array of saving rows and the stored callback method.
        // _saveAllEditsRowCallback will successfully recognize if this has occurred and have
        // other (successful) callbacks from this flow no-op.
        delete this._saveAllEditRowsCallback[flowNum];
        delete this._saveAllEditsPendingRows[flowNum];
        delete this._saveAllEditsRemoveRows[flowNum];
        return;
    }

    // look up the set of rows that were committed to together
    var savingRows = this._saveAllEditsPendingRows[flowNum],
        removingRows = this._saveAllEditsRemoveRows[flowNum];

    // If we have no stored 'saving rows' one of the saves must have failed so we will
    // never fire our save callback. Just bail in this case.
    if (savingRows == null && removingRows == null) return;

    // remove the row that we have just successfully saved
    var index, found, removing;
    for (index = 0; index < savingRows.length; index++) {
        var testID = savingRows[index];
        if (testID == editValuesID) {
            found = true;
            break;
        }
    }

    if (!found) {
        for (index = 0; index < removingRows.length; index++) {
            var testID = removingRows[index];
            if (testID == editValuesID) {
                found = true;
                break;
            }
        }
        if (found) removing = true;
    }

    

    if (removing) {
        removingRows.removeAt(index);
    } else {
        savingRows.removeAt(index);
    }
    // if all rows have been successfully saved
    if (savingRows.length == 0 && removingRows.length == 0) {
        // fire the callback passed into saveAllEdits()
        
        this._fireSaveCallback(this._saveAllEditRowsCallback[flowNum],
                                rowNum, colNum, editCompletionEvent);
        // clean up:
        delete this._saveAllEditRowsCallback[flowNum];
        delete this._saveAllEditsPendingRows[flowNum];
        delete this._saveAllEditsRemoveRows[flowNum];
    }
},

// _parseEditorValue - helper method to convert the value currently displayed in an editor into
// the appropriate raw value for saving.
// calls 'parseEditorValue' at the field / grid levels if defined.

_parseEditorValue : function (value, field, rowNum, colNum, record) {
    // allow the record to be passed in as an optional parameter if it happens to be available
    // for the calling function.
    var undef;
    if (record === undef) record = this.getCellRecord(rowNum, colNum);

    if (field && field.parseEditorValue != null) {
        isc.Func.replaceWithMethod(field, "parseEditorValue",
                                            "value,record,rowNum,colNum,grid");
        value = field.parseEditorValue(value, record, rowNum, colNum, this);
    } else if (this.parseEditorValue != null) {
        value = this.parseEditorValue(value, record, rowNum, colNum);
    }
    return value;

},

// returns true if edits should not propagate to upstream data sources/sets

// NOTE: This method has been moved up to DataBoundComponent, because there are methods at
// that level which call it, and not every DBC is a ListGrid (eg, TileGrid)
//shouldSaveLocally : function () {
//    return (!this.dataSource || this.getFullDataPath() != null || this.saveLocally);
//},

//> @method listGrid.saveEditedValues() (A)
//  Save edited values that have passed client-side validation.  Fire the callback when
//  save process completes (with param to indicate failure if appropriate).
//
//  @group  editing
//
//  @param  rowNum  (number)    index of edited row
//  @param  colNum  (number)    index of edited column
//  @param  newValues   (Object)    Values returned by the editor.
//  @param  oldValues   (Object)    Values before the edit
//  @param  editCompletionEvent (EditCompletionEvent)  event that caused edit completion
//  @param  [saveCallback]    (Callback)  optional callback function to fire on completion of
//                                        saving process
//  @visibility internal
//<
saveEditedValues : function (rowNum, colNum, newValues, oldValues,
                             editValuesID, editCompletionEvent, saveCallback)
{
    // assemble the edit information into a single object, so it can be passed around as part
    // of the context for this event.
    

    // NOTE: we use an arbitrary "editValuesID" to track edited values, since newly
    // created records won't have primary keys, and rowNums could change if data is shuffled.
    var editInfo = {
        editValuesID:editValuesID,
        rowNum:rowNum,
        colNum:colNum,
        values:newValues,
        oldValues:oldValues,
        editCompletionEvent:editCompletionEvent
    };
    // At this point we have already validated the change (on the client), so we just need to
    // save changes

    // if there's no dataSource, immediately commit changes locally
    if (this.shouldSaveLocally()) {

        // if useRemoteValidators is true, ask the dataSource to validate the change and only
        // continue with the save if validation is successful.
        
        if (this.useRemoteValidators == true) {
            var hasServerValidators = false,
                ds = this.getDataSource(),
                fields = ds ? ds.getFieldNames() : null;

            if (fields != null) {
                for (var i = 0; i < fields.length; i++) {
                    var field = ds.getField(fields[i]),
                        validators = field.validators;
                    if (validators == null) continue;
                    if (!isc.isAn.Array(validators)) validators = [validators];
                    for (var ii = 0; ii < validators.length;ii++) {
                        if (isc.Validator.isServerValidator(validators[ii])) {
                            hasServerValidators = true;
                            break;
                        }
                    }
                    if (hasServerValidators) break;
                }
            }

            if (hasServerValidators) {
                var requestProperties = {
                    validationMode:"partial",
                    prompt:isc.RPCManager.validateDataPrompt,
                    showPrompt:this.shouldWaitForSave(),
                    internalClientContext:{
                        editInfo:editInfo,
                        saveCallback:saveCallback
                    },
                    componentID:this.ID
                };
                ds.validateData(
                    editInfo.values,
                    // this callback handles calling saveLocally directly.
                    {target:this,methodName:"remoteValidationForLocalSaveComplete"},
                    requestProperties
                );

                // Hang onto a flag noting we're in the process of saving this row
                if (this._savingEdits == null) this._savingEdits = {};
                this._savingEdits[editInfo.editValuesID] = true;

                return;
            }
        }
        // no server-side validation errors so just call saveLocally synchronously.
        return this._saveLocally(editInfo, saveCallback);
    }

    // If we're offline, forbid the save
    if (isc.Offline && isc.Offline.isOffline() && !this.dataSource.clientOnly) {
        isc.warn(this.offlineSaveMessage);
        return false;
    }

    var _this = this;

    // otherwise, submit change to server, and wait until it returns without error to commit
    var callback = function (dsResponse, data, dsRequest) {
            _this._updateRecordReply(dsResponse, dsRequest);
        },
        request = {
        // allow customizing the operation used to save
        operationId : (oldValues == null ? this.addOperation : this.updateOperation) ||
                    this.saveOperation,
        // allow customizing the application the operation is performed in
        application : this.application,

        // so we can see validation errors
        willHandleError : true,
        // show a prompt to block user interaction during save
        showPrompt : this.shouldWaitForSave(),

        // for long transactions, if supported by backend.  NOTE: currently no error codes or
        // frontend UI defined for handling concurrent update error case
        oldValues : oldValues,

        // the actual record object that was edited, if present.  Needed for
        _originalRecord: this.getRecord(rowNum, colNum),

        // Client side context stuff
        internalClientContext:{
            // if we were passed an explicit callback, hang onto this
            // (It will be fired by _updateRecordReply)
            saveCallback : saveCallback,

            // changed values
            newValues : newValues,
            // all other context
            editInfo : editInfo
        },

        componentId: this.ID
    };

    // support for dataBoundComponentField.includeFrom:<dataSourceID>.<fieldName>
    // for fields that are not in the dataSource but pick up their value from
    // a related dataSource
    // In this case simply update the outputs property of the request -- the
    // server will be responsible for actually getting the value from the other
    // dataSource
    var completeFields = this.getAllFields();
    if (completeFields != null) {
        for (var i = 0; i < completeFields.length; i++) {
            if (completeFields[i].includeFrom != null &&
                this.getDataSource().getField(completeFields[i].name) == null)
            {
                if (request.additionalOutputs == null) request.additionalOutputs = "";
                else request.additionalOutputs += ",";
                request.additionalOutputs += [
                        completeFields[i].name,
                        completeFields[i].includeFrom].join("!")

            }
        }
    }

    if (this.saveRequestProperties) {
        isc.addProperties(request, this.saveRequestProperties);
    }
    // unsort to prevent changed data popping out of viewport
    
    this._unsortOnChange(newValues, oldValues);

    // Hang onto a flag noting we're in the process of saving this row
    if (this._savingEdits == null) this._savingEdits = {};
    this._savingEdits[editInfo.editValuesID] = true;

    var ds = isc.DS.get(this.dataSource);

    if (oldValues == null) {
        var newRecord = isc.addProperties({}, oldValues, newValues);
        ds.addData(newRecord, callback, request);
    } else {
        // combine the new values with primary keys to form the update set for the modified
        // record.  Copy so that we still have the original values intact when the transaction
        // returns.
        var pks = isc.DS.get(this.dataSource).filterPrimaryKeyFields(oldValues),
            updates = isc.addProperties({}, pks, newValues);
            this.updateData(updates, callback, request);
    }
},

_saveLocally : function (editInfo, saveCallback) {

    var rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        oldValues = editInfo.oldValues,
        newValues = editInfo.values
    ;

    
    var record = this.getCellRecord(rowNum, colNum),
        addNew = (record == null);
    // Note: This should be split into a separate method, which would handle updating
    // local data, or server-side data (and the list would automatically unsort as a result
    // of dataChanged())
    if (addNew) {
        var data = this.getOriginalData();

        // Associate the new record object with the edit values before adding the record to
        // the data array.
        
        var editValuesContext = this.getEditSession(rowNum);
        editValuesContext._primaryKeys = this.getPrimaryKeys(newValues);
        
        delete editValuesContext._newRecord;

        if (isc.ResultSet && isc.isA.ResultSet(data)) {
            if (data.allRows != null) {
                data.allRows.add(isc.addProperties({},newValues));
                data.filterLocalData();
            } else {
                this.logWarn("Unable to add data to resultSet - allRows is not set");
            }
        } else {
            data.add(newValues);
            data.dataChanged();
        }

    // update the record in place with 'setRawCellValue()' if we're editing an existing one
    } else {

        var cellValue, dataChanged, undef;
        
        var seenFieldNames = {};
        for (var i = 0; i < this.completeFields.length; i++) {
            var field = this.completeFields[i],
                fieldLocator = this.getEditorName(rowNum, field, true);
            cellValue = isc.Canvas._getFieldValue(null, field, newValues,
                                                     this, true, "edit");
            if (cellValue !== undef) {
                var fieldNum = this.fields.indexOf(field);
                if (fieldNum != -1) {
                    this.setRawCellValue(record, rowNum, fieldNum, cellValue, true);
                    dataChanged = true;
                } else {
                    isc.Canvas._saveFieldValue(null, field, cellValue,
                                                 record, this, true);
                }
            }

            var name = fieldLocator;
            if (fieldLocator.indexOf("/") >= 0) {
                name = isc.DynamicForm._trimDataPath(fieldLocator, this);
            }
            seenFieldNames[name] = true;
        }

        // handle deferred dataChanged now that loop is done
        
        if (dataChanged) {
            var origData = this.getOriginalData(),
                passParams = !this.forceRedrawOnDataChanged && 
                            isc.ResultSet && isc.isA.ResultSet(origData);
            if (passParams) {
                origData.dataChanged("update", record, rowNum, record);
            } else {
                origData.dataChanged();
            }
        }

        
        this.combineValuesRecursively(record, newValues, seenFieldNames);
    }
    // un-sort the list if the sorted field value was edited.  Otherwise the record might
    // get sorted out of the viewport.
    this._unsortOnChange(newValues, oldValues);
    this._editCompleteCallback(editInfo, saveCallback);

    // If we are part of a valuesManager notify it of the update
    
    if (this.valuesManager != null) {
        // _updateMultipleMemberValue handles combining a data-index into a path
        // 2nd param unnecessary since we're modifying the whole record, not a field within it.
        this.valuesManager._updateMultipleMemberValue(rowNum, null, record, this);
    }
},

combineValuesRecursively : function (target, source, skipFields, path, objectCache) {
    if (path == null) path = "";

    // Avoid stack overflows arising from recursion loops
    if (objectCache == null) objectCache = [];
    if (isc.isAn.Object(target) && !isc.isA.Date(target)) {
        if (objectCache.contains(target)) return;
        objectCache.add(target);
    }

    if (skipFields[path]) {
        //isc.logWarn("Skipping object tree rooted at path '" + path + "' because it's in the skip list");
        return;
    }

    if (isc.isAn.Array(source)) {
        //isc.logWarn("Processing array at dataPath '" + path);
        for (var i = 0; i < source.length; i++) {
            var newPath = path == "" ? "" + i : path + "/" + i;
            if (isc.isAn.Object(source[i]) && !isc.isA.Date(source[i])) {
                if (target[i] == null) target[i] = isc.isAn.Array(source[i]) ? [] : {};
                this.combineValuesRecursively(target[i], source[i], skipFields, newPath, objectCache);
            } else {
                target[i] = source[i];
            }
        }
    } else if (isc.isAn.Object(source) && !isc.isA.Date(source)) {
        //isc.logWarn("Processing object at dataPath '" + path);
        for (var attr in source) {
            var newPath = path == "" ? attr : path + "/" + attr;
            if (isc.isAn.Object(source[attr]) && !isc.isA.Date(source[attr])) {
                if (target[attr] == null) target[attr] = isc.isAn.Array(source[attr]) ? [] : {};
                this.combineValuesRecursively(target[attr], source[attr], skipFields, newPath, objectCache);
            } else {
                if (skipFields[newPath]) {
                    //isc.logWarn("Skipping value at dataPath '" + newPath + "' - found it as a leaf in the skip list");
                } else {
                    //isc.logWarn("Setting value at dataPath '" + newPath + "' to " + source[attr]);
                    target[attr] = source[attr];
                }
            }
        }
    }
},


remoteValidationForLocalSaveComplete : function (dsResponse, data, dsRequest) {
    var context = dsResponse.internalClientContext,
        editInfo = context.editInfo;

    // drop the savingEdits flag we set up to ensure we don't kick off multiple save attempts
    // for the same edited values, etc.
    if (this._savingEdits && this._savingEdits[editInfo.editValuesID]) {
        delete this._savingEdits[editInfo.editValuesID];
        if (isc.isAn.emptyObject(this._savingEdits)) delete this._savingEdits;
    }

    if (dsResponse.status < 0 && dsResponse.status != isc.RPCResponse.STATUS_VALIDATION_ERROR) {
        this.logWarn("Server-side validation failed: " + dsResponse.data);
        isc.RPCManager._handleError(dsResponse, dsRequest);
        return;
    }

    var liveEdits = this._getEditValues(editInfo.editValuesID);

    if (dsResponse.errors) {
        var errors = isc.DynamicForm.getSimpleErrors(dsResponse.errors),
            nonEmptyErrors = false;

        // Show server errors
        for (var fieldName in errors) {
            nonEmptyErrors = true;
            if (liveEdits == null) {
                this.logWarn("Asynchronous remote validation failed for attempted save of edits " +
                    "for row:" + editInfo.rowNum + " but edit values have subsequently been " +
                    "discarded. Ignoring validation failure.  Validation failure details:\n" +
                    this.echoFull(errors));
                break;
            }
            var fieldErrors = errors[fieldName],
                field = this.getField(fieldName)
            ;
            if (fieldErrors != null && field != null) {
                // if the edit val has changed since the user attempted to save it, we should
                // presumably not show the validation error for the field.
                
                var saveVal = editInfo.values[fieldName],
                    liveVal = liveEdits[fieldName];

                if (saveVal != liveVal &&
                    !(isc.isA.Date(liveVal) && isc.isA.Date(saveVal) &&
                        (liveVal.getTime() == saveVal.getTime())))
                {
                    this.logWarn("Asynchronous remote validation failed for attempted save of edits " +
                        "for row:" + editInfo.rowNum + ". Submitted value for field " + fieldName +
                        " was " + saveVal + ", but the edit value has subsequently been modified " +
                        "and is now:" + liveVal + ". Not showing the following validation " +
                        "error[s] for this field:\n" + this.echoAll(fieldErrors));

                    continue;
                }
                if (!isc.isAn.Array(fieldErrors)) fieldErrors = [fieldErrors];
                fieldErrors = fieldErrors.getProperty("errorMessage");

                var liveRowNum = this.getEditSessionRowNum(editInfo.editValuesID);

                // if (liveRowNum != editInfo.rowNum) {
                //     this.logWarn("Edit row remapped during async validation - was "
                //               + editInfo.rowNum + ", now:" + liveRowNum)
                // }

                this.setFieldError(liveRowNum, fieldName, fieldErrors, false);
            }
        }
        if (nonEmptyErrors) return;
    }

    // At this point we know validation was successful - run saveLocally to update the
    // actual data set.
    this._saveLocally(editInfo, context.saveCallback);

},

// unsort() if we are sorted and the sort field will be changed in this update

_unsortOnChange : function (newValues, oldValues) {
    var currentSort = this.getSort();
    if (currentSort == null || currentSort.length == 0) {
        return;
    }

    if (this.logIsInfoEnabled("sorting")) {
        this.logInfo("unsort on change: current sort: " + this.echo(currentSort) +
                    ", newValues: " + this.echo(newValues) +
                    ", oldValues: " + this.echo(oldValues)
        );
    }
    var unsort,
        undef;
    // If we don't have an existing record to compare against, assume we must unsort
    if (oldValues == null) unsort = true;
    else {
        for (var i = 0, numSortSpecifiers = currentSort.length; i < numSortSpecifiers; ++i) {
            var sortSpecifier = currentSort[i],
                property = sortSpecifier.property,
                undef;
            
            // newValues is a set of editValues - if it doesn't specify a value for this 
            // sort-field, that means it wasn't edited - continue
            if (!isc.propertyDefined(newValues, property)) continue;

            
            if (!isc.propertyDefined(oldValues, property) || 
                !this.fieldValuesAreEqual(property, oldValues[property], newValues[property])) 
            {
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("Value for current sort field '" + property + 
                                "' has changed - grid will unsort");
                }
                unsort = true;
                break; // no need to check other props at this point.
            }
        }
    }
    if (unsort) {
        this.unsort(true);
    }
},

// callback from server save triggered in commitEditValue
_updateRecordReply : function (dsResponse, dsRequest) {
    var results = dsResponse.data,
        context = dsResponse.internalClientContext,
        editInfo = context.editInfo,
        colNum = editInfo.colNum,
        field = this.fields[colNum];

    // Clear out the _savingEdits flag for this row as the save will have completed now.
    
    if (this._savingEdits && this._savingEdits[editInfo.editValuesID]) {
        delete this._savingEdits[editInfo.editValuesID];
        if (isc.isAn.emptyObject(this._savingEdits)) delete this._savingEdits;
    }

    // the rowNum may be different by now due to unrelated changes.  Look up the editValues we
    // were trying to save by editValuesId, and see what rowNum they are now associated with.
    
    var editSession = this.getEditSession(editInfo.editValuesID);

    if (editSession != null) {
        editInfo.rowNum = editSession._rowNum;
        
    } else {
        
        if (results && results[0]) {
            editInfo.rowNum = this.findRowNum(results[0]);
            if (this.useCellRecords) editInfo.colNum = this.findColNum(results[0]);
        }

        // If no record was returned, assume it was an attempt to save a new row which
        // failed to save, and for which editVals have now been discarded
        else editInfo.rowNum = -1;
    }

    var rowNum = editInfo.rowNum, colNum = editInfo.colNum;
    if (dsResponse.status < 0) { // error occurred
        // XXX We should really check for the 'validation failed' error code here
        // (results.status) rather than just checking for the presence of errors

        // we store validation errors per row as a simple object with an array
        // of error message strings per field.  dsResponse.errors is allowed to have one of a
        // few possible formats - convert this error block into our internal format before
        // storing / displaying errors
        var errors = this.parseServerErrors(dsResponse.errors);

        this.logInfo("error on save, status: " + dsResponse.status +
                     ", errors: " + this.echo(dsResponse.errors), "gridEdit");

        // The server will return an array of error object - one per record edited.
        // Since we only support saving out one record at a time, this should be a one element
        // array only.
        // Pull out the error object for the edited row, and pass it back to the setRowErrors()
        // method to store and display the errors
        
        if (isc.isAn.Array(errors)) {
            if (errors.length != 1)
                this.logWarn("Server reports validation errors for multiple records - only " +
                             "displaying errors for the first record.", "gridEdit");

            errors = errors[0];
        }

        // Store, and display the new errors
        if (this.useCellRecords) this.setCellErrors(rowNum, colNum,
                                                    errors[this.getEditorName(rowNum, colNum)]);
        else this.setRowErrors(rowNum, errors);

        // fire the simple callback function indicating the edit failed
        // (The second param would be any additional callback to fire on completion)
        this._editFailedCallback(editInfo, context.saveCallback, dsResponse, dsRequest, errors);

        return false;
    }
    // if we got here, the edit was successful
    this._editCompleteCallback(editInfo, context.saveCallback, dsResponse, dsRequest)
    
},

// parseServerErrors(): convert the formats allowed for dsResponse.errors to our internal
// error storage format

parseServerErrors : function (errors) {
    if (isc.isAn.Array(errors)) {
        if (errors.length > 1) {
            this.logWarn("server returned errors for multiple records - dropping all but the " +
                        "first record returned");
        }
        errors = errors[0];
    }

    
    if (errors && errors.recordPath) delete errors.recordPath;

    for (var fieldName in errors) {
        var fieldErrors = errors[fieldName];
        if (fieldErrors == null) fieldErrors = "Unspecified error";

        if (isc.isAn.Array(fieldErrors)) {
            for (var i = 0; i < fieldErrors.length; i++) {
                fieldErrors[i] = fieldErrors[i].errorMessage;
            }
        } else if (fieldErrors.errorMessage) {
            errors[fieldName] = [fieldErrors.errorMessage];
        } else {
            errors[fieldName] = [fieldErrors];
        }
    }
    return errors;
},


//> @method listGrid._editCompleteCallback    (I)
//
//      Callback method triggered when a saveEditedValues flow completes successfully.
//      Fired whether the save succeeded on the client or on the server.
//      Calls the 'editComplete' string method (with the same signature) if present.
//
//  @group  editing
//
//  @param  editInfo (Object)       Details of the edit
//                                  <br>Contains:
//                                  <ul>
//                                  <li>rowNum - index of edited row</li>
//                                  <li>colNum - index of edited column</li>
//                                  <li>values - edited values for the record</li>
//                                  <li>oldValues - values for the record before this edit</li>
//                                  <li>editCompletionEvent - how the edit was completed</li>
//                                  </ul>
//  @param [callback] (Function)      Optional callback function to fire
//  @param [dsResponse] (DSResponse)  DSResponse for DataSource saves
//
//  @visibility internal
//<
_editCompleteCallback : function (editInfo, callback, dsResponse, dsRequest) {
    // If the editForm has focus, ensure the latest values have been stored
    if (this._editorShowing && this.getEditForm().hasFocus) this.storeUpdatedEditorValue(true);

    var rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        valuesID = editInfo.editValuesID,
        editSession = this.getEditSession(valuesID),
        newRecord = this.isNewEditRecord(valuesID);

    var record;

    // Databound saves will have been passed a dsResponse from the server
    if (dsResponse != null) {

        var updateData = isc.DataSource.getUpdatedData(dsRequest, dsResponse, true),
            record = isc.isAn.Array(updateData) ? updateData[0] : updateData;
        if (record == null) {
            
            return;
        }

        // If the user was editing a new record, we may not have any primary key field
        // on the editSession object, required to reliably associate the editSession with
        // the record in the dataSet.
        // Catch this case and call newRecordForEditValues() to perform the association
        if (editSession && editSession._primaryKeys == null) {
            this.newRecordForEditValues(valuesID, record);
        }

    } else {
        // for client-only saves assume the save will never change the rowNum
        record = this.getCellRecord(rowNum, colNum)
    }

    // Clear up the editValues that have already been saved to the server.
    // Leave anything that has been edited after the save was committed
    
    var submittedValues = editInfo.values,
        // use the internal getEditValues() since we already stored the updated value if
        // appropriate
        currentEditValues = this._getEditValues(valuesID),

        
        stillEditing = this.isEditingRecord(rowNum, colNum),
        primaryKeyFields =
            this.dataSource ? isc.DS.get(this.dataSource).getPrimaryKeyFieldNames()
            : null;

    var hasChanges = false;
    for (var field in currentEditValues) {

        var isPK = primaryKeyFields && primaryKeyFields.contains(field),
            fieldObj = this.getField(field);
        if (this.fieldValuesAreEqual(fieldObj,
                                     currentEditValues[field], submittedValues[field]))
        {
            // If we're in this conditional, the edit value was successfully submitted
            // to the server so we should throw it away. Typically this doesn't require
            // a refresh of the cell value
            // However - if the server changed the value via a server side validator resultingValue
            // or similar, we do need a refresh.
            var mustRefresh = this.isDrawn() && !this.isDirty() && !this.body.isDirty() && 
                                !this.fieldValuesAreEqual(fieldObj, submittedValues[field], record[field]);
            // If we're still showing the editor, don't wipe out primary key fields- we always
            // want these included in our edit values. Only required for databound grids.
            
            if (!(stillEditing && isPK)) this.clearEditValue(valuesID, field, !mustRefresh, true);
        } else {
            if (!isPK) hasChanges = true;
        }
    }
    // If the editor is no longer showing, and there are no outstanding edits, ensure the
    // editValues object has been cleared
    // Note: If the editor is still showing, we'll drop all unchanged edit values when the
    // editor gets hidden.
    
    if (!stillEditing && !hasChanges && !this.rowHasErrors(rowNum, colNum)) {
        this._clearEditValues(valuesID, colNum);
    }

    // displayUpdatedDSRecord will refresh the mapping between pending edit values and rowNums.
    // We can avoid this if this was a local save (which we can handle by just refreshing
    // the cells in question.
    if (dsResponse != null || newRecord) {
        if (dsResponse != null && this.isGrouped) {
            var ignore = false;
            // New record always requires regrouping so it ends up in the correct group.
            // Existing record only requires regroup if group field value changed.
            if (!newRecord) {
                ignore = true;
            var groupFields = this.getGroupByFields(),
                    fieldNames = dsResponse.context && dsResponse.context.params ? dsResponse.context.params : {}
            ;
            for (var i=0; i<groupFields.length; i++) {
                var key = groupFields[i];
                if (fieldNames[key] != null) {
                    ignore = false;
                    break;
                }
            }
            }
            if (ignore) this._ignoreRegroup = true;
        }
        this.displayUpdatedDSRecord(rowNum, colNum, record);
    }

    // At this point edit context objects match their associated edit rows, and all edit values
    // have been updated.
    // Fire callbacks.
    

       
    var newValues = editInfo.values,
        oldValues = editInfo.oldValues,
        editCompletionEvent = editInfo.editCompletionEvent;

    
    if (rowNum == -1) rowNum = editInfo.rowNum;

    if (this.convertToMethod("editComplete")) {
        this.editComplete(rowNum, colNum, newValues, oldValues, editCompletionEvent, dsResponse);
    }

    this._fireCellChanged(record, rowNum, colNum, newValues, oldValues, dsRequest);


    if (callback) this._fireSaveCallback(callback, rowNum, colNum, editCompletionEvent, true);
},

// displayUpdatedDSRecord - called from editCompleteCallback on databound save
// calls dataChanged() to to refresh the mapping between pending edit values and rowNums,
// and redraw to show new rows


displayUpdatedDSRecord : function (rowNum, colNum, record) {
    if (this._remapEditRows()) {
        this.suppressEditRowRemap = true;
        this.dataChanged();
        this.suppressEditRowRemap = false;
    } else if (this.isGrouped) {
        // If we're grouped, and we didn't fire dataChanged here, explicitly regroup so
        // records' whose group field value changed show up in the right place.
        
        if (this._ignoreRegroup && !this._markForRegroup) {
            delete this._ignoreRegroup;
            return;
        }
        this.regroup();
    }
},

isEditingRecord : function (rowNum, colNum) {
    return this.getEditRow() == rowNum;
},

// Fires the single callback explicitly passed into saveEdits() as a parameter
_saveCallbackParams:"rowNum,colNum,editCompletionEvent,success",
_fireSaveCallback : function (callback, rowNum, colNum, editCompletionEvent, success) {
    if (callback != null) {
        this.fireCallback(callback,
                          this._saveCallbackParams,
                          [rowNum,colNum,editCompletionEvent,success]
        );
    }
},

_fireCellChanged : function (record, rowNum, colNum, newValues, oldValues, dsRequest) {

    // if a cellChanged was supplied, call that
    // Currently available at field and LG level (should we allow it per-row too?)
    var changeGroup, autoFitField;
    for (var i in newValues) {
        var oldValue = (oldValues == null ? null : oldValues[i]);
        if (newValues[i] == oldValue) continue;
        var currentField = this.fields.find(this.fieldIdProperty, i);

        // if a field was changed which does not exist in the grid's field list,
        // ignore it. It can't be grouped and cellChanged() cannot be called on it.
        if (!currentField) continue;

        // check for the need to re-group this record
        if (this.isGrouped && currentField) {
            var groupFields = this.getGroupByFields();
            if (groupFields.contains(currentField.name)) changeGroup = true;
        }
        if (this.shouldAutoFitField(currentField)) {
            autoFitField = true;
        }

        this._cellChanged(
                            record, currentField,
                            newValues[i], oldValue,
                            rowNum,
                            this.fields.indexOf(currentField)
                          );
    }


    if (autoFitField) {
        if (this.shouldSaveLocally()) {
            // if bound, dataChanged will already handle this
            this.updateFieldWidthsForAutoFitValue("Local edit");
        }
    }
    if (changeGroup) {
        if (this.shouldSaveLocally()) {
            // if bound, dataChanged will already handle this
            this._incrementalRegroup(record, record, newValues);
        }

        // redraw grid
        // regardless of if the data is saved locally, folderToggleObservation is not
        // called before this point, so it must exist outside the above codepath.
        this._suppressFolderToggleRedraw = false;
        this._folderToggleObservation();
    }
},

// Fire the 'cellChanged' string method handler(s) at the field or List level, if defined.
// If an entire row was edited this method (and the public cellChanged handlers) will be fired
// for each field edited.
_cellChanged : function (record, field, newValue, oldValue, recordNum, fieldNum) {
    if (field && field.cellChanged) {
        if (!isc.isA.Function(field.cellChanged)) {
            // (We must use replaceWithMethod rather than convertToMethod as the field is
            // not an ISC class with a string method registry on it)
            isc.Func.replaceWithMethod(field, "cellChanged",
                        "record,newValue,oldValue,rowNum,colNum,grid,recordNum,fieldNum");
        }

        // call() to call the function on the grid rather than the field
        field.cellChanged.call(this,
                               record,newValue,oldValue,recordNum,fieldNum,this,recordNum,fieldNum);

    } else if (this.cellChanged) {
        // call the list.cellChanged method, and note if it returns false (thus rejecting the change)
        this.cellChanged(record,newValue,oldValue,recordNum,fieldNum,this,recordNum,fieldNum);
    }

},

// Called when saving fails due to validation or other errors.  Calls the 'editFailed'
// string method (with the same signature) if present.  Will be called once per record
// if there was an attempt to save multiple records at once (saveAllEdits())

_editFailedCallback : function (editInfo, callback, dsResponse, dsRequest, errors) {
    var rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        values = editInfo.values,
        oldValues = editInfo.oldValues,
        eCe = editInfo.editCompletionEvent
    ;

    var record = this.getRecord(rowNum);
    if (record != null && this.canExpandRecord(record, rowNum) && 
        this.expansionMode == "editor") 
    {
        // we're expandable and
        var errors = isc.isAn.Array(dsResponse.errors) ? dsResponse.errors[0] : dsResponse.errors,
            record = this.getRecord(rowNum),
            shouldExpand = false
        ;

        if (isc.isAn.Object(errors)) {
            for (var key in errors) {
                var field = this.getField(key);
                if (!field || !this.fieldIsVisible(field)) {
                    shouldExpand = true;
                    break;
                }
            }
        }

        if (shouldExpand) {
            this.expandRecord(record);
            // do we need to validate the form just now?
        }
    }

    // note newValue can be a single value or an entire record
    if (this.convertToMethod("editFailed")) {        
        this.editFailed(rowNum, colNum, values, oldValues, eCe, dsResponse, dsRequest);
    }
    if (callback != null) this._fireSaveCallback(callback, rowNum,colNum,eCe,false);

    
    this.clearSubmittedEditValues(editInfo.editValuesID, values);
    
    
    if (!this._editorShowing && errors) {
        var field = this.getField(colNum);
        if (field && !errors[field.name]) this.refreshCell(rowNum, colNum);
    }
},

// see doc near stringMethod declaration, below
editFailed : function (rowNum, colNum, newValues, oldValues, editCompletionEvent, dsResponse, dsRequest) {

    // if this was an attempted server-side commit that returned a failure code from the server
    // (with no specific error messages), pass it on to rpcManager.handleError()
    
    if (dsResponse != null && dsResponse.errors == null) {
        isc.RPCManager._handleError(dsResponse, dsRequest);
    }
},

// ============================================================================================
// Validation
// ============================================================================================

// Performing validation
// ------------------------------------------------

//> @groupDef gridValidation
// ListGrids support automatic validation of edited cells / records. This group is a collection
// of APIs related to the validation subsystem.
// <p>
// Default validation occurs in response to the user navigating between edit cells
// (see +link{listGrid.validateByCell}) or whenever edited values are to be committed to the
// server for saving.  Standard validation can also be triggered for a cell or row programmatically at
// any time.<br>
// When standard validation occurs, +link{listGridField.validators} will be run on each
// cell to be validated.<br>
// In addition to this standard behavior developers can add custom errors to fields
// via +link{listGrid.setFieldError()} / +link{listGrid.setFieldError()}.
//
// @see group:editing
// @visibility external
//<


//> @method listGrid.validateRow()
// Validate the current set of edit values for the row in question.
// <P>
// Called when the user moves to a new edit row, or when an edited record is to be saved if
// client side validation is enabled for this grid.
// <P>
// This method may also be called directly to perform row level validation at any time.
//
// @param   rowNum (int) index of row to be validated.
// @return  (Boolean) returns true if validation was successful (no errors encountered), false
//                    otherwise.
// @group gridValidation
// @visibility external
//<
validateRow : function (rowNum, suppressRefresh) {
    return this.validateRecord(rowNum, suppressRefresh);
},


// validateRecord()
// Actually perform the validation of edit values for some record
// For one-record-per-cell implementations this will need to be overridden
validateRecord : function (cell, suppressRefresh) {
    var rowNum, colNum;
    if (isc.isAn.Array(cell)) {
        rowNum = cell[0];
        colNum = cell[1];
    } else {
        rowNum = cell;
    }

    
    var newValues = this.getEditValues(rowNum, colNum);

    // Feed this through _getFieldValue to narrow down by dataPath if necessary
    //if (this.dataPath) {
    //    newValues = isc.Canvas._getFieldValue(this.dataPath, newValues, this);
    //}

    // If the row is not being edited always "pass" validation.
    if (newValues == null) return true;

    var record = this.getCellRecord(rowNum,colNum),
        // Validate every field. This is necessary because of conditional validators
        // that may depend on other field values.
        fields = this.getFields().getProperty(this.fieldIdProperty)
    ;

    // Wrap field validation in a queue so that server validators are
    // sent as a single request.
    var wasAlreadyQueuing = isc.rpc.startQueue();

    if (this._skipServerValidation != true) {
        this._deferServerValidation = true;

        // Field objects that require server validation
        this._fieldsNeedingServerValidation = [];
    }
    var errorBlock = this.validateRowValues(newValues, record, rowNum, fields);
    // Perform deferred server validation if needed
    if (this._deferServerValidation && this._fieldsNeedingServerValidation.length > 0) {
        var validationOptions = {rowNum: rowNum},
            callerContext = {editValuesID:this.getEditValuesID(rowNum,colNum) };

        this.validateFieldsOnServer(this._fieldsNeedingServerValidation, 
                            this.getEditedRecord(rowNum, null, true), validationOptions, callerContext);
    }
    this._deferServerValidation = null;

    // Submit server validation requests queue
    if (!wasAlreadyQueuing) isc.rpc.sendQueue();

    // call setRowErrors() to store, and display the new set of editValues for the row.
    this.setRowErrors(rowNum, errorBlock, suppressRefresh);

    return (errorBlock == null)
},

hasFieldDependencies : function (field, newValues) {
    if (!field || newValues == null) return false;

    var dataPath = field.dataPath;
    if (dataPath != null) {
        dataPath = this._trimDataPath(dataPath);
    } else {
        dataPath = field.name;
    }

    // call propertyDefined() if there are no extra field dependencies
    // XXX: This isn't good enough - the value might not be a simple property of newValues.  
    // We need to see if there is a value at the field's relative dataPath 
    
    var fields = this.getFieldDependencies(field);
    if (fields == null) {
        //return isc.propertyDefined(newValues, dataPath);
        return isc.Canvas._fieldHasValue(dataPath, field, newValues, this, true, "compare");
    }
    // include field itself
    fields.add(dataPath);

    // check fields for overlap with changes (newValues)
    var undef;
    for (var i = 0; i < fields.length; i++) {
        if (newValues[fields[i]] !== undef || newValues.hasOwnProperty(fields[i])) {
            return true;
        }
    }
    return false;
},

//> @method listGrid.validateRowValues()
//  Helper method to perform validation on a row.
//  Called by validateRow() - returns any errors found on the row.
//
//  @group gridValidation
//  @param  newValues   (Object)    Field-value mapping showing the edited values for each field
//  @param  oldValues   (Object)    Field-value mapping showing the values for each field before
//                                  editing
//  @param  rowNum      (number)    Index of the row being edited
//  @param  fields      (number | String | Array)
//                          Fields to be validated.  If more than one field is to be validated,
//                          this will be an array.
//                          Note that each field can be designated either by fieldName or the
//                          numeric index.
//  @return (Object)   set of errors returned by validation, in the format
//                      {fieldName:["errorMessage", ...],...}.
//                     will be null if no errors encountered
//  @visibility internal
//<
validateRowValues : function (newValues, oldValues, rowNum, fields) {
    var validationPassed = true,
        errorBlock = {};

    // handle being passed a single field
    if (!isc.isAn.Array(fields)) fields = [fields];

    // Handle editing a new record - oldValues for each cell will be undefined.
    var isNewRecord = false;
    if (oldValues == null) {
        isNewRecord = true;
        oldValues = {};
    }

    // validate each field separately, then show the errors for all fields
    for (var i = 0; i < fields.length; i++) {
        
        if (fields[i] == null) continue;
        var fieldName,
            colNum;

        // ensure fields[i] is a fieldName and record the colNum
        if (isc.isA.Number(fields[i])) {
            colNum = fields[i];
            fieldName = fields[i] = this.getFieldName(colNum);
        } else {
            fieldName = fields[i];
            colNum = this.getFields().findIndex(this.fieldIdProperty, fieldName)
        }
        // If the field isn't included in this list, skip it... This is likely to happen
        // as lists won't show every field, but we will include the primary keys in our edit
        // values
        if (colNum < 0) continue;

        // validate if this is an editable cell in a new record (in order to enforce eg the
        // required validator), or if the field has been edited.
        var shouldValidateCell = (
            (isNewRecord && this.canEditCell(rowNum, colNum)) ||
            this.hasFieldDependencies(this.getField(colNum), newValues)
        
        );
        var newValue, oldValue;

        var field = this.getField(fieldName),
            dataPath = field ? field.dataPath : null,
            undef;
        if (dataPath != null) {
            dataPath = this._trimDataPath(dataPath);
        } else {
            dataPath = field.name;
        }
        
        newValue = isc.Canvas._getFieldValue(dataPath, field, newValues, this, true, 
                                             "validate");
        oldValue = isc.Canvas._getFieldValue(dataPath, field, oldValues, this, true, 
                                             "validate");

        if (!shouldValidateCell) {
            shouldValidateCell = (newValue !== undef && (oldValue === undef || oldValue == null));
        }
        if (!shouldValidateCell) continue;

        
        if (newValue === undef) newValue = oldValue;

        
        var validationErrors = this.validateCellValue(rowNum, colNum, newValue, oldValue);

        if (validationErrors != null) {
            validationPassed = false;
            errorBlock[fieldName] = validationErrors;
        }
    }
    if (!validationPassed) return errorBlock;
    return null;
},


//> @method listGrid.validateCell()
// Validate the current edit value for the cell in question.  Called when the user moves to a
// new edit cell if +link{ListGrid.validateByCell} is true.<br>
// This method may also be called directly to perform cell level validation at any time.
// @param   rowNum (number) index of row to be validated.
// @param   fieldName (String | number) field name (or column index) of field to be validated
// @return  (Boolean) returns true if validation was successful (no errors encountered), false
//                    otherwise.
// @group gridValidation
// @visibility external
//<
validateCell : function (rowNum, fieldName, suppressDisplay, processDependencies) {

    var colNum;
    if (isc.isA.String(fieldName)) colNum = this.getColNum(fieldName);
    else {
        colNum = fieldName;
        fieldName = this.getEditorName(rowNum, colNum);
    }

    // if we're showing an edit item for the field, ensure its value is up to date.
    
    if (this._editorShowing && (this.getEditRow() == rowNum )
        && this.getEditForm().getItem(fieldName) != null)
    {
        this.storeUpdatedEditorValue(null, colNum);
    }

    var editVals = this.getEditValues(rowNum, colNum),
        record = this.getCellRecord(rowNum, colNum)
    ;

    // don't validate if the cell has not been edited (unless this is a new record in which
    // case it will be saved as a null value.
    if (record != null && 
        (!editVals || !this.hasFieldDependencies(this.getFieldByName(fieldName), editVals)))
    {
        return true;
    }

    var undef, hadErrors = this.cellHasErrors(rowNum, fieldName),
        newValue, oldValue,
        field = this.getFieldByName(fieldName);

    if (!editVals) {
        newValue = undef;
    } else {
        newValue = isc.Canvas._getFieldValue(null, field, editVals, this, true, "validate");
    }

    if (!record) {
        oldValue = undef;
    } else {
        oldValue = isc.Canvas._getFieldValue(null, field, record, this, true, "validate");
    }

    
    if (newValue === undef) newValue = oldValue;

    var errors = this.validateCellValue(rowNum, colNum, newValue, oldValue, processDependencies);
    if (errors != null) {
        // call setFieldError() to store the error object on the
        // appropriate cell, and display it to the user.
        this.setFieldError(rowNum, fieldName, errors);
        return false;
    }

    // if the cell previously had errors, explicitly clear them out
    if (hadErrors) {
        this.setFieldError(rowNum, fieldName, null);
    }
    return true;
},

//> @method listGrid.validateCellValue()    (A)
// Helper method for validateCell(): Validate the new value the user supplied for a single cell.
// <p>
// Default implementation falls through to the stringMethod
// list.validateFieldValue(newValue, oldValue, record, field, rowNum, colNum) to
// perform validation based on the edit field's validators.
//
//  @group gridValidation
//
//  @param rowNum (Integer)   Edited cell's row number
//  @param colNum (Integer)   Edited cell's field number
//  @param  newValue    (Any)       Value returned by the editor.
//  @param  oldValue    (Any)   Value before editing
//  @return (Array) Array of validation error objects, or null if none found
//<
validateCellValue : function (rowNum, colNum, newValue, oldValue, processDependencies) {
    var record = this.getCellRecord(rowNum, colNum);
    var field = this.getField(colNum);
    return this.validateFieldValue(newValue, oldValue, record, field, rowNum, colNum, processDependencies);
},

// Allow customization of the 'required field' validation error message

//> @method listGrid.getRequiredFieldMessage()
// Returns the message to display when a user attempts to save a required field with an
// empty value.  By default returns +link{Validator.requiredField}.
// @param field (Object) definition of the field being edited
// @param record (Object) record object being edited
// @return (String) "Field is required"
// @group i18nMessages, gridValidation
// @visibility external
//<
getRequiredFieldMessage : function (field, record) {
    return isc.Validator.requiredField;
},

//> @method listGrid.validateFieldValue()   (A)
//
//  Validate the new value the user supplied for a cell via an editCellValue() call against
//  any validators defined on the edit field.
//
//  @group  editing
//
//  @param  newValue    (Any)       Value returned by the editor.
//  @param  oldValue    (Any)       Value before editing
//  @param  record  (Object)    pointer to the record object for the edited cell
//  @param  field   (Object)    pointer to the field descriptor object for the edited cell
//  @param  rowNum  (number)    row index of the edited cell
//  @param  colNum  (number)    column index for the edited cell
//  @return (Array)     array of error objects, or null if no errors found
//<
validateFieldValue : function (newValue, oldValue, record, field, rowNum, colNum, processDependencies) {
    var errors = [],
        success = true;

    var required = this.cellIsRequired(rowNum, colNum);
    // Check for required fields
    if (required && (newValue == null || isc.isAn.emptyString(newValue))) {
        var errorMessage = this.getRequiredFieldMessage(field, record);
        errors.add(errorMessage);
        success = false;
    }
    // validate the value if the field specifies validators
    var validators = this.getCellValidators(rowNum, colNum);
    if (validators) {

        if (this.logIsDebugEnabled("gridEdit")) {
            this.logDebug((this.useCellRecords ? "At col:" + colNum : "At field: " + field.name) +
                          " applying validators: " + this.echoAll(validators) +
                          " to value:" + newValue,
                          "gridEdit");
        }

        var fieldResult,
            editedRecord = this.getEditedRecord(rowNum,colNum),
            allErrors = null,
            options = {
                rowNum: rowNum,
                colNum: colNum
            }
        ;
        
        if (this._skipServerValidation == true) {
            options.skipServerValidation = true;
        } else if (this._deferServerValidation == true) {
            options.deferServerValidation = true;
        }
        if (processDependencies) {
            fieldResult = this.validateFieldAndDependencies(field, validators, newValue,
                                            editedRecord, options);
        } else {
            fieldResult = this.validateField(field, validators, newValue,
                                            editedRecord, options);
        }
        if (fieldResult != null) {
            if (fieldResult.needsServerValidation) {
                this._fieldsNeedingServerValidation.add(field);
            }
            if (fieldResult.valid != true) {
                success = false;
                if (processDependencies)
                    errors = fieldResult.errors[field.name] || [];
                else
                    errors = fieldResult.errors || [];
            } else {
                
                if (fieldResult.resultingValue != null) {
                    this.setEditValue(rowNum, colNum,
                                      fieldResult.resultingValue,
                                      null, null, null, true);
                    newValue = fieldResult.resultingValue;
                }
            }

            // Even though the changed field may be valid, there may be other fields
            // that are no longer valid because of a dependency. These errors should
            // be shown on the form.
            allErrors = fieldResult.errors;

            if (this.logIsInfoEnabled("gridEdit")) {
                this.logInfo("validateFieldValue, newValue: " + this.echo(newValue) +
                             ", passed validation: " + success +
                             ", resultingValue: " + this.echo(fieldResult.resultingValue),
                             "gridEdit");
            }
        }
    }

    // If dependencies were processed, we may have errors on other fields to show/clear.
    if (processDependencies) {
        for (var errorFieldName in allErrors) {
            if (errorFieldName != field.name) {
                this.setFieldError(rowNum, errorFieldName, allErrors[errorFieldName], true);
            }
        }
    }

    if (success) return null
    else return errors;
},

// cellIsRequired / getCellValidators allows us to separate our validator definitions from
// true field objects (makes custom cubeGrid validation easier to apply)
cellIsRequired : function (rowNum, colNum) {
    var field = this.getField(colNum);
    return field && ((field.required || this.isXMLRequired(field)) && !field.conditionallyRequired);
},

// return the combined validators on the field and and edit item (if any)
getCellValidators : function (rowNum, colNum) {
    var field = this.getField(colNum);
    if (!field) return null;

    var itemValidators,
        fieldValidators = field.validators,
        editForm = this.getEditForm();
    if (editForm) {
        var fieldName = field[this.fieldIdProperty],
            editItem = editForm.getItem(fieldName);
        if (editItem) itemValidators = editItem.validators;
    }

    
    if (fieldValidators && itemValidators) {
        var combined = [];
        for (var i = 0; i < fieldValidators.length; i++) {
            var validator = fieldValidators[i];
            if (!combined.contains(validator)) combined.add(validator);
        }
        for (var i = 0; i < itemValidators.length; i++) {
            var validator = itemValidators[i];
            if (!combined.contains(validator)) combined.add(validator);
        }
        return combined;
    }

    return fieldValidators || itemValidators || null;
},

getFieldEditorValidators : function (field) {

    if (!field) return [];
    var validators = [];
    var editorClass = field.editorType ? isc[field.editorType] : null;
    if (editorClass && editorClass.getPrototype && editorClass.getPrototype().validators) {
        // if there are prototype validators on the (editorType) formItem, append them
        validators.addList(isc.shallowClone(editorClass.getPrototype().validators));
    }
    var editorProps = field.editorProperties
    if (editorProps && editorProps.validators) {
        // if there are validators on the field's editorProperties, append those too
        validators.addList(isc.shallowClone(editorProps.validators));
    }
    // if there are validators, return them - otherwise return null
    return validators.length > 0 ? validators : null;
},

// Validation Errors
// ---------------------------------------------------------------------------------------

//> @method listGrid.hasErrors()
// Does this grid currently have errors associated with editValues for any row in the grid.
// @group gridValidation
// @return  (Boolean)   true if there are unresolved errors, false otherwise
// @visibility external
// @see listGrid.rowHasErrors()
// @see listGrid.cellHasErrors()
//<
hasErrors : function () {
    var editRows = this.getAllEditRows(true);
    for (var i = 0; i < editRows.length; i++) {
        if (this.rowHasErrors(editRows[i])) return true;
    }
    return false;
},

//> @method listGrid.rowHasErrors()
// Does the specified row have unresolved errors?
// @group gridValidation
// @param rowNum (int)   rowNum to check for errors
// @return  (Boolean)   true if there are unresolved errors, false otherwise
// @visibility external
// @see listGrid.hasErrors()
// @see listGrid.cellHasErrors()
//<
// Note: the rowNum parameter can also be the editValuesID property associated with some
// set of edit values [IE some edited row] for the grid.
rowHasErrors : function (rowNum, colNum) {
    var editData = this.getEditSession(rowNum, colNum);

    return (editData && editData._validationErrors &&
            !isc.isA.emptyObject(editData._validationErrors));
},

//> @method listGrid.cellHasErrors()
// Given a rowNum and a colNum or fieldName, determine whether we currently have stored
// validation errors for the record/field in question.
//  @group gridValidation
//  @param  rowNum  (number)    index of row to check for validation errors
//  @param  fieldID (String | number)    name of field, or index of column to check for validation
//                                      errors
//  @return (Boolean)   true if we have validation errors for the row/col in question
// @visibility external
// @see listGrid.hasErrors()
// @see listGrid.rowHasErrors()
//<
// As with rowHasErrors, the rowNum can be an editValuesID as well as a rowNum

cellHasErrors : function (rowNum, fieldID) {
    var fieldName = this.getEditorName(rowNum, fieldID),
        editData = this.getEditSession(rowNum, fieldID),
        errors = editData ? editData._validationErrors : null;

    return (
        errors != null &&
        errors[fieldName] != null
    );
},


// No obvious use for a listGrid.getErrors() method.

//>!BackCompat 2007.02.14
//> @method listGrid.getRowValidationErrors()
//  Returns any currently stored validation errors for this row in the following format:<br>
//  &nbsp;&nbsp;<code>{fieldName:[validation error array], ...}</code>
//  @group  editing
//  @visibility internal
//  @param  rowNum (number) index of row to check for validation errors.
//  @return (Object)   object showing validation error arrays by field for the row passed in - if
//                      no validation errors stored for the row, null is returned.
// @deprecated in favor of +link{listGrid.getRowErrors()}
//<

getRowValidationErrors : function (rowNum) {
    return this.getRowErrors(rowNum);
},
//<!BackCompat

//> @method listGrid.getRowErrors()
//  Returns any currently stored validation errors for this row in the following format:<br>
//  &nbsp;&nbsp;<code>{fieldName:[array of error messages], ...}</code>
//  @group gridValidation
//  @param  rowNum (number) index of row to check for validation errors.
//  @return (Object)   object showing validation error arrays by field for the row passed in
//                      - if no validation errors stored for the row, null is returned.
// @visibility external
// @see listGrid.getCellErrors()
//<

getRowErrors : function (rowNum, colNum) {
    var data = this.getEditSession(rowNum, colNum);
    return (data != null ? data._validationErrors : null);
},

//> @method listGrid.getCellErrors()
//  Returns the current set of errors for this cell.
//  @group gridValidation
//  @param  rowNum (number) index of row to check for validation errors.
//  @param  fieldName   (String | number)   field to check for validation errors - can be fieldName
//                                          or index of the column.
//  @return (Array of String) array of error messages (strings) for the specified cell. If no validation
//                  errors are present, returns null.
//  @visibility external
//<
getCellErrors : function (rowNum, fieldName) {
    // assume fieldName is a colNum if we're working with cellrecords
    var data = this.getEditSession(rowNum, fieldName);
    if (data == null) return null;

    if (isc.isA.Number(fieldName)) fieldName = this.getEditorName(rowNum, fieldName);
    var errors = data._validationErrors;
    return (errors == null ? null : errors[fieldName]);
},


// Synonym of setFieldError(), since we already supply getCellErrors()
setCellErrors : function (row, field, error, suppressDisplay) {
    return this.setFieldError(row, field, error, suppressDisplay);
},

//> @method listGrid.setFieldError()
// Set a validation error for some cell.
// @group gridValidation
// @param  rowNum  (number)    row index of cell to add validation error for
// @param  fieldName (String | number)    col index or field name of cell to add validation error for
// @param  errorMessage  (String | Array of String)    validation error/errors for the cell.
// @visibility external
// @see listGrid.getCellErrors()
// @see listGrid.setRowErrors()
//<
setFieldError : function (rowNum, fieldID, errorMessage, dontDisplay) {
    var fieldName = fieldID;
    if (isc.isA.Number(fieldName)) fieldName = this.getEditorName(rowNum, fieldName);

    var gridHadErrors = this.hasErrors();

    // If passed an empty set of errors, use delete to clear the error instead
    if (errorMessage == null || (isc.isAn.Array(errorMessage) && errorMessage.length == 0)) {

        if (!this.cellHasErrors(rowNum, fieldID)) return;

        this.logDebug("setFieldError() passed empty errors- clearing the errors for row:" + 
                      rowNum + ", field:" + fieldID, "gridEdit");

        var data = this.getEditSession(rowNum, fieldID);
        delete data._validationErrors[fieldName];
        // Don't hang onto an empty errors object - this will confuse hasErrors et al.
        if (isc.isAn.emptyObject(data._validationErrors)) delete data._validationErrors
    } else {
        // If passed a bad fieldNum, for example, just drop it
        if (fieldName == null) {
            this.logWarn("setFieldError() passed field identifier '" + fieldID + "'. " +
                        "Unable to find corresponding field in this grid - not setting error.");
            return;
        }

        // Warn if the user has set errors on non visible fields (or completely random fields)
        var visFields = this.getFields().getProperty(this.fieldIdProperty);
        if (!visFields.contains(fieldName)
            
            )
        {
            this.logWarn("setFieldError() passed field identifier '" + fieldID + "'. This " +
                         "is not a visible field in the grid - error may not be visible to user.");
        }

        var errors;
        if (isc.isAn.Array(errorMessage)) errors = errorMessage
        else errors = [errorMessage];

        var data = this.getEditSession(rowNum, fieldID);
        // Unlikely to happen, but catch the case of being passed a row with no edit values
        if (data == null) {
            var colNum = this.getColNum(fieldID),
                record = this.getCellRecord(rowNum, colNum);
            data = this.createEditSession(rowNum, colNum, record);
        }

        this.logDebug("setFieldError() setting errors for row:" + rowNum + ", field:"
              + fieldID + " to:" + this.echo(errors), "gridEdit");


        if (data._validationErrors == null) data._validationErrors = {};
        data._validationErrors[fieldName] = errors;
    }

    // If appropriate show the errors to the user
    if (!dontDisplay) {
        
        if (this.useCellRecords) this.showCellErrors(rowNum, fieldID)
        else this.showErrors(rowNum, [fieldName]);
    }
    this._updateGridHasErrorsInRuleScope(gridHadErrors);
},

// This method passes straight through to setFieldError; it is implemented purely so that
// DBC._handleServerValidationResponse has a standard method to call when populating errors
addFieldErrors : function (fieldName, errorMessage, showErrors, rowNum) {
    this.setFieldError(rowNum, fieldName, errorMessage);
},

//> @method listGrid.setRowErrors()
// Set the validation errors for some row (replacing any pre-existent validation errors)
// <P>
// Note that in the case of a +link{listGrid.groupByField,grouped listGrid}, or a 
// +link{treeGrid}, some records may be hidden form view (part of a collapsed group or
// parent folder). In this case there is no meaningful row number associated with a record.
// This method cannot be called on such rows - developers should make the row visible first.
// This is by design - users should always be able to see errors.
//    
// @group gridValidation
// @param  rowNum  (number)    row to add validation error for
// @param  errors (Any) validation errors for the row in the format
//                          <code>{fieldName:errorMessage, ...}</code> <br>or <br>
//                          <code>{fieldName:[errorMessage1, errorMessage2], ...}</code>
// @visibility external
// @see listGrid.getRowErrors()
// @see listGrid.setFieldError()
//<

setRowErrors : function (rowNum, errors, dontDisplay) {
    

    if (rowNum == null || rowNum == -1) return;

    var storedErrors = this.getRowErrors(rowNum);
    if (!errors && !storedErrors) return;

    var data = this.getEditSession(rowNum);
    
    if (data == null) data = this.createEditSession(rowNum, null, this.getRecord(rowNum));
    if (errors) {

        var visibleFields = this.getFields().getProperty(this.fieldIdProperty);
        for (var fieldName in errors) {
            // Warn if passed an error on a non-visible field as this will not show up
            // via the standard 'error cell' styling
            // Should probably have a customizable method to handle this
            if (!dontDisplay && !visibleFields.contains(fieldName)) {
                this.logWarn("setRowErrors() passed error for non-visible field: '" + fieldName + "'");
            }

            // Convert single error message strings into arrays.
            if (!isc.isAn.Array(errors[fieldName])) errors[fieldName] = [errors[fieldName]];
        }
    }
    this.logDebug("setRowErrors() setting errors for row " + rowNum + " to " + 
                  this.echo(errors), "gridEdit");

    var gridHadErrors = this.hasErrors();

    // Actually store the validation object.
    data._validationErrors = errors;

    if (!dontDisplay) {

        // For efficiency, only refresh cells that actually need to be refreshed due to
        // new errors, or errors being cleared.
        var fields = errors ? isc.getKeys(errors) : [];

        // We need to update each cell in the row to reflect any changes to validation errors,
        // either new errors, or errors that have been cleared.
        for (var fieldName in storedErrors) {
            var colNum = this.getColNum(fieldName);

            if (!fields.contains(fieldName)) fields.add(fieldName);
        }

        // Call showErrors() to actually update the error styling on the cells and show any
        // error messages to the user
        this.showErrors(rowNum, fields);
    }
    this._updateGridHasErrorsInRuleScope(gridHadErrors);
},

//> @method listGrid.clearFieldError()
// Clears any validation errors for some cell.
// @group gridValidation
// @param  rowNum  (number)    row index of cell to add validation error for
// @param  fieldName (number | String)    col index or field name of cell to add validation error for
// @visibility external
// @see listGrid.setFieldError()
//<
clearFieldError : function (rowNum, fieldName, dontDisplay) {
    return this.setFieldError(rowNum, fieldName, null, dontDisplay);
},


//> @method listGrid.clearRowErrors()
//  Clear any stored validation errors for some row
//  @group  validation
//  @param  rowNum  (number)    index of row to clear validation error for
// @visibility external
// @see listGrid.setRowErrors()
//<
clearRowErrors : function (rowNum, dontDisplay) {
    this.setRowErrors(rowNum, null, dontDisplay);
},



// Showing Validation Errors
// ---------------------------------------------------------------------------------------

//> @method listGrid.showErrors() ([A])
// Update the specified row to display the current set of validation errors.<br>
// If +link{listGrid.stopOnErrors} is true and the row has errors, this method will also
// call display the error messages to the user in a warning dialog, and reset focus to
// the first cell that failed validation.
// @param rowNum (number) row to be updated
// @param [fields] (Array) Array of fieldNames for which errors should be displayed or cleared.
//                      If not passed defaults to displaying errors for every field in the row.
// @group gridValidation
// @visibility internal
//<
// Notes:
// - This is a potential override point - may want to make this external
// - The fields parameter is for more than just efficiency - it will also modify which
//   errors get displayed to the user via displayRowErrorMessages()
// - falls through to displayRowErrorMessages() to actually show the error messages
//   to the user in a warn dialog if stopOnErrors is true. Not clear that there's much point
//   to exposing this as if a developer wants to perform custom validation display this method
//   would probably be the more natural override point.
showErrors : function (rowNum, fields) {

    
    if (fields == null) fields = this.getFields().getProperty(this.fieldIdProperty);

    var errors = this.getRowErrors(rowNum);
    if (errors == null) errors = {};

    var firstFieldName;
    for (var i = 0; i < fields.length; i++) {
        var fieldName = fields[i];
        // Update the cell to display error styling and icon (or clear errorIcon and styling)
        this.showCellErrors(rowNum, fieldName);

        if (firstFieldName == null && errors[fieldName]) firstFieldName = fieldName;
    }

    // Split the method to convert the errors into a user-visible string into a separate
    // method for localization
    var errorMessageString = this.assembleErrorMessage(errors, fields);

    // Call a simple (overrideable) method to actually inform the user of the validation errors.
    
    if (errorMessageString) {
        this.displayRowErrorMessages(errorMessageString);
    }

    // If we're not saving in the background, put focus back into the first cell that failed
    // the edit (only necessary if the validation failed)
    if (this.stopOnErrors && firstFieldName != null) {
        var firstColNum = this.getColNum(firstFieldName);
        if (firstColNum != -1) {
            this.showInlineEditor(rowNum, firstColNum);
            return;
        }
        for (var fieldName in errors) {
            if (this.fieldIsVisible(fieldName) && errors[fieldName]) {
                this.showInlineEditor(rowNum, this.getColNum(fieldName));
            }
        }
    }
},

// showCellErrors()
// Helper method to update a cell in the body to display errors (or clear errors if appropriate)
showCellErrors : function (rowNum, colNum) {

    // Accept the 2nd param as a colNum or fieldName
    var fieldName;
    if (isc.isA.Number(colNum)) {
        this.getEditorName(rowNum, colNum);
    } else {
        fieldName = colNum;
        colNum = this.getColNum(fieldName);
    }
    // If passed a non-visible field, just bail.
    if (colNum == -1) return;

    if (this.showErrorIcons) {
        // refresh cell to rewrite the HTML to show (or hide) the icon.
        this.refreshCell(rowNum,colNum, null, true);
    } else {
        this.body._updateCellStyle(null, rowNum, colNum)
    }
},


//> @method listGrid.assembleErrorMessage()
// This method is called when validation errors occur, and assembles the set of errors into
// a string to be displayed to the user. Overridable for localization.
// @param errors (Object) Object containing <code>fieldName:error</code> mappings. Note that the
//              <code>error</code> object for each field may be a simple error message string,
//              a pointer to the validator that failed (so the errorMessage is available as
//              the <code>errorMessage</code> attribute of that object, or
//              an array of validator type objects (for multiple validation failures).
// @return (String) By default returns a string in the following format:<pre>
//                  Validation errors occurred:
//                  Field '[fieldTitle]':
//                  * [errorMessage]
//                  * [errorMessage]
//                  </pre>
// @visibility internal
// @group editing, i18nMessages
//<
assembleErrorMessage : function (errors, fields) {

    // Iterate through the set of errors, assembling an
    // error message string to show the user for the row.
    // Note the errors object is expected to be in the format:
    //   {fieldName:["error message 1", "errorMessage 2", ...],
    //    fieldName2:["error message 1", ...], ... }
    var errorMessageFound = false,
        errorMessageString = "Validation Errors occurred:\r\n";

    for (var fieldName in errors) {
        if (fields && !fields.contains(errors)) continue;

        // Assemble the errors together into a string to ultimately be passed to
        // 'displayRowErrorMessages'
        var errorMessage = this._createFieldErrorString(fieldName, errors[fieldName]);

        if (errorMessage != null) {
            errorMessageFound = true;
            errorMessageString += errorMessage;
        }

    }
    return (errorMessageFound ? errorMessageString : null);
},


// Internal helper for assembling all the error messages for a row into a single string
_createFieldErrorString : function (fieldName, errors) {
    // Assemble the errors together into a string to ultimately be passed to
    // 'displayRowErrorMessages'
    var errorMessageString, fieldErrorMessage,
        field = this.getField(fieldName),
        fieldTitle = field && field.title ? field.title : fieldName;

    // Note that we always normalize the format of stored errorMessages to
    // an array of strings per field
    for (var i =0; i < errors.length; i++) {
        var errorMessage = errors[i];
        if (errorMessage != null) {
            if (fieldErrorMessage == null) {
                fieldErrorMessage = "<br>Field '" + fieldTitle + "':";
            }
            fieldErrorMessage += "<br>* " + errorMessage;
        }
    }
    return fieldErrorMessage;
},

//> @method listGrid.displayRowErrorMessages()
//  A simple method called from 'showErrors' to display errorMessages from validation
//  on some row.
//  Takes a single errorMessage parameter - default implementation alerts this string if
//  this.stopOnErrors is true.<br>
//  Notes:<br>
//  Override this method to display error messages in some other way.<br>
//  For a more sophisticated validation error handling, the 'showErrors()' method can be
//  overridden instead.<br>
//  @group  editing
//
//  @param  rowNum  (number) Index of the record on which the validation errors occurred.
//  @param  errors  (Object) Object containing a map of field names to arrays of validation errors.
//  @see    listGrid.validateCellValue()
//  @see    listGrid.showErrors()
//  @see listGrid.assembleErrorMessage()
//<
displayRowErrorMessages : function (errorString) {
    
    if (this.stopOnErrors) isc.warn(errorString, "var LG=" + this.getID() +
                                            ";if(LG._editRowForm)LG._editRowForm.focus()");
    // -- in this case we might want to stick the error into a hover, etc.
    // - but hold off on that for now
},

// Removal of data
// ---------------------------------------------------------------------------------------



//> @method listGrid.removeData()
// Remove a record from this ListGrid.
// <P>
// If this grid is bound to a DataSource, it will perform a DataSource "remove" operation to
// remove records from this component's DataSource.
// <P>
// Otherwise the data will be removed from the grid's +link{listGrid.data,data} object.
// <P>
// To make changes to the local data object even when a DataSource is present, use
// +link{listGrid.saveLocally}.
//
// @param data (Record) listGrid record, or primary key values of record to delete.
// @param [callback] (DSCallback)  method to call on operation completion.
//   Note that if this is method does not trigger a dataSource remove operation, the callback
//   will still be fired when the data has been removed, but the <code>dsResponse</code> parameter
//   will be null.
// @param [requestProperties] (DSRequest Properties)   additional properties to set on any DSRequest
//                                          that will be issued
//
// @group dataBoundComponentMethods
// @visibility external
//<
removeData : function (recordKeys, callback, requestProperties, fromUserAction) {

    // Hang the original callback onto the request internalClientContext - we'll fire it from
    // 'removeDataComplete()'.
    

    // copy to avoid problems with re-using the same object
    requestProperties = isc.addProperties({}, requestProperties);

    
    requestProperties.internalClientContext = {
        removeDataCallback: callback
    };

    var editInfo = {
        fromUserAction:fromUserAction,
        // Note: rowNum / colNum are basically available for callbacks
        rowNum:this.findRowNum(recordKeys),
        colNum:null,
        values:recordKeys,
        editCompletionEvent:isc.ListGrid.PROGRAMMATIC
    };
    requestProperties.internalClientContext.editInfo = editInfo;

    // Override willHandleError so we don't get wedged in a loading state
    requestProperties.internalClientContext._explicitWillHandleError = requestProperties.willHandleError;
    requestProperties.willHandleError = true;

    if (this.getDataSource() != null && !this.shouldSaveLocally()) {
        
        if (recordKeys) recordKeys = isc.addProperties({}, recordKeys);

        return this.Super("removeData",
                [recordKeys, {target:this, methodName:"removeDataComplete"}, requestProperties],
                arguments);
    }
    if (this.data) {
        var editValuesID = this.getEditValuesID(recordKeys);
        if (editValuesID != null) this.discardEdits(editValuesID);
        if (isc.ResultSet && isc.isA.ResultSet(this.data) && this.shouldSaveLocally()) {
            if (this.data.allRows != null) {
                this.data.allRows.remove(recordKeys);
                this.data.filterLocalData();
            } else {
                this.logWarn("Unable to remove data from resultSet - allRows is not set");
            }
        } else {
            var origData = this.getOriginalData();
            origData.remove(recordKeys);
        }
        this.updateFieldWidthsForAutoFitValue("removeData");
        this.regroup();
    }

    this.fireCallback({target:this, methodName:"removeDataComplete"},
                    "dsResponse,data,dsRequest",
                     [null,recordKeys,requestProperties]);
},

removeDataComplete : function (dsResponse, data, dsRequest) {

    // We set up dsRequest.internalClientContext.editInfo even if this was client-only.
    var context = dsRequest.internalClientContext,
        editInfo = context.editInfo,
        fromUserAction = editInfo.fromUserAction,
        rowNum = editInfo.rowNum,
        colNum = editInfo.colNum,
        values = editInfo.oldValues || editInfo.values,
        editCompletionEvent = editInfo.editCompletionEvent;

    var success = dsResponse == null || dsResponse.status >= 0;
    if (success) {
        // if we have edit vals for the removed data, clear them up.
        if (!isc.isAn.Array(data)) data = [data];
        for (var i = 0; i < data.length; i++) {
            var editValsID = this.getEditValuesID(data[i]);
            
            if (editValsID != null) {
                this.discardEdits(editValsID);
            }
        }

        // Fire 'editComplete' notification since a remove is a specialized edit.
        // editComplete takes old and new values -- for removal of course this is just
        // the record being removed -- really just the primary key.
        var newValues = editInfo.values || editInfo.oldValues,

            rowNum = editInfo.rowNum;

        if (fromUserAction && this.convertToMethod("editComplete")) {
            this.editComplete(rowNum, colNum, values, values, editCompletionEvent, dsResponse);
        }
    } else {
        // We overrode willHandleError for the request.
        // Fire standard error handling now unless the original request already suppressed
        // this.
        var willHandleError = dsRequest.internalClientContext._explicitWillHandleError;
        if (!willHandleError) {
            isc.RPCManager._handleError(dsResponse, dsRequest)
        }
//        this.logWarn("removeData failed on server:" + data);
        // fire editFailed notification
        if (fromUserAction && this.convertToMethod("editFailed")) {
            this.editFailed(rowNum, colNum, values, values,
                            editCompletionEvent, dsResponse, dsRequest);
        }
    }

    // Note that if the server failed, we still need to fire callbacks - expected in
    // 'showRemoveCompleteAnimation' at least.
    if (context.removeDataCallback) {
        this.fireCallback(context.removeDataCallback,
                        "dsResponse,data,dsRequest", [dsResponse,data,dsRequest]);
    }
},

//> @method listGrid.removeRecordClick()
// Method fired when the user clicks the "remove" icon if +link{canRemoveRecords} is true.
// Default behavior will remove the record from the data set, or if we're
// +link{deferRemoval,deferring removal} mark record as removed [or for records already
// marked as removed, clear this removed marker].
// <P>
// If +link{listGrid.warnOnRemoval} is set, this method will also show a warning dialog to users
// allowing them to cancel the removal.
// <P>
// This method may be called directly to cause a record to be removed or marked for removal
// as if the user had hit the "remove" icon.
// <P>
// <smartgwt>To be notified when a "remove" click occurs, developers
// should add a
// {@link com.smartgwt.client.widgets.grid.ListGrid#addRemoveRecordClickHandler * RemoveRecordClickHandler}.
// </smartgwt>
// <smartclient>May be overridden to perform custom logic on remove click.</smartclient>
// @param rowNum (int) Row on which the icon was clicked
// @visibility external
//<

removeRecordClick : function (rowNum,colNum) {
    
    var record = this.getRecord(rowNum);
    // if there's no record, nothing to do

    // If this record is explicitly marked to not allow removal ignore the click
    if (this.recordCanRemoveProperty && record != null &&
        record[this.recordCanRemoveProperty] == false)
    {
        return;
    }

    // SGWT event handler entry point.
    
    if (this.onRemoveRecordClick(rowNum) == false) return;

    var shouldWarn = this.warnOnRemoval,
        shouldDefer = this.shouldDeferRemoval();
    // don't warn on unremoval.
    if (shouldWarn && shouldDefer && this.recordMarkedAsRemoved(rowNum)) shouldWarn = false;
    
    if (shouldWarn) {
        isc.ask(
            this.warnOnRemovalMessage,
            this.getID() + ".completeRemoveRecordClick(value, " + rowNum + "," + colNum + ")"
        );
    } else {
        this.completeRemoveRecordClick(true, rowNum, colNum);
    }
},

//> @method listGrid.onRemoveRecordClick ()
// Handler fired when the user clicks the "remove" icon if +link{canRemoveRecords} is true.
// Default behavior will remove the record from the data set, or if we're
// +link{deferRemoval,deferring removal} mark the record as removed [or for records already
// marked as removed, clear this removed marker].
// <P>
// If +link{listGrid.warnOnRemoval} is set, this method will also show a warning dialog to users
// allowing them to cancel the removal.
// <P>
// This event may be cancelled to suppress the default behavior.
//
// @param rowNum (int) Row on which the icon was clicked
// @return (boolean) return false to cancel the event
// @visibility sgwt
//<

onRemoveRecordClick : function (rowNum) {
    return true;
},

completeRemoveRecordClick : function (shouldRemove, rowNum, colNum) {
    // user hit "No" on the warn dialog - just bail.
    if (!shouldRemove) return;

    if (this.shouldDeferRemoval()) {
        if (this.recordMarkedAsRemoved(rowNum)) {
            this.unmarkRecordRemoved(rowNum);
        } else {
            this.markRecordRemoved(rowNum);
        }
    } else {
        var editRows = this.getAllEditRows(),
            isEditing = editRows.contains(rowNum);

        if (isEditing) this.discardEdits(rowNum, colNum);

        var record = this.getCellRecord(rowNum,colNum);
        if (record == null) return;
        // use delayCall to actually remove the record in a separate thread.
        // required since we can't redraw immediately in response to a mouseDown
        this.delayCall("removeRecord", [rowNum, record]);
    }
},

// Remove a record from this ListGrid.
// This is called from a click on the remove field.

removeRecord : function (rowNum, record) {
    if (record == null) record = this.data.get(rowNum);
    else rowNum = (this.data ? this.data.indexOf(record) : null)

    // Only support removing the record if it's actually showing up in this grid!
    // (This not removing nodes in closed parent folders for example)
    if (record == null || rowNum == null || rowNum == -1 || !this.data) return;

    if (isc.Offline && isc.Offline.isOffline() && this.dataSource && !this.dataSource.clientOnly) {
        isc.warn(this.offlineSaveMessage);
        return;
    }

    // animating record removal
    // If we're animating the record removal, we want to remove the data before starting the
    // animation. This ensures the record gets successfully cleared (not guaranteed in the case
    // of a server operation).
    // Set up the row animation before removing the data, then kick off the animation when we know
    // row removal was successful.
    
    var animateRemoveRecord = this.animateRemoveRecord && this.isDrawn() && this.isVisible() &&
                              this.body &&
                              rowNum >= this.body._firstDrawnRow &&
                              rowNum <= this.body._lastDrawnRow;
    // Avoid attempting to do animatedResize when we have variable row heights and frozen
    // fields. The rowHeightSpacerHTML breaks the appearance during the resize
    if (this.fixedRecordHeights == false && this.frozenFields != null) {
        animateRemoveRecord = false;
    // Don't attempt to animate remove rows with embedded components. Since the components
    // won't be clipped by the animation it'll look funky.
    } else if (this._hasEmbeddedComponents(record)) {
        animateRemoveRecord = false;
    }

    if (animateRemoveRecord) {
        this._suppressRedrawOnDataChanged = true;
        var delta = 1;
        if (isc.isA.Tree(this.data) && this.data.isFolder(record) && this.data.isOpen(record)) {
            var children = this.data.getChildren(record);
            if (children && (!isc.isA.ResultSet(children) || children.lengthIsKnown())) {
                delta += children.getLength();
            }
        }

        this._removeRowDelta = delta;
        // perform the setup for the animated hide while our data is still present in our dataSet
        this.body._initializeShowHideRow(false, rowNum, rowNum+delta);
    }

    var ds = this.getDataSource(),
        removeLocally = (ds == null || this.shouldSaveLocally());
    if (!removeLocally) {
        if (!ds.getPrimaryKeyField()) {
            this.logWarn("DataSource:"+ ds +
                        " has no primary key field - unable to remove records");
            return;
        }
    }
    var callback;
    if (animateRemoveRecord) {
        callback = this.getID() + ".showRemoveCompleteAnimation(" + rowNum + ", data,dsResponse);";
    }

    // if the record about to be removed is expanded, collapse it to properly clear the 
    // expansionComponent
    if (this.canExpandRecords && this.isExpanded(record)) this.collapseRecord(record);

    this.removeData(record, callback, {showPrompt:false}, true);
},

// Callback to animate a removed record out of view. Set up by 'removeRecord()'
showRemoveCompleteAnimation : function (rowNum, record, response) {
    // if this was a server-based removal, check for errors
    if (response && response.status < 0) {
        this.logWarn("Removal of record failed");
        record = null;
    }

    if (!record) {
        delete this._suppressRedrawOnDataChanged;

        if (this.body) {
            // clear up the properties set up by _initializeShowHideRow
            delete this.body._animatedShowStartRow;
            delete this.body._animatedShowEndRow;
            delete this.body._animatedShowRowHeight;
            delete this.body._animatedShowCallback;
        }
        this.markForRedraw();
    } else {
        this.startRowAnimation(false, rowNum, rowNum+this._removeRowDelta,
                                {target:this, methodName:"_removeDataAnimationComplete"},
                                this.animateRemoveSpeed, this.animateRemoveTime);
        delete this._removeRowDelta;
    }
},

_removeDataAnimationComplete : function () {
    delete this._suppressRedrawOnDataChanged;
    this._clearRemoveAnimation = true;
    this.redraw();
},

// override DataBoundComponent.removeSelectedData() to ensure we support grouped ListGrids
removeSelectedData : function (callback, requestProperties, queueCallback) {
    var selection = this.getSelection();

    this.invokeSuper(isc.ListGrid, "removeSelectedData", callback, requestProperties, function (responses) {
        // we don't need to make any adjustments to the databound case, so limit cleanup
        if (this.data && (this.getDataSource() == null || this.shouldSaveLocally())) {
            // if data is not a ResultSet, check for and remove records from originalData
            if (!isc.ResultSet || !isc.isA.ResultSet(this.data) || !this.shouldSaveLocally()) {
                var origData = this.getOriginalData();
                if (origData != this.data) origData.removeList(selection);
            }
            // rerun autofitting without the deleted records, and regroup
            this.updateFieldWidthsForAutoFitValue("removeSelectedData");
            this.regroup();            
        }
        // finally, fire the originally passed callback, since it hasn't been called yet
        if (queueCallback) {
            this.fireCallback(queueCallback, "responses", [responses]);
        }
    });
},


// Row Animation
// ---------------------------------------------------------------------------------------

//>Animation
// Animated showing and hiding of rows
//> @method listGrid.startRowAnimation()
// @include gridRenderer.startRowAnimation()
//<
startRowAnimation : function (show, startRow, endRow, callback, speed,
                               duration, effect, slideIn, delayed)
{
    if (!this.body) return;

    // force an immediate finish of any currently running row animation.
    // will no op in most cases
    this.finishRowAnimation();

    this._rowAnimationCompleteCallback = callback;

    // if we have a frozen body too, animate there, but avoid firing the callback twice when
    // both animations complete
    if (this.frozenBody) {
        this.frozenBody.startRowAnimation(show, startRow, endRow,
                                          {target:this, methodName:"rowAnimationComplete",
                                           argNames:"body,hasFrozenBody",
                                           args:[this.frozenBody, true]},
                                          speed,
                                          duration, effect, slideIn, true, delayed);
    }
    this.body.startRowAnimation(show, startRow, endRow,
                                {target:this, methodName:"rowAnimationComplete",
                                 argNames:"body,hasFrozenBody",
                                 args:[this.body, (this.frozenBody != null)]},
                                speed,
                                duration, effect, slideIn, true, delayed);
},

// rowAnimationComplete callback - fires the callback passed to startRowAnimation.
// Will be called twice if we have a frozenBody as well as a liquid body - in this case
// only fire the callback we were passed when both bodies have finished animating
rowAnimationComplete : function (body, hasFrozenBody) {
    var fireCallback = !hasFrozenBody || this._frozenBodyAnimationComplete;

    if (!fireCallback) {
        // just set a flag so the next time this method is run (with the other body), we'll
        // fire our callback.
        this._frozenBodyAnimationComplete = true;
    } else {
        delete this._frozenBodyAnimationComplete;

        var callback = this._rowAnimationCompleteCallback;
        delete this._rowAnimationCompleteCallback;
        if (callback != null) this.fireCallback(callback);
    }
},

finishRowAnimation : function () {
    if (this.body) this.body.finishRowAnimation();
    if (this.frozenBody) this.frozenBody.finishRowAnimation();
},

//> @method listGrid.animateRowHeight()
// @include gridRenderer.animateRowHeight()
//<
animateRowHeight : function (rowNum, newHeight, callback, speed, duration, effect, slideIn) {
    if (!this.body) return;
    return this.body.animateRowHeight(rowNum, newHeight, callback, speed, duration, effect, slideIn, true);
},
//<Animation

//> @method listGrid.setCellHeight()
// Set the cellHeight for the listGrid as a whole. To set the height of individual rows use
// +link{ListGrid.setRowHeight()} instead.
//<
setCellHeight : function (newHeight) {
    var oldHeight = this.cellHeight;
    this.cellHeight = newHeight;
    if (this.body) this.body.cellHeight = newHeight;
    if (oldHeight != newHeight && this.isDrawn()) {
        this.body.markForRedraw("Cell height changed");
        if (this.frozenBody) this.frozenBody.markForRedraw("Cell height changed");
    }

},


//> @method listGrid.setRowHeight()
// @include gridRenderer.setRowHeight()
//<
setRowHeight : function (rowNum, newHeight) {
    if (!this.body) return;
    // keep frozen / unfrozen bodies in sync
    if (this.frozenBody != null) this.frozenBody.setRowHeight(rowNum, newHeight);

    return this.body.setRowHeight(rowNum, newHeight);
},


// Body Drag&Drop (selection, reorder records, drag records out, drop records in)
// --------------------------------------------------------------------------------------------

//> @method listGrid.setDragTracker()
// @include dataBoundComponent.setDragTracker()
// @visibility external
//<

//> @method listGrid.getDragTrackerProperties()
// @include dataBoundComponent.getDragTrackerProperties()
//<

//> @attr listGrid.dragTrackerStyle
// @include dataBoundComponent.dragTrackerStyle
//<


//> @method listGrid.getDragTrackerIcon()
// Return an icon to display as a drag tracker when the user drags some record.<br>
// Default implementation:
// If +link{listGridField.valueIcons} is specified for the title field of this grid
// (see +link{listGrid.getTitleField()}), the appropriate value icon will be displayed.
// If no appropriate valueIcon can be found, the icon will be derived from
// +link{ListGrid.trackerImage}.<br>
// If multiple records are selected, only the first record is examined for valueIcons.
// <p>
// Note: Only called if +link{listGrid.dragTrackerMode} is set to <code>"icon"</code>.
// @param records (Array of ListGridRecord) Records being dragged
// @return (String) Image URL of icon to display
// @group dragTracker
// @visibility external
//<
getDragTrackerIcon : function (records) {
    // we don't expect this method to fire if no records are selected, but if so, just show
    // the generic drag tracker
    var record = records ? records[0] : null,
        icon;
    if (record) {
        var titleFieldName = this.getTitleField();
        icon = this.getValueIcon(this.getField(titleFieldName), record[titleFieldName], record);
    }
    if (icon == null) icon = this.trackerImage;
    return icon;
},

//> @method listGrid.getDragTrackerTitle()
// Return "title" HTML to display as a drag tracker when the user drags some record.<br>
// Default implementation will display the cell value for the title field (see
// +link{listGrid.getTitleField()}) for the record(s) being dragged (including any
// icons / custom formatting / styling, etc).
// <p>
// Note: Only called if +link{listGrid.dragTrackerMode} is set to <code>"title"</code>.
// @param record (ListGridRecord) First selected record being dragged
// @param rowNum (number) row index of first record being dragged
// @return (String) Title for the row. Default implementation looks at the value of the
//                  title-field cell for the row.
// @group dragTracker
// @visibility external
//<
getDragTrackerTitle : function (record, rowNum) {
    var undef,
        titleField = this.getTitleField(),
        formattedValue = this.getFormattedValue(record, titleField, record ? record[titleField] : undef);
    return "<nobr>" + formattedValue + "</nobr>";
},

// We have our own drag/drop handling and don't want the Layout level handling
// (showing drop line, allowing user to drop new members in the layout, etc)
_suppressLayoutDrag:true,

//> @method listGrid.dragStart()    (A)
// drag start event
// @group events, dragging
// @return (boolean) false non-existent record or !canDrag; true otherwise
//<
dragStart : function () {
    
    // if the user is attempting to drag a header button, we can just disallow the drag
    // as this logic is only concerned with dragging records.
    // Safe to kill this event if we see it - if the header was draggable
    // (canReorderFields:true), the event wouldn't get bubbled
    // up to us at all.
    var eventTarget = isc.EH.getTarget();
    if (eventTarget && this.header && this.header.contains(eventTarget)) {
        return false;
    }

    // if dragging means drag-selection, we do nothing until dragMove
    if (this.canDragSelect) return true;

    
    if (!this._shouldAllowRecordDrag()) return false;

    // get the records to be dragged
    var dragData = this.getDragData();
    // no records or any record is canDrag == false, cancel the drag by returning false
    if (dragData == null || dragData.length == 0) return false;
    for (var i = 0; i < dragData.length; i++) {
        if (!dragData[i]._isGroup && dragData[i].canDrag == false) return false;
    }

    // Otherwise store a snapshot of the current selection on the ListGrid object so that we
    // are able to transfer the correct record(s) when the user drops them, in the unlikely
    // event that they change the ListGrid selection (with the keyboard) during the drag
    // operation
    this._dragDataAtDragStart = dragData;

    return true;
},

dragMove : function () {
    var dropTarget = isc.EH.dropTarget;
    // if you're not allow to drag records out, cancel dragging over anything that isn't this
    // grid
    if (!this.canDragRecordsOut && dropTarget != null &&
        dropTarget != this && !this.contains(dropTarget))
    {
        return false;
    }
},

//> @method listGrid.dropMove() (A)
// Handle a dropMove event.  This will show the drag line in the appropriate position.
// @group events, dragging
// @return (boolean) true if the list can't reorder
//<
dropMove : function () {
    var accept = this.willAcceptDrop();
    if (accept) {
        // If the list can be reordered, show the dragLine
        if (this.canReorderRecords) this.showDragLineForRecord();

        // In case it was previously set
        this.body.clearNoDropIndicator();
        
        // We've claimed the drop, so don't bubble
        return false;
    } else if (accept == null) {
        // We wouldn't accept this drop for any record. So, let it bubble.
        return true;
    } else {
        // The drop would have been accepted for some rows, but not this one. 
        // In this case, show the no-drop cursor. 
        this.body.setNoDropIndicator();
        
        // But still show the drag-line if reordering is enabled, so the user
        // can see where they would be dropping -- so it's clear what's
        // disallowed.
        if (this.canReorderRecords) this.showDragLineForRecord();
        
        // We've conclusively denied the drop, so don't bubble
        return false;
    } 
},

dropOver : function () {
    // Execute the dropMove() logic for dropOver, so that we stop bubbling
    // in the appropriate cases, so that our ancestors don't draw dropLines
    // inappropriately.
    return this.dropMove();
},

//> @method listGrid.dropOut()  (A)
// handle a dragOut event
// @group events, dragging
//<
dropOut : function () {
    this.body.clearNoDropIndicator();
    this.hideDragLine();
},

//> @method listGrid.dragStop() (A)
// handle a dragStop event
// @group events, dragging
//<
dragStop : function () {
    this.body.clearNoDropIndicator();
    this.hideDragLine();
    this._dragDataAtDragStart = null
},

//> @method listGrid.willAcceptDrop()   (A)
//
// This method overrides +link{Canvas.willAcceptDrop()} and works as follows:<br>
// <ul>
// <li>If +link{Canvas.willAcceptDrop()} (the superclass definition) returns false, this
//     method always returns false.  This allows +link{canvas.dragType} and
//     +link{canvas.dropTypes} to be used to configure eligibility for drop.  By default,
//     a ListGrid has no dropTypes configured and so this check will not prevent a drop.</li>
// <li>If this is a self-drop, that is, the user is dragging a record within this list, this is
//     an attempted drag-reorder.  If +link{ListGrid.canReorderRecords} is
//     false, this method returns false.</li>
// <li>If the +link{EventHandler.getDragTarget(),dragTarget} is another widget, if
//     +link{ListGrid.canAcceptDroppedRecords} is false this method returns false.</li>
// <li>If a call to +link{ListGrid.getDragData()} on the <code>dragTarget</code> fails to return
//     an record object or an array of records, this method returns null.</li>
// <li>If the drop target record is disabled or has +link{ListGridRecord.canAcceptDrop}
//     set to false, return false.</li>
// </ul>
// Note that this method may be called repeatedly during a drag-drop interaction to update the
// UI and notify the user as to when they may validly drop data.
//
// @group   events, dragging
// @return (boolean) true if this component will accept a drop of the dragData,
//                   otherwise false, or null if the drop() should be bubbled
//                   to parent elements
// @see ListGridRecord.canAcceptDrop
// @see ListGrid.getDragData()
//
// @visibility external
//<
willAcceptDrop : function () {
    // Use superclass implementation to check that there is a valid dragTarget, and
    // that dragType / dropTypes (if set) match up.
    // Note - if we're dragReordering a record within this listGrid, the dragTarget will
    // be this widget.  This is because we set up the listGrid body's dragTarget property to
    // point back to this widget (unless this.canDragSelect is true).
    // If we're doing a drag selection, this method will not be called, as drag select doesn't
    // involve dropping.
    // Therefore if the dragTarget is this widget, we can assume we're reordering records within
    // this widget.
    // If dropTypes are specified on this widget, and a developer wants canReorderRecords
    // behavior, they must specify a dragType on this LV that matches a dropType -- they can
    // just make up a "reorderDragDrop" dragType/dropType.
    var EH = this.ns.EH;

    var superAccept = this.Super("willAcceptDrop", arguments);
    if (!superAccept && EH.dragTarget != this.body) return superAccept;

    if (EH.dragTarget == this) {
        // Bail if we're attempting to drag records within LV, and we can't reorder
        // Since we're dragging our own records, return false to forbid bubbling
        if (!this._canDragRecordsToSelf()) return false;
    } else {
        // Bail if we're attempting to drag from elsewhere and canAcceptDroppedRecords is false
        // Since we're dragging from elsewhere, return null to allow bubbling
        if (!this.canAcceptDroppedRecords) return null;
    }

    // if not native dragging and the 'getDragData' for the dragTarget doesn't give us a suitable
    // object (Array or Object), bail (but allow bubbling)
    if (!EH.nativeDragging &&
        !EH.wasNativeDragging &&
        !isc.isAn.Object(EH.dragTarget.getDragData()))
    {
        // Allow bubbling
        return null;
    }

    isc._useBoxShortcut = true;
    // get the record being dropped on
    var rowNum = this.getEventRecordNum(),
        colNum = this.getEventFieldNum();
    var position = this.getRecordDropPosition(rowNum);
    if (rowNum != -2 && position == isc.ListGrid.AFTER) rowNum += 1;
    isc._useBoxShortcut = false;

    // if cursor is below the list, it's ok (may want to drop below last record), unless
    // canDropInEmptyArea is false
    if (rowNum < -1) {
        if (this.canDropInEmptyArea == false) return false;
        return true;
    }

    // if the cursor is above the list, bail
    if (rowNum == -1) return false;

    // if the record is disabled or can't accept drops, return false to cancel drop
    var record = this.getRecord(rowNum, colNum);
    if (!this.recordIsEnabled(record, rowNum, colNum) ||
        (record != null && record.canAcceptDrop == false)) return false;
    
    // if we get here, it should be OK!
    return true;
},

//> @method listGrid._canDragRecordsToSelf() (AR)
// Can we drag records within this LV
// @group events, dragging
//<
_canDragRecordsToSelf : function () {
    return this.canReorderRecords;
},

//> @method listGrid.transferSelectedData()
// @include dataBoundComponent.transferSelectedData()
//<

//> @method listGrid.drop() (A)
// Handle a drop event. Default implementation supports moving data within this grid or 
// transferring data into the grid from some other component.
// <P>
// Developers wishing to implement custom listGrid record drag and drop behavior should typically
// use the +link{listGrid.recordDrop()} method rather than overriding this method directly.
//
// @return (boolean) true for completion of a successful drag/drop interaction
//
// @group events, dragging
// @see listGrid.willAcceptDrop()
// @see listGrid.transferDragData()
// @visibility external
//<
drop : function () {
    // verify that the drop is valid
    if (this.willAcceptDrop() == false) return false;

    var sourceWidget = this.ns.EH.dragTarget;

    var dropIndex = this.getDropIndex();

    var dropRecords = sourceWidget.cloneDragData();

    var targetRecord = (dropIndex != -2 && this.getTotalRows()>dropIndex ? this.data.get(dropIndex) : null);
    
    // onRecordDrop() - fires before recordDrop() and gives developers an opportunity to cancel
    // the drop event
    
    var dropPosition = this.getRecordDropPosition(this.getEventRecordNum());
    if (this.onRecordDrop != null &&
        (this.onRecordDrop(dropRecords,targetRecord,dropIndex,dropPosition,sourceWidget) == false))
    {
        return false;
    }
    return this.recordDrop(dropRecords, targetRecord, dropIndex, sourceWidget);
},


//> @method listGrid.recordDrop()
// Process a drop of one or more records on a ListGrid record.
// <P>
// This method can be overridden to provide custom drop behaviors, and is a more appropriate
// override point than the lower level +link{Canvas.drop()} handler.
// <P>
// If this is a self-drop, records are simply reordered.
// <P>
// For a drop from another widget, +link{ListGrid.transferDragData()} is called, which
// depending on the +link{ListGrid.dragDataAction,dragDataAction} specified on the source
// widget, may either remove the source records from the original list
// (<code>dragDataAction:"move"</code>) or just provide a copy to this list
// (<code>dragDataAction:"copy"</code>).
// <P>
// If this grid is databound, the new records will be added to the dataset by calling
// +link{dataSource.addData()}.  Further, if the new records were dragged from another
// databound component, and +link{DataBoundComponent.addDropValues,addDropValues}
// is true, +link{DataBoundComponent.getDropValues,getDropValues} will be called for every item
// being dropped.
// <P>
// For multi-record drops, Queuing is automatically used to combine all DSRequests into a
// single HTTP Request (see QuickStart Guide, Server Framework chapter).  This allows the
// server to persist all changes caused by the drop in a single transaction (and this is
// automatically done when using the built-in server DataSources with Power Edition and
// above).
// <P>
// Note that reordering records has no effect on a databound grid.
// <P>
// The newly dropped data is then selected automatically.
// <P>
// If these default persistence behaviors are undesirable, return false to cancel them, then
// and implement your own behavior, typically by using grid.updateData() or addData() to add
// new records.
// <p><b>NOTE:</b> the records you receive in this event are the actual Records from the source
// component.  Use +link{DataSource.copyRecords()} to create a copy before modifying the records
// or using them with updateData() or addData().
// <P>
// NOTE: for a drop beyond the last visible record of a ListGrid, <code>targetRecord</code>
// will be null and the <code>index</code> will be one higher than the last record.  This
// includes a drop into an empty ListGrid, where <code>index</code> will be 0.
//
// @param dropRecords (Array of ListGridRecord[]) records being dropped
// @param targetRecord (ListGridRecord) record being dropped on.  May be null
// @param index (int) index of record being dropped on
// @param sourceWidget (Canvas) widget where dragging began
//
// @visibility external
//<
recordDrop : function (dropRecords, targetRecord, index, sourceWidget) {
    this.transferRecords(dropRecords, targetRecord, (this.canReorderRecords ? index : null),
                         sourceWidget);

    // signature "records,rowNum,viewer,sourceWidget"
    if (this.recordsDropped) this.recordsDropped(dropRecords, index, this, sourceWidget);

    // NOTE: we don't need to redraw since we're watching the data and it will change!

    // return false to cancel additional event processing
    return false;
},

//> @method ListGrid.transferDragData() (A)
// @include dataBoundComponent.transferDragData()
// @visibility external
//<

//> @method listGrid.getDragData()
// @include dataBoundComponent.getDragData()
//<

// --------------------------------------------------------------------------------------------

viewRow : function (rowNum) {
    this.getDataSource().viewFile(this.getRecord(rowNum));
},

downloadRow : function (rowNum) {
    this.getDataSource().downloadFile(this.getRecord(rowNum));
},

viewCell : function (rowNum, fieldName) {
    this.getDataSource().viewFile(this.getRecord(rowNum), fieldName);
},

downloadCell : function (rowNum, fieldName) {
    this.getDataSource().downloadFile(this.getRecord(rowNum), fieldName);
},

//> @method listGrid.autoSizeColumn()   (A)
//      @group  sizing, positioning
//
//      Can only be called after draw()
//
//      Resize this column to the size it needs to be in order to accommodate it's contents.
//<
autoSizeColumn : function (columnNum) {
    // determine the auto-size
    var body = this.body,
        frozen = this.fieldIsFrozen(columnNum),
        localFieldNum = this.getLocalFieldNum(columnNum);
    if (frozen && this.frozenBody) {
        body = this.frozenBody;
    }
    if (!body) return;

    var columnWidth = body.getColumnAutoSize(localFieldNum);
    if (this.includeGridSummaryInAutoFitWidth && this.showGridSummary && this.summaryRow != null) {

        var summaryBody = frozen ? this.summaryRow.frozenBody : this.summaryRow.body;
        if (summaryBody != null) {
            var summaryWidth = summaryBody.getColumnAutoSize(localFieldNum);
            if (summaryWidth > columnWidth) columnWidth = summaryWidth;
        }
    }

    // resize the field
    if (columnWidth != null) this.resizeField(columnNum, columnWidth);
},

//> @method listGrid.getRecord()    (A)
// Return the pointer to a particular record by record number.
// Synonym for +link{ListGrid.getCellRecord()}.
//
// @see ListGrid.getCellRecord()
// @see ListGrid.getEditedRecord()
// @param recordNum  (number) row index of record to return.
// @return (ListGridRecord) Record object for the row.
// @visibility external
//<
getRecord : function (rowNum, colNum) {
    return this.getCellRecord(rowNum, colNum);
},

// used by DBC/CellSelection to determine whether to return cellRecords (CubeGrid) or normal
// distinct records (ListGrid)
cellRecordMode: "row",

//> @method listGrid.getCellRecord()    (A)
// Return the pointer to a particular record by record number.<br>
// Notes:<br>
// - If this is a databound grid, and the record for some row has not yet been loaded,
//   returns the +link{resultSet.getLoadingMarker(),loading marker}, and a fetch will be
//   initialized to retrieve the record from the server.<br>
// - If this is a new row in an editable ListGrid, and has not yet been saved, this method will
//   return null.
// @see ListGrid.getRecord()
// @see ListGrid.getEditedRecord()
// @param recordNum  (number) row index of record to return.
// @return (ListGridRecord) Record object for the row.
// @visibility external
//<
getCellRecord : function (rowNum, colNum) {
    if (!isc.isA.Number(rowNum)) {
        this.logWarn("getCellRecord called with bad rowNum: " + this.echo(rowNum)
        //+ this.getStackTrace()
        );
        return;
    }
    // ListGrid assumes one record per row
    // Note - this.getTotalRows() may return a value higher than this.data.length. Don't
    // try to fetch records beyond the end of the dataset
    if (!this.data || 0 > rowNum || rowNum >= this.data.getLength()) return null;

    var record = this.data.get(rowNum);

    if (this._hasUnmatchedEdits) this._testRowEditData(record,rowNum);
    return record;
},


_getCachedCellRecord : function (rowNum, colNum) {
    if (!isc.isA.Number(rowNum)) {
        this.logWarn("getCellRecord called with bad rowNum: " + this.echo(rowNum));
        return;
    }
    if (!this.data || 0 > rowNum ||
        (isc.isA.ResultSet(this.data) && !this.data.lengthIsKnown()) ||
        rowNum >= this.data.getLength())
    {
        return null;
    }
    var record = this.data.getCachedRow(rowNum);
    if (this._hasUnmatchedEdits) this._testRowEditData(record, rowNum);
    return record;
},

// Internal method to map edit data for some record to that record's rowNum.

_testRowEditData : function (record, rowNum) {
    if (record == null || record[this.editValuesTestedProperty]) return;

    if (this._editRowMap == null) this._editRowMap = {};
    var noUnmatchedEdits = true;

    for (var i in this._editSessions) {
        var vals = this._editSessions[i];
        if (vals != null && vals._rowNum == null) {
            if (this.comparePrimaryKeys(record, vals._primaryKeys)) {
                vals._rowNum = rowNum;
                this._editRowMap[rowNum] = i;
            } else {
                // We use 'noUnmatchedEdits' to determine whether we have a rowNum for every
                // record in this._editValuesArray.
                // This is used to update the '_hasUnmatchedEdits' flag allowing us to avoid this
                // method entirely when we have matched every set of edit values to a rowNum.
                // Note - if this record is the last unmatched edit, and it matches the record,
                // we  leave this flag set to true, and avoid firing this method again.
                noUnmatchedEdits = false;
            }
        }
    }

    if (noUnmatchedEdits) delete this._hasUnmatchedEdits;
    record[this.editValuesTestedProperty] = true;
},

//> @method listGrid.comparePrimaryKeys()   ([AI])
//  Compare a record and a primaryKeys object, returning true if the primary keys match the
//  record.
//  @group  data
//  @param  record  (Object)    Record to compare to primary keys object
//  @param  keys    (Object)    set of primary keys / values
//  @return (boolean)   True if the primary keys match the record.
//<
comparePrimaryKeys : function (record, keys) {
    var rKeys = this.getPrimaryKeys(record);

    // For local data sets we use a pointer to the record object as primary keys
    if (!this.dataSource || this.shouldSaveLocally()) return (rKeys == keys);

    for (var keyField in rKeys) {
        if (rKeys[keyField] != keys[keyField]) return false;
    }
    return true;

},

// Returns unique primary keys for a record.
// Use 'comparePrimaryKeys()' to compare against some record.

getPrimaryKeys : function (record, colNum) {

    // assume a number is a recordIndex
    if (isc.isA.Number(record)) record = this.getCellRecord(record, colNum);
    if (this.shouldSaveLocally()) return record;

    var ds = this.getDataSource(),
        pkArray = ds.getPrimaryKeyFieldNames(),
        keys = {};

    if (!isc.isAn.Array(pkArray)) pkArray = [pkArray];

    for (var i = 0; i < pkArray.length; i++) {
        keys[pkArray[i]] = record[pkArray[i]]
    }
    return keys;
},

//> @method listGrid.getTotalRows()
// Return the total number of rows in the grid.
// <P>
// Note that, when creating new rows via inline editing, this can be more than the total number
// of rows in the dataset (that is, grid.data.getLength())
//
// @return (int) total number of rows in the grid
// @visibility external
//<
// Override 'getTotalRows' - the total set of rows for the grid are the length of the data, and
// any unsaved edit rows beyond the last record.
getTotalRows : function () {

    if (this.data == null) return 0;
    if (this.data.getLength == null) {
        this.logWarn("GetTotalRows: ListGrid has invalid data object:"+ this.echo(this.data));
        return 0;
    }
    var totalRows = this.data.getLength(),
        lastEditRow = this._getLastEditRow();
    if (lastEditRow != null && lastEditRow+1 > totalRows) totalRows = lastEditRow+1;

    if (this.shouldShowNewRecordRow()) totalRows += 1;

    return totalRows;
},

// Needed by the cell navigation logic moved down from CubeGrid to ListGrid
getTotalCols : function () { return this.fields.length; },

// Internal method to return the last (highest value) row for which we have edit values.
// Note: returns -1 if we have no edit values for any rows.
_getLastEditRow : function () {

    // Cache the last edit row for performance reasons.  We update this in the methods to
    // set / clear edit values
    if (this._lastEditRow == null) {
        var lastER = -1,
            allEditRows = (this._editRowMap ? isc.getKeys(this._editRowMap) : []);
        for (var i = 0; i < allEditRows.length; i++) {
            // Note the 'parseInt' is required, because the rowNums returned are strings rather
            // than numbers
            var currentER = parseInt(allEditRows[i]);
            if (currentER > lastER) lastER = currentER;
        }
        this._lastEditRow = lastER;
    }

    return this._lastEditRow;
},

//> @method listGrid.recordIsEnabled()  (A)
// return if record recordNum is enabled
// note: also returns false if the <code>record[this.isSeparatorProperty]</code> is true
// @param record (ListGridRecord) the record at index recordNum
// @param recordNum (number) record number to test for enabled
// @group selection, appearance
// @return (boolean) whether this record is enabled or not
//<
recordIsEnabled : function (record, row, col) {
    
    if (record == null) return true;
    if (this.recordMarkedAsRemoved(row)) return false;
    return (record[this.recordEnabledProperty] != false && record[this.isSeparatorProperty] != true);
},

cellIsEnabled : function (record, row, col) { 
    // if the grid is disabled, so is the cell
    if (this.isDisabled()) return false;
    return this.recordIsEnabled(record, row, col); 
},

//> @method listGrid.getCellField() (A)
//      Takes rowNum / colNum as parameters.
//      Return the pointer to the field structure for a cell
//
//      @group  display
//      @param  rowNum  (number)    Row Index of the cell
//      @param  colNum  (number)    Column index of the cell
//
//      @return (Object)    Field description
//<
getCellField : function (rowNum, colNum) {
    return this.getField(colNum);
},

//> @method listGrid.getFields()
// Get the array of all <b>currently visible</b> fields for this ListGrid.
// <P>
// This list fields is only valid once the ListGrid has been +link{draw(),drawn} or once
// +link{setFields()} has been called explicitly.  If called earlier, only the list of directly
// specified fields will be returned (the Array passed to create()).
// <P>
// This Array should be treated as <b>read-only</b>.  To modify the set of visible fields, use
// +link{showField()}, +link{hideField()} and related APIs.  To update properties of individual
// fields, use +link{setFieldProperties()} or more specific APIs such as
// +link{setFieldTitle()}.
// <P>
// To get the Array of all fields, including fields that are not currently visible or were
// specified implicitly, use +link{getAllFields()}.
//
// @return (Array of ListGridField) Array of all currently visible fields
// @visibility external
//<

getFields : function () {
    return this.fields;
},

//> @method listGrid.getAllFields()
// Get the complete array of fields for this ListGrid, including fields that are not currently
// visible or were specified implicitly via +link{listGrid.dataSource}.
// <P>
// This list of fields is only valid once the ListGrid has been +link{canvas.draw(),drawn} or once
// +link{setFields()} has been called explicitly.  If called earlier, only the list of directly
// specified fields will be returned (the Array passed to create()).
// <P>
// This Array should be treated as <b>read-only</b>.  To modify the set of visible fields, use
// +link{showField()}, +link{hideField()} and related APIs.  To update properties of individual
// fields, use +link{setFieldProperties()} or more specific APIs such as
// +link{setFieldTitle()}.
//
// @return (Array of ListGridField) Array of all fields in the ListGrid
// @visibility external
//<
getAllFields : function () {
    return this.completeFields || this.fields;
},

getUserFields : function () {
    return this.getAllFields().findAll({ fieldName: "featureField", operator: "notEqual", value: true });
},

//> @method listGrid.getSpecifiedField() (A)
// Looks up a field object by name or position.
// <p>
// Returns the field from this.completeFields (if available) rather than this.fields,
// allowing you to get a pointer to any field in the completeFields array
//
// @group display
// @param fieldID (String | number | ListGridField)
//                field number or field.name. If passed a field, it will be returned.
// @return (Object) Field description
//<

getSpecifiedField : function (fieldID) {
    var fields = this.completeFields;
    if (fields == null) fields = this.fields;
    if (fields == null) return;
    
    var field = null;

    if (isc.isAn.Object(fieldID)) {
        if (fields.contains(fieldID)) field = fieldID;
        // Catch the case where we're passed a field that's not present in our
        // fields/completeFields array.

        
        if (isc.isA.RecordEditor(this) && this.isAFilterEditor()) {
            field = this.getSpecifiedField(fieldID[this.fieldIdProperty]);        
        }

    } else if (isc.isA.String(fieldID)) {
        var map = this._completeFieldNamesMap;
        field = map ? map[fieldID] : fields.find(this.fieldIdProperty, fieldID);
    }
    else field = fields[fieldID];
    
    if (field) this._setFieldGridID(field);
    return field;
},

_setFieldGridID : function (field) {
    if (field && !field.componentID) field.componentID = this.ID;
},

//> @method listGrid.getFieldName() (A)
// Given a column number or field id, return the field name of a field.
//      @group  display
//      @param  colNum      (number | ID)  number or id of the field.
//      @return (String)    Name of the field.
//      @visibility external
//<
getFieldName : function (fieldNum) {
    var field = this.getField(fieldNum);
    return field ? field[this.fieldIdProperty] : null;
},

//> @method listGrid.getFieldByName()
// Given a field name, return the appropriate field definition.  Unlike 
// +link{listGrid.getField, getField()}, this method will return the field definition even if
// it's not visible in the grid.
//
// @param fieldName (FieldName) name of the field to retrieve
// @return (ListGridField) field definition
// @visibility external
//<
getFieldByName : function (fieldName) {
    return this.getSpecifiedField(fieldName);
},

//> @method listGrid.getField()
// Given a column number or field name, return the field definition of a field which is visible
// in the grid.  To retrieve the definition of <i>any</i> field, including hidden ones, use
// +link{listGrid.getFieldByName, getFieldByName()}.
// <P>
// When using +link{attr:DataBoundComponent.fields,DataBinding}, the field definition may be
// a mix of information derived from +link{listGrid.fields} and +link{listGrid.dataSource}.
//
// @param colNum (int | FieldName) number or name of the field
// @return (ListGridField) field definition
// @visibility external
//<

getField : function (id) {
    if (this.fields == null || id == null) return null;

    var field;

    if (this._noNumericFields) {
        field = this.fields[id];
        
        if (field != null && this._$emptyArr[id] == null) return field;
    } else {
        // Number: assume index.
        if (isc.isA.Number(id)) return this.fields[id];
    }

    // Object: return unchanged
    if (id._isFieldObject || isc.isAn.Object(id)) return id;

    // String: fieldName / dataPath
    if (isc.isA.String(id)) {
        if (!id.contains(isc.Canvas._$slash)) {
            // Either a fieldName or a plain relative dataPath - try name first
            field = this.fields.find(this.fieldIdProperty, id);
            if (field) return field;
        }
        // The dataPath declared on the field may be full or partial, absolute or
        // relative, and may have a (meaningless) trailing slash as well.  We'll have to
        // look for it in all the various forms it might take.  We'll keep this comparison
        // as sparse as possible - the following compare fields will be undefined unless
        // they are different from the base id (eg, if the base id starts with a slash,
        // "absolute" will remain undefined, because it would otherwise be identical to id)
        var absolute,
            noLeadingSlash,
            noTrailingSlash,
            slashesTrimmed = id.trim(isc.Canvas._$slash),
            complete,
            thisLevelOnly,
            thisLevelPlusTrailing,
            undef;

        if (id.startsWith(isc.Canvas._$slash)) {
            noLeadingSlash = id.substring(1);
            if (id.endsWith(isc.Canvas._$slash)) {
                noTrailingSlash = id.substring(0, id.length);
            } else {
                absolute = id + "/";
            }
        } else {
            if (id.endsWith(isc.Canvas._$slash)) {
                noTrailingSlash = id.substring(0, id.length);
                absolute = "/" + id;
            } else {
                absolute = "/" + id + "/";
            }
            complete = "/" + id;
        }
        var lastSlash = slashesTrimmed.lastIndexOf(isc.Canvas._$slash);
        if (lastSlash != -1) {
            thisLevelOnly = slashesTrimmed.substring(lastSlash + 1);
            thisLevelPlusTrailing = thisLevelOnly + "/";
        }

        for (var i = 0; i < this.fields.length; i++) {
            var dataPath = this.fields[i].dataPath;
            if (!dataPath) continue;
            if (dataPath == id ||
                (noLeadingSlash && dataPath == noLeadingSlash) ||
                (noTrailingSlash && dataPath == noTrailingSlash) ||
                (slashesTrimmed && dataPath == slashesTrimmed) ||
                (complete && dataPath == complete) ||
                (absolute && dataPath == absolute) ||
                (thisLevelOnly && dataPath == thisLevelOnly) ||
                (thisLevelPlusTrailing && dataPath == thisLevelPlusTrailing)
               )
            {
                return this.fields[i];
            }
            var trimmed = this._trimDataPath(dataPath, this);
            if (trimmed == id ||
                (noLeadingSlash && trimmed == noLeadingSlash) ||
                (noTrailingSlash && trimmed == noTrailingSlash) ||
                (slashesTrimmed && trimmed == slashesTrimmed) ||
                (complete && trimmed == complete) ||
                (absolute && trimmed == absolute) ||
                (thisLevelOnly && trimmed == thisLevelOnly) ||
                (thisLevelPlusTrailing && trimmed == thisLevelPlusTrailing)
               )
            {
                return this.fields[i];
            }
        }
    }

    // otherwise invalid
    return null;
},

//> @method listGrid.getFieldNum()  (A)
//      Given a field or field id, return it's index in the fields array
//      @group  display
//      @param  fieldID     (String | number)   field number or field.name
//      @return (int)   index of the field within this.fields
//      @visibility external
//<
// NOTE: implemented on Canvas

// make 'getColNum' a synonym of getFieldNum() since it's common to refer to 'colNum's
getColNum : function (fieldId) {
    return this.getFieldNum(fieldId);
},


//> @method listGrid.getFieldTitle() (A)
// Return the title of a field, specified by name or index.
// @param fieldId (String | Number) name or index of the field
// @return (String) Field title.
// @visibility external
//<
getFieldTitle : function (fieldId) {
    // get the field from the grid or the DS
	var field = this.getUnderlyingField(fieldId);

    // bail if no field
	if (!field) return "Unknown field";

	// if the field specifies a "getFieldTitle" method, call that
	if (field.getFieldTitle) {
		// CALLBACK API:  available variables:  "viewer,fieldNum"
		// Convert a string callback to a function
		isc.Func.replaceWithMethod(field, "getFieldTitle", "viewer,fieldNum");

		return field.getFieldTitle(this, this.getFieldNum(field));
	}

	// otherwise just return the title or the fieldName
	return field.title || field.name;
},

//> @method listGrid.getSummaryTitle()  (A)
// Return the summary title of particular field.  This is the title of
// the field to be used in the show / hide fields context menu. Default implementation will
// use  +link{listGridField.getSummaryTitle()} or +link{ListGridField.summaryTitle} if specified,
// otherwise +link{listGridField.title}.
// @group i18nMessages
// @group display
// @param field (ListGridField) field for which we're returning the title
// @return  (String)    Field summary title.
// @visibility external
//<
getSummaryTitle : function (field) {
    var title;
    // If the custom 'summary title' has been specified on the field, use that.
    if (field.getSummaryTitle != null) {
        // CALLBACK API:  available variables:  "viewer,field"
        // Convert a string callback to a function
        isc.Func.replaceWithMethod(field, "getSummaryTitle", "viewer,field");
        title = field.getSummaryTitle(this, field);
    } else if (field.summaryTitle != null) {
        title = field.summaryTitle;
    } else {
        title = this.getFieldTitle(field);
    }

    return title;
},


//> @method listGrid.setValueMap()
// Set the +link{listGridField.valueMap, valueMap} for a field.
// See also the +link{ListGrid.setEditorValueMap(), setEditorValueMap()}
// and +link{ListGrid.getEditorValueMap(), getEditorValueMap()} methods which allow further
// customization of the valueMap displayed while the field is in edit mode.
// @param fieldID (String | int) Name or index of field to update
// @param map (Object) ValueMap for the passed field
// @visibility external
//<
setValueMap : function (fieldID, map) {
    this.setFieldValueMap(fieldID, map);

    if (this._editorShowing) {
        var fieldName, field;
        var fieldNum = this.getColNum(fieldID);
        // don't crash on hidden fields / bad fieldNames that don't exist
        if (fieldNum != -1 && fieldNum < this.fields.length) {
            var field = this.getField(fieldID),
                fieldName = field[this.fieldIdProperty];
            
            var item = this._editRowForm.getItem(fieldName);
            if (item != null) delete item._dynamicPropsValueMap;
            
            this._editRowForm.setValueMap(
                fieldName,
                this.getEditorValueMap(field, this.getEditedRecord(this.getEditRow(), fieldNum))
            );
        }
    }
    // If we're showing a summaryRow grid, copy the valueMap across to that so if we do
    // something like show a max, or a mean that has a display value it'll update correctly
    if (this.summaryRow) {
        this.summaryRow.setValueMap(fieldID, map);
    }

    if (this.isDrawn() && this.isVisible()) {
        this._markBodyForRedraw("setValueMap");
    }
},

//> @method listGrid.getDisplayValue()
// Given a field with a specified +link{listGridField.valueMap} or +link{listGridField.displayField}
// this method will return the display value for any underlying data value.
// @param fieldID (String | number | ListGridField) Field or field identifier with valueMap
// @param valueFieldValue (Any) Data value for this field
// @param record (Record) The record containing the data values to be inspected
// @return (String) Display value associated with the specified valueFieldValue
// @visibility external
//<
getDisplayValue : function (fieldID, valueFieldValue, record) {
    var field = this.getField(fieldID),
        valueMap = field ? field.valueMap : null;
    var displayValue = this._getDisplayValue(
        field, valueMap, field && field.displayField, valueFieldValue, record);
    if (displayValue != null && !isc.isA.String(displayValue)) displayValue = "" + displayValue;
    return displayValue;
},
_getDisplayValue : function (field, valueMap, displayField, valueFieldValue, record) {
    // If `getDisplayValue()` is overridden by the user then we have to call it.
    if (this.getDisplayValue != isc.ListGrid.getInstanceProperty("getDisplayValue")) {
        return this.getDisplayValue(field, valueFieldValue, record);
    }

    if (field) {
        if (isc.isAn.Object(valueMap) && !isc.isAn.Array(valueMap) &&
            isc.propertyDefined(valueMap, valueFieldValue))
        {
            return valueMap[valueFieldValue];
        } else if (record && displayField) {
            valueFieldValue = record[displayField];
        }
    }

    return valueFieldValue;
},

//> @method listGrid.getData()
// Method to return the listGrid's +link{listGrid.data,data} object.
//
// @return (Object)    The data that is being displayed
//
// @see listGrid.getOriginalData()
//<
getData : function () {
    return this.data;
},

//> @method listGrid.getRecordIndex()
// Get the index of the provided record.
// <P>
// This is essentially the same as calling listGrid.data.indexOf(record), except that
// the currently visible range of records is checked first.  This is important for
// responsiveness in functions that respond to user actions when the user is working near the
// end of a very large dataset (eg 500k records).
//
// @param record (ListGridRecord) the record whose index is to be retrieved
// @return (int) index of the record, or -1 if not found
// @visibility external
//<
getRecordIndex : function (record) {
    var index = -1;

    if (this.body && this.body.isDrawn()) {
        index = this.data.indexOf(record, this.body._firstDrawnRow, this.body._lastDrawnRow);
    }
    if (index == -1) index = this.data.indexOf(record);
    return index;
},

//> @method listGrid.getRowNum()
// Synonym of +link{getRecordIndex(),getRecordIndex()}.
//
// @include method:getRecordIndex()
//<
getRowNum : function (record) {
    return this.getRecordIndex.apply(this, arguments);
},

//> @method listGrid.getRecordCellIndex()
// Get the row and column index of the provided record.
// <P>
// This function is set up with a colNum argument so it can be called on a ListGrid
// and return a meaningful cell object.  When 'selectOnEdit' is ultimately supported
// in CubeGrid, the overridden version of this function there won't use that argument,
// since the record will completely determine the cell to return.
//
// @param record (ListGridRecord) the record whose index is to be retrieved
// @param colNum (number) the cell column position (since record represents entire row)
// @return cell (Array) 2 element array containing the rowNum and colNum of the record
//                      (or -1 in both slots if not found)
//
// @visibility internal
//<
getRecordCellIndex : function (record, colNum) {
    var rowNum = this.getRecordIndex(record);
    return rowNum >= 0 ? [rowNum, colNum] : [-1, -1];
},

// Subclasses of ListGrid (such as CubeGrid) support one-record-per-cell data models
// Implement a stub method to determine the cell coordinates for a record which may be
// overridden by subclasses to return a meaningful colNum as well as rowNum
getCellCoordinates : function (record) {
    return this.getRecordCellIndex(record, 0);
},

//> @method listGrid.getEventRow()
// @include gridRenderer.getEventRow()
// @group events
// @visibility external
//<
getEventRow : function (y) {

    // If we're over the header, bail
    // XXX this works, but is a little kludgey - ideally we'd not call getEventRow() unless
    // we were over the body.
    if (this.header && this.header.containsPoint(this.ns.EH.getX(), this.ns.EH.getY())) {
        return -1;
    }
    if (this._passthroughBody) return this._passthroughBody.getEventRow(y);
    return this.body.getEventRow(y);
},

//> @method listGrid.getEventColumn()
// @include gridRenderer.getEventColumn()
// @group events
// @visibility external
//<
getEventColumn : function (x) {
    var tempX = (x != null ? x : this.getOffsetX()),
        colNum = 0,
        frozenColumns = 0
    ;
    
    if (this.frozenBody) frozenColumns = this.frozenFields.length;

    if (frozenColumns > 0 && tempX < this.frozenBody.getVisibleWidth()) {
        colNum = this.frozenBody.getEventColumn(x);
    } else {
        colNum = this.body.getEventColumn(x) + frozenColumns;
    }

    return colNum;

},

// local synonyms reflect ListGrid's row<->record, column<->field convention
getEventRecordNum : function (y) {
    return this.getEventRow(y);
},
getEventFieldNum : function (x) {
    return this.getEventColumn(x);
},

// inner drop position logic is reused in a few different places
_getRecordDropPosition : function (recordNum, y, dropAppearance) {
    if (!dropAppearance) dropAppearance = this.recordDropAppearance;

    var localY = y - this.body.getRowTop(recordNum),
        recordHeight = this.body.getRowSize(recordNum);

    if (dropAppearance == isc.ListGrid.BETWEEN) {
        // Top half, drop above, bottom half drop below
        if (localY > Math.round(recordHeight / 2)) {
            return isc.ListGrid.AFTER;
        } else {
            return isc.ListGrid.BEFORE;
        }
    } else if (dropAppearance == isc.ListGrid.BOTH) {
        if (localY < Math.round(recordHeight / 4)) {
            return isc.ListGrid.BEFORE; // top 1/4, drop above, 
        } else if (localY > Math.round(3 * recordHeight / 4)) {
            return isc.ListGrid.AFTER;  // bottom 1/4, drop below
        } else {
            return isc.ListGrid.OVER;   // middle - drop into folder    
        }
    }
},

//> @method listGrid.getRecordDropPosition()
// Returns the +link{RecordDropPosition} for some record drop operation.
// This value is passed to the +link{recordDrop()} event notification method.
// <P>
// Default implementation determines the position to return based on
// the specified +link{listGrid.recordDropAppearance} for the grid and the
// +link{EventHandler.getY(),y-coordinate of the drop event}.
//
// @return (RecordDropPosition) record drop position.
//
// @visibility external
//<
getRecordDropPosition : function (recordNum, y, dropAppearance) {
    if (this.recordDropAppearance == isc.ListGrid.OVER) return isc.ListGrid.OVER;
    if (this.recordDropAppearance == isc.ListGrid.BODY) return null;

    // If a y-coordinate was not passed, get it from the offset of the last event
    if (y == null) y = this.body.getOffsetY();

    // which row is the mouse over?
    if (recordNum == null) recordNum = this.getEventRow(y);

    // -2 implies we're past the end of the list
    if (recordNum == -2) return isc.ListGrid.AFTER;

    // a number greater than the number of records in the list implies we're past the end
    // of the list, so we want to return before since it's meaningless to position after a
    // non existent row -- we'll actually just be dropping at the end of the list.
    if (recordNum >= this.getTotalRows()) return isc.ListGrid.BEFORE;

    return this._getRecordDropPosition(recordNum, y, dropAppearance);
},

//> @method listGrid.getDropIndex()
// Return the drop-index for a given row and reorderPosition.
// <P>
// When there are no rows in the grid, getDropIndex() returns zero.
// <P>
// If parameter <i>recordNum</i> is not passed, the current event row is used, see
// +link{listGrid.getEventRow()}.
// <P>
// Parameter +link{ReorderPosition,reorderPosition} indicates where the drop-item should appear
// in relation to the row at index <i>recordNum</i>.  If no reorderPosition is provided, it is
// calculated based on the physical position of the mouse in the drop-target row when the drop
// occurs; if the mouse is in the top half of a row, the drop-index is before
// <i>recordNum</i>.  Otherwise, the drop-index is after <i>recordNum</i>.
//
// @param [recordNum]        (number)    Index of the record to drop onto
// @param [reorderPosition]  (ReorderPosition) Where to drop in relation to <i>recordNum</i>
// @return (number) The calculated drop-index
// @visibility external
//<
getDropIndex : function (recordNum, reorderPosition) {
    if (this.data.getLength() == 0) {
        // if there's no data, we have to drop in position 0
        return 0;
    }

    if (recordNum == null) recordNum = this.getEventRow();
    if (reorderPosition == null) reorderPosition = this.getRecordDropPosition(recordNum);

    if (this.canReorderRecords) {
        // if drop-record is -2, set to last record to slide after last record
        if (recordNum == -2) recordNum = this.data.getLength() - 1;

        if (reorderPosition == isc.ListGrid.AFTER) recordNum++;
    }

    return recordNum;
},

// cellSelectionChanged is passed through from the GR - include documentation for it.
//> @method listGrid.cellSelectionChanged() ([A])
// @include gridRenderer.cellSelectionChanged()
// @example cellSelection
//<
cellSelectionChanged : function () {
},

// selectionChanged is passed through from the GR - include documentation for it.
//> @method listGrid.selectionChanged()
// Called when (row-based) selection changes within this grid. Note this method fires for
// each record for which selection is modified - so when a user clicks inside a grid this
// method will typically fire twice (once for the old record being deselected, and once for
// the new record being selected).
// <P>
// NOTE: For updating other components based on selections or triggering selection-oriented
// events within an application, see the
// +link{dataBoundComponent.selectionUpdated(),selectionUpdated()} event
// which is likely more suitable.  Calls to +link{listGrid.getSelection(),getSelection()}
// from within this event may not return a valid set of selected records if the event has
// been triggered by a call to +link{dataBoundComponent.selectAllRecords(),selectAllRecords()}
// or +link{dataBoundComponent.deselectAllRecords(),deselectAllRecords()} - in this case
// use the +link{dataBoundComponent.selectionUpdated(),selectionUpdated()} event instead.
//
// @param   record  (ListGridRecord)    record for which selection changed
// @param   state   (boolean)   New selection state (true for selected, false for unselected)
// @group selection
// @visibility external
// @example multipleSelect
//<


selectionChanged : function () {
},

// selectionUpdated is defined in DBC - include documentation for it
//> @method listGrid.selectionUpdated()
// @include dataBoundComponent.selectionUpdated()
// @visibility external
//<

getSerializeableFields : function (removeFields, keepFields) {
    removeFields = removeFields || [];
    removeFields.addList(["header", "selection"]);

    return this.Super("getSerializeableFields", [removeFields, keepFields], arguments);
},

// Frozen Fields / Frozen Columns
// ---------------------------------------------------------------------------------------

// detect frozen fields and reorder the fields array to place frozen fields first, also
// establishing this.frozenFields vs this.normalFields.
// Called by deriveVisibleFields(), which in turn is called by setFields and in other
// circumstances where the set of visible fields has changed or been reordered.
// this.fields is assumed to contain only visible fields.
deriveFrozenFields : function () {

    // detect frozen fields
    var frozenFields = this.frozenFields = this.fields.findAll("frozen", true),
        autoFreezeFields = this.fields.findAll("autoFreeze", true),
        autoFrozenFields = this.fields.findAll("__autoFrozen", true)
    ;

    // if all frozen fields were __autoFrozen, unfreeze them all now
    if (frozenFields && autoFrozenFields && frozenFields.length == autoFrozenFields.length) {
        for (var i=0; i<autoFrozenFields.length; i++) {
            var field = autoFrozenFields[i];
            field.frozen = false;
            delete field.__autoFrozen;
        }
        frozenFields = this.frozenFields = null;
    }

    var allFrozenFields = this.completeFields.findAll("frozen", true);

    // Exception - disallow having all frozen fields and no 'unfrozen' fields
    // Our code doesn't currently handle this and it's not clear what the expected behavior would
    // be!
    if (frozenFields && frozenFields.length == this.fields.length) {
        frozenFields = this.frozenFields = null;
        // setting this flag lets us know that if we show additional, unfrozen fields
        // we'll have to do a rebuild to properly "freeze" the frozen fields!
        
        this._suppressedFrozenFields = true;
    } else this._suppressedFrozenFields = false;

    if (frozenFields) {
        // freeze any unfrozen autoFreeze: true fields, since other fields are frozen
        if (autoFreezeFields) {
            for (var i=0; i<autoFreezeFields.length; i++) {
                var field = autoFreezeFields[i];
                if (!field.frozen) {
                    field.frozen = true;
                    field.__autoFrozen = true;
                    var pos = field.getAutoFreezePosition ? field.getAutoFreezePosition() :
                            this.freezeStart() ? 0 : this.fields.length,
                        allPos = field.getAutoFreezePosition ? field.getAutoFreezePosition() :
                            this.freezeStart() ? 0 : this.completeFields.length
                    ;
                    frozenFields.addAt(field, pos);
                    allFrozenFields.addAt(field, allPos);
                }
            }
        }

        // reorder the main fields array to put frozen fields on left or right
        this.fields.slideList(frozenFields, this.freezeStart() ? 0 : this.fields.length);
        this.completeFields.slideList(allFrozenFields, this.freezeStart() ? 0 : this.completeFields.length);

        // does not currently work
        this.resizeFieldsInRealTime = false;
    }

    for (var i = 0; i < this.fields.length; i++) {
        var field = this.fields[i];
        // mark all fields with a masterIndex - their index in the master fields Array
        // (listGrid.fields)
        field.masterIndex = i;
    }

    if (frozenFields) {
        // put together the normal fields for the primary body (excludes frozen fields)
        var normalFields = this.normalFields = [];
        for (var i = 0; i < this.fields.length; i++) {
            var field = this.fields[i];
            if (!field.frozen) normalFields.add(field);
        }
    } else this.normalFields = null;

    
},

// rebuild for possible change in frozen fields.  Can be called as an alternative to
// a full setFields() when only the frozenness of fields has changed.  Unlike setFields(), this
// ends inline editing.

_$toggleFrozen:"toggle frozen fields",
rebuildForFreeze : function (forceRebuild) {

    if (!this.body) return; // children have not been created

    // If we're showing a filterEditor, essentially rebuild it for freeze, but without
    // killing the current edit.
    
    if (this.filterEditor) {
        // Note: this also handles shifting the checkboxField (if we're showing one) into the
        // frozen fields block via deriveFrozenFields()
        

        this.filterEditor.deriveVisibleFields();
        this.filterEditor.updateBody(forceRebuild);
        this.filterEditor.remapEditFieldsForFreeze();
        this.filterEditor.layoutChildren(this._$toggleFrozen);
    }
    this.endEditing();

    this.deriveVisibleFields();
    // NOTE: will destroy old header and re-create.  Always happens for any change in fields
    this.updateHeader();

    // will recreate bodies if necessary, otherwise just refresh fields
    this.updateBody(forceRebuild);
    this.layoutChildren(this._$toggleFrozen);

    // If we have a frozen body, the 'getDrawRows()' method delegates to the unfrozen body.
    // Since they're both rendered in a layout we can end up with the frozen body being sized
    // and drawn first, meaning the unfrozen body's getDrawRows() is initially unreliable.
    // Handle this by always doing a single immediate redraw of the frozen body after
    // layoutChildren sizes and renders everything.
    if (this.frozenBody) {
        this.frozenBody.markForRedraw("Recalculating draw area from initial sizing of body");
    }
    // If we're showing a gridSummary row, freeze it as well
    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow.setFields(this.completeFields.duplicate());
        this.summaryRow.rebuildForFreeze(forceRebuild);
        this.summaryRow._recalculateSummaries();
    }

    if (this.showRecordComponents && this.recordComponentPoolingMode == "data") {
        // bodies may have been destroyed, which would orphan recordComponents in "data"
        // pooling mode - if there are any orphaned components, loop over them and re-add any
        // that still have records in the loaded data, removing them from the "orphaned" array
        if (this._orphanedRecordComponents) {
            var comps = isc.getValues(this._orphanedRecordComponents),
                len = comps.length
            ;
            for (var i=len-1; i>=0; i--) {
                var comp = comps[i];
                if (!this.data.contains(comp.embeddedRecord)) continue;
                
                this.addEmbeddedComponent(comp, comp.embeddedRecord);
                delete this._orphanedRecordComponents[comp.ID];
            }
        }
    }
},

//> @method ListGrid.setCanFreezeFields()
// Setter method for +link{ListGrid.canFreezeFields}
// @param canFreeze (boolean) New value for <code>listGrid.canFreezeFields</code>
// @visibility external
//<
setCanFreezeFields : function (canFreeze) {
    this.canFreezeFields = canFreeze;
    delete this._autoDerivedCanFreeze;
},

// refresh the "masterIndex" property on subcomponents that have been created with a copy of
// the fields array
refreshMasterIndex : function () {
    // this.fields may be set before this.body has been built.
    // Ensure the masterIndex property is correct there.
    
    if (this.fields) this._refreshMasterIndexForFields(this.fields);
    if (!this.body) return;

    if (this.header) this._refreshMasterIndexForFields(this.header.getMembers());
    if (this.body) this._refreshMasterIndexForFields(this.body.fields || []);
    if (!this.frozenFields) return;
    if (this.frozenHeader) this._refreshMasterIndexForFields(this.frozenHeader.getMembers());
    if (this.frozenBody) this._refreshMasterIndexForFields(this.frozenBody.fields);

},
_refreshMasterIndexForFields : function (fields) {
    for (var i = 0; i < fields.length; i++) {
        fields[i].masterIndex = this.fields.findIndex("name", fields[i].name);
    }
},

getFreezeOn : function () {
    return (this.freezeOn != null ? this.freezeOn : (this.isRTL() ? "right" : "left"));
},

// Whether frozen columns are on the left or right
freezeLeft : function () {
    return this.getFreezeOn() == "left";
},

// whether frozen columns are at the start or end (before or after the unfrozen body)
freezeStart : function () {
    if (this.isRTL()) {
        return this.getFreezeOn() == "right";
    } else {
        return this.getFreezeOn() == "left";
    }
},

getLeftBody : function () {
    var freezeLeft = this.freezeLeft()
    return this.frozenFields && freezeLeft ? this.frozenBody : this.body;
},

getRightBody : function () {
    var freezeLeft = this.freezeLeft();
    return this.frozenFields && !freezeLeft ? this.frozenBody : this.body;
},

setFreezeOn : function (side) {
    var oldSide = this.get
    this.freezeOn = side;
    if (side != oldSide) this.rebuildForFreeze(true);
},

// given an Array, return a subArray of just the slots corresponding to the frozen fields
// (getFrozenSlots) or unfrozen fields (getUnfrozenSlots).  Can be used on an Array of fields,
// or an Array containing any other value that corresponds 1 to 1 with the fields, such as
// field sizes
getFrozenSlots : function (array) {
    var frozenFields = this.frozenFields;
    if (!frozenFields) return array;
    return this.freezeStart() ? array.slice(0, frozenFields.length) :
                               array.slice(array.length - frozenFields.length);
},
getUnfrozenSlots : function (array) {
    var frozenFields = this.frozenFields;
    if (!frozenFields) return array;
    return this.freezeStart() ? array.slice(frozenFields.length) :
                               array.slice(0, array.length - frozenFields.length);
},

fieldIsFrozen : function (colNum) {
    // This can happen even if field.frozen is true - see _suppressedFrozenFields
    if (!this.frozenFields) return false;

    var field = this.getField(colNum);
    return field && !!field.frozen;
},

// frozen fields column numbering:
// - frozen fields do appear in this.fields, always first or last depending on which side the
//   frozen body appears on
// - both header buttons and the fields passed to the body/frozenBody have a masterIndex
//   property indicating their index in this.fields
// - events coming from either body will have a colNum that matches the index in this.fields.
//   This is done via remapping the colNum in makeBodyMethods
// - if you have a colNum with respect to this.fields:
//   - getFieldBody()/getFieldHeader() will give you the body (GR instance) or header (Toolbar
//     instance) where that column appears
//   - getLocalFieldNum() will give you the field/column number within that component

// return the "body" where a column is rendered
getFieldBody : function (colNum) {
    if (!this.frozenFields) return this.body;
    return this.fieldIsFrozen(colNum) ? this.frozenBody : this.body;
},

// return the "header" where a column is rendered
getFieldHeader : function (colNum) {
    if (!this.frozenFields) return this.header;
    return this.fieldIsFrozen(colNum) ? this.frozenHeader : this.header;
},

getFieldHeaderButton : function (fieldNum) {
     // getFieldHeader / getLocalFieldNum will account for frozen fields
    var header = this.getFieldHeader(fieldNum);
    return header ? header.getMember(this.getLocalFieldNum(fieldNum)) : null;
},

// given a colNum, return the index for that column in the body or header where it appears
// (Takes a numeric colNum - not a string or field object)
getLocalFieldNum : function (colNum) {
    // For a null colNum just return null.
    
    if (colNum == null) return null;

    // when printing the body fields array gets out of sync with that of the listGrid
    // so we directly pull out any shouldPrint:false fields until printing is complete.
    // We need to handle this otherwise we'd end up returning the wrong colNum - this can lead to
    // JS errors with our complex logic to fire passthrough / passback methods as we end up
    // unable to find fields.
    if (this.body && this.body.isPrinting) {
        var field = this.fields[colNum];
        if (!this._suppressedFrozenFields && field.frozen && this.frozenBody) {
            return this.frozenBody.fields.indexOf(field);
        } else {
            return this.body.fields.indexOf(field);
        }
    }
    if (!this.frozenFields) return colNum;

    var offset;
    
    offset = this.frozenFields.length;
    
    // if column is in main body, subtract number of frozen fields if fields are frozen on left
    if (!this.fieldIsFrozen(colNum)) return colNum - offset;

    // otherwise, column is in frozen body.
    return this.freezeStart() ? colNum
                             : colNum - (this.fields.length - this.frozenFields.length);
},

// given a colNum within the body / frozen body, return the 'fieldNum' in our fields array
getFieldNumFromLocal : function (localColNum, body) {
    if (localColNum == null) return null;

    // if we're printing, shouldPrint:false fields will have been pulled out of the body
    // so we need to adjust for that.
    if (this.isPrinting) {
        var bodyFields = this.frozenFields != null ?
                            (body == this.frozenBody ? this.frozenFields : this.unfrozenFields) :
                            this.fields;
        var localField = body.fields[localColNum];
        for (var i = 0; i < bodyFields.length; i++) {
            if (bodyFields[i].name == localField.name) break;
            if (bodyFields[i].shouldPrint == false) localColNum++;
        }

    }

    if (!this.frozenFields) return localColNum;

    if (body == this.frozenBody) {
        if (this.freezeStart()) return localColNum;
        else {
            var unfrozen = this.fields.length - this.frozenFields.length;
            return localColNum + unfrozen;
        }
    } else {
        var offset = this.freezeStart() ? this.frozenFields.length : 0;
        return localColNum + offset;
    }
},

// map various methods through to the appropriate body.
// if this set continues to grow, we may want to take a code generation approach instead

//> @method ListGrid.getColumnLeft() ([A])
// Return the left offset (in local coordinate space) of a particular column.
// @param colNum (Integer) number of the column
// @return (Integer) left offset of the passed colNum, or null if not yet drawn or no such column
// @group sizing, positioning
// @visibility external
//<
getColumnLeft : function (colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getColumnLeft(this.getLocalFieldNum(colNum));
},

//> @method ListGrid.getColumnPageLeft() ([A])
// Return the left coordinate for a given column number as a GLOBAL coordinate
// @param colNum (Integer) number of the column
// @return (Integer) page left offset of the passed colNum, or null if undrawn or no such column
// @group sizing, positioning
// @visibility external
//<
getColumnPageLeft : function (colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getColumnPageLeft(this.getLocalFieldNum(colNum));
},

//> @method ListGrid.getColumnWidth() ([A])
// Return the width of a particular column.
// @param colNum (number) number of the column
// @return (Integer) width of the column, or <code>null</code> if undrawn or no such column.
// @group sizing, positioning
// @visibility external
//<
getColumnWidth : function (colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getColumnWidth(this.getLocalFieldNum(colNum));
},

//> @method ListGrid.getCellPageRect() ([A])
// Returns the page offsets and size of the cell at the passed row and column.  If auto-sizing
// is enabled, sizes are not definitive until the grid has finished drawing, so calling this
// method before drawing completes will return the configured column sizes.
// @param rowNum (number) row index of the cell
// @param colNum (number) column index of the cell
// @return (Array of Integer) the page rect of the passed cell, or null if undrawn
// @group sizing, positioning
// @visibility external
//<
getCellPageRect : function (rowNum, colNum) {
    var body = this.getFieldBody(colNum);
    if (!body) return null;
    return body.getCellPageRect(rowNum, this.getLocalFieldNum(colNum));
},

refreshCellStyle : function (rowNum, colNum, className) {
    var body = this.getFieldBody(colNum);
    return body.refreshCellStyle(rowNum, this.getLocalFieldNum(colNum), className);
},

//> @method listGrid.freezeField()
// Freeze the indicated field, so that it remains in place and visible when horizontal
// scrolling occurs.
//
// @param field (ListGridField | Integer | String | Array) field or fields to freeze.
//  fields may be specified as ListGridField objects, field names or colNum.
// @group frozenFields
// @visibility external
//<
freezeField : function (field) {
    return this.toggleFrozen(field, true);
},

//> @method listGrid.unfreezeField()
// Unfreeze a frozen field, so that it will now scroll along with other fields when horizontal
// scrolling occurs.
//
// @param field (ListGridField | Integer | String | Array) field or fields to unfreeze.
//  fields may be specified as ListGridField objects, field names or colNum.
// @group frozenFields
// @visibility external
//<
unfreezeField : function (field) {
    return this.toggleFrozen(field, false);
},

//> @method listGrid.toggleFrozen()
// Freeze or unfreeze the indicated field according to whether it is currently frozen.
// <P>
// Called when the ListGrid freezes or unfreezes fields by user action.
//
// @param field (ListGridField | Integer | String | Array) field or fields to freeze.
//  fields may be specified as ListGridField objects, field names or colNum.
// @group frozenFields
// @visibility external
//<
// isFrozen parameter undocumented - developer would typically call freezeField or unfreezeField
// directly
toggleFrozen : function (field, isFrozen) {
    if (!isc.isAn.Array(field)) field = [field];
    var changed = false;
    for (var i = 0; i < field.length; i++) {
        var currentField = this.getField(field[i]);
        if (!currentField || !this.fieldIsVisible(currentField) ||
            this.isCheckboxField(currentField))
        {
            continue;
        }
        var shouldFreeze = isFrozen;
        if (shouldFreeze == null) shouldFreeze = !currentField.frozen;
        if (currentField.frozen == isFrozen) continue; // field frozenness did not change

        changed = true;
        currentField.frozen = shouldFreeze;
    }

    if (!changed) return false;

    this.rebuildForFreeze();
    // Note: rebuildForFreeze will ultimately call updateBody() which
    // remaps any embedded components to the appropriate colNum based on field name.

    // re-select the sort-button as necessary
    this.selectSortFieldHeaderButton();

    this.handleFieldStateChanged(true);

    return true; // field frozenness changed
},

// Body
// --------------------------------------------------------------------------------------------

// update the body for a change in fields
updateBody : function (forceRebuild) {
    // if frozen fields are being introduced or going away entirely, recreate the body[s] and
    // bodyLayout.  Otherwise, just refresh the fields array being used by each body.

    if (forceRebuild ||
        (this.frozenFields && !this.frozenBody) ||
        (this.frozenBody && !this.frozenFields))
    {
        forceRebuild = true;
        // We're going to destroy the current body or bodies. Drop all recordComponents first
        // so we don't get confused by pointers to destroyed recordComponents.
        this.dropRecordComponents();

        

        if (this.body) {
            // Un-embed and Destroy all embedded components.
            
            this._destroyEmbeddedComponentsForRebuild();
        }

        // frozen body being introduced or going away, or freeze side changing
        if (this.bodyLayout) this.bodyLayout.destroy();
        else if (this.body)  this.body.destroy();
        this.body = this.bodyLayout = this.frozenBody = null;
        this.createBodies();
    }

    // If we've already run through "createChildren" we need to explicitly add the
    // body as a member now.
    // Calling code will handle calling "layoutChildren" which'll ensure the fieldWidths are
    // correct, etc.
    if (this.isDrawn()) {
        this.updateGridComponents();
    }
    if (this.body) {
        this.body.fields = this.normalFields || this.fields;
        
        this.body._clearCellValueCache();
        if (!forceRebuild) this._remapEmbeddedComponentColumns(this.body);
        this.body.markForRedraw("fields change");
    }
    if (this.frozenBody) {
        this.frozenBody.fields = this.frozenFields;
        this.frozenBody._clearCellValueCache();
        if (!forceRebuild) this._remapEmbeddedComponentColumns(this.frozenBody);
        this.frozenBody.markForRedraw("fields change");
        if (this.canSelectCells) this._updateDependentSelections();
    }
},




// In various circumstances we automatically un-embed embedded components.
// - rebuilding bodies for freeze / unfreeze
// - data change such that an embedded components' record is no longer present in the
//   data set
// - field visibility changes to show/hide cells containing components.
// Should we auto-destroy components when this occurs?

shouldDestroyOnUnembed : function (embeddedComponent, reason) {

    // Respect 'dontAutoDestroy' on embedded components. We explicitly doc this for recordComponent
    // usage
    if (embeddedComponent.dontAutoDestroy) return false;

    if (embeddedComponent.isBackgroundComponent) {
        // if we created the backgroundComponent for some record, and the record has now
        // been lost from our data-set, drop it
        if (reason == this._$dataChanged && embeddedComponent.creator == this) return true;
        // Otherwise keep it around (either the developer explicitly created the canvas,
        // or we are simply changing fields / rebuilding for freeze but still have the
        // data around).
        return false;
    }

    if (embeddedComponent.isRecordComponent) {
        if (reason == this._$dataChanged) return true;
        return false;
    }

    if (embeddedComponent.destroyOnUnembed != null) return embeddedComponent.destroyOnUnembed;

    // Keep components around if we just changed columns, otherwise destroy
    if (reason == this._$columnRemap) return false;
    return true;
},

// Used by updateBody - when we rebuild the entire body we just wipe out all embedded
// components.
_$rebuildingBody:"rebuilding body",
_destroyEmbeddedComponentsForRebuild : function () {
    var components = this.body._embeddedComponents;
    if (this.frozenBody) {
        var allComponents = [];
        if (components == null) components = allComponents;
        else components = allComponents.addList(components);
        components.addList(this.frozenBody._embeddedComponents || []);
    }

    if (components && components.length > 0) {
        for (var i=0; i<components.length; i++) {
            var record = components[i] && components[i].embeddedRecord,
                shouldCollapse = false,
                embeddedComponents = this._getEmbeddedComponents(record)
            ;
            if (embeddedComponents.length > 0) {
                for (var j=0; j<embeddedComponents.length; j++) {
                    var component = embeddedComponents[j];
                    if (!component || component.destroying || component.destroyed) continue;
                    shouldCollapse = shouldCollapse || component.isExpansionComponent;

                    if (this.shouldDestroyOnUnembed(component, this._$rebuildingBody)) {
                        component.markForDestroy();
                    } else {
                        component.deparent();
                    }
                }
                this._setEmbeddedComponents(record, null);
                if (shouldCollapse) this._setExpanded(record, false);
                this._deleteEmbeddedComponents(record);
            }
        }
    }
},

createBodies : function () {
    if (this.body != null) return; // already created

    // Update virtual scrolling based on showRecordComponents()
    
    this._updateVirtualScrollingForRecordComponents();

    // create the primary body and add it as a child
    this.body = this.createBody(this.ID + "_body", this.normalFields || this.fields);
    this.body.setLocatorParent(this, "body");
    

    // We explicitly mark as canFocus:false, then ask the body for its canFocus state
    this._updateCanFocus();
    
    if (this._editorShowing) {
        this.updateEditFormTabPosition();
    }

    
    // unless gridComponents is customized, the header and sorter button are created before the
    // body. Because the sorter button width may depend on the body's scrollbar size, if the
    // sorter button exists, recompute its width.
    if (this.sorter != null) {
        this.sorter.setWidth(this._getSorterWidth(true));
    }

    this.body.resizeTo("100%", "100%");

    this.bodies = [this.body];

    // drag scrolling should target the body
    this.dragScrollTarget = this.body;

    var frozenFields = this.frozenFields;
    if (frozenFields == null || frozenFields.length == 0) {
        return this.body;
    }

    this.body.addProperties({
        _getViewportFillRows : function (a, b, c) {
            // the frozen body may report an additional row if the normal body is showing an
            // h-scrollbar - check for that and increment the endRow accordingly
            var frozenRows = [0,0];
            if (!this.frozen && this.grid && this.grid.frozenBody) {
                frozenRows = this.grid.frozenBody._getViewportFillRows(a, b, c);
            }

            var rows = this.Super("_getViewportFillRows", arguments);
            if (frozenRows[1] > rows[1]) rows[1]++;
            return rows;
        }
    });

    this.frozenBody = this.createBody(this.ID + "_freezeBody", frozenFields, true);
    this.frozenBody.setLocatorParent(this, "frozenBody");

    this.frozenBody.useNativeDrag = false;
    this.frozenBody.drawAllMaxCells = 0;
    
    // NOTE: Freezing the fields on the left implies we almost certainly have an HScrollbar
    // for the fields on the right, creating a difference in viewport area
    // Add some space to the bottom of the freeze body to make up this difference in the
    // scrollHeight so when the user scrolls to the bottom the grids stay in sync
    if (this.body.hscrollOn && !this.shrinkForFreeze) {
        this.frozenBody.setEndSpace(this.body.getScrollbarSize());
    }

    if (this.freezeStart()) {
        this.bodies.unshift(this.frozenBody);
    } else {
        this.bodies.add(this.frozenBody);
    }

    this.bodyLayout = this.createAutoChild("bodyLayout", {
        width:"100%", height:"100%",
        autoDraw:false,
        members : this.bodies
    }, isc.HLayout);

    // create separate selection objects for body/frozenBody
    this._separateDependentSelections();
    
},

//> @method listGrid.getBody()
// Returns the primary +link{ListGrid.body,body}, which, when there are frozen fields, is the
// +link{GridRenderer} used to render the non-frozen portion of the dataset; otherwise, the
// primary body (the only body) is the GridRenderer used to render the entire dataset.
// @return (GridRenderer) the primary body or null if this ListGrid has not been drawn yet.
// @visibility external
//<
getBody : function () {
    return this.body;
},

_separateDependentSelections : function () {
    if (this.canSelectCells) {
        var start = this.freezeStart(),
            selection = this.selectionManager,
            normalLength = this.body.fields.length,
            frozenLength = this.frozenBody ? this.frozenBody.fields.length : 0
        ;
              this.body._setSeparateCellSelection(selection, start ? frozenLength : 0);
        this.frozenBody._setSeparateCellSelection(selection, start ? 0 : normalLength);
    }
},

_updateDependentSelections : function () {
    if (!isc.isA.DependentCellSelection(      this.body.selectionManager)||
        !isc.isA.DependentCellSelection(this.frozenBody.selectionManager)) {
            // this.logWarn("ListGrid._updateDependentSelection() called when one or more" +
            //              "GridRenderer bodies are not DependentCellSelections!");
        return;
    }
    var start = this.freezeStart(),
        normalLength = this.body.fields.length,
        frozenLength = this.frozenBody.fields.length
    ;
          this.body.selectionManager._updateDependency(start ? frozenLength : 0, normalLength);
    this.frozenBody.selectionManager._updateDependency(start ? 0 : normalLength, frozenLength);
},

// bodyOverflowed - notification method when adjustOverflow runs on the body
// Updates the endSpace on this.frozenBody if we're showing frozen cells.
bodyOverflowed : function () {
    if (this.summaryRow != null && this.summaryRow.body) {
        this.summaryRow.body.setRightSpace(this.body.vscrollOn ? this.body.getScrollbarSize() : 0);
    }
    if (!this.frozenBody) return;
    this.frozenBody.setEndSpace(this.body.hscrollOn && !this.shrinkForFreeze
                                    ? this.body.getScrollbarSize() : 0);
},

//> @attr listGrid.screenReaderCellSeparator (HTMLString : "/" : IRA)
// Special cell-separator that may be inserted between cell values when screen-readers
// are reading the content of a row. Only applies when screen-reader mode is enabled, and
// for ListGrids with +link{listGrid.ariaRole,ariaRole:"list"}.
// <P>
// When +link{isc.setScreenReaderMode(),screen reader mode} is enabled,
// for ListGrids with +link{ListGrid.ariaRole} set to <code>"list"</code>, each row
// in the grid will be rendered as HTML with role <code>"listItem"</code>.<br>
// In this mode, the <code>screenReaderCellSeparator</code> property, (along with
// +link{screenReaderIncludeFieldTitles} and +link{screenReaderRowSeparator}), 
// gives developers a way to customize how screen readers
// read the row's text value in a way that may be helpful for grids with multiple columns.<br>
// Instead of just picking up the value of each cell in the row strung together, 
// readers will instead pick up the field title, the cell value and then the cellSeparator for
// each cell, and then the rowSeparator to mark the end of the row. Most screenreaders will
// also read the row index and total row count - something like "3 of 20".
// <P>
// <P>
// Note that screen readers vary widely on which punctuation symbols are read aloud, and
// sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA,
// and VoiceOver screen readers all read the forward slash '/' as "slash".
// See +externalLink{http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/,Why Don’t Screen Readers Always Read What’s on the Screen? Part 1: Punctuation and Typographic Symbols}
// for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA,
// and VoiceOver.
// <P>
// Implementation notes: the generated row HTML makes use of the 
// +externalLink{https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute,aria-labelledby}
// property to achieve this - pointing the
// screenReader to the title button for the column, the cell content, and a special hidden
// element containing the cellSeparator.<br>
// Note that this aria-labelledby setting is applied in addition to other aria state specified
// by +link{listGrid.getRowAriaState()}.
// <P>
// To entirely disable this feature, developers may set 
// +link{listGrid.screenReaderWriteRowLabelledBy} to <code>false</code>. In this case other
// row aria attributes will still be picked up from +link{listGrid.getRowAriaState()}, including
// the <code>setsize</code> and <code>posinset</code> attributes that tell the screen reader where
// they currently are in the list.
// <P>
// See +link{listGrid.ariaRole} for more information on the ARIA attributes generated
// by ListGrids.
// 
// @group accessibility
// @visibility external
//<
screenReaderCellSeparator:"/",

//> @attr listGrid.screenReaderRowSeparator (HTMLString : "," : IRA)
// Special row-separator that may be inserted at the end of the row value when screen-readers
// are reading the content of a row. Only applies when screen-reader mode is enabled, and
// for ListGrids with +link{listGrid.ariaRole,ariaRole:"list"}.
// <P>
// See the documentation for +link{listGrid.screenReaderCellSeparator} for details on how
// the header values, cell separators and row separators are picked up by screenreaders
// in this mode.
// <P>
// For more information on the ARIA attributes generated
// by ListGrids, see +link{listGrid.ariaRole}.
// 
// @group accessibility
// @visibility external
//<
screenReaderRowSeparator:",",

//> @attr listGrid.screenReaderIncludeFieldTitles (Boolean : true : IRA)
// Should column titles be read along with cell values when screen-readers
// are reading the content of a row? Only applies when screen-reader mode is enabled, and
// for ListGrids with +link{listGrid.ariaRole,ariaRole:"list"}.
// <P>
// Has no effect if +link{showHeader} is false.
// <P>
// See the documentation for +link{listGrid.screenReaderCellSeparator} for implementation 
// details on how the header values, cell separators and row separators are picked up by screenreaders
// in this mode.
// <P>
// For more information on the ARIA attributes generated
// by ListGrids, see +link{listGrid.ariaRole}.
// 
// @group accessibility
// @visibility external
//<
screenReaderIncludeFieldTitles:true,

//> @attr listGrid.screenReaderWriteRowLabelledBy (Boolean : true : IRA)
// When +link{isc.setScreenReaderMode(),screen reader mode} is enabled, for grids with
// +link{listGrid.ariaRole} set to <code>"list"</code>, should a custom
// +externalLink{https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute,aria-labelledby}
// attribute be written out in addition to any other 
// +link{listGrid.getRowAriaState(),row aria properties} 
// to ensure the +link{screenReaderIncludeFieldTitles,column titles},
// +link{listGrid.screenReaderCellSeparator} and +link{listGrid.screenReaderRowSeparator} are
// read out along with cell content when reading rows?
// <P>
// Setting this property to false will disable the writing out of this <code>labelled-by</code>
// attribute. See the documentation for +link{listGrid.screenReaderCellSeparator} for more on
// how the header values, cell separators and row separators are picked up by screenreaders
// in this mode.
// <P>
// For more information on the ARIA attributes generated
// by ListGrids, see +link{listGrid.ariaRole}.
// 
// @group accessibility
// @visibility external
//<

screenReaderWriteRowLabelledBy:true,

createBody : function (ID, fields, frozen) {
    // create a body object to show the body of the list
    var body = isc.ClassFactory.getClass(this.bodyConstructor, true).createRaw();

    body.ID = ID;
    body.autoDraw = false;

    // Body doc'd as auto-child so set creator for back-reference
    body.creator = this;

    body.grid = this;

    body.fields = fields;

    body.frozen = frozen;

    body.overflow = frozen ? "hidden" : this.bodyOverflow;
    
    if (this.scrollbarConstructor != null) body.scrollbarConstructor = this.scrollbarConstructor;
    if (this.showCustomScrollbars != null) body.showCustomScrollbars = this.showCustomScrollbars;
    if (this.alwaysShowScrollbars != null) body.alwaysShowScrollbars = this.alwaysShowScrollbars;
    
    if (this.useTouchScrolling != null) body.useTouchScrolling = this.useTouchScrolling;
    if (this.scrollbarSize != null) body.scrollbarSize = this.scrollbarSize;

    body.backgroundColor = this.bodyBackgroundColor;
    var bodyStyleName = this.bodyStyleName;
    if (this.alternateBodyStyleName != null && this.alternateRecordStyles) {
        bodyStyleName = this.alternateBodyStyleName;
    }
    body.styleName = bodyStyleName;

    // In order to float widgets above the list, we want to allow contents (the
    // actual table) and children to be drawn for this element.
    body.allowContentAndChildren = true;

    // table geometry (NOTE: record -> row terminology translation)
    
    body.fixedRowHeights = this.fixedRecordHeights;
    body.fixedColumnWidths = this.fixedFieldWidths;
    body.variableRecordHeightFields = this.variableRecordHeightFields;
    body.alternateRowStyles = this.alternateRecordStyles;
    body.alternateRowFrequency = this.alternateRecordFrequency;
    body.alternateRowSuffix = this.alternateRecordSuffix;
    body.alternateColumnStyles = this.alternateFieldStyles;
    body.alternateColumnFrequency = this.alternateFieldFrequency;
    body.alternateColumnSuffix = this.alternateFieldSuffix;
    body.canSelectText = this.canDragSelectText;
    body.showAllRows = this.showAllRecords;
    if (this.virtualScrolling != null) body.virtualScrolling = this.virtualScrolling;

    // if using drag selection, don't give the Grid a dragTarget
    // - the Grid can handle the selection
    // - the ListGrid won't show a dragTracker
    // Otherwise we're doing dragging of records in and out, so have the ListGrid
    // handle the drag event, and show a tracker.
    body.dragTarget = this.canDragSelect ? null : this;
    body.dragAppearance = isc.EventHandler.NONE;

    body.screenReaderCellSeparator = this.screenReaderCellSeparator;
    body.screenReaderRowSeparator = this.screenReaderRowSeparator;

    // To make checkboxField work with singleCellValue
    body.selectionAppearance = this.selectionAppearance;

    // support for defining GridRenderer override functions and properties directly
    // on the LV instead of via LV.body.
    var propNames = isc.ListGrid._gridPassthroughProperties;

    // pass all of these properties straight through
    for (var i = 0; i < propNames.length; i++) {
        var propName = propNames[i],
            value = this[propName];
        if (value != null) body[propName] = value;
    }

    if (this._originalUseNativeTabIndex != null) {
        body._useNativeTabIndex = this._originalUseNativeTabIndex;
    }

    isc.addProperties(body, this.bodyDefaults, this.bodyProperties);

    // suppress empty message on frozen body - only show it in one place!
    if (frozen) body.showEmptyMessage = false;

    body.completeCreation();

    body = isc.SGWTFactory.extractFromConfigBlock(body);

    // add passthroughs from the body to the ListGrid for pluggable body APIs defined on the grid
    // Note that this has to be after extracting the body from the SGWT config block, if any
    this._addBodyPassthroughMethods(body);

    return body;
},


_cellMouseDown : function (record, rowNum, colNum) {
    var field = this.getField(this.getLocalFieldNum(colNum));
    var returnVal;
    if (field.cellMouseDown) {
        if (field.cellMouseDown(this, record, rowNum, colNum) == false) return false;
    }
},

//> @method listGrid.getDrawnRowHeight() ([A])
// Get the drawn height of a row.
//
// @param rowNum (number)
// @return (number) height
// @group sizing, positioning
// @visibility external
//<

//> @method listGrid.getRowHeight()
// Return the height this row should be.  Default is this.cellHeight. If
// +link{listGrid.fixedRecordHeights} is false, the row may be rendered taller than this
// specified size.
// <P>
// If records will be variable height,
// you should switch on +link{listGrid.virtualScrolling, virtualScrolling}.
// <P>
// Note if +link{listGrid.allowRowSpanning,row spanning} is enabled,
// this method should return the height of a single row (with rowSpan set to 1).
//
// @param   record  (ListGridRecord)    cell record as returned by getCellRecord
// @param   rowNum  (number)    row number
// @return  (number)    height in pixels
// @visibility external
//<
// Undocumented 'isFrozenBody' param used by the ListGrid
// Freezing and editing
// By default in edit mode we allow form items to overflow the available space (don't fix the edit
// However if we have frozen fields we can have form items of different heights in the 2 bodies
// leading to a mismatch.
// Catch this if we can by applying an explicit min-height matching the space that will be
// required by the edit items (for efficiency only run this logic if we have to)
getRowHeight : function (record,rowNum,isFrozenBody) {
    var cellHeight;
    
    if (this.allowRowSpanning && this.getRowSpan) {
        // This code makes an assumption that rowSpanning will never increase going from
        // left to right, and you'll always have at least one column with rowSpan set to 1.
        // If we don't make this assumption we'll have to call the getRowSpan method for
        // every column on both bodies to figure out what the minimum rowSpan for each
        // gridRenderer instance is which won't scale well (code to do this included, can
        // be enabled via an undocumented flag).
        if (!this.allowIncreasingRowSpanning) {
            if (isFrozenBody) {
                cellHeight = this.cellHeight
                    * this.frozenBody._getRowSpan(record, rowNum, this.frozenFields.length-1);
            } else {
                cellHeight = this.cellHeight;
            }

        } else {
            var minRowSpan,
                body = isFrozenBody ? this.frozenBody : this.body,
                startField = isFrozenBody ? 0 :
                            (this.frozenFields ? this.frozenFields.length : 0),
                endField = isFrozenBody ? this.frozenFields.length : this.fields.length;

            for (var i = startField; i < endField; i++) {
                if (minRowSpan == null) {
                    // calling the internal version of the method which will round
                    // off if the rowSpan exceeds the number of rows
                    minRowSpan = body._getRowSpan(record, rowNum, i);
                } else {
                    minRowSpan = Math.min(minRowSpan, body._getRowSpan(record, rowNum, i));
                }
                if (minRowSpan == 1) break;
            }
            cellHeight = this.cellHeight * minRowSpan;
        }
    } else {
        cellHeight = this.cellHeight;
    }

//    this.logWarn("getRowHeight called at row: " + rowNum +
//                 " body is: " + (isFrozenBody ? "frozen" : "unfrozen") +
//                 " returning: " + cellHeight);

    if (this.frozenFields && this.getEditRow() == rowNum) {
        var editForm = this.getEditForm(),
            items = editForm ? editForm.getItems() : [];
        for (var i = 0; i < items.length; i++) {
            var itemHeight = (items[i].getHeight() + 2*this.cellPadding);
            if (itemHeight > cellHeight) cellHeight = itemHeight;
        }
    }
    return this.body.updateHeightForEmbeddedComponents(record, rowNum, cellHeight);
},

// Selection / Rollover effects
// ---------------------------------------------------------------------------------------

selectionCanvasDefaults: {
    
    _constructor: "SelectionOrRollOverCanvas",
    opacity: 20,
    overflow:"hidden"
},

selectionUnderCanvasDefaults: {
},

makeSelectionCanvas : function (record) {
    
    return this.selectionCanvas = this.createAutoChild("selectionCanvas",
        {
            eventProxy:this.body,
            snapTo:"TL",
            width:"100%", height:"100%",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            percentSource:this, percentBox:"custom",
            grid:this,
            autoDraw:false
        }
    );
},

makeSelectionUnderCanvas : function (record) {
    
    return this.selectionUnderCanvas = this.createAutoChild("selectionUnderCanvas",
        {
            eventProxy:this.body,
            snapTo:"TL",
            width:"100%", height:"100%",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            percentSource:this, percentBox:"custom",
            grid:this,
            autoDraw:false
        }
    );
},

getSelectionCanvas : function () {
    var selectionCanvas = this.selectionCanvas;
    if (selectionCanvas == null || selectionCanvas.destroyed) {
        selectionCanvas = this.makeSelectionCanvas();
    }
    return selectionCanvas;
},

getSelectionUnderCanvas : function () {
    var selectionUnderCanvas = this.selectionUnderCanvas;
    if (selectionUnderCanvas == null || selectionUnderCanvas.destroyed) {
        selectionUnderCanvas = this.makeSelectionUnderCanvas();
    }
    return selectionUnderCanvas;
},

updateSelectionCanvas : function () {
    var selection = this.selectionManager,
        rowNum,
        colNum,
        record;
    if (isc.isA.CellSelection(selection)) {
        var cell = selection.getSelectedCells()[0];
        rowNum = cell ? cell[0] : -1,
        colNum = cell ? cell[1] : -1;
        record = cell ? this.getCellRecord(rowNum,colNum) : null;
    } else {
        record = this.getSelectedRecord();
        rowNum = this.data ? this.data.indexOf(record) : -1;
    }

    var selectionCanvas = this.selectionCanvas,
        selectionUnderCanvas = this.selectionUnderCanvas,
        refSelectionCanvas = selectionCanvas || selectionUnderCanvas,
        currentRecord,
        currentRowNum,
        currentColNum;
    if (refSelectionCanvas != null) {
        currentRecord = refSelectionCanvas.embeddedRecord;
        currentRowNum = refSelectionCanvas._currentRowNum;
        currentColNum = refSelectionCanvas._currentColNum;
        
    } else {
        currentRecord = null;
        currentRowNum = -1;
        currentColNum = -1;
    }

    // nothing to do if we don't have a selection canvas or a selection, OR
    // we have a selectionCanvas already assigned to the selected record
    var showSelectionOrSelectionUnderCanvas = this.showSelectionCanvas || this.showSelectionUnderCanvas;
    if (refSelectionCanvas == null) {
        if (record == null || !showSelectionOrSelectionUnderCanvas) return;
    } else if (showSelectionOrSelectionUnderCanvas &&
               currentRecord == record &&
               currentRowNum == rowNum &&
               currentColNum == colNum)
    {
        return;
    }

    if (showSelectionOrSelectionUnderCanvas && this.selectionType != isc.Selection.SINGLE &&
        this.selectionType != isc.Selection.NONE)
    {
        this.logWarn((this.showSelectionCanvas
                      ? (this.showSelectionUnderCanvas
                         ? "showSelectionCanvas and showSelectionUnderCanvas are"
                         : "showSelectionCanvas is")
                      : "showSelectionUnderCanvas is") +
                     " set to true, but this is not supported for selectionType " +
                     this.selectionType);
        this.showSelectionCanvas = false;
        this.showSelectionUnderCanvas = false;
        showSelectionOrSelectionUnderCanvas = false;
    }

    // If we're not showing the row, or we have no selection,
    // ensure the selectionCanvas is hidden and bail.
    if (!record || rowNum == -1 || !showSelectionOrSelectionUnderCanvas) {
        if (selectionCanvas != null) {
            this.removeEmbeddedComponent(currentRecord, selectionCanvas);
        }
        if (selectionUnderCanvas != null) {
            this.removeEmbeddedComponent(currentRecord, selectionUnderCanvas);
        }
        return;
    }

    // calling the getters will create the selectionCanvas / selectionUnderCanvas if necessary
    if (this.showSelectionCanvas) {
        selectionCanvas = this.getSelectionCanvas();
        
        selectionCanvas.record = record;
        selectionCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(selectionCanvas, record, rowNum, colNum, "within");
    }
    if ((this.showSelectionCanvas && this.showSelectionUnderCanvas == null) ||
        this.showSelectionUnderCanvas)
    {
        selectionUnderCanvas = this.getSelectionUnderCanvas();
        
        selectionUnderCanvas.record = record;
        selectionUnderCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(selectionUnderCanvas, record, rowNum, colNum, "within");
    }
},

// Roll Over Canvas


rollOverCanvasDefaults: {
    
    _constructor: "SelectionOrRollOverCanvas",
    
    contents: isc.Browser.isChrome ? "<span></span>" : isc.nbsp,
    snapTo: "TL",
    width: "100%",
    height: "100%",
    overflow:"hidden",
    // used by Canvas._adjustSpecialPeers() - this widget floats relative to the grid but isn't
    // an actual child of it
    skipModalCheck: true
},

rollUnderCanvasDefaults: {
    snapTo: "TL",
    width: "100%",
    height: "100%",
    overflow:"hidden",
    // used by Canvas._adjustSpecialPeers() - this widget floats relative to the grid but isn't
    // an actual child of it
    skipModalCheck: true
},

// Internal method to create the rollOver canvas using the autoChild subsystem
makeRollOverCanvas : function (frozen) {
    
    var canvas = this.createAutoChild("rollOverCanvas",
        {   eventProxy:frozen ? this.frozenBody : this.body,
            percentSource:this, percentBox:"custom",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            grid:this,
            autoDraw:false
        }
    );

    if (frozen) this.frozenRollOverCanvas = canvas;
    else this.rollOverCanvas = canvas;

    return canvas;
},

makeRollUnderCanvas : function (frozen) {
    
    
    var canvas = this.createAutoChild("rollUnderCanvas",
        {
            eventProxy:frozen ? this.frozenBody : this.body,
            percentSource:this, percentBox:"custom",
            bubbleMouseEvents:true,
            destroyOnUnEmbed:false,
            grid:this,
            autoDraw:false
        }
    );
    if (frozen) this.frozenRollUnderCanvas = canvas;
    else this.rollUnderCanvas = canvas;

    return canvas;
},

//> @method listGrid.getRollOverCanvas()
// This method is called to retrieve the +link{rollOverCanvas} when
// the user moves over a new row or cell if +link{listGrid.showRollOverCanvas} is true,
// or when the user moves over the selected record if +link{listGrid.showSelectedRollOverCanvas} 
// is true.
// <P>
// The default implementation uses the +link{AutoChild} subystem to create the +link{rollOverCanvas}
// auto child. It may be overridden for custom behavior.
// <P>
// Note that for efficiency this should not typically create a new Canvas every time that it is
// called. Instead usually a single rollOver canvas should be created and updated to reflect
// the current rollOver row if necessary.
// <p>
// Return null to avoid showing a <code>rollOverCanvas</code> for this row.
// <P>
// See also +link{listGrid.getFrozenRollOverCanvas()}.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param rowNum (Integer) index of the current rollOver row.
// @param colNum (Integer) index of the current rollOver column. This parameter will be null unless
// +link{useCellRollOvers,useCellRollOvers} is true for the grid.
// @return (Canvas) the embedded component
// @group hoverComponents
// @visibility external
//<
getRollOverCanvas : function (rowNum, colNum) {
    var rollOverCanvas = this.rollOverCanvas;
    if (rollOverCanvas == null || rollOverCanvas.destroyed) {
        rollOverCanvas = this.makeRollOverCanvas(false);
    }
    return rollOverCanvas;
},

//> @method listGrid.getFrozenRollOverCanvas()
// For grids with frozen columns, this method is called to retrieve the 
// +link{frozenRollOverCanvas} when
// the user moves over a new row or cell if +link{listGrid.showRollOverCanvas} is true,
// or when the user moves over the selected record if +link{listGrid.showSelectedRollOverCanvas} 
// is true.
// <P>
// The default implementation uses the +link{AutoChild} subystem to create the +link{frozenRollOverCanvas}
// based on the <code>rollOverCanvas</code> auto child settings. 
// It may be overridden for custom behavior.
// <P>
// Note that for efficiency this should not typically create a new Canvas every time that it is
// called. Instead usually a single rollOver canvas should be created and updated to reflect
// the current rollOver row if necessary.
// <p>
// Return null to avoid showing a <code>rollOverCanvas</code> for this row.
// <P>
// See also +link{listGrid.getRollOverCanvas()}.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param rowNum (Integer) index of the current rollOver row.
// @param colNum (Integer) index of the current rollOver column. This parameter will be null unless
// +link{useCellRollOvers,useCellRollOvers} is true for the grid.
// @return (Canvas) the embedded component
// @group hoverComponents
// @visibility external
//<
getFrozenRollOverCanvas : function (rowNum, colNum) {
    var rollOverCanvas = this.frozenRollOverCanvas;
    if (rollOverCanvas == null || rollOverCanvas.destroyed) {
        rollOverCanvas = this.makeRollOverCanvas(true);
    }
    return rollOverCanvas;
},

//> @method listGrid.getRollUnderCanvas()
// This method is called to retrieve the +link{rollUnderCanvas} when
// the user moves over a new row or cell if 
// +link{listGrid.showRollUnderCanvas,showing a rollUnder canvas} or showing a
// +link{listGrid.showSelectedRollUnderCanvas,rollUnder canvas for the selected record}.
// <P>
// The default implementation uses the +link{AutoChild} subystem to create the +link{rollUnderCanvas}
// auto child. It may be overridden for custom behavior.
// <P>
// Note that for efficiency this should not typically create a new Canvas every time that it is
// called. Instead usually a single rollOver canvas should be created and updated to reflect
// the current rollOver row if necessary.
// <p>
// Return null to avoid showing a <code>rollUnderCanvas</code> for this row.
// <P>
// See also +link{listGrid.getFrozenRollUnderCanvas()}.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param rowNum (Integer) index of the current rollOver row.
// @param colNum (Integer) index of the current rollOver column. This parameter will be null unless
// +link{useCellRollOvers,useCellRollOvers} is true for the grid.
// @return (Canvas) the embedded component
// @group hoverComponents
// @visibility external
//<
getRollUnderCanvas : function (rowNum, colNum) {
    var rollUnderCanvas = this.rollUnderCanvas;
    if (rollUnderCanvas == null || rollUnderCanvas.destroyed) {
        rollUnderCanvas = this.makeRollUnderCanvas(false);
    }
    return rollUnderCanvas;
},

//> @method listGrid.getFrozenRollUnderCanvas()
// For grids with frozen columns, this method is called to retrieve the 
// +link{frozenRollUnderCanvas} when
// +link{listGrid.showRollUnderCanvas,showing a rollUnder canvas} or showing a
// +link{listGrid.showSelectedRollUnderCanvas,rollUnder canvas for the selected record}.
// <P>
// The default implementation uses the +link{AutoChild} subystem to create the +link{rollUnderCanvas}
// auto child. It may be overridden for custom behavior.
// <P>
// Note that for efficiency this should not typically create a new Canvas every time that it is
// called. Instead usually a single rollOver canvas should be created and updated to reflect
// the current rollOver row if necessary.
// <p>
// Return null to avoid showing a <code>rollUnderCanvas</code> for frozen fields for this row.
// <P>
// See also +link{listGrid.getRollUnderCanvas()}.
// <smartgwt><p>
// <b>Note: This is an override point.</b></smartgwt>
//
// @param rowNum (Integer) index of the current rollOver row.
// @param colNum (Integer) index of the current rollOver column. This parameter will be null unless
// +link{useCellRollOvers,useCellRollOvers} is true for the grid.
// @return (Canvas) the embedded component
// @group hoverComponents
// @visibility external
//<
getFrozenRollUnderCanvas : function (rowNum, colNum) {
    var rollUnderCanvas = this.frozenRollUnderCanvas;
    if (rollUnderCanvas == null || rollUnderCanvas.destroyed) {
        rollUnderCanvas = this.makeRollUnderCanvas(true);
    }
    return rollUnderCanvas;
},

updateRollOverCanvas : function (rowNum, colNum, leaving) {
    //this.logWarn("UpdateRollOverCanvas running:" + [rowNum, colNum,leaving]);

    var removeOnly = false;
    var record;
    
    if (leaving || 
        // none of the 'showROC' options are enabled
        (!this.showSelectedRollOverCanvas && !this.showSelectedRollOverCanvas) && 
        (!this.showRollOverCanvas && !this.showRollUnderCanvas) || 
        
        rowNum == null || rowNum == -1) 
    {
        removeOnly = true;
    } else {
        record = this.getCellRecord(rowNum, colNum);
        
        if (record == null || Array.isLoading(record)) {
            removeOnly = true;
        } else {
            
            var selection = this.selectionManager,
                isSelected = isc.isA.CellSelection(selection) ?
                    selection.isSelected(rowNum, colNum) :
                    selection.isSelected(record, rowNum, true)
            ;
            // If we're only showing the selected-over canvas check for the record being selected
            if (!this.showRollOverCanvas && !this.showRollUnderCanvas && !isSelected) {
                removeOnly = true;
            }
        }
    }
    if (removeOnly) {
        var ROCs = [
            this.currentRollOverCanvas, 
            this.currentRollUnderCanvas, 
            this.currentFrozenRollOverCanvas, 
            this.currentFrozenRollUnderCanvas
        ];
        
        for (var i = 0; i < ROCs.length; i++) {
            var ROC = ROCs[i];
            if (ROC && !ROC.destroying && !ROC.destroyed) {
                this.removeEmbeddedComponent(ROC.embeddedRecord, ROC);
            }
        }
        return;
    }

    
    
    if (!this.useCellRollOvers) {
        colNum = null;
    }

    // Assume we will never be called if the rowNum / colNum hasn't changed since we already
    // have a check for this in GR.mouseMove
    
    
    // Duplicate all this logic for the frozen rollOver/rollUnder canvas.
    
    
    // Are we (potentially) showing roll-over for frozen body, unfrozen body or both?
    var showFrozen, showUnfrozen;
    
    if (colNum != null) {
        var isFrozenCol = this.fieldIsFrozen(colNum);
        showFrozen = isFrozenCol;
        showUnfrozen = !showFrozen;
    } else {    
        showFrozen = this.frozenFields && this.frozenFields.length > 0;
        showUnfrozen = true;
    }

    var oldRollOverCanvas = this.currentRollOverCanvas,
        oldRollUnderCanvas = this.currentRollUnderCanvas,
        // If we have frozen fields, the same:
        oldFrozenRollOverCanvas = this.currentFrozenRollOverCanvas,
        oldFrozenRollUnderCanvas = this.currentFrozenRollUnderCanvas;
        
    var rollOverCanvas = null,
        frozenRollOverCanvas = null;
    if (this.showRollOverCanvas || (this.showSelectedRollOverCanvas && isSelected)) {
        if (showUnfrozen) {
            rollOverCanvas = this.getRollOverCanvas(rowNum, colNum);
        }
        if (showFrozen) {
            frozenRollOverCanvas = this.getFrozenRollOverCanvas(rowNum, colNum);
        }
    }
    
    this.currentRollOverCanvas = rollOverCanvas;
    this.currentFrozenRollOverCanvas = frozenRollOverCanvas;
    
    var rollUnderCanvas = null,
        frozenRollUnderCanvas = null;
    if ((this.showRollOverCanvas && this.showRollUnderCanvas == null) ||
        this.showRollUnderCanvas  ||
        (isSelected &&
            ((this.showSelectedRollOverCanvas && this.showSelectedRollUnderCanvas == null) ||
             this.showSelectedRollUnderCanvas)
        )
       )
    {
        if (showUnfrozen) {
            rollUnderCanvas = this.getRollUnderCanvas(rowNum, colNum);
        }
        if (showFrozen) {
            frozenRollUnderCanvas = this.getFrozenRollUnderCanvas(rowNum, colNum);
        }
    }
    this.currentRollUnderCanvas = rollUnderCanvas;
    this.currentFrozenRollUnderCanvas = frozenRollUnderCanvas;

    if (rollOverCanvas != null) {
        rollOverCanvas.grid = this;
        rollOverCanvas.record = record;
        rollOverCanvas.removeOnHideField = true;
        rollOverCanvas.sizeWithExpansion = this.showRollOverInExpansion;
        this.addEmbeddedComponent(rollOverCanvas, record, rowNum, colNum, "within");

    } else if (oldRollOverCanvas != null && !oldRollOverCanvas.destroying) {
        this.removeEmbeddedComponent(oldRollOverCanvas.embeddedRecord, oldRollOverCanvas);
    }

    if (rollUnderCanvas != null) {
        rollUnderCanvas.grid = this;
        rollUnderCanvas.record = record;
        rollUnderCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(rollUnderCanvas, record, rowNum, colNum, "within");

    } else if (oldRollUnderCanvas != null && !oldRollUnderCanvas.destroying) {
        this.removeEmbeddedComponent(oldRollUnderCanvas.embeddedRecord, oldRollUnderCanvas);
    }
    
    if (frozenRollOverCanvas != null) {
        frozenRollOverCanvas.grid = this;
        frozenRollOverCanvas.record = record;
        frozenRollOverCanvas.removeOnHideField = true;
        
        this.addEmbeddedComponent(frozenRollOverCanvas, record, rowNum, colNum, "within",
                                     this.frozenBody);

    } else if (oldFrozenRollOverCanvas != null && !oldFrozenRollOverCanvas.destroying) {
        this.removeEmbeddedComponent(oldFrozenRollOverCanvas.embeddedRecord, oldFrozenRollOverCanvas);
    }

    if (frozenRollUnderCanvas != null) {
        frozenRollUnderCanvas.grid = this;
        frozenRollUnderCanvas.record = record;
        frozenRollUnderCanvas.removeOnHideField = true;
        this.addEmbeddedComponent(frozenRollUnderCanvas, record, rowNum, colNum, "within",
                                    this.frozenBody);

    } else if (oldFrozenRollUnderCanvas != null && !oldFrozenRollUnderCanvas.destroying) {
        this.removeEmbeddedComponent(oldFrozenRollUnderCanvas.embeddedRecord, oldFrozenRollUnderCanvas);
    }    
},

// handle embedded components' z-indices here - allows us to float selection canvas behind
// the LG table if appropriate
updateEmbeddedComponentZIndex : function (component) {
    if (!component) return;
    if (this.selectionCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        this.selectionCanvas.setZIndex(tableIndex + 50);
    }
    if (this.selectionUnderCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        this.selectionUnderCanvas.setZIndex(tableIndex - 100);
    }
    // rollover should appear on top of selection.
    if (this.currentRollOverCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        component.setZIndex(tableIndex + 100);
    }
    if (this.currentRollUnderCanvas == component) {
        var tableIndex = this.body.getTableZIndex();
        component.setZIndex(tableIndex - 50);
    }
    if (this.currentFrozenRollOverCanvas == component) {
        var tableIndex = this.frozenBody.getTableZIndex();
        component.setZIndex(tableIndex + 100);
    }
    if (this.currentFrozenRollUnderCanvas == component) {
        var tableIndex = this.frozenBody.getTableZIndex();
        component.setZIndex(tableIndex - 50);
    }

},

_handleEmbeddedComponentResize : function (body, component, deltaX, deltaY) {

    // This logic ensures that we don't allow fields to size smaller than their
    // widest embedded component (and that we change that min on component resize
    // if necessary.
    if (component != null && component._currentFieldName &&
        component.embeddedPosition == this._$within &&
        deltaX != null && deltaX != 0)
    {
        // Ignore components not embedded in a column.
        var fieldName = component._currentFieldName,
            field = this.getField(fieldName);
        // Ignore percentWidth components whose size is driven by the
        // field itself rather than vice versa.
        var percentWidth = component._percent_width;
        if (field &&
            (percentWidth == null || !percentWidth.endsWith("%")))
        {

            var newSize = component.getVisibleWidth(),
                oldSize = newSize - deltaX;

            var currentMaxWidth = field._maxComponentWidth;

            // Assertion - if the "field._maxComponentWidth" is currently null,
            // it's either never been set, or we're pending a re-calculation of it.
            // Either way, no need to fire the notification to recalculate again.
            if (currentMaxWidth != null) {
                if (newSize > currentMaxWidth) {
                    this._fieldComponentWidthsChanged(fieldName, newSize);
                } else if (oldSize == currentMaxWidth) {
                    // Don't pass in a "new width" here - we don't know if
                    // other embedded components in this field exceed this component's
                    // new size so have fieldComponentWidthsChanged simply drop the
                    // cached max-width for lazy recalculation.
                    this._fieldComponentWidthsChanged(fieldName);
                }
                // Nothing to do if neither the new nor old size exceeds the
                // width of some other embedded component in the col.
            }
        }
    }


    // If we have frozen fields and an embeddedComponent in one body resizes vertically,
    // refresh both the frozen and unfrozen body to ensure row heights tay in sync.
    if (this.frozenBody != null && deltaY != null && deltaY != 0) {
        var otherBody = (body == this.frozenBody) ? this.body : this.frozenBody;
        otherBody.markForRedraw("Embedded component requires row resizing");
    }
},

// Header
// --------------------------------------------------------------------------------------------

// get properties common to *both* header buttons and the corner sort button
getButtonProperties : function () {
    var propsFromGrid = {
        // textAlign: wipe out the default alignment, which is center, to cause the default to
        // come from the text direction
        align:null
    };
    if (this.headerTitleStyle != null) propsFromGrid.titleStyle = this.headerTitleStyle;
    // NOTE: for headerButtons, headerBaseStyle needs to be re-applied after init, because if
    // field.baseStyle is set it overrides this default.  field.baseStyle is meant to apply to
    // cells only
    if (this.headerBaseStyle != null) propsFromGrid.baseStyle = this.headerBaseStyle;

    // headerButtonSrc / frozenHeaderButtonSrc
    // In multiple skins we use an ImgButton for our header buttons, and provide a custom src
    // property to get the appearance we want
    // These properties allow the overriding of that property for frozen and non frozen ImgButton
    // based header buttons
    
    if (this.headerButtonSrc != null) propsFromGrid.src = this.headerButtonSrc;
    // If 'frozenHeaderBaseStyle' / frozenHeaderTitleStyle is specified, store it on the button
    // defaults under a custom property name so we can apply it when creating buttons for frozen
    // fields
    if (this.frozenHeaderBaseStyle != null)
        propsFromGrid.frozenBaseStyle = this.frozenHeaderBaseStyle;
    if (this.frozenHeaderTitleStyle != null)
        propsFromGrid.frozenTitleStyle = this.frozenHeaderTitleStyle;
    if (this.frozenHeaderButtonSrc != null)
        propsFromGrid.frozenSrc = this.frozenHeaderButtonSrc;


    var properties = isc.addProperties({},
                this.headerButtonDefaults, propsFromGrid, this.headerButtonProperties);

    // we'll handle visibilty/enabled state for fields at the grid level
    properties.createCanvasWhenRules = false;

    return properties;
},

// get properties for the headerButtons only (not the sort button)
getHeaderButtonProperties : function (props) {

    var properties = this.getButtonProperties();

    if (this.buttonTitleFunction == null) {
        this.buttonTitleFunction = function () {
            return this.parentElement.grid.getHeaderButtonTitle(this);
        };
    }

    isc.addProperties(
                properties,
                {
                    _canHover: true,
                    minNonEdgeSize: isc.Browser.isTouch? 10: 5,

                    // header button selection is mutex
                    
                    defaultRadioGroup: this.getID()+"_header_radioGroup",

                    // If this field is sortable, we want the button to be a radio button
                    // (Note - mutually-exclusive selection is handled by default by toolbars for
                    // radio type buttons)
                    getActionType : function (a,b,c,d) {
                        var header = this.parentElement,
                            grid;

                        if (header) grid = header.grid;

                        if (grid && isc.isA.ListGrid(grid)) {

                            var field = grid.fields[header.getButtonNumber(this)];

                            // if the list's canSort is false, or the field's
                            // 'canSort' property is false, then this field can't be sorted
                            var canSort = (grid.canSort != false);
                            if (canSort && field != null) canSort = (grid._canSort(field) != false);

                            if (canSort && grid.selectHeaderOnSort) return isc.Button.RADIO;
                        }

                        // We either are canSort:false, or couldn't get a pointer to the list.
                        return this.invokeSuper(null, "getActionType", a,b,c,d);

                    },
                    getTitle : this.buttonTitleFunction,

                    // Override handleMouseOver / handleMouseOut to show the headerMenuButton if appropriate
                    handleMouseOver : function (event) {
                        var grid = this.parentElement.grid;
                        if (grid.shouldShowHeaderMenuButton(this, null, true)) {
                            var hmb = grid._showHeaderMenuButton(this);

                            
                            if (event) {
                                var hmbPageRect = hmb.getPageRect();
                                if (hmbPageRect[0] <= event.x && hmbPageRect[1] <= event.y &&
                                    event.x <= (hmbPageRect[0] + hmbPageRect[2]) &&
                                    event.y <= (hmbPageRect[1] + hmbPageRect[3]))
                                {
                                    
                                    this._delayedSuperHandleMouseOverTmrID = this._delayedSuper("handleMouseOver", arguments, null, 50);
                                    return;
                                }
                            }
                        }

                        return this.Super("handleMouseOver", arguments);
                    },
                    handleMouseOut : function () {
                        if (this._delayedSuperHandleMouseOverTmrID != null) {
                            isc.Timer.clear(this._delayedSuperHandleMouseOverTmrID);
                            delete this._delayedSuperHandleMouseOverTmrID;
                        }

                        
                        var EH = this.ns.EH;
                        if (!isc.Browser.isTouch &&
                            !this.containsPoint(EH.getX(), EH.getY()))
                        {
                            var grid = this.parentElement.grid,
                                headerMenuButton = grid.headerMenuButton;
                            // If the HMB is showing over this button, hide it unless the user rolled
                            // onto it.
                            if (isc.EH.getTarget() != headerMenuButton) {
                                grid._hideHeaderMenuButton(this);
                            }
                        }
                        
                        // clear the hover if it's showing
                        if (isc.Hover.isActive && !isc.Hover._hoverHasFocus) isc.Hover.clear();

                        return this.Super("handleMouseOut", arguments);
                    },
                    handleHover : function () {
                        var header = this.parentElement,
                            grid = header.grid,
                            fieldNum = this.masterIndex;

                        // headerHover is not currently a cancellable event, though
                        // this would be easy to implement as such.                        
                        if (grid.headerHover != null) grid.headerHover(fieldNum);
                        
                        var HTML = grid.defaultHeaderHoverHTML(fieldNum);
                        if (grid.headerHoverHTML) HTML = grid.headerHoverHTML(fieldNum, HTML);
                        
                        grid._showHeaderHover(fieldNum, HTML);
                    }
                },
                // force layoutAlign: bottom for all header buttons, if spans are present
                
                this.headerSpans != null ? {layoutAlign: "bottom"} : null,
                props
    );

    return properties;

},

//> @method listGrid.makeHeader()   (A)
// Make the headerBar for the body columns.
// @group   gridHeader
//<
// This method will create a single header or a layout containing frozen and unfrozen header if
// there are frozen fields.
// It will not add as a member or draw() - the calling code is responsible for that.
makeHeader : function () {

    if (this.header != null) return;

    var header = this.header = this.makeHeaderForFields(this.normalFields || this.fields || []);
    // for autoTest APIs
    header.locatorParent = this;

    header.setLocatorParent(this, "header");

    // make and add the sorter
    if (this.sorter == null) {
        this.makeCornerSortButton();
    }

    this.headers = [header];

    
    if (this.frozenFields) {


        var frozenHeader = this.frozenHeader =
                this.makeHeaderForFields(this.frozenFields, "visible", this.getID() + "_frozenHeader");
        frozenHeader.setLocatorParent(this, "frozenHeader");    
                
        frozenHeader.setOverflow("hidden");

        if (this.freezeStart()) {
            this.headers.unshift(this.frozenHeader);
        } else {
            this.headers.add(this.frozenHeader);
        }

        var headerMembers= this.headers.duplicate();

        this.headerLayout = this.createAutoChild("headerLayout", {
            autoDraw: false,
            overflow:"hidden",
            height: this.getHeaderHeight(),
            members : headerMembers
        }, isc.HLayout);
    }

    var outerHeader = this.headerLayout || this.header;

    if (this.showHeaderShadow && outerHeader.shouldUseCSSShadow()) {
        outerHeader.showShadow = true;
        
        if (this.headerShadowHOffset != null) {
            outerHeader.shadowHOffset = this.headerShadowHOffset;
        }
        if (this.headerShadowVOffset != null) {
            outerHeader.shadowVOffset = this.headerShadowVOffset;
        }
        if (this.headerShadowSoftness != null) {
            outerHeader.shadowSoftness = this.headerShadowSoftness;
        }
        if (this.headerShadowColor != null) {
            outerHeader.shadowColor = this.headerShadowColor;
        }
        
    }
    // We explicitly size the header to fit the specified width less scrollbar-width
    // so we don't want standard layout member-breadth-mgmt code to override this.
    outerHeader.inherentWidth = true;

    this.observe(outerHeader, "moved", function () { this.updateSorter(); });
    this.observe(outerHeader, "resized", function () { this.updateSorter(); });

},

// updateSorter - ensures the sorter is in the correct position and visible (or hidden) as appropriate.
updateSorter : function () {

    if (this.destroying || this.destroyed) return;
    if (!this.sorter || this.sorter.destroying || this.sorter.destroyed) return;

    if (this._overflowQueued || this._deferredOverflow) {
        this.delayCall("updateSorter");
        return;
    }

    // If this.showSort is unset, the sort button's visibility is determined by
    // leaveScrollbarGap, and whether the body has a vertical scrollbar.
    // This may have changed, so ensure the sorter is visible or hidden as appropriate.
    var showSorter = (this.header || this.headerLayout) && this._showSortButton();
    if (showSorter) {
        this.sorter.moveTo(this.getSorterLeft(), this.getSorterTop());
        this.sorter.setHeight(this.getHeaderHeight());
    } else {
        this.sorter.moveTo(0,0);
    }
    this.sorter.setVisibility(
        showSorter ? isc.Canvas.INHERIT : isc.Canvas.HIDDEN
    );
    // if the sorter wasn't created at init, it may not have been drawn yet
    if (showSorter) {
        if (this.isDrawn() && !this.sorter.isDrawn()) this.sorter.draw();
        else this.sorter.moveAbove(this.headerLayout || this.header);
    }
    
    if (this.sortByGroupFirst) {
        var sort = this.getSort();
        
        this.setSort(sort);
    }

},

makeHeaderForFields : function (fields, overflow, ID) {
    // make and add the header
    var header = this.createHeader({
        
        ID:ID,
        grid:this,

        // both the header and LV are looking at the same set of objects for field/button
        // config, but they may have them in a different order due to distinct Array instances.
        buttons:fields.duplicate(),

        // don't actually permanently change the order of the members on drop - we'll handle it from
        // reorderField
        reorderOnDrop:false,

        // wipe the default height of the Toolbar.  Use null instead of headerHeight since, for
        // frozen columns, when there are multiple headers in an HLayout, we don't want heights
        // on each header, just on the overall layout (applied in layoutChildren())
        height:null,

        minMemberLength : this.minFieldWidth,

        // don't force the user to tab between the fields in the toolbar
        tabWithinToolbar:false,

        overflow: overflow || "hidden",

        
        _redrawWithParent:!this.fixedFieldWidths
    })

    // observe the scroll routine of the header to ensure we sync scrolling of the body if the
    // header is scrolled
    // This is necessary when we can natively tab to the button elements (or to focusProxies
    // positioned behind the button elements) because when the native focus goes to a button in
    // the header, the native behavior is to scroll the button into view
    // (if it's not  currently in view).
    this.observe(header, "scrollTo", function () { this.headerScrolled(); });

    return header;
},

//> @method listGrid.setFieldButtonProperties()
// Method to update properties on a field's header button at runtime.
// This property allows customization of any settable properties on the ListGridField's
// header button after it has been generated.  <smartgwt>Note that the provided Canvas should
// only have the minimal needed properties set on it, and should not be a Canvas that's already
// been drawn or added as the child of another widget.</smartgwt>
// @param name (String) Field to update
// @param properties (Canvas Properties) new properties to apply to the header button
// @visibility external
//<
// The reasoning behind this is that developers will likely want to customize
// the "src" attribute [and other stuff like capSize] for img / stretchImg based
// header buttons.

setFieldButtonProperties : function (name, properties) {
    var field = this.getField(name)
    if (field != null) {
        var button = this.getFieldHeaderButton(this.getFieldNum(field));
        if (button != null) {
//            this.logWarn("Setting prop:" + button + " > " + this.echo(properties));
            button.setProperties(properties);
        }

    } else {
        field = this.completeFields.find("name", name);
    }
    if (field == null) {
        this.logWarn("setFieldButtonProperties() Unable to find specified field: " + name);
        return;
    }

    // Also copy the properties onto the field definition, so if the button is
    // destroyed / created later, we don't lose the settings.
    // Note that we have some special cases where we pick up a property from a field
    // as part of 'makeButton' and store it on the button under a different name, so
    // remap before applying to the field object. This means we wont (for example)
    // inadvertently clobber the field level "baseStyle" which has different meaning
    // for a ListGridField than for a header button.
    var maskedProps = isc.addProperties({}, properties);
    var remappedPropNames = {
        titleStyle:"headerTitleStyle",
        baseStyle:"headerBaseStyle"
    }
    for (var prop in remappedPropNames) {
        if (maskedProps[prop] != null) {
            maskedProps[remappedPropNames[prop]] = maskedProps[prop];
            delete maskedProps[prop];
        }
    }
    isc.addProperties(field, maskedProps);
},

getHeaderSpanConfig : function (name, spans) {
    if (spans == null) spans = this.headerSpans;
    if (spans == null) return;

    var spanConfig = spans.find("name", name);
    if (spanConfig != null) return spanConfig;
    // Nested header spans - check the "name" property of each span's sub-spans recursively
    
    for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        if (span.spans != null) {
            spanConfig = this.getHeaderSpanConfig(name, span.spans);
            if (spanConfig != null) return spanConfig;
        }
    }
},

//> @method listGrid.setHeaderSpanButtonProperties()
// Method to update properties on a headerSpan's header button at runtime.
// This property allows customization of any settable properties on the HeaderSpan's
// header button after it has been generated.
// @param name (String) +link{HeaderSpan.name,name} of span to update
// @param properties (Canvas Properties) new properties to apply to the header button
// @visibility external
//<
setHeaderSpanButtonProperties : function (name, properties) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanButtonProperties() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    if (spanConfig.liveObject) {
        spanConfig.liveObject.setProperties(properties);
    }

    // Also copy the properties onto the header-span definition, so if the button is
    // destroyed / created later, we don't lose the settings.
    // Note that we have some special cases where we pick up a property from a field
    // as part of 'makeButton' and store it on the button under a different name, so
    // remap before applying to the field object. This means we wont (for example)
    // inadvertently clobber the field level "baseStyle" which has different meaning
    // for a ListGridField than for a header button.
    var maskedProps = isc.addProperties({}, properties);
    var remappedPropNames = {
        titleStyle:"headerTitleStyle",
        baseStyle:"headerBaseStyle"
    }
    for (var prop in remappedPropNames) {
        if (maskedProps[prop] != null) {
            maskedProps[remappedPropNames[prop]] = maskedProps[prop];
            delete maskedProps[prop];
        }
    }
    isc.addProperties(spanConfig, maskedProps);
},

// For some span - goes through every nested inner-span and figures out for all branches
// of the tree the maximum depth. Used for apportioning sizing
getNestedSpanDepth : function (span) {
    if (span._nestedSpanDepth != null) return span._nestedSpanDepth;
    if (span.spans) {
        var innerSpanDepth = 0;
        for (var i = 0; i < span.spans.length; i++) {
            innerSpanDepth = Math.max(innerSpanDepth, this.getNestedSpanDepth(span.spans[i]));
        }
        span._nestedSpanDepth = (1 + innerSpanDepth);
        return span._nestedSpanDepth
    }
    // No inner spans so no nesting
    return 1;
},

getHeaderTableStyle : function (field) {
    // returns an the appropriate style to apply to the <table> element in headerButtons - Flat 
    // skins use this to show a field-separator that needn't fill the height like a border does
    var tableStyle = null;
    if (!this.headerSpans) {
        // normal buttons, no headerSpans
        tableStyle = this.headerTableStyle;
    } else {
        // headerSpans and spanned buttons
        tableStyle = this.spannedHeaderTableStyle;
    }
    return tableStyle;
},

//> @method listGrid.createHeader() (A)
// Create a header object suitable for labelling rows or columns
// @group gridHeader
//<
createHeader : function (properties) {

    
    var grid = this;
    var canTabToHeader = this.canTabToHeader || (this.canTabToHeader == null && isc.screenReader);
    var headerProps = isc.addProperties(
        {

            ariaRole:this.getHeaderAriaRole ? this.getHeaderAriaRole(): null,

            // shouldDragScroll is overridden for the header as the standard implementation is
            // dependent on the header having scrollbars. This header scrolls in sync with the
            // grid body which owns the scrollbars.
            shouldDragScroll: function() { return grid && grid.body && grid.body.hscrollOn;},
            // override makeButton to ignore any baseStyle specified directly on the
            // field definition, and instead always use this.headerBaseStyle
            // Also pick up headerTitleStyle from the field if specified
            makeButton : function (button,a,b,c,d) {
                // this copy is necessary because we pass the actual objects from this.fields
                // into Toolbar.buttons, and hence Toolbar.makeButton receives them, and they
                // should not be modified
                button = isc.addProperties({}, button);
                // The ListGrid already mirrors the button's alignment if reverseRTLAlign is true.
                button.ignoreRTL = true;

                // if the ListGrid is managing the title clipping, then do not enable title
                // clipping in the button. Also set showClippedTitleOnHover to false.
                if (!grid.clipHeaderTitles) {
                    button.clipTitle = false;
                    button.showClippedTitleOnHover = false;
                }

                button.tableStyle = grid.getHeaderTableStyle(button);

                
                button._redrawLabelWithMaster = true;

                button._getAfterPadding = function () {
                    var grid = this.grid,
                        fieldNum = this.masterIndex
                    ;
                    return grid._shouldPadHeaderButton(this) ? 
                        grid._getHeaderButtonPadding(grid.getField(fieldNum)) : null;
                };

                if (button.headerTitleStyle) button.titleStyle = button.headerTitleStyle;
                else if (button.frozen && this.buttonProperties.frozenTitleStyle)
                    button.titleStyle = button.frozenTitleStyle;

                if (button.frozen && this.buttonProperties.frozenSrc)
                    button.src = this.buttonProperties.frozenSrc;

                // Override showIf to be unset - we already handle evaluating showIf on listGrid
                // fields - if it returned false the button will never be created - if it returned
                // true for the field we know we want to show the button rather than re-eval
                // field.showIf on button draw
                button.showIf = null;

                button.grid = grid;
                button._isFieldHeaderButton = true;
                
                // If the field is marked as autoFitWidth, autoFitApproach:'title',
                // set overflow to visible
                var autoFit = grid.shouldAutoFitField(button),
                    approach,
                    fitTitle, fitValue;
                if (autoFit) {
                    approach = grid.getAutoFitWidthApproach(button);
                    if (approach == "both") {
                        fitTitle = true;
                        fitValue = true;
                    } else if (approach == "title") {
                        fitTitle = true;
                        fitValue = false;
                    } else {
                        fitTitle = false;
                        fitValue = true;
                    }
                }
                if (autoFit && fitTitle) {
                    button.overflow = isc.Canvas.VISIBLE;
                    button.resized = function () {
                        if (this.isDrawn() && this.grid) {
                            this.grid.headerButtonResized(this);
                        }
                    }
                }

                // pick up the default wrap and apply it to the button (but not for CG fields)
                
                if (button.wrap == null && button.headerLevel == null) {
                    button.wrap = grid.wrapHeaderTitles;
                }

                // header button initialization for rotated titles
                if (button.rotateTitle) {
                    button.customState = "Rotated";

                    
                    var clipperID = this.grid._getHeaderTitleClipperID(button);
                    if (isc.Browser.isMoz || isc.Browser.isSafariStrict) {
                        button.modifyContent = function () {
                            var clipper = isc.Element.get(clipperID);
                            if (clipper) {
                                var target = clipper.parentElement,
                                    targetWidth = isc.Element.getClientWidth(target),
                                    clipperWidth = isc.Element.getClientWidth(clipper)
                                ;
                                target.style.width = (targetWidth + clipperWidth) + "px";
                            }
                        }
                    }
                }

                // Also if we already calculated a field width based on auto-fit to values,
                // apply it to the header button:
                if (button._calculatedAutoFitWidth) {
                    if (button.width == null || button.width < button._calculatedAutoFitWidth) {
                        button.width = button._calculatedAutoFitWidth
                    }
                    // apply minWidth calculated in _updateFieldWidths
                    if (button.width < button._calculatedMinWidth) {
                        button.width = button._calculatedMinWidth;
                    }
                // Otherwise we must be auto-fitting to title.  Set the default width to the
                // minimum field width (max of field and grid's minimums), and then the title
                // overflowing will expand the button to accommodate it.
                } else if (button.width == null && fitTitle) {
                    button.width = Math.max(grid.minFieldWidth || 1, button.minWidth || 1);
                }
                // This flag ensures that if the header button is implemented as an imgButton
                // we size the actual image to fit the overflowed size of the label rather than
                // sizing to explicit width
                button.sizeImageToFitOverflow = true;

                // If reverseRTLAlign is true, flip titles too
                if (grid.reverseRTLAlign && grid.isRTL()) {
                    if (button.align == isc.Canvas.LEFT) button.align = isc.Canvas.RIGHT;
                    else if (button.align == isc.Canvas.RIGHT) button.align = isc.Canvas.LEFT;
                }

                // ScreenReader support: Mark header buttons as
                // "columnheaders". 
                
                // Include haspopup:true if we support context menus
                // on them
                // Note - the "button" passed in is the field object so we can check on the
                // master-index directly
                
                if (button.masterIndex != null) {

                    if (grid.getHeaderButtonAriaRole) {
                        button.ariaRole = grid.getHeaderButtonAriaRole(button);
                    }

                    if (grid.getHeaderButtonAriaState) {
                        button.getAriaState = function () {
                            return grid.getHeaderButtonAriaState(this);
                        }
                    }
                }
                var button = this.Super("makeButton", [button,a,b,c,d]);

                // button autofitting other than "value" is incompatible with title rotation
                if (button.rotateTitle && grid.getAutoFitWidthApproach(button) != "value") {
                    button.logWarn("Autofitting by title width isn't supported for " +
                                   "rotated titles - width or layout may be incorrect");
                }

                // pick up field level headerBaseStyle if specified.
                
                var gridHasSpans = this.parentElement != null && this.parentElement.headerSpans != null;
                if (gridHasSpans && button.spannedHeaderBaseStyle) {
                    button.setBaseStyle(button.spannedHeaderBaseStyle);
                } else if (gridHasSpans && this.parentElement.spannedHeaderBaseStyle) {
                    button.setBaseStyle(this.parentElement.spannedHeaderBaseStyle);
                } else if (button.headerBaseStyle) {
                    button.setBaseStyle(button.headerBaseStyle);
                // otherwise rely on the fact that headerBaseStyle is passed to us as part
                // of our default 'button' config
                } else {
                    if (button.frozen && this.buttonProperties.frozenBaseStyle)
                        button.setBaseStyle(this.buttonProperties.frozenBaseStyle);
                    else if (this.buttonProperties.baseStyle != null)
                        button.setBaseStyle(this.buttonProperties.baseStyle);
                }
                return button;
            },
            // Note: make all headerButton items members of the same radio group for
            // click-sort.  Previously this was taken care of by an auto-init of the radioGroup
            // in the Toolbar class - which was in turn based on the value returned by
            // getActionType() method on the button.  Since our getActionType override assumes a
            // parent chain and Toolbar no longer guarantees that this will be set up before
            // the radio group is auto-inited, we just pass one in here.
            buttonProperties:this.getHeaderButtonProperties(),

            border:this.headerBorder,
            styleName:this.headerBarStyle,
            backgroundColor:this.headerBackgroundColor,
            backgroundImage:this.headerBackgroundImage,
            
            canResizeItems: (this.canResizeFields || (this.editingOn && this.editProxy && this.editProxy.canResizeFields)),
            canReorderItems: (this.canReorderFields || (this.editingOn && this.editProxy && this.editProxy.canReorderFields)),
            
            dontObserve:false,

            childVisibilityChanged : function () {
                this.Super("childVisibilityChanged", arguments);
                this._sizeSpans();
            },

            // use this internal API rather than childResized/resized - this leaves those
            // public APIs available for other use, plus reduces the number of reflows by
            // dealing with the layout directly rather than responding to a cascae of
            // childResize()s
            _layoutChildrenDone : function () {
                this.Super("_layoutChildrenDone", arguments);
                this._sizeSpans();
            },

            dragReorderMove : function () {
                this.Super("dragReorderMove", arguments);
                this._sizeSpans();                
            },

            addSpan : function (span) {

                if (!this._spans) this._spans = [];
                this._spans.add(span);

                // unless the user passed an explicit, always size the span to the height of
                // the header
                if (this.isDrawn()) {
                    this._sizeSpan(span);
                    this.addChild(span);
                }
            },
            _sizeSpans : function () {
                if (!this._spans || !this.isDrawn()) return;
                // We explicitly suppress this method when resizing field buttons
                // in _adjustSpans (where we've already handled setting span button sizes)
                if (this._suppressSizeSpans) return;

                // diable instantRelayout while sizing the spans.
                
                var instantRelayout = this.instantRelayout;
                this.instantRelayout = false;

                for (var i = 0; i < this._spans.length; i++) this._sizeSpan(this._spans[i]);
                this.instantRelayout = instantRelayout;
                delete this._sizingSpans;
            },
            // members == actual members of the layout so they correspond to fields in the
            // grid.
            // if we have nested spans, this method will will return all fields covered by the
            // span and it's child-spans
            _getSpannedMembers : function (span) {
                // use the cached _spanButtons if we've already calculated it.
                // This cache is dropped when we add or remove buttons in the
                // toolbar, so we'll lazily recreate it here.
                if (span._spansButtons != null) {
                    return span._spansButtons;
                }
                var fields = grid.getSpannedFields(span);

                var spansButtons = [],
                    count = fields.length,
                    empty = true;
                for (var i = 0; i < this.members.length; i++) {
                    if (span._spansFields[this.members[i].name] == true) {
                        empty = false;
                        spansButtons[spansButtons.length] = this.members[i];
                        count--;
                    }
                    if (count == 0) break;
                }
                span._spansButtons = spansButtons;
                return empty ? null : spansButtons;
            },

            getNestedSpanDepth : function (span) {
                return grid.getNestedSpanDepth(span);
            },
            _sizeSpan : function (span) {
                if (!this.isDrawn()) {
                    return;
                }

                if (span._spanAutoSizeHeight) {
                    if (grid.autoFitHeaderHeights) {
                        span.setHeight(
                            Math.max(grid.getHeaderButtonDefaultHeight(span.spanConfig),
                                     grid.getHeaderButtonMinHeight(span.spanConfig))
                        );
                    } else {

                        // For nested spans, figure out how many parents / children we have so we can
                        // size and align vertically.
                        // Note: We support "asymmetrically nested" spans - for example a top-span
                        // containing one child span which has fields and another which has an additional
                        // layer of nesting.
                        // Therefore we need to figure out the maximum nested depth and divide
                        // the available space to get a consistent appearance.
                        // Note 2: We support allowing header titles to expand header buttons
                        // vertically. When this occurs the header as a whole has to expand -
                        // already handled via getHeaderHeight(). When this occurs we'll
                        // size the actual header buttons to the max of the calculated
                        // height (specified headerHeight/stack depth) and overflowed height
                        // and rely on the fact that getHeaderHeight() already sized the
                        // header as a whole large enough to accommodate this.
                        var currentSpan = span,
                            availableSpace = grid.headerHeight;
                        while (currentSpan.parentSpan != null
                            && currentSpan.parentSpan.liveObject)
                        {
                            var parentSpan = currentSpan.parentSpan.liveObject;
                            availableSpace -= parentSpan.getVisibleHeight();
                            currentSpan = parentSpan;
                        }

                        // Figuring out the max-depth of nesting of child spans is recursive, handled
                        // in a separate method
                        var childDepth = this.getNestedSpanDepth(span);
                        var height = Math.floor(availableSpace / (childDepth + 1));
                        
                        if (height <= 0) height = 1;

                        span.setHeight(height);
                    }
                }
                if (span.parentSpan != null && span.parentSpan.liveObject != null) {
                    span.setTop(span.parentSpan.liveObject.getBottom());
                }
                var autoSizeWidth = grid.autoSizeHeaderSpans;
                
                var spannedMembers = this._getSpannedMembers(span);

                // buttons are removed from the layout when hidden, so don't break on the lack
                // of spanned members
                var allHidden = spannedMembers == null || spannedMembers.length == 0;
                if (allHidden) {
                    if (this.isVisible()) {
                        span.hide();
                    }
                    return;
                }

                var firstVisibleMember,
                    totalVisibleMembers = 0,
                    spanWidth = 0
                ;
                for (var i = 0; i < spannedMembers.length; i++) {
                    var spannedMember = spannedMembers[i];

                    // disable header reorder drop over spanned columns
                    spannedMember.canReorder = false;

                    if (spannedMember.visibility != isc.Canvas.HIDDEN) {
                        totalVisibleMembers++;
                        spanWidth += spannedMember.getVisibleWidth();
                        if (!firstVisibleMember || this.isRTL()) firstVisibleMember = spannedMember;
                    }
                }

                if (firstVisibleMember) {
                    span.setVisibility(isc.Canvas.INHERIT);
                    span.setLeft(firstVisibleMember.getLeft());
                    var originalWidth = span.getWidth();
                    span.setWidth(spanWidth);
                    
                    if (autoSizeWidth && span.isDrawn()) {
                        // Force an immediate redraw if the span is dirty so getVisibleWidth()
                        // below picks up on the correct new size which may be effected by
                        // the innerHTML
                        if (span.isDirty()) span.redraw();
                        span.setOverflow(isc.Canvas.VISIBLE);

                        var visibleWidth = span.getVisibleWidth();
                        if (visibleWidth > spanWidth) {
                            span.setWidth(visibleWidth);
                            var delta = visibleWidth - spanWidth;

                            for (var i = 0; i < spannedMembers.length; i++) {
                                var spannedMember = spannedMembers[i];
                                if (spannedMember.visibility != isc.Canvas.HIDDEN) {
                                    var itemDelta = Math.ceil(delta / totalVisibleMembers);
                                    delta -= itemDelta;
                                    totalVisibleMembers -= 1;
                                    spannedMember.resizeBy(itemDelta);
                                }
                            }
                            
                            
                            if (visibleWidth != originalWidth) {
                                grid._updateFieldWidths("autoSizeHeaderSpans: Caused fields to expand", true);
                            }
                        }
                        span.setOverflow(isc.Canvas.HIDDEN);
                    }
                }
            },

            _adjustSpans : function (resizeFieldsOnly) {
                if (!this._spans) return;
                
                var recursive = this._adjustingSpans;
                this._adjustingSpans = true;
                if (!resizeFieldsOnly) this._sizeSpans();
                var thisHeight = this.getVisibleHeight();

                // Flag to suppress reacting to reflow for sizing header buttons by
                // re-sizing spans!
                this._suppressSizeSpans = true;
                // also disable instantRelayout while sizing the field buttons
                
                var instantRelayout = this.instantRelayout;
                this.instantRelayout = false;

                for (var i = 0; i < this._spans.length; i++) {
                    var span = this._spans[i];
                    if (!this.resizeFieldsOnly) this.addChild(span);

                    var spannedMembers = this._getSpannedMembers(span);
                    if (!spannedMembers) continue;

                    for (var j = 0; j < spannedMembers.length; j++) {
                        var header = spannedMembers[j],
                            headerHeight = header.getVisibleHeight()
                        ;

                        // For nested spans, figure out the total height of nested spans,
                        // and size the field to take up the rest of the header's height
                        
                        var parentSpan = grid.spanMap[header.name],
                            spanHeight = 0;
                        do {
                            // 'liveObject' should have been created if we have
                            // a button for the children!
                            if (parentSpan.liveObject == null) break;
                            spanHeight += parentSpan.liveObject.getVisibleHeight();
                            parentSpan = parentSpan.parentSpan;
                        } while (parentSpan != null)
                        header.setHeight(thisHeight - spanHeight);
                        // Depending on skin, buttons sometimes need to redraw on resize
                        // Do this now so the reported visible width/height is accurate for
                        // subsequent layout.
                        // Resolves an issue where in some cases header buttons could be
                        // mis-positioned when 
                        if (header.isDirty()) {
                            header.redraw();
                        }
                    }
                    span.bringToFront();
                }
                this.instantRelayout = instantRelayout;
                if (!recursive) {
                    delete this._suppressSizeSpans;
                    delete this._adjustingSpans;
                }
            },

            removeButtons : function (buttons) {
                if (grid.headerSpans) grid._removeHeaderSpans(buttons, this);
                this.Super("removeButtons", arguments);
            },
            addButtons : function (buttons, position) {
                this.Super("addButtons", arguments);
                if (grid.headerSpans) grid._addHeaderSpans(buttons, this);
                this._adjustSpans();
            },


            draw : function () {
                if (this._spans && grid.unspannedHeaderVAlign) {
                    for (var i = 0; i < this.buttons.length; i++) {
                        var button = this.buttons[i],
                            isSpanned = grid.spanMap[button.name] != null;
                        if (!isSpanned) {
                            button.valign = grid.unspannedHeaderVAlign;
                        }
                    }
                }
                this.Super("draw", arguments);
                this._adjustSpans();

                // autofitting the header height is incompatible with title rotation
                if (grid.autoFitHeaderHeights) {
                    var rotateHeaderTitles = this.rotateHeaderTitles;

                    for (var i = 0; i < this.buttons.length; i++) {
                        var rotateTitle = this.buttons[i].rotateTitle;
                        if (rotateHeaderTitles ? rotateTitle != false : rotateTitle) {
                            grid.logWarn("Autofitting header heights isn't supported for " +
                                         "rotated titles - height or layout may be incorrect");
                            break;
                        }
                    }
                }
            }

            // AutoTest subsytem APIs
            // Allow mapping header buttons by field name rather than just position in the
            // header!
            

            ,getStandardChildLocator : function (canvas) {
                var fieldNum = canvas.masterIndex,
                    grid = this.grid;
                if (fieldNum != null && grid != null) {
                    var fieldName = grid.getFieldName(fieldNum);
                    return isc.AutoTest.createLocatorFallbackPath("headerButton", {fieldName:fieldName});
                }

                return this.Super("getStandardChildLocator", canvas);
            },

            getChildFromLocatorSubstring : function (substring, index, locatorArray, configuration)
            {
                // Don't interfere with standard 'autoChild' / 'scrollbar' identifiers
                if (isc.isA.Canvas(this[substring])) return this[substring];

                var parsedPath = isc.AutoTest.parseLocatorFallbackPath(substring);
                if (this.grid && parsedPath && parsedPath.name == "headerButton") {

                    var fieldName = parsedPath.config.fieldName,
                        fieldNum = this.grid.getFieldNum(fieldName),
                        header = this.grid.getFieldHeader(fieldNum);

                    // field, or header may have been hidden
                    if (fieldNum == -1 || header == null) {
                        this.logWarn("fieldName:" + fieldName + ", gave fieldNum:" + fieldNum
                                + " unable to find header button for this field.");
                        return;
                    }
                    if (header != this) {
                        this.logWarn("AutoTest locator string specified this header for field "
                            + fieldName + " but that header button is contained in header "
                            + header + ". This can happen if headers have been frozen / "
                            + "unfrozen since the locator string was created. Redirecting to that widget.");
                        return header.getChildFromLocatorSubstring(substring);
                    }
                    // return locator header button state value if requested
                    if (configuration && configuration.attribute == isc.Canvas._$Value) {
                        var field = this.grid.fields[fieldNum];
                        if (fieldNum == this.grid.getCheckboxFieldPosition()) {
                            configuration.value = !!field._allSelected;
                        } else configuration.value = field.sortDirection;
                    }
                    return this.members[this.grid.getLocalFieldNum(fieldNum)];
                }

                return this.Super("getChildFromLocatorSubstring", arguments);
            },

            // reflow with hPolicy: "fill" so that buttons are stretched to fit available space
            _reflowNow : function (a, b, c) {
                var originalPolicy = this.hPolicy;
                this.hPolicy = "fill";

                this.reflowNow(a, b, c);
                
                this.hPolicy = originalPolicy;
            }

        }, properties);
    // if cantabToHeader is false, suppress tabbing to the header!
    
    if (!canTabToHeader) {
        headerProps.tabIndex = -1;
    }
    if (this.headerButtonConstructor != null)
        headerProps.buttonConstructor = this.headerButtonConstructor;

    var header = this.createAutoChild("header", headerProps,
        
        isc.Toolbar);

    // if the canReorderFields is true, observe the reorderItem method of the header
    if (header.canReorderItems && !header.dontObserve) {
        this.observe(header, "itemDragReordered", function (itemNum, newPosition) {
            this.headerDragReordered(itemNum, newPosition, header);
        });
        // NOTE: we don't actually do anything in the LV until reorder completes in the header
    }

    // if canResizeFields is true, observe the resizeItem and dragResize* methods of the header
    if (header.canResizeItems && !header.dontObserve) this._observeHeaderResize(header);

    if (this.headerSpans) this._addHeaderSpans(properties.buttons, header);
    return header;
},

// If we're showing overflow:"visible" header buttons (for auto-fitting to titles), we need to
// react to them resizing due to a title change (such as showing the sort arrow!)
headerButtonResized : function (button) {

    if (this._suppressAutoFitToTitle) return;
    
    if (this._dragResizingField) return;
    
    // If we're being called directly from setFieldWidth/setFieldWidths, don't react
    // to the resize. Upstream code should handle this
    if (this._settingHeaderFieldWidths) return;
    
    // If we're doing an "autoFit" to the field content - this is similar to a drag-resize - no need to react.
    if (this._autoFittingField != null && this._autoFittingField == this.getField(button.name)) {
        return;
    }
    
    // Clear the appliedInitialAutoFitWidth flag and run field width resize logic
    
    this.fields._appliedInitialAutoFitWidth = false;
    
    this._updateFieldWidths("header button resized");
},

// If a developer declares header-spans, fields that are spanned by the same header need to be
// next to each other (obviously).
// This means we may need to reorder the fields array as specified in the code.
// If we actually change anything let's log a warning - developers may be confused as to why
// the fields are not matching the specified positions.

reorderFieldsForHeaderSpans : function (spans) {
    if (spans == null) spans = this.headerSpans;
    if (spans == null) return;
    var orderChanged = false;
    for (var i = 0; i < spans.length; i++) {
        var span = spans[i],
            fields = this.getSpannedFields(span);
        if (fields == null || fields.length == 0 || fields.length == 1) continue;

        var gridFields = this.fields,
            length = fields.length,
            positions = [],
            frozen = null;

        for (var ii = 0; ii < length; ii++) {
            var pos = this.completeFields.findIndex("name", fields[ii]);
            // fieldName may not be present (due to setFields call etc)
            if (pos == -1) continue;

            // Frozen fields - currently we just warn if the developer attempted to
            // mix frozen and unfrozen fields within a span.
            if (frozen == null) {
                frozen = !!(this.completeFields[pos].frozen);
            } else {
                if (frozen != !!(this.completeFields[pos].frozen)) {
                    this.logWarn("HeaderSpan with title:" + span.title +
                        " has both frozen and unfrozen fields specified. This is not supported.");
                    
                }
            }
            positions.add({
                field:fields[ii],
                pos:this.completeFields.findIndex("name", fields[ii])
            });
        }

        positions.sortByProperty("pos", Array.ASCENDING);

        if (positions.length > 0 &&
            (positions.last().pos - positions.first().pos) > (positions.length-1))
        {
            this.logWarn("HeaderSpan with title " + span.title
                + " spans fields that are not adjacent in the specified fields array. "
                + "Reordering fields such that they are adjacent and can be spanned.");
            // We don't attempt to maintain the relative order specified in the fields array.
            // This would be difficult with nested spans since we'd potentially have to
            // reorder inner-spans within the parent depending on where fields were defined in the
            // fields array.
            var targetPos = positions.first().pos;
            for (var ii = 0; ii < length; ii++) {
                var field = fields[ii],
                    currentPos = this.completeFields.findIndex("name", field);
                
                if (currentPos == -1) continue;

                if (targetPos != currentPos) {
                    orderChanged = true;
                    this.completeFields.slide(currentPos, targetPos);
                }
                targetPos += 1;
            }
        // This implies that the fields are all adjacent.
        // Howeve if we have *nested* spans we also need to verify they're adjacent within
        // their various inner-spans
        } else if (span.spans) {
            orderChanged = this.reorderFieldsForHeaderSpans(span.spans);
        }
    }
    return orderChanged;
},

// Make a reverse map of fieldNames to header spans so we can look up
// the span (hierarchy) for a field rapidly.

buildSpanMap : function (spans, parentSpan, forPrinting, spanMap) {
    if (spanMap == null) spanMap = {};
    if (spans == null) spans = this.headerSpans;

    for (var i = 0; i < spans.length; i++) {
        var headerSpanConfig = spans[i];
        if (parentSpan) headerSpanConfig.parentSpan = parentSpan;
        if (headerSpanConfig.spans) {
            this.buildSpanMap(headerSpanConfig.spans, headerSpanConfig, forPrinting, spanMap);
        } else if (headerSpanConfig.fields) {
            // If we're printing, filter out the fields that should not be printed.
            if (forPrinting == true) {
                headerSpanConfig = isc.addProperties({}, headerSpanConfig);
                headerSpanConfig.fields = headerSpanConfig.fields.duplicate();
                for (var j = 0; j < headerSpanConfig.fields.length; ){
                    var fieldName = headerSpanConfig.fields[j];
                    var field = this.getField(fieldName);
                    if (field == null || field.shouldPrint == false) {
                        headerSpanConfig.fields.removeAt(j);
                        // don't increment `j'
                    } else {
                        ++j;
                    }
                }
                headerSpanConfig.fields.removeAll(headerSpanConfig.fields.findAll("shouldPrint", false));
            }
            for (var j = 0; j < headerSpanConfig.fields.length; j++) {
                spanMap[headerSpanConfig.fields[j]] = headerSpanConfig;
            }
        } else {
            this.logWarn("ListGrid passed unexpected header span object with " +
                "neither fields nor spans specified:" + this.echo(headerSpanConfig));
        }
    }

    return spanMap;
},


getSpannedFields : function (span, canHideFieldsOnly) {
    
    if (span == null) return [];

    if (span.fields) {
        var fields = span.fields;
        // This method is used by the column picker menu - if passed the
        // canHideFieldsOnly flag, ignore any fields marked as canHide:false
        if (canHideFieldsOnly) {
            var finalFields = [];
            for (var i = 0; i < span.fields.length; i++) {
                var fieldObj = (this.completeFields || this.fields).find("name", span.fields[i]);
                if (!fieldObj || fieldObj.canHide == false) {
                    continue;
                }
                finalFields.add(span.fields[i]);
            }
            fields = finalFields;
        }
        return fields;
    }

    var fields = [];
    if (span.spans) {
        for (var i = 0; i < span.spans.length; i++) {
            fields.addList(this.getSpannedFields(span.spans[i], canHideFieldsOnly));
        }
    }
    return fields;
},


_headerSpanVisible : function (fieldNames, span) {
    if (span.spans) {
        for (var i = 0; i < span.spans.length; i++) {
            if (this._headerSpanVisible(fieldNames, span.spans[i])) return true;
        }
        return false;
    } else {
        return (fieldNames.intersect(span.fields).length > 0)
    }
},


// Called recursively to create header-span-buttons and to layout
_addHeaderSpans : function (fields, header, headerSpans, parentSpan) {

    // For convenience, allow calling directly for top level spans.
    if (headerSpans == null) headerSpans = this.headerSpans;

    // find headerSpans that match our set of fields
    var fieldNames = fields.getProperty(this.fieldIdProperty);

// so headerSpans will now be an array of all the spans we actually care about,
// with the inner spans first in the list....

    for (var i = 0; i < headerSpans.length; i++) {
        var headerSpanConfig = headerSpans[i];

        // We don't support both fields and spans on a span - if we hit this
        // warn and drop the fields.
        if (headerSpanConfig.fields != null && headerSpanConfig.spans != null) {
            this.logWarn("ListGrid specified with headerSpan config object containing both " +
                "spans and fields. This is not supported - spanned fields must be all frozen or " +
                "all not frozen. Span Configuration:\n" +
                    this.echo(headerSpanConfig));

            headerSpanConfig.fields = null;
        }

        // If the header span doesn't match any visible fields, skip it
        if (!this._headerSpanVisible(fieldNames, headerSpans[i])) continue;

        // allow a canvas to be passed in

        // default to using the same component that header buttons are made of - this
        // way we get a consistent cross-skin look that's a reasonable default
        var grid = this,
            span = this.createHeaderSpan(header, headerSpanConfig);

        header.addSpan(span);

        // recursively build nested spans and add them to the header as well.
        if (span.spans) {
            this._addHeaderSpans(fields, header, span.spans, span);
        }
    }
},

createHeaderSpan : function (header, headerSpanConfig) {
    var grid = this,
        span = headerSpanConfig.liveObject;
        
    // If the span is destroyed or destroying, rebuild it.
    
    if (span == null || span.destroyed || span.destroying || span._pendingDestroy) {
        var config = headerSpanConfig,
            dynamicProperties = isc.addProperties(this.getButtonProperties(), {
                _constructor: header.buttonConstructor,
                height: this.headerSpanHeight,
                // typical to align the span text in the center
                align: "center",
                valign: this.headerSpanVAlign,
                showRollOver: false,

                // apply a style to the wrapper-table in the button, to apply sizable right border
                tableStyle: this.getHeaderTableStyle(config),

                showContextMenu : function () {
                    return grid.headerSpanContextClick(this);
                },
                // Suppress the title-clipper if we're auto-size:true
                
                shouldClipTitle : function (span) {
                    if (grid.autoSizeHeaderSpans) return false;
                    return this.Super("shouldClipTitle", arguments);
                }
            }, config)
        ;

        // Support custom per-span styling:

        // title style useful for stretchImgButtons
        // Note that if you have stretchImgButton based headers, in order to customize
        // appearance you'd probably also want to specify custom src and capSize
        // This is actually supported in both ListGridFields and HeaderSpans, but
        // not explicitly documented.
        if (config.headerTitleStyle) {
            dynamicProperties.titleStyle = config.headerTitleStyle;
        }

        // BaseStyle for simple buttons (more recent skins)
        if (config.headerBaseStyle != null) {
            dynamicProperties.baseStyle = config.headerBaseStyle;
        }
        else {
            // headerSpanDefaults/Properties baseStyle is overwritten by getButtonProperties()
            // because that configuration is applied last. To pick the headerSpan values up
            // instead, pull them out explicitly
            var baseStyle = (this.headerSpanProperties ? this.headerSpanProperties.baseStyle : null) ||
                            (this.headerSpanDefaults   ? this.headerSpanDefaults.baseStyle   : null);
            if (baseStyle) dynamicProperties.baseStyle = baseStyle;
        }

        // override the liveObject title with headerTitle, if it's present
        if (config.headerTitle != null) dynamicProperties.title = config.headerTitle;
        span = config.liveObject = this.createAutoChild("headerSpan", dynamicProperties);

        // auto-size span height unless an explicit height is set somewhere
        var height = config.height ||
                     (this.headerSpanProperties ? this.headerSpanProperties.height : null) ||
                     (this.headerSpanDefaults   ? this.headerSpanDefaults.height   : null) ||
                     this.headerSpanHeight;

        
        span._spanAutoSizeHeight = this.autoFitHeaderHeights ? height || true : height == null;
    }

    
    span._spansFields = {};
    var fields = this.getSpannedFields(headerSpanConfig);
    for (var ii = 0; ii < fields.length; ii++) {
        span._spansFields[fields[ii]] = true;
    }

    // drop the cached live buttons we actually span - we'll lazily regenerate when they're required.
    span._spansButtons = null;

    span.spanConfig = headerSpanConfig;

    return span;
},

_removeHeaderSpans : function (buttons, header) {
    // find headerSpans that match our set of fields
    var headerSpans = [],
        fieldNames = buttons.getProperty(this.fieldIdProperty)
    ;
    for (var i = 0; i < fieldNames.length; i++) {
        var span = this.spanMap[fieldNames[i]];
        while (span != null && span.liveObject != null) {
            span.liveObject._spansButtons = null;
            span = span.parentSpan;
        }
    }

    // no need to actually remove the span from the header - we'll lazily hide it as part of
    // this._sizeSpans()
},


//> @attr listGrid.showHeaderSpanTitlesInFormulaBuilder (Boolean : true : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, should field titles be
// prefixed with the titles of the headerSpans in which they are contained when
// using the +link{FormulaBuilder} or +link{SummaryBuilder}.
// @see listGrid.formulaBuilderSpanTitleSeparator
// @visibility external
//<
showHeaderSpanTitlesInFormulaBuilder:true,

//> @attr listGrid.formulaBuilderSpanTitleSeparator (String : " - " : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, and
// +link{showHeaderSpanTitlesInFormulaBuilder,showHeaderSpanTitlesInFormulaBuilder} is true,
// this string will be inserted between the headerSpan title(s) and the field title in the
// field chooser grid in the +link{FormulaBuilder} and +link{SummaryBuilder}.
// @group i18nMessages
// @visibility external
//<
formulaBuilderSpanTitleSeparator:" - ",

//> @attr listGrid.showHeaderSpanTitlesInSortEditor (Boolean : true : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, should field titles be
// prefixed with the titles of the headerSpans in which they are contained when
// using the +link{MultiSortDialog,multi-sort editor}.
// @see listGrid.sortEditorSpanTitleSeparator
// @visibility external
//<
showHeaderSpanTitlesInSortEditor:true,

//> @attr listGrid.sortEditorSpanTitleSeparator (String : " - " : IRW)
// If this grid has specified +link{listGrid.headerSpans,headerSpans}, and
// +link{showHeaderSpanTitlesInSortEditor,showHeaderSpanTitlesInSortEditor} is true, this
// string will be inserted between the headerSpan title(s) and the field title in the field
// chooser grid on the +link{MultiSortDialog,multi-sort editor}
// @group i18nMessages
// @visibility external
//<
sortEditorSpanTitleSeparator:" - ",

//> @attr listGrid.showHeaderSpanTitlesInHiliteEditor (Boolean : true : IRW)
// If this grid has specified +link{listGrid.headerSpans}, should field titles be
// prefixed with the titles of the headerSpans in which they are contained when
// using the +link{databoundComponent.editHilites,hilite editor}.
// @see listGrid.hiliteEditorSpanTitleSeparator
// @visibility external
//<
showHeaderSpanTitlesInHiliteEditor:true,

//> @attr listGrid.hiliteEditorSpanTitleSeparator (String : " - " : IRW)
// If this grid has specified +link{listGrid.headerSpans}, and
// +link{showHeaderSpanTitlesInHiliteEditor} is true, this string will be inserted
// between the headerSpan title and the field title in the hiliteEditor field chooser
// grid.
// @group i18nMessages
// @visibility external
//<
hiliteEditorSpanTitleSeparator:" - ",

// When getting the set of fields to show in a hilite editor, prefix with
// header span titles where applicable.
getHiliteCriteriaFields : function () {

    var fields = this.Super("getAllFields", arguments);
    if (!fields) return;
    fields = fields.duplicate();
    if (this.showHeaderSpanTitlesInHiliteEditor && this.headerSpans != null) {
        for (var i = 0; i < fields.length; i++) {
            var span = this.spanMap[fields[i].name],
                isSpanned = false,
                spans = [{title:this.getFieldTitle(fields[i])}];
            while (span != null) {
                isSpanned = true;
                spans.addAt(span, 0);
                span = span.parentSpan;
            }
            if (isSpanned) {
                var title = spans.getProperty("title").join(this.hiliteEditorSpanTitleSeparator);
                
                fields[i] = isc.addProperties({}, fields[i],
                    {title:title});
            }
        }
    }
    return fields;
},

//> @method listGrid.dirtyHeader()  (A)
//          let the header know that it should redraw when we get a chance
//      @group  gridHeader
//<
dirtyHeader : function () {
    if (this.header) this.header.markForRedraw();
},

// update an existing header to match the current set of fields.
updateHeader : function () {

    // wipe out the old header if there was one
    var oldHeader = this.frozenHeader ? this.headerLayout : this.header;

    if (oldHeader) {
        // defer destruction to prevent possible IE slow script dialogs for large number of columns
        oldHeader.markForDestroy();
        // need to clear out IDs to prevent ID collision warnings as we recreate the header (it
        // will have the same ID).

        
        
        oldHeader.clear();
        if (this.showHeader) {
            var toolbars = [this.frozenHeader,this.header];
            for (var i = 0; i < toolbars.length; i++) {
                if (toolbars[i] == null) continue;
                if (toolbars[i]._spans != null) {
                    for (var ii = 0; ii < toolbars[i]._spans.length; ii++) {
                        var span = toolbars[i]._spans[ii];
                        if (span) {
                            span.deparent();
                            
                            if (this._autoDestroySpans) span.destroy();
                        }
                    }
                }
            }
            delete this._autoDestroySpans;
        }
        
        oldHeader.clearIDs();

        // clear the pointer to the headerMenuButton (if present) because it is going to be destroyed
        this.headerMenuButton = null;
    }

    this.header = this.frozenHeader = this.headerLayout = null;

    // create a new header if so configured
    var showHeader = this.showHeader,
        headerIndex;
    if (showHeader) {
        headerIndex = this.gridComponents.indexOf(this._$header);
        if (headerIndex == -1) {
            showHeader = false;
            this.logWarn("showHeader set to true, but header not included in grid header components." +
                " The header will not be shown.");
        }
    }
    if (showHeader) {
        // If we're auto-fitting fields to their titles vertically this process may change
        // the header height - drop the cached header heights now.
        // This means that getHeaderHeight() will lazily recalculate the correct value and
        // we'll reflow to accommodate it.
        if (this.autoFitHeaderHeights) {
            this.dropCachedHeaderButtonHeights();
        }

        this.makeHeader();
        // createChildren builds the standard grid components and adds them as members.
        // If this has already occurred, we'll need to explicitly add the header as
        // a member here. Note that calling code typically will cause a resize, etc via
        // a call to layoutChildren or _updateFieldWidths()
        this.updateGridComponents();
        

    // We're hiding the sorter here, since _updateFieldWidths handles positioning and showing
    // the sorter if appropriate
    // sorter may be undef (if showSorter is false)
    } else if (this.sorter) {
        this.sorter.hide();
    }

    
},

//> @method listGrid.setHeaderHeight()
// Modify the height of a listGrid. To hide the header set height to zero.
// @param height (number) new height for the header
// @visibility external
// @group sizing, gridHeader
//<
_$headerHeightChanged:"header height changed",
setHeaderHeight : function (height) {
    var oldHeight = this.headerHeight;

    if (oldHeight == height) return;

    this.headerHeight = height;

    this._updateHeaderHeight(oldHeight == 0);
},

_updateHeaderHeight : function (wasHidden) {
    // No need to update the header if we're not showing it.
    if (this.showHeader == false) return;

    if (!this.header && this.getHeaderHeight() > 0) {
        // Don't build the header if it's not included in the gridComponents array!
        var headerIndex = this.gridComponents.indexOf("header");
        if (headerIndex == -1) {
            return;
        }
        // If we're not drawn the header will get created when we get drawn
        // Otherwise create and draw it now.
        if (this.isDrawn()) {
            this.updateGridComponents();
        }
    } else {
        
        if (wasHidden) this.updateHeader();
        // handles resizing (and showing/hiding if appropriate)
        this.layoutChildren(this._$headerHeightChanged)
    }

    this.updateSorter();
    if (this.headerSpans) {
        
        this.header._adjustSpans(true);
    }
},

//> @method listGrid.setShowHeader()
// Show or hide the ListGrid header.
// @param show (boolean) true to show the header, false to hide it.
// @visibility external
// @group gridHeader
//<
_$headerVisibilityChanged:"header visibility changed",
setShowHeader : function (show) {
    if (show == this.showHeader) return;

    this.showHeader = show;

    this.updateHeader();
    this.layoutChildren(this._$headerVisibilityChanged);
},

// Header Menu button
// -------------------------------------------------------------------------------------------

shouldShowHeaderMenuButton : function (header, skipTouchEventCheck, updateItems) {
    
    if (!skipTouchEventCheck && this.ns.EH._handlingTouchEventSequence()) return false;

    // Support a simple (undocumented) flag to always suppress the header menu button.
    // Used by the Tour subsystem
    if (this.suppressHeaderMenuButton) return false;

    var shouldShow;
    if (header.showDefaultContextMenu == false) {
        shouldShow = false;
    }
    
    else if (header.showHeaderContextMenuButton != null) {
        shouldShow = header.showHeaderContextMenuButton;
    } else {
        shouldShow = this.showHeaderMenuButton;
    }
    
    if (this.showHeaderContextMenu && shouldShow && header.masterIndex != null) {
        // return true if this headerButton has menuItems to show
        return this.hasHeaderContextMenuItems(header.masterIndex);
    }
    return false;
},

// getHeaderMenuButton
// creates the headerMenuButton autoChild. Lazily creates the button if it hasn't been shown yet
getHeaderMenuButton : function (button) {
    // after certain column operations like freeze, the headerMenuButton may be destroyed
    // so recreate it if so.
    if (!this.headerMenuButton || this.headerMenuButton.destroyed) {
        var dynamicDefaults = {
            resizeFrom:(this.isRTL() ? "L" : "R")
        };

        // don't default anything to explicit null!
        if (this.headerMenuButtonIcon) dynamicDefaults.icon = this.headerMenuButtonIcon;
        if (this.headerMenuButtonIconHeight) {
            dynamicDefaults.iconHeight = this.headerMenuButtonIconHeight;
        }
        if (this.headerMenuButtonIconWidth) {
            dynamicDefaults.iconWidth = this.headerMenuButtonIconWidth;
        }
        var gridHasSpans = this.headerSpans != null;
        if (gridHasSpans && this.spannedHeaderMenuBaseStyle) {
            dynamicDefaults.baseStyle = this.spannedHeaderMenuBaseStyle;
        } else if (this.headerMenuButtonBaseStyle) {
            dynamicDefaults.baseStyle = this.headerMenuButtonBaseStyle;
        }
        if (this.headerMenuButtonTitleStyle) {
            dynamicDefaults.titleStyle = this.headerMenuButtonTitleStyle;
        }
        if (this.headerMenuButtonSrc) dynamicDefaults.src = this.headerMenuButtonSrc;
        
        this.createAutoChild("headerMenuButton", dynamicDefaults, "Button", true);
    }

    

    // update button position and orientation
    this._updateHeaderMenuButtonForRotation(button);

    this.headerMenuButton.masterIndex = button.masterIndex;

    this.headerMenuButton.canDragResize = button.canDragResize != null ? 
        button.canDragResize && this.canResizeFields : this.canResizeFields;

    return this.headerMenuButton;
},

_getHeaderMenuButtonSnapOffsetLeft : function (button) {
    // correct the position of the header menu button so that it is not obscured by
    // the sorter button or any length of the button on the right that is clipped by
    // the viewport.
    var hmbSnapOffsetLeft = 0,
        fieldIsFrozen = this.fieldIsFrozen(button.masterIndex);
    if (!fieldIsFrozen && this.body != null) {
        var viewportWidth = this.body.getViewportWidth(),
            buttonScrollWidth = button.getVisibleWidth();
            
        if (this.isRTL()) {
            
        } else {
            var buttonLeft = button.getLeft(),
                offset = buttonLeft - this.body.getScrollLeft(),
                hiddenLength = offset + buttonScrollWidth - viewportWidth;
            if (this._showSortButton()) hiddenLength += this._getSorterWidth();
            if (this.body.vscrollOn) hiddenLength -= this.body.getScrollbarSize();
            if (hiddenLength > 0) {
                hmbSnapOffsetLeft = -hiddenLength;
            }
        }
    } else if (fieldIsFrozen && this.frozenBody != null) {
        var viewportWidth = this.getViewportWidth(),
            buttonScrollWidth = button.getVisibleWidth();
        
        if (this.isRTL()) {
            
        } else {
            var hiddenLength;
            if (this.sorter != null && this._showSortButton()) {
                hiddenLength = button.getPageLeft() + buttonScrollWidth - this.sorter.getPageLeft();
            } else {
                hiddenLength = button.getLeft() + buttonScrollWidth - viewportWidth;
                if (this.frozenBody.vscrollOn) hiddenLength -= this.frozenBody.getScrollbarSize();
            }

            if (hiddenLength > 0) {
                hmbSnapOffsetLeft = -hiddenLength;
            }
        }
    }
    return hmbSnapOffsetLeft;
},



_updateHeaderMenuButtonForRotation : function (button) {
    var hmb = this.headerMenuButton,
        initialized = hmb.getSnapTo() != null,
        isRotated = hmb.getCustomState() != null,
        shouldRotate = this._shouldRotateHeaderMenuButton(button)
    ;

    if (!initialized || isRotated != shouldRotate) {
        hmb.setSnapTo(shouldRotate ? "T" : (this.isRTL() ? "L" : "R"));

        hmb.setWidth(shouldRotate ? this.rotatedHeaderMenuButtonWidth :
                     this.headerMenuButtonWidth);
        hmb.setHeight(shouldRotate ? this.rotatedHeaderMenuButtonHeight :
                      this.headerMenuButtonHeight);

        hmb.setCustomState(shouldRotate ? "Rotated" : null);
    }

    hmb.setSnapOffsetLeft(shouldRotate ? 0 : this._getHeaderMenuButtonSnapOffsetLeft(button));
},

headerMenuButtonDefaults: {
    // Default the title to explicit null rather than the default Button.title property
    // (EG "Untitled Button")
    title:null,
    iconSpacing:0,
    showDisabled:false,
    showDisabledIcon:false,
    showIconCustomState:false,

    click : function () {
        this.creator.headerMenuButtonClick();
        //>EditMode
        // In editMode cancel any further bubbling of the click event which can cause the
        // context menu to not be displayed. A return of false here may be valid even
        // outside of editMode but to prevent regression the context is limited.
        if (this.creator.editingOn && this.creator.editProxy) {
            return false;
        }
        //<EditMode
    },
    doubleClick : function () {
        this.creator.headerMenuButtonDoubleClick();
    },
    mouseOut : function () {
        var EH = this.ns.EH;
        if (!isc.Browser.isTouch) {
            var target = EH.getTarget();
            if (!target || !this.parentElement.contains(target)) {
                this.hide();
            }
        }

        // call Super to reset 'over' state
        this.Super("mouseOut", arguments);
    }
    
    
},

// called from a click on the header menu button
headerMenuButtonClick : function () {
    var header = this.header,
        headerMenuButton = this.headerMenuButton,
        buttonIndex = header.containsEvent() ? header.getMouseOverButtonIndex() : -1;
    if (buttonIndex < 0 && this.frozenHeader) {
        header = this.frozenHeader;
        buttonIndex = header.getMouseOverButtonIndex();
    }
    if (buttonIndex == -1 || !headerMenuButton) return;

    var headerButton = header.getMember(buttonIndex),
        menuTop = headerMenuButton.getPageBottom(),
        menuWidth = this._cornerMenu ? this._cornerMenu.getVisibleWidth()
                                     : isc.Menu.getPrototype().defaultWidth,
        headerLeft = headerButton.getPageLeft(),
        headerMenuButtonRight = headerMenuButton.getPageRight(),
        menuLeft = this.isRTL() ?
                   Math.min(headerLeft, headerMenuButtonRight - menuWidth) :
                   Math.max(headerLeft, headerMenuButtonRight - menuWidth);
    this.displayHeaderContextMenu(headerMenuButton, [menuLeft, menuTop]);
    // unmask the hmb -- if a double click occurs on it we want to auto-fit
    headerMenuButton.bringToFront();
},

// called from a double click on the header menu button
headerMenuButtonDoubleClick : function () {
    var header = this.header,
        buttonIndex = header.getMouseOverButtonIndex();
    if (buttonIndex == -1 && this.frozenHeader) {
        header = this.frozenHeader;
        buttonIndex = header.getMouseOverButtonIndex();
    }
    if (buttonIndex == -1) return;

    if (this.frozenFields && header == this.header) {
        // headerDoubleClick expects a master field index, not a localised one
        buttonIndex += this.frozenFields.length;
    }

    // we showed the header menu on click - hide it now
    // otherwise when the field resized it shows up in the wrong place...
    isc.Menu.hideAllMenus();
    
    return this.headerDoubleClick(buttonIndex, header);
},

_showHeaderMenuButton : function (headerButton) {
    var hmb = this.getHeaderMenuButton(headerButton);
    if (hmb.masterElement != null) hmb.masterElement.markForRedraw();
    headerButton.addPeer(hmb);
    hmb.enable();
    
    hmb.addProperties({
        dragTarget: headerButton
    });
    // bringToFront if necessary
    if (headerButton.zIndex > hmb.zIndex) hmb.bringToFront();
    if (!hmb.isVisible()) {
        hmb.show();
    }
    headerButton.markForRedraw();
    return hmb;
},

_hideHeaderMenuButton : function (headerButton) {
    var hmb = this.headerMenuButton;
    if (hmb != null && hmb.isVisible()) {
        var hmbMasterElement = hmb.masterElement;
        if (headerButton == null) headerButton = hmbMasterElement;

        if (hmbMasterElement == headerButton) {
            hmb.hide();
            if (hmbMasterElement != null) hmbMasterElement.markForRedraw();
        }
    }
},

// Header Buttons
// --------------------------------------------------------------------------------------------

_shouldClipHeaderTitle : function (fieldNum) {
    var field = this.fields[fieldNum];
    if (this.autoFitHeaderHeights) return false;

    
    if (this._getHeaderButtonWrap(field)) return false;

    var shouldAutoFit = this.shouldAutoFitField(field);
    if (shouldAutoFit) {
        var approach = this.getAutoFitWidthApproach(field);

        if (approach == "title" || approach == "both") {
            return false;
        }
    }
    return true;
},

_$titleClipper:"_titleClipper",
_getHeaderTitleClipperID : function (field) {
    if (!field || !field.name) return null;
    return this._getDOMID(field.name + this._$titleClipper);
},

//> @method listGrid.headerTitleClipped() (A)
// Is the field title for the specified field clipped?
//
// @param fieldNum (number) field number for the header button title to test
// @return (boolean) whether the field title for the specified field is clipped
// @see attr:ListGrid.clipHeaderTitles
// @group gridHeader
// @visibility external
//<
headerTitleClipped : function (fieldNum) {
    
    var field = this.fields[fieldNum],
        titleClipperID = this._getHeaderTitleClipperID(field);
    if (titleClipperID == null) return false;

    var titleClipperHandle = isc.Element.get(titleClipperID);
    if (titleClipperHandle == null) {
        var button = this.getFieldHeaderButton(fieldNum);
        
        if (button.overflow == isc.Canvas.VISIBLE) {
            return button.getVisibleHeight() > button.getHeight();
        }
        var sortAnchorHandle = field ? this._getHeaderButtonSortAnchor(field) : null;
        return button && button.titleClipped ? button.titleClipped(sortAnchorHandle) : null;
    }

    
    var rotateTitle = field.rotateTitle;
    if (rotateTitle && field.wrap) {
        // select the titleClipper node as a range inside its parent
        var range = this.getDocument().createRange();
        range.selectNode(titleClipperHandle);
        // now compare bounding clientRects of the range and the parent DIV
        var contentsBCR = range.getBoundingClientRect(),
            bcr = titleClipperHandle.parentElement.getBoundingClientRect();
        return bcr.height < contentsBCR.height || bcr.width < contentsBCR.width;
    }

    
    if (isc.Browser.isChrome ||
        (isc.Browser.isMoz && isc.Browser.version >= 7))
    {
        var range = this.getDocument().createRange();
        range.selectNodeContents(titleClipperHandle);
        var contentsBCR = range.getBoundingClientRect(),
            bcr = titleClipperHandle.getBoundingClientRect();
        return rotateTitle ? bcr.height < contentsBCR.height :  
                             bcr.width  < contentsBCR.width;
                            
    } else {
        return rotateTitle ? titleClipperHandle.clientHeight < titleClipperHandle.scrollHeight :
            isc.Element.getClientWidth(titleClipperHandle) < titleClipperHandle.scrollWidth;
    }
},

// return the DOM element created by getHeaderButtonTitle() to hold the sort arrow and numeral
_getHeaderButtonSortAnchor : function (field) {
    if (this.isSortField(field[this.fieldIdProperty]) &&
        (this.showSortArrow != isc.ListGrid.NONE && this.showSortArrow != isc.ListGrid.CORNER ||
         this.showSortNumerals && this.getSortFieldCount() > 1))
    {
        var sortAnchorID = this._getHeaderButtonSortAnchorID(field);
        if (sortAnchorID != null) return isc.Element.get(sortAnchorID);
    }
    return null;
},

headerButtonPaddingThreshold: 50,
// should we pad the header button to make space for menu button
_shouldPadHeaderButton : function (button, fieldWidth) {
    if (!button) return false;

    // locate field from button
    var fieldNum = button.masterIndex,
        field = this.getField(fieldNum != null ? fieldNum : button[this.fieldIdProperty]);
    if (!field) return false;

    // if the padding would require too much of the available space, don't add it
    
    var threshold = this.headerButtonPaddingThreshold;
    if (threshold != null && (this.getAutoFitWidthApproach(field) == "value" ||
         (!this.shouldAutoFitField(field) && this._autoFittingField != field &&
          (!this._autoFittingFields || field.canAutoFitWidth == false)))) 
    {
        if (!fieldWidth) fieldWidth = isc.isA.Canvas(button) ? button.getVisibleWidth() :
                                                                  this.getColumnWidth(fieldNum);
        if (!fieldWidth || fieldWidth < threshold) return false;
    }

    // only apply a pad if the menu button will be shown on hover, but pad all buttons
    return this.shouldLeaveHeaderMenuButtonSpace(field) && 
           this.shouldShowHeaderMenuButton(button) &&
           (this._shouldClipHeaderTitle(fieldNum) || this._getHeaderButtonWrap(button));
},

// determine how much padding to add - depends on sorter/numeral
_getHeaderButtonPadding : function (button) {
    

    var padding = this.headerMenuButtonWidth + 1;

    // add to base padding if showing sort arrow and/or numeral
    if (button) {
        var fieldName = button[this.fieldIdProperty],
            isSortField = this.isSortField(fieldName);
        if (isSortField) {
            // showing sort arrow
            if (!this.showSortArrow || this.showSortArrow == isc.ListGrid.FIELD ||
                                       this.showSortArrow == isc.ListGrid.BOTH) 
            {
                padding += this.sortArrowMenuButtonSpaceOffset;
            }
            // showing sort numeral
            if (this.showSortNumerals != false && this.getSortFieldCount() > 1) {
                padding += this.sortNumeralMenuButtonSpaceOffset;
            }
        }
    }

    return padding;
},

_$sortAnchor:"_sortAnchor",
_getHeaderButtonSortAnchorID : function (field) {
    if (!field || !field.name) return null;
    return this._getDOMID(field.name + this._$sortAnchor);
},

//> @method listGrid.getHeaderButtonTitle() (A)
// Given a header button (or column number), returns the title for that header button.
// @group   drawing, gridHeader
// @param   button      (number)
// @return  (String)    HTML for header button contents
// @visibility internal
//<

getHeaderButtonTitle : function (button, clipTitle) {
    var fieldNum = button;
    // passed a header button or field
    if (isc.isA.Object(button)) fieldNum = button.masterIndex;
    else {
        button = this.getFieldHeaderButton(fieldNum);
    }

    var field = this.fields[fieldNum];
    if (!field) return ""; // if field is null, we've shrunk the number of columns, so forget it

    var fieldName = field[this.fieldIdProperty],
        isSortField = this.isSortField(fieldName),
        addPadding = this._shouldPadHeaderButton(button || field),
        showSortArrow = isSortField &&
                        (!this.showSortArrow || this.showSortArrow == isc.ListGrid.FIELD ||
                         this.showSortArrow == isc.ListGrid.BOTH),
        showSortNumeral = this.showSortNumerals == false ? false :
                              isSortField && this.getSortFieldCount() > 1
    ;

    var sortIndex;
    if (showSortNumeral) {
        var specifier = this.getSortSpecifier(fieldName);
        sortIndex = specifier.sortIndex;
    }

    var isRTL = this.isRTL(),
        rotateTitle = field.rotateTitle,
        wrapTitle = this._getHeaderButtonWrap(field),
        align = this.getFieldHeaderAlign(fieldNum, isRTL)
    ;
    var fullTitle = isc.StringBuffer.create(),
        title = field.showTitle == false ? "" : 
            (field.headerTitle != null ? field.headerTitle : this.getFieldTitle(fieldNum))
    ;

    if (clipTitle == null) clipTitle = this._shouldClipHeaderTitle(fieldNum);

    
    if (wrapTitle && !rotateTitle) {

        
        if (addPadding) {
            var offset = this.headerMenuButtonWidth + 1,
                arrow = showSortArrow ? this.getSortArrowImage(fieldNum) : null,
                numeral = showSortNumeral ? this.getSortNumeralHTML(fieldName, sortIndex, 
                              isRTL ? "margin-right:4px" : "margin-left:4px") : null
            ;
            if (arrow || numeral) {
                fullTitle.append("<a id='", this._getHeaderButtonSortAnchorID(field),
                                 "' style='display:inline-block;position:absolute;",
                    isRTL ? "left:" : "right:", offset, "px;'>", arrow, numeral, "</a>");
            }
        } else {
            if (showSortNumeral) {
                fullTitle.append("<a style='display:inline-block;",
                    (isRTL ? "float:left;margin-right:" : "float:right;margin-left:"),
                    "4px'>", this.getSortNumeralHTML(fieldName, sortIndex), "</a>");
            }
            if (showSortArrow) {
                fullTitle.append(this.getSortArrowImage(fieldNum, false, false, true));
            }
        }

        fullTitle.append(title);

    } else if (!addPadding && (!clipTitle || !this.clipHeaderTitles) && !rotateTitle) {
        
        fullTitle.append("<div style='display:inline-block;max-width:100%;text-align:", 
                align, ";vertical-align:middle'>");
        fullTitle.append(title);
        if (showSortArrow) fullTitle.append(isc.nbsp, this.getSortArrowImage(fieldNum));
        if (showSortNumeral) {
            fullTitle.append(isc.nbsp, this.getSortNumeralHTML(fieldName, sortIndex));
        }

        // append a spacer after the title text if we're showing the headerMenuButtton for this
        // field. That means that if the title is right-aligned, or if we're auto-fitting the field,
        // we leave space for the headerMenuButton to show without occluding the title.
        if (!clipTitle && button && this.shouldLeaveHeaderMenuButtonSpace(field) &&
            this.shouldShowHeaderMenuButton(button))
        {
            fullTitle.append(isc.Canvas.spacerHTML(this.headerMenuButtonWidth, 1));
        }
        fullTitle.append("</div>");

    } else {
        

        fullTitle.append("<div style='display:inline-block;max-width:100%;text-align:", align,
                         ";vertical-align:");

        // vertical alignment of a rotated title is controlled by LGF.valign
        if (rotateTitle) {
            if      (button.valign == isc.Canvas.TOP)    fullTitle.append("top'>");
            else if (button.valign == isc.Canvas.BOTTOM) fullTitle.append("bottom'>");
            else                                         fullTitle.append("middle'>");
        } else fullTitle.append("middle'>");

        var writeExtraMargin,
            sortHtmlHeight = 0,
            extraRightWidth = 0
        ;
        if (addPadding) {
            var offset = this.headerMenuButtonWidth + 1,
                arrow = showSortArrow ? this.getSortArrowImage(fieldNum) : null,
                numeral = showSortNumeral ? this.getSortNumeralHTML(fieldName, sortIndex,
                              isRTL ? "margin-right:4px" : "margin-left:4px") : null
            ;
            if (arrow || numeral) {
                fullTitle.append("<a style='display:inline-block;position:absolute;",
                    isRTL ? "left:" : "right:", offset, "px;'>", arrow, numeral, "</a>");
            }
        } else {
            writeExtraMargin = isc.Browser.isMoz && !rotateTitle;

            

            if (showSortNumeral) {
                
                var sortNumeralHTMLWidth = (sortIndex >= 9 ? 12 : 6);
                extraRightWidth += 4 + sortNumeralHTMLWidth;
                fullTitle.append("<a style='", isRTL ? "float:left;" : "float:right;");

                // due to the line-height, we don't need the margin for rotated titles unless
                // it's separating the sort arrow and numeral
                if (!rotateTitle || showSortArrow) {
                    fullTitle.append(isRTL ? "margin-right:" : "margin-left:", "4px;");
                }
                
                
                if (rotateTitle && (wrapTitle || isc.Browser.isSafariStrict)) {
                    fullTitle.append("height:12px;");
                    sortHtmlHeight = 12;
                }
                fullTitle.append("width:", sortNumeralHTMLWidth, "px;overflow:hidden'>",
                                 this.getSortNumeralHTML(fieldName, sortIndex), "</a>");
            }
            if (showSortArrow) {
                var img = this.getSortArrowImage(fieldNum, true, true);
                if (img != null) {
                    extraRightWidth += 4 + img.width;
                    fullTitle.append(this.getSortArrowImage(fieldNum, false, clipTitle, 
                                                            wrapTitle, rotateTitle));
                    // adjust the gap discussed above for the sort arrow, if appropriate
                    if (rotateTitle && (wrapTitle || isc.Browser.isSafariStrict)) {
                        sortHtmlHeight = Math.max(sortHtmlHeight, img.height);
                    }
                }
            }
        }
        fullTitle.append("<div");
        var titleClipperID = this._getHeaderTitleClipperID(field);
        if (titleClipperID != null) {
            fullTitle.append(" id='", titleClipperID, "'");
        }
        fullTitle.append(" style='overflow:hidden;", isc.Browser._textOverflowPropertyName,
                         ":ellipsis;white-space:", wrapTitle ? "normal;" : "nowrap;");

        // style the inner titleClipper to create the rotated title
        if (rotateTitle) {

            // vertical alignment of a rotated title is controlled by LGF.valign
            var textVAlign = "center;";
            if      (button.valign == isc.Canvas.TOP)    textVAlign = "right;";
            else if (button.valign == isc.Canvas.BOTTOM) textVAlign = "left;";

            // both "writing-mode" CSS and a CSS rotation transform are required
            var writingMode = this._getTextWritingMode(true, isRTL);
            fullTitle.append("text-align:", textVAlign, this._getTextTransform(true, isRTL), 
                             "writing-mode:", writingMode);

            
            if (isc.Browser.isSafariStrict) {
                fullTitle.append("-webkit-writing-mode:", writingMode);
            }

            
            if (isc.isAn.Instance(button)) {
                var maxHeight = button.getHeight() - button._getVPadding() - sortHtmlHeight;
                if (sortHtmlHeight > 0) {
                    fullTitle.append("margin-top:", sortHtmlHeight, "px;display:block;height:");
                } else {
                    fullTitle.append("display:inline-block;height:");
                }
                fullTitle.append(maxHeight, "px;");

            } else {
                                
            }
        }
        if (writeExtraMargin) {
           fullTitle.append(isRTL ? "margin-left:" : "margin-right:", extraRightWidth, "px;");
        }
        fullTitle.append("'>", title, "</div>", "</div>");
    }

    return fullTitle.release(false);
},

shouldLeaveHeaderMenuButtonSpace : function (field) {
    // is there ever a need to show a menuButton if the item won't show any menuItems?
    if (field.hasMenuItems == false) return false;
    if (this._shouldRotateHeaderMenuButton(field)) return false;
    if (field.leaveHeaderMenuButtonSpace != null) return field.leaveHeaderMenuButtonSpace;
    if (this.leaveHeaderMenuButtonSpace != null) return this.leaveHeaderMenuButtonSpace;
    return field.align != "center";
},

// rotate header menu button iff title is rotated, unless rotateHeaderMenuButton is false
_shouldRotateHeaderMenuButton : function (field) {
    if (this.rotateHeaderMenuButton == false) return false;
    return this.rotateHeaderTitles ? field.rotateTitle != false : !!field.rotateTitle;
},

_setCheckboxHeaderState : function (state, isPartial) {

    // If we're invoked at init time we may not have had our fields set up yet. 
    // no-op if this happens
    if (this.fields == null) {
        return;
    }

    var fieldNum = this.getCheckboxFieldPosition(),
        field = this.fields[fieldNum];

    // sanity check only - this shouldn't happen if we are showing a checkbox field
    if (!this.isCheckboxField(field)) return;
    // if (field._allSelected == state) return;

    var title = (this.canSelectAll == false || this.selectionType == "single") ? isc.nbsp
                 : this._getCheckboxValueIconHTML(state, isPartial, true, false, field);

    this.setFieldTitle(fieldNum, title);
    field._allSelected = state && !isPartial;
    
    field._partialSelected = state && isPartial;
},

updateCheckboxHeaderState : function () {


    
    var data = this.getOriginalData();

    
    var validData = isc.isAn.Array(data) ||
                    (isc.isA.ResultSet(data) && data.allMatchingRowsCached());
    if (!validData) {
        // this.logWarn('Not updating header checkbox as data is not "valid data" ' + 
        //              '(contains unloaded rows, etc)');
        return;
    }

    // calculate allSelected and anySelected record meta properties
    var records = this.isGrouped ? this.getAllRecordsFromGroupTree() : data,
        allSelected = true,
        anySelected = false
    ;
    var _canSelectItem,
        isCellSelectionManager = this.selectionManager.isA("CellSelection");
    // records can occasionally be undefined: http://forums.smartclient.com/node/237223
    if (records != null) {
        for (var i = 0, recordsLength = records.getLength(); i < recordsLength; ++i) {
            var record = records.get(i);
            if (isCellSelectionManager) {
                _canSelectItem = this.canSelectRecord(record);
            } else {
                _canSelectItem = this.selectionManager._canSelectItem(record);
            }
            if (_canSelectItem) {
                if (this.selectionManager.isSelected(record)) {
                    anySelected = true;
                    if (!allSelected) break;
                } else {
                    allSelected = false;
                    if (anySelected) break;
                }
            }
        }
    }
    // apply allSelected and anySelected properties, as appropriate
    var showPartial = this.showHeaderPartialSelection,
        state = anySelected && (allSelected || (showPartial != false && anySelected)),
        isPartial = showPartial != false ? anySelected && !allSelected : false
    ;
    this._setCheckboxHeaderState(state, isPartial);
},

defaultHeaderHoverHTML : function (fieldNum) {
    var field = this.fields[fieldNum];
    if (field == null) return null;
    if (field.prompt != null) return field.prompt;

        
    var showTitle = this.clipHeaderTitles && this.showClippedHeaderTitlesOnHover &&
                    this.headerTitleClipped(fieldNum);
    
    if (showTitle) {
        return field.headerTitle != null ? field.headerTitle
                                     : this.getFieldTitle(fieldNum);
    }
    return null;
},

//> @method listGrid.headerHoverHTML() (A)
// Returns the HTML that is displayed by the default +link{ListGrid.headerHover(),headerHover}
// handler. Return null or an empty string to cancel the hover.
// <smartgwt><p>Use <code>setHeaderHoverFormatter()</code> to provide a custom
// implementation.</smartgwt>
//
// @param fieldNum (number) field number for the header that was hovered
// @param defaultHTML (HTMLString) the HTML that would have been displayed by default
// @return (HTMLString) HTML to be displayed in the hover. If null or an empty string, then the hover
// is canceled.
// @see attr:ListGrid.showClippedHeaderTitlesOnHover
// @see attr:ListGrid.clipHeaderTitles
// @group hovers
// @group gridHeader
// @visibility external
//<
headerHoverHTML : function (fieldNum, defaultHTML) {
    return defaultHTML;
},

//> @attr listGrid.headerHoverStyle (CSSStyleName : null : IRW)
// This property may be set to customize the css style for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverAlign (Alignment : null : IRW)
// This property may be set to customize the alignment for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverVAlign (VerticalAlignment : null : IRW)
// This property may be set to customize the vertical alignment for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverOpacity (Integer : null : IRW)
// This property may be set to customize the opacity for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverHeight (Integer : null : IRW)
// Optional default height for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverWidth (Integer : null : IRW)
// Optional default width for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

//> @attr listGrid.headerHoverWrap (Boolean : null : IRW)
// This property may be set to customize the <code>wrap</code> attribute for the
// hover shown on +link{ListGrid.headerHover()}.
// @visibility external
//<

_showHeaderHover : function (fieldNum, HTML) {
    var field = this.fields[fieldNum];
    if (HTML && !isc.is.emptyString(HTML)) {
        var properties = this._getHeaderHoverProperties(field);
        isc.Hover.show(HTML, properties, (field.hoverRect || this.headerHoverRect));
    } else isc.Hover.clear();
},

_getHeaderHoverProperties : function (field) {
    var props = {};
    if (field) {
        props = isc.addProperties({}, {
            align: (field.hoverAlign != null ? field.hoverAlign : this.headerHoverAlign),
            baseStyle: (field.hoverStyle != null ? field.hoverStyle : this.headerHoverStyle),
            height: (field.hoverHeight != null ? field.hoverHeight : this.headerHoverHeight),
            hoverDelay: (field.headerHoverDelay != null ? field.headerHoverDelay :
                        field.hoverDelay != null ? field.hoverDelay : this.headerHoverDelay),
            moveWithMouse: (field.hoverMoveWithMouse != null ? field.hoverMoveWithMouse :
                        this.headerHoverMoveWithMouse),
            opacity: (field.hoverOpacity != null ? field.hoverOpacity : this.headerHoverOpacity),
            valign: (field.hoverVAlign != null ? field.hoverVAlign : this.headerHoverVAlign),
            width: (field.hoverWidth != null ? field.hoverWidth : this.headerHoverWidth),
            wrap: (field.hoverWrap != null ? field.hoverWrap : this.headerHoverWrap),
            autoFitWidth: this.hoverAutoFitWidth,
            autoFitMaxWidth: this.hoverAutoFitMaxWidth
        });
    } else {
        props = isc.addProperties({}, {
            align: this.headerHoverAlign,
            baseStyle: this.headerHoverStyle,
            height: this.headerHoverHeight,
            hoverDelay: this.headerHoverDelay,
            moveWithMouse: this.headerHoverMoveWithMouse,
            opacity: this.headerHoverOpacity,
            valign: this.headerHoverVAlign,
            width: this.headerHoverWidth,
            wrap: this.headerHoverWrap,
            autoFitWidth: this.hoverAutoFitWidth,
            autoFitMaxWidth: this.hoverAutoFitMaxWidth
        });
    }

    return props;
},

// _headerClick - maps the local fieldNum within the header to the master index before
// calling the public headerClick method
_headerClick : function (headerFieldNum, header) {
    var fieldNum = header.getMember(headerFieldNum).masterIndex;
    //this.logWarn("click on field: " + headerFieldNum + " in header: " + header +
    //             " maps to field: " + fieldNum);
    return this.headerClick(fieldNum, header);
},

//> @method listGrid.headerClick()  (A)
// Handle a click in the list header.
// <P>
// By default, calls +link{sort()} to sort by the field that was clicked, if
// +link{listGrid.canSort,sorting is enabled}, and calls +link{autoFitField()} if
// +link{canAutoFitFields} is true and +link{headerAutoFitEvent} is set to <code>"click"</code>.
//
// @param fieldNum (number) field number for the header that was clicked
// @group sorting
// @group events
// @group gridHeader
// @visibility external
//<
headerClick : function (fieldNum, header) {
    //>EditMode
    if (this.editingOn && this.editProxy && this.editProxy.headerClick) {
        this.editProxy.headerClick(fieldNum, header);
        return;
    }
    //<EditMode

    // 'onHeaderClick' stringMethod can intercept the header click
    
    if (this.onHeaderClick && (this.onHeaderClick(fieldNum,header) == false)) {
        return;
    }

    var field = this.fields[fieldNum];
    // check if the checkbox column header was clicked
    if (this.isCheckboxField(field) && this.selectionType != "single" && this.canSelectAll != false) {
        if (field._allSelected || (field._partialSelected && this.deselectOnPartialCheckboxClick)) {
            this.deselectAllRecords();
            this._setCheckboxHeaderState(false);
        } else {
            this.userSelectAllRecords();
            // Note that due to canSelectRecord() this may not actually select all
            // so call the method to determine whether the checkboxHeaderState should
            // be checked or not.
            this.updateCheckboxHeaderState();
        }
        return false;
    }

    // If canAutoFit is true, autoFit the field on click if headerAutoFitEvent is 'click'
    if (field && this.canAutoFitField(field) && this.headerAutoFitEvent == "click") {
        this.autoFitField(fieldNum);
    }

    // if the list's canSort is false, the field wasn't defined or the field's 'canSort' property is
    // false, return false
    if (!this._canSort(field)) return false;

    var fieldName = field[this.fieldIdProperty],
        specifier = this.isSortField(fieldName) ? this.getSortSpecifier(fieldName) : null,
        EH = isc.EventHandler,
        key = EH.getKey(),
        shiftDown = EH.shiftKeyDown(),
        globalSortDir = this._baseSortDirection,
        sortDir = field.sortDirection
    ;

    // if the menu was displayed (_showingHeaderContextMenu is true), don't also sort
    if (!this._showingHeaderContextMenu) {
        if (shiftDown && this._canMultiSort() && this._canSortData(field)) {
            // add this field to the sort-configuration, or alter it if it's already sorted
            if (this.isSortField(fieldName)) {
                if (sortDir == globalSortDir || this.canUnsort == false) {
                    // reverse the sort-direction of this field
                    this.toggleSort(fieldName);
                } else {
                    // unsort the field - if this is the only sorted field, or the last field in
                    // a multiSort arrangement, no visual resort will occur - otherwise, a visual
                    // resort occurs to reapply remaining sort-specifiers
                    this.toggleSort(fieldName, "unsort");
                }
            } else {
                // add this field to the sort-configuration
                this._addSort(field);
            }
        } else {
            if (this.isSortField(fieldName) && this.getSortFieldCount() == 1) {
                if (sortDir == globalSortDir || this.canUnsort == false) {
                    // toggle the sortDirection on this field
                    this.toggleSort(fieldName);
                } else {
                    // unsort this field
                    this.toggleSort(fieldName, "unsort");
                }
            } else {
                var fieldSortDir = this._getFieldSortDirection(field);
                this.setSort([{
                    property: fieldName,
                    direction: fieldSortDir
                }]);
            }
        }
    }

    // return false to stop further event processing
    // if we don't do this, clicks in the header will sometimes select items in the list
    return false;
},

// _headerDoubleClick - maps the local fieldNum within the header to the master index before
// calling the public headerDoubleClick method
_headerDoubleClick : function (headerFieldNum, header) {
    if (this.data && this.data.lengthIsKnown && !this.data.lengthIsKnown()) {
        // we only want to run auto-sizing code if the data has already arrived - bail now
        // and set a flag to have dataArrived re-run do the auto-sizing
        this._autoSizeOnDataArrived = true;
        this._autoSizeHeaderFieldNum = headerFieldNum;
        this._autoSizeHeader = header;
        return;
    }
    return this.headerMenuButtonDoubleClick();
},



//> @method listGrid.headerDoubleClick()    (A)
// Handle a double click in the list header.
// <P>
// By default, calls +link{autoFitField()} if +link{canAutoFitFields} is true and
// +link{headerAutoFitEvent} is <code>"doubleClick"</code>.
//
// @param fieldNum (number) field number for the header that was clicked
// @group events
// @group gridHeader
// @visibility external
//<
headerDoubleClick : function (fieldNum, header) {

    var field = this.fields[fieldNum];
    if (this.isCheckboxField(field)) return;

    // If canAutoFit is true, autoFit the field on click if headerAutoFitEvent is 'doubleClick'
    if (field && this.canAutoFitField(field) && this.headerAutoFitEvent == "doubleClick") {
        this.autoFitField(fieldNum);
    }

    // return false to stop further event processing
    return false;
},

// Field Drag Resize
// --------------------------------------------------------------------------------------------

//> @method listGrid.fieldDragResizeStart() (A)
// Event sent when header column starts drag-resizing.
// <p>
// Current implementation creates a drag line and sizes it to the height of the list body.
// <p>
// Observed from this.header.dragResizeStart()
//
//      @group  dragging
//<
fieldDragResizeStart : function () {
    this._dragResizingField = true;
    // Turn off the logic that expands one field to fill the viewport if autoFitFields is
    // enabled
    
    this.autoFitFieldsFillViewport = false;
    // make sure the drag line is set up
    this.makeDragLine();

    // and resize it to cover the entire height of the listGrid
    this._dragLine.resizeTo(2,
         this.getVisibleHeight() - (this.body.hscrollOn ? this.body.getScrollbarSize() : 0));

    // set the overflow of the header being dragged to hidden so that the user can clip the title
    // text if he chooses.
    var dt = this.ns.EH.dragTarget;

    // ensure we no longer attempt to autoFit
    var field = this.getField(dt.masterIndex);
    if (field) {
        field.autoFitWidth = false;
        
        var wrap = this._getHeaderButtonWrap(field);
        if (wrap != dt.wrap) {
            dt.setWrap(wrap);
        }
    }

    dt.setWidth(dt.getVisibleWidth());
    dt.setOverflow("hidden");
},

//> @method listGrid.fieldDragResizeMove()  (A)
//      Event sent when header column is drag-resizing.
//
//      Current implementation moves the dragLine to show the new boundary.
//
//      Observed from this.header.dragResizeMove()
//      @group  dragging, drawing
//<
fieldDragResizeMove : function () {
    var EH = this.ns.EH,
        resizingField = EH.dragTarget;

    if (this.autoSizeHeaderSpans != null) {
        this._autoSizeHeaderSpans = this.autoSizeHeaderSpans;
        this.autoSizeHeaderSpans = false;
    }

    // move the drag line to show the new field boundary
    var colNum = this.header._resizePosition;
    this.showDragLineForField(colNum);
    // if we're supposed to resize fields as they're dragging
    if (this.resizeFieldsInRealTime) {
        this.realtimeFieldResize(colNum);
    }

    

    // make sure that the header menu button snapOffsetLeft is 0 to prevent the user from
    // seeing an offset if the column is narrowed to the point where an offset is unnecessary.
    if (this.headerMenuButton && this.headerMenuButton.snapOffsetLeft != 0) {
        this.headerMenuButton.setSnapOffsetLeft(0);
    }
},

realtimeFieldResize : function (colNum) {

    // change the width of the field and redraw
    var EH = isc.EH,
        width = EH.dragResizeWidth,
        minWidth = this.getMinFieldWidth(this.fields[colNum], true);
    // Disallow shrinking below minWidth
    if (width < minWidth) width = minWidth;

    this._fieldWidths[colNum] = width;

    

    // Ensure the body's h-scroll position is synced with that of the header before
    // resizing body fields
    
    if (this._delayingBodyScrolling) {
        this.syncBodyScrolling();
    }


    this._settingBodyFieldWidths = true;
    this.setBodyFieldWidths(this._fieldWidths);
    // While resizing fields in real time we want the body's incremental rendering system
    // to use the 'quick' draw ahead ratio.
    this.body.useQuickDrawAheadRatio = true;
    this.body.redraw("fieldDragResize");
    delete this.body.useQuickDrawAheadRatio;
    delete this._settingBodyFieldWidths;

    // if we're scrolled, as the body shrinks it's scroll position may become invalid,
    // so it scrolls back, and the header needs to match
    
    if (!this.isRTL()) {
        var bodyScrollLeft = this.body.getScrollLeft();
        if (bodyScrollLeft > 0) {
            this.header.scrollTo(bodyScrollLeft, null, "headerResize");
        }

    
    } else {
        if (this.header.getScrollLeft() < this.header.getLeft()) {
            this.header.scrollTo(this.header.getLeft());
        }
    }
},

//> @method listGrid.fieldDragResizeStop()  (A)
//      Event sent when header column is done drag-resizing.
//
//      Current implementation hides the dragLine.
//
//      Observed from this.header.dragResizeStop()
//      @group  dragging, drawing
//<
fieldDragResizeStop : function () {
    if (this._autoSizeHeaderSpans != null) {
        this.autoSizeHeaderSpans = this._autoSizeHeaderSpans;
        delete this._autoSizeHeaderSpans;
    }

    this.hideDragLine();
},



// Reorder / Resize Field APIs
// --------------------------------------------------------------------------------------------

headerDragReordered : function (fieldNum, moveToPosition, header) {
    var masterFieldNum = header.getMember(fieldNum).masterIndex,
        masterMoveToPosition = header.getMember(moveToPosition).masterIndex;
    //this.logWarn("reorder of header field from " + fieldNum +
    //             " to " + moveToPosition + " on header: " + header +
    //             " will move master field from " + masterFieldNum +
    //             " to : " + masterMoveToPosition);
    this.reorderField(masterFieldNum, masterMoveToPosition);
},

//> @method listGrid.reorderField() (A)
// Reorder a particular field
//
// @param   fieldNum        (number)    Number of the field to reorder
// @param   moveToPosition  (number)    New position for that field
//
// @visibility external
//<
reorderField : function (fieldNum, moveToPosition) {
    this.reorderFields(fieldNum, fieldNum+1, moveToPosition - fieldNum);
},

//> @method listGrid.reorderFields()    (A)
// Reorder a set of adjacent fields, from start to end exclusive at the end, by distance
// moveDelta.<br><br>
//
// NOTE: start and end coordinates are in terms of the currently visible fields, not the full set of
// fields.
//
// @param    start     (number) Start of the range of fields to move, inclusive
// @param    end       (number) End of the range of fields to move, non-inclusive
// @param    moveDelta (number) Distance to move by
//
// @visibility external
//<
reorderFields : function (start, end, moveDelta) {

    // Note this method is public and can be called programmatically - avoid crashing
    // if various things that get set up on draw, such as _fieldWidths or filterEditor aren't
    // yet present.

    // reorder the fields in the filterEditor if showing
    
    if (this.showFilterEditor && this.filterEditor != null) {
        this.filterEditor.reorderFields(start, end, moveDelta);
    }

    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow.reorderFields(start,end,moveDelta);
    }

    var startField = this.fields[start],
        endField = this.fields[end -1],
        targetIndex = start + moveDelta,
        targetField = this.fields[targetIndex];


    // preserve the sorted field
    var sortFieldNum = this._getSortFieldNum(),
        sortField = this.fields[sortFieldNum];
    // reorder the field widths for the moved field range
    if (this._fieldWidths != null) this._fieldWidths.slideRange(start, end, start+moveDelta);


    // update this.completeFields, rather than this.fields.
    // Note that we may have hidden fields, so we have to recalculate start, end and target.
    if (this.completeFields == null) this.setFields(this.fields);
    if (this.completeFields.contains(targetField)) {
        var cfStart = this.completeFields.indexOf(startField),
            cfEnd = this.completeFields.indexOf(endField) + 1,
            cfTargetIndex = this.completeFields.indexOf(targetField);
        //this.logWarn("start, end, targetIndex of: " + [start,end,targetIndex] +
        //             " translated to: " + [cfStart, cfEnd, cfTargetIndex] +
        //             " fields: " + this.completeFields.getProperty("name"));
        this.completeFields.slideRange(cfStart, cfEnd, cfTargetIndex);
        //this.logWarn("after slideRange, fields: " +
        //             this.completeFields.getProperty("name"));
    }

    // set the visibleFields based on newly reordered complete set of fields
    this.deriveVisibleFields();

    // update the sortFieldNum to reflect the slide
    if (sortFieldNum != null) {
        sortFieldNum = this.fields.indexOf(sortField);
        // field no longer visible
        if (sortFieldNum == -1) sortFieldNum = null;
        this._setSortFieldNum(sortFieldNum);
    }

    // find the header for this field
    var header;

    if (!this.frozenFields) {
        header = this.getFieldHeader(start);
        // reorder the header items
        if (header) {
            header.reorderItems(this.getLocalFieldNum(start), this.getLocalFieldNum(end),
                                this.getLocalFieldNum(start+moveDelta));
        }

    } else {
        // for frozen fields, just rebuild for freeze
        
        header = this.getFieldHeader(start);
        this.rebuildForFreeze();
        // re-sync the header with the current position of the body
        this.syncHeaderScrolling(this.body.getScrollLeft());
    }

    // tell that toolbar button to show the sort
    if (sortFieldNum != null && header && this.selectHeaderOnSort) {
        this.selectSortFieldHeaderButton();
    }

    // if necessary, preserve the edit field
    var editorShowing = this._editorShowing;
    if (editorShowing) {
        // If the editor is showing, we will need to update the editForm in 2 ways:
        // - the colNum property for each item must be updated
        // - the form items should be reordered so the items are in order wrt to the new
        //   field order.
        // When this has been accomplished, we can rely on the body redraw to handle writing
        // out the appropriate HTML, setting the values of the form items, and updating focus
        // if required.
        var editForm = this._editRowForm,
            editRowNum = this.getEditRow(),
            editField = this.getEditField(),
            newItemsArray = []
        for (var i = 0; i < editForm.items.length; i++) {
            var item = editForm.items[i];
            item.colNum = this.fields.findIndex(this.fieldIdProperty, item.getFieldName());
            for (var j = 0; j <= newItemsArray.length; j++) {
                if (newItemsArray[j] == null || newItemsArray[j].colNum > item.colNum) {
                    newItemsArray.addAt(item, j);
                    break;
                }
            }
        }

        // Update the items array to match the reordered version of itself
        editForm.items.setArray(newItemsArray);
        // Update the 'editColNum' to reflect the repositioned edit field.
        this._editColNum = this.fields.indexOf(editField);
    }

    // We want to remap embedded components to catch the cell change
    // for any components embedded by cell.
    // Note we don't expect a simple reorder of fields to impact frozen/unfrozen
    // state so we need to update either the frozen or unfrozen body embedded
    // columns only
    var body = this.body;
    if (this.frozenFields && start < this.frozenFields.length) {
        body = this.frozenBody;
    }

    if (body) {
        // this may not all be necessary if we rebuilt for freeze.
        this.body.fields = this.normalFields || this.fields;
        if (this.frozenBody) this.frozenBody.fields = this.frozenFields;

        // give the bodies the reordered field widths
        this.setBodyFieldWidths(this._fieldWidths);

        if (body._embeddedComponents != null) {
            this._remapEmbeddedComponentColumns(body);
        }

        // redraw (may be required if fields had matching widths)
        if (!body.isDirty()) this._markBodyForRedraw("reorderFields");
    }

    
    if (this.showFilterEditor && this.filterEditor != null && !this._shouldLeaveScrollbarGap())
    {
        var nFields = this.fields.length;
        if (end == nFields || end + moveDelta == nFields) {
            this.filterEditor.sourceWidgetFieldsResized();
        }
    }
    this.handleFieldStateChanged();
},

// Ensure that the .colNum property is up to date on our editors

remapEditFieldsForFreeze : function () {
    if (this._editorShowing) {
        var form = this.getEditForm(),
            items = form.getItems();
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            item.colNum = this.fields.findIndex(this.fieldIdProperty, item.getFieldName());
            var field = this.fields[item.colNum];

            if (!this._suppressedFrozenFields && field.frozen) item.containerWidget = this.frozenBody;
            else item.containerWidget = this.body;
        }
    }
},

headerDragResized : function (fieldNum, newWidth, header) {
    var masterFieldNum = header.getMember(fieldNum).masterIndex;
    // this.logWarn("resize of header field: " + fieldNum + " on header: " + header +
    //             " will resize master fieldNum: " + masterFieldNum);

    // Once the user has drag resized a field in the grid, we'll reflow to 
    // accommodate the new size.
    // Temporarily suppress *all* dynamic sizing for any fields.
    // In other words, don't reflow "*"/"%" sized fields, or autoFit fields.
    // This means if autoFitHeaderHeights is true, and the horizontal resize of
    // a header changed wrapping, we may end up changing the height of the
    // header as a whole. We don't want the toolbar to then jarringly rerun layout
    // policy logic and change things from your dragged size(s).
    // However make this temporary! If the widget as a whole resizes subsequently,
    // we want the "*" etc sizes to be recalculated
    
    for (var i = 0; i < this.fields.length; i++) {
        if (i == masterFieldNum) continue;
        this.fields[i]._origWidth = this.fields[i].width;
        this.fields[i]._origAutoFit = this.fields[i].autoFitWidth
        this.fields[i].width = this.getFieldWidth(i);
        this.fields[i].autoFitWidth = false;
        var button = this.getFieldHeaderButton(i);
        if (button) {
            button._prevUserWidth = button._userWidth;
            button.updateUserSize(this.fields[i].width, this._$width);
        }
    }
    this.resizeField(masterFieldNum, newWidth, true);
    // Reset dynamic sizes ("*", "n%", etc) so subsequent reflows will respect them.
    for (var i = 0; i < this.fields.length; i++) {

        if (i == masterFieldNum) continue;

        this.fields[i].width = this.fields[i]._origWidth;
        delete this.fields[i]._origWidth;

        this.fields[i].autoFitWidth = this.fields[i]._origAutoFit
        delete this.fields[i]._origAutoFit;

        var button = this.getFieldHeaderButton(i);
        if (button) {
            button.updateUserSize(button._prevUserWidth, this._$width);
            delete button._prevUserWidth;
        }
    }

    // clear the _dragResizingField flag set up on drag start and ensure scrolling is
    // all in sync
    this._dragResizingField = false;
    var left = this.body.getScrollLeft();
    this.syncHeaderScrolling(left, top);
    this.syncFilterEditorScrolling(left, top);
    this.syncSummaryRowScrolling(left,top);



},

//> @method ListGrid.setCanResizeFields()
// Setter method for updating +link{ListGrid.canResizeFields} at runtime.
// @param canResize (boolean) new value for this.canResizeFields
// @visibility external
//<
setCanResizeFields : function (canResize) {
    if (this.canResizeFields == canResize) return;
    this.canResizeFields = canResize;
    if(canResize==false) this.canAutoFitFields=false;
    if (this.header) this.header.setCanResizeItems(canResize);
    if (this.frozenHeader) this.frozenHeader.setCanResizeItems(canResize);
    if (this.headerMenuButton) this.headerMenuButton.canDragResize = canResize;
    if (canResize) {
        if (this.header && !this.header.dontObserve) this._observeHeaderResize(this.header);
        if (this.frozenHeader && !this.frozenHeader.dontObserve)
            this._observeHeaderResize(this.frozenHeader);
    } else {
        if (this.header) this._ignoreHeaderResize(this.header);
        if (this.frozenHeader) this._ignoreHeaderResize(this.frozenHeader);
    }
},

_observeHeaderResize : function (header) {
    this.observe(header, "itemDragResized", function (itemNum, newSize) {
        this.headerDragResized(itemNum, newSize, header);
    });
    this.observe(header, "dragResizeMemberStart", function () { this.fieldDragResizeStart(); });
    this.observe(header, "dragResizeMemberMove", function () { this.fieldDragResizeMove(); });
    this.observe(header, "dragResizeMemberStop", function () { this.fieldDragResizeStop(); });
},

_ignoreHeaderResize : function (header) {
    if (this.isObserving(header, "itemDragResized"))
        this.ignore(header,"itemDragResized");
    if (this.isObserving(header, "dragResizeMemberStart"))
        this.ignore(header, "dragResizeMemberStart");
    if (this.isObserving(header, "dragResizeMemberMove"))
        this.ignore(header, "dragResizeMemberMove");
    if (this.isObserving(header, "dragResizeMemberStop"))
        this.ignore(header, "dragResizeMemberStop");
},

//> @method listGrid.resizeField()  (A)
// Resize a particular field to a new width. Note that this method
// will also set +link{listGridField.autoFitWidth} to false if it was previously true.
//
// @param   fieldNum    (number)    Number of the field to resize
// @param   newWidth    (number)    New width of the field
//
// @visibility external
//<
// @param storeWidth (boolean) Additional internal parameter - should we update field.width?
//  Updating field.width means if setFields() is called after init with an overlapping set
//  of field objects (typical use case: showing / hiding fields) - we retain the width set here.
//  Otherwise we resize the field but don't store the new width value
resizeField : function (fieldNum, newWidth, storeWidth) {
    this._resizeFields([fieldNum], [newWidth], [storeWidth]);
},
_resizeFields : function (fieldNums, newWidths, storeWidths) {
    for (var i = 0; i < fieldNums.length; i++) {
        var fieldNum = fieldNums[i];
        if (!isc.isA.Number(fieldNum)) fieldNum = this.getFieldNum(fieldNum);
        if (fieldNum == -1) {
            fieldNums.removeAt(i);
            newWidths.removeAt(i);
            storeWidths.removeAt(i);
            i--;
        } else {
            // store the normalized value in case we were passed a name
            fieldNums[i] = fieldNum;

            var minWidth = this.getMinFieldWidth(this.fields[fieldNum], true);
            if (minWidth > newWidths[i]) {
                newWidths[i] = minWidth;
            }
        }
    }
    if (fieldNums.length == 0) return;

    // adjust the header for this field, if we have a header
    var adjustHeader = this.header && this.header.isDrawn();
    if (adjustHeader) {
        // Suppress instant relayout of the header for each field we resize
        
        var instantRelayout = this.header.instantRelayout,
            frozenInstantRelayout = this.frozenHeader ? this.frozenHeader.instantRelayout
                                                        : null;
        this.header.instantRelayout = false;
        if (this.frozenHeader) this.frozenHeader.instantRelayout = false;
    }

    // This flag prevents headerButtonResized from attempting to reflow the header, etc
    // to the resize.
    
    this._settingHeaderFieldWidths = true;
    for (var i = 0; i < fieldNums.length; i++) {
        var fieldNum = fieldNums[i],
            newWidth = newWidths[i];
        if (adjustHeader) {
            var header = this.getFieldHeader(fieldNum),
                headerFieldNum = this.getLocalFieldNum(fieldNum);

            
            header.getMember(headerFieldNum).setOverflow("hidden");
            header.getMember(headerFieldNum).setWidth(newWidth);
        }

        var storeWidth = storeWidths[i];
        if (storeWidth == null || storeWidth) {
            this.fields[fieldNum].width = newWidth;
            this.fields[fieldNum].autoFitWidth = false;
            // tag the user's chosen width as userResizeWidth - for use by getStateForField()
            this.fields[fieldNum].userResizeWidth = newWidth;
        }

        // update the body column widths
        if (this._fieldWidths != null) {
            this._fieldWidths[fieldNum] = newWidth;
        }
    }
    delete this._settingFieldWidths;

    if (adjustHeader) {

        this.header.instantRelayout = instantRelayout;
        this.header.reflowNow("resized headers");
        if (this.frozenHeader) {
            this.frozenHeader.instantRelayout = frozenInstantRelayout;
            this.frozenHeader.reflowNow("resized headers");
        }
    }

    // don't crash if not drawn
    if (!this.isDrawn()) return;

    this._settingBodyFieldWidths = true;
    this.setBodyFieldWidths(this._fieldWidths);
    


    // force an immediate redraw of the body - this will enable us to check the
    // _settingBodyFieldWidths flag in updateFieldWidths
    
    if (this.body.isDirty()) {
        this.body.redraw("setting body field widths");
    }
    delete this._settingBodyFieldWidths;

    // Field widths can effect rendered heights of titles due to wrapping/reflow
    // if we're autoFitting to header heights we may need to recalculate now.
    
    if (!this._autoFittingFields && this.header && this.autoFitHeaderHeights) {
        this.dropCachedHeaderButtonHeights();
        this._updateHeaderHeight();
    }
    if (this.isRTL() && this.header != null) {
        this.syncBodyScrolling();
    }

    if (this.showFilterEditor && this.filterEditor) {
        this.filterEditor.sourceWidgetFieldsResized();
    }
    if (this.summaryRow && this.showGridSummary) {
        this.summaryRow._resizeFields(fieldNums, newWidths, storeWidths);
    }


    // fire handleFieldStateChanged() -> fieldStateChanged() / viewStateChanged()
    this.handleFieldStateChanged(true);
},

// Sorter (corner button)
// --------------------------------------------------------------------------------------------

// should we draw the corner sort button in the header?
_showSortButton : function () {
    var showSort = this.showSortArrow;
    if (showSort != null) {
        return (showSort == isc.ListGrid.CORNER || showSort == isc.ListGrid.BOTH);
    }
    // If we haven't been explicitly set to show the corner sort button, show it if we're
    // leaving a gap for the scrollbar.
    return this._shouldLeaveScrollbarGap();
},

// predictScrollbarGap - internal but non obfuscated flag - if true, when leaveScrollbarGap is false
// we predict whether the body will show a vertical scrollbar based on cellHeight and number of
// rows.
// This allows us to render the body at the appropriate width to accommodate a vertical scrollbar
// rather than waiting for the vertical scrollbar to be rendered (which may also introduce a
// horizontal scrollbar), then resizing.
predictScrollbarGap:true,

_shouldLeaveScrollbarGap : function (vscrollOn) {

    
    if (this.body && this.body.suppressScrollbarGap) return false;

    var verticalAutoFit = (this.autoFitData == isc.Canvas.VERTICAL || this.autoFitData == isc.Canvas.BOTH);
    if (this.leaveScrollbarGap && !verticalAutoFit) return true;
    if (!this.body || this.isEmpty()) return false;

    
    if (vscrollOn == null) vscrollOn = this.body.vscrollOn;
    if (vscrollOn) return true;

    var body = this.body,
        
        headerHeight = this.getHeaderHeight(),
        
        bodyHeight = this.getInnerHeight() - this.body.getVMarginBorder() -
                        (this.showHeader ? headerHeight : 0);

    // exception case - when we're auto-fitting to content the body will be allowed to expand
    if (verticalAutoFit) {
        bodyHeight = (this.getTotalRows() * this.cellHeight);
        var maxHeight = this.getAutoFitMaxBodyHeight();
        if (maxHeight && maxHeight < bodyHeight) {
            bodyHeight = maxHeight;
        }
        if (this.autoFitMaxRows && (this.autoFitMaxRows * this.cellHeight) > bodyHeight) {
            bodyHeight = (this.autoFitMaxRows * this.cellHeight);
        }
    }
//     this.logWarn("predicting gap: bodyHeight: " + bodyHeight +
//                  ", rows: " + this.getTotalRows() +
//                  ", rowsHeight: " + (this.getTotalRows() * this.cellHeight))

    
    if (bodyHeight <= 0) return false;

    return this.predictScrollbarGap && this.bodyOverflow == isc.Canvas.AUTO &&
           (this.getTotalRows() * this.cellHeight > bodyHeight);
},

// The sorter is implemented as a child (not a member) that we float at the right edge of the
// header (Which we size small enough to accommodate it).

getSorterTop : function () {
    
    return (this.headerLayout || this.header).getTop();
},
getSorterLeft : function () {
    if (this.isRTL()) {
        return this.getLeftMargin() + this.getLeftBorderSize() + this.getLeftPadding();
    } else {
        // clamp the sorter to the right of the header (or header-layout)
        var headerLayout = (this.headerLayout || this.header);
        var left = headerLayout.getWidth() + headerLayout.getLeft() - this._getSorterWidth();
        if (this._shouldLeaveScrollbarGap()) {
            left += this.body != null ? this.body.getScrollbarSize() : this.getScrollbarSize();
        }
        return left;
    }
},

_getSorterWidth : function (recompute) {
    var sorter = this.sorter;
    if (recompute || sorter == null) {
        var scrollbarSize = this.body != null ? this.body.getScrollbarSize() : this.getScrollbarSize(),
            sorterWidth;
        if (scrollbarSize <= 0) sorterWidth = 16;
        else sorterWidth = Math.max(5, scrollbarSize);
        return sorterWidth;
    } else {
        return sorter.getWidth();
    }
},

//> @method listGrid.makeCornerSortButton() (A)
// Make the sorter button
// @group drawing
//<
makeCornerSortButton : function () {
    

    this.sorter = this.createAutoChild("sorter",
        isc.addProperties(this.getButtonProperties(),
            // Explicitly lay sorterDefaults on top of the buttonProperties.
            // If we didn't do this, sorterDefaults would be picked up as defaults but would
            // be overridden by the standard button properties, which means headerDefaults
            // would override sorterDefaults for the button
            this.sorterDefaults,
            {
                ID:this.getID()+"_sorter",
                width:this._getSorterWidth(),
                height:this.getHeaderHeight(),
                
                backgroundColor:this.headerBackgroundColor,
                imgDir:this.widgetImgDir,
                visibility:(this._showSortButton() ? isc.Canvas.INHERIT : isc.Canvas.HIDDEN),
                ariaState: { label: this.sorterButtonTitle },

                // Only allow tabbing to the corner sort button if explicitly requested via
                // canTabToSorter
                
                tabIndex: this.canTabToSorter ? null :-1,
                
                canHover: true,
                getHoverHTML: isc._makeFunction("return " + this.getID() + ".getFieldCriteriaHover()"),
                hoverWrap: true,
                hoverAutoFitWidth: true,
                hoverAutoFitMaxWidth: 300
            }
        )
    );

    if (this.showHeaderShadow && this.sorter.shouldUseCSSShadow()) {
        this.sorter.showShadow = true;
        
        if (this.headerShadowHOffset != null) {
            this.sorter.shadowHOffset = this.headerShadowHOffset;
        }
        if (this.headerShadowVOffset != null) {
            this.sorter.shadowVOffset = this.headerShadowVOffset;
        }
        if (this.headerShadowSoftness != null) {
            this.sorter.shadowSoftness = this.headerShadowSoftness;
        }
        if (this.headerShadowColor != null) {
            this.sorter.shadowColor = this.headerShadowColor;
        }        
    }
    this.addChild(this.sorter, "sorter", false);
},

//> @method listGrid.sorterContextClick() (A)
// Notification method fired when the user right-clicks on the corner
// +link{listGrid.sorterConstructor, sort button}.  Return false to suppress the default
// behavior of showing the sorter's context menu.
//
// @return (boolean) return false to suppress the context menu
// @group events, sorting
// @visibility external
//<

_sorterContextClick : function () {
    // Returning false from sorterContextClick suppresses both the
    // custom context menu and the native context menu
    
    if (this.sorterContextClick && !this.sorterContextClick()) return false;

    var showContextMenu = this.showHeaderContextMenu;
    //>!BackCompat 2007.02.02
    // If the old showCornerContextMenu attr is defined, have it take precedence
    if (this.showCornerContextMenu != null) showContextMenu = this.showCornerContextMenu;
    //<!BackCompat
    if (showContextMenu) return this.displayHeaderContextMenu(this.sorter);
},

// if the header context menu is enabled, also show it on the headerBar
headerBarContextClick : function (header) {
    var showContextMenu = this.showHeaderContextMenu;
    //>!BackCompat 2007.02.02
    // If the old showCornerContextMenu attr is defined, have it take precedence
    if (this.showCornerContextMenu != null) showContextMenu = this.showCornerContextMenu;
    //<!BackCompat
    if (showContextMenu && (isc.EH.isKeyEvent() || header.containsEvent())) {
        var index = isc.EH.isKeyEvent() ? header.getFocusButtonIndex() :
                                          header.getMouseOverButtonIndex();
        return this.displayHeaderContextMenu(header.getMember(index));
    }
},

headerSpanContextClick : function (span) {
    var menuItems = this.getHeaderSpanContextMenuItems(span);
    if (!menuItems || menuItems.length == 0) return false;
    if (!this.spanContextMenu) {
        this.spanContextMenu = this.createAutoChild(
            "spanContextMenu",
            {
                items: menuItems,
                autoFitFieldWidths: true
            },
            this.getMenuConstructor());
    } else {
       this.spanContextMenu.setItems(menuItems);
    }
    this.spanContextMenu.showContextMenu();
    return false;
},


//> @method ListGrid.displayHeaderContextMenu()
// If +link{attr:listGrid.showHeaderContextMenu} is <code>true</code> this method is fired
// when the user right-clicks on the header for this grid.<br>
// Default implementation will display a menu with entries derived from
// +link{listGrid.getHeaderContextMenuItems()} for the appropriate column.
// @param target (Canvas) which button in the header received the right-click event
//                        (may be the sorter button or header menu button)
// @param [position] (Array) Optional 2-element array specifying position at which the menu should
//                           be shown. If this is not passed in the menu will be shown at the
//                           mouseEvent position (default context menu behavior).
// @visibility external
// @group gridHeader
// @see listGrid.showHeaderContextMenu
//<
displayHeaderContextMenu : function (headerButton, position) {
     // headerButton will be null when contextClick appears on header background or FilterEditorBody
    if (!headerButton) {
        if (this.sorter) {
            headerButton = this.sorter;
        } else {
            return;    
        }        
    }
    // don't display a header context menu for the checkbox column
    var field = this.fields[headerButton.masterIndex];
    if (field && field.showDefaultContextMenu == false) return false;
    // Determine the items to show
    var items = this.getHeaderContextMenuItems(headerButton.masterIndex);
    // If there are no items don't show the menu
    if (items.length == 0) return;

    if (!this._cornerMenu) this._cornerMenu = this.getHeaderContextMenu(headerButton);
    this._cornerMenu.setData(items);
    this._showingHeaderContextMenu = true;
    if (position != null && position.length > 0) {
        var cornerMenu = this._cornerMenu;
        cornerMenu.target = headerButton;
        cornerMenu = cornerMenu._navStackContainer || cornerMenu._navStack || cornerMenu;
        cornerMenu.setVisibility("hidden");
        if (cornerMenu !== this._cornerMenu) {
            if (!cornerMenu.isDrawn()) {
                
                this._cornerMenu._showOffscreen();
                // _showOffscreen() calls draw(), of course, so this next line seems 
                // unnecessary - stick it in a condition for now, to avoid console warnings
                if (!cornerMenu.isDrawn()) cornerMenu.draw();
            }
        } else {
            cornerMenu.moveTo(0, 0);
            if (!cornerMenu.isDrawn()) {
                cornerMenu._showOffscreen();
                // _drawOffscreen() calls draw(), of course, so this next line seems 
                // unnecessary - stick it in a condition for now, to avoid console warnings
                if (!cornerMenu.isDrawn()) cornerMenu.draw();
            } else {
                cornerMenu.redraw();
            }
            cornerMenu.placeNear(position[0], position[1]);
        }
        this._cornerMenu.show();
        return false;
    } else {
        return this._cornerMenu.showContextMenu(headerButton);
    }
},



//> @attr ListGrid.sortFieldAscendingText (String : "Sort Ascending" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to sort a field in ascending order.
// @group i18nMessages
// @visibility external
//<
sortFieldAscendingText: "Sort Ascending",

//> @attr ListGrid.sortFieldDescendingText (String : "Sort Descending" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to sort a field in descending order.
// @group i18nMessages
// @visibility external
//<
sortFieldDescendingText: "Sort Descending",

//> @attr ListGrid.clearSortFieldText (String : "Clear Sort" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to clear an existing sort on this field.
// @group i18nMessages
// @visibility external
//<
clearSortFieldText: "Clear Sort",

//> @attr ListGrid.clearAllSortingText (String : "Clear All Sorting" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute will be shown as the menu item title to clear any existing sort on all fields.  This
// menu-item is displayed only in the context menu for the sorter button.
// @group i18nMessages
// @visibility external
//<
clearAllSortingText: "Clear All Sorting",

//> @attr ListGrid.clearFilterText (String : "Clear Filter" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and a +link{listGrid.showFilterEditor, filter-editor} is visible, this
// attribute will be shown as the menu item title to clear any existing filter.  This
// menu-item is displayed only in the context menu for the sorter button.
// @group i18nMessages
// @visibility external
//<
clearFilterText: "Clear Filter",

//> @attr ListGrid.advancedFilteringText (String : "Advanced filtering..." : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and a +link{listGrid.showFilterEditor, filter-editor} is visible and
// +link{listGrid.allowFilterWindow,allowFilterWindow} is enabled, this
// attribute will be shown as the menu item title to configure advanced filtering.  This
// menu-item is displayed in the context menu for the sorter button and in the 
// +link{allowFilterOperators, filter using} operators menu.
// 
// @group i18nMessages
// @visibility external
//<
advancedFilteringText: "Advanced filtering...",

//> @attr ListGrid.configureSortText (String : "Configure Sort..." : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and multi-sorting is enabled, this attribute is used as the title for a menu item that opens
// a +link{class:MultiSortDialog} to configure the sort-specification for this grid.  This
// menu-item is displayed only in the context menu for the sorter button.
// @group i18nMessages
// @visibility external
//<
configureSortText: "Configure Sort...",

//> @attr ListGrid.configureGroupingText (String : "Configure Grouping..." : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and multi-grouping is enabled, this attribute is used as the title for a menu item that opens
// a +link{class:MultiGroupDialog} to configure the grouping for this grid.
//
// @group i18nMessages
// @visibility external
//<
configureGroupingText: "Configure Grouping...",

//> @attr ListGrid.autoFitFieldText (String : "Auto Fit" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and user-driven auto fit of fields is enabled via +link{listGridField.canAutoFitWidth} or 
// +link{listGrid.canAutoFitFields}, this attribute will be shown as the menu
// item title for an item to perform a one-time autoFit of the field to its title or content
// via a call to +link{listGrid.autoFitField()}.
// @group i18nMessages
// @group autoFitFields
// @visibility external
//<
autoFitFieldText: "Auto Fit",

//> @attr ListGrid.autoFitAllText (String : "Auto Fit All Columns" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid,
// and +link{listGrid.canAutoFitFields} is true, this attribute will be shown as the menu
// item title for an item to perform a one-time autoFit of all visible fields via
// the +link{listGrid.autoFitField()} method.
// @group i18nMessages
// @group autoFitFields
// @visibility external
//<
autoFitAllText: "Auto Fit All Columns",

//> @attr ListGrid.fieldVisibilitySubmenuTitle (String : "Columns" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, and
// +link{listGrid.canPickFields,this.canPickFields} is true, this
// attribute will be shown as the title for the menu item which contains a submenu with items
// allowing the user to show and hide fields in the grid.
// @group i18nMessages
// @visibility external
//<
fieldVisibilitySubmenuTitle: "Columns",

//> @attr ListGrid.fieldVisibilitySubmenuIcon (String : "[SKINIMG]actions/column_preferences.png" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, this
// attribute specifies the icon to show in the 
// +link{ListGrid.fieldVisibilitySubmenuTitle, Column-picker item}, to the left of its title.
// 
// @visibility internal
//<
fieldVisibilitySubmenuIcon: "[SKINIMG]actions/column_preferences.png",

//> @attr listGrid.freezeFieldText (HTMLString : "Freeze ${title}" : IRWA)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canFreezeFields,this.canFreezeFields} is true, this string will be shown as the
// title for the menu item to freeze a currently unfrozen field.
// <P>
// This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
// when the message is displayed, with <code>title</code> available as a variable containing
// the field title.
// <P>
// Default value returns "Freeze " + the field's summary title.
// @group i18nMessages
// @visibility external
//<
freezeFieldText:"Freeze ${title}",

//> @attr listGrid.unfreezeFieldText (HTMLString : "Unfreeze ${title}" : IRWA)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canFreezeFields,this.canFreezeFields} is true, this string will be shown as the
// title for the menu item to unfreeze a currently frozen field.
// <P>
// This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
// when the message is displayed, with <code>title</code> available as a variable containing
// the field title.
// <P>
// Default value returns "Unfreeze " + the field's summary title.
// @group i18nMessages
// @visibility external
//<
unfreezeFieldText:"Unfreeze ${title}",

//> @method listGrid.getToggleFreezeText()
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canFreezeFields,this.canFreezeFields} is true, this string will be shown as the
// title for the menu item to toggle whether a field is frozen or unfrozen.
// <P>
// Default implementation evaluates and returns +link{ListGrid.freezeFieldText} or
// +link{ListGrid.unfreezeFieldText} depending on whether the field is currently frozen.
// @param field (ListGridField) field to get the menu item title for
// @return (HTMLString) Title to show in the menu item
// @group i18nMessages
// @visibility external
//<
getToggleFreezeText : function (field, span) {
    var messageArgs = {
        viewer:this,
        title: span ? span.title : this.getSummaryTitle(field)
    };
    return (!this._suppressedFrozenFields && field.frozen)
            ? this.unfreezeFieldText.evalDynamicString(this, messageArgs)
            : this.freezeFieldText.evalDynamicString(this, messageArgs);
},

//> @attr listGrid.groupByText (HTMLString : "Group by ${title}" : IRWA)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canGroupBy,this.canGroupBy} is true, this string will be shown as the
// title for the menu item to toggle the group by setting for a field.
// <P>
// This is a dynamic string - text within <code>&#36;{...}</code> will be evaluated as JS code
// when the message is displayed, with <code>title</code> available as a variable containing
// the field title.
// <P>
// Default value returns "Group by " + the field's summary title.
// @group i18nMessages
// @visibility external
//<
groupByText : "Group by ${title}",

//> @method listGrid.getGroupByText()
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid and
// +link{listGrid.canGroupBy,this.canGroupBy} is true, this string will be shown as the
// title for the menu item to toggle the group by setting for a field.<br>
// Default implementation evaluates and returns the dynamic +link{listGrid.groupByText}
// string.
// @param field (ListGridField) field to get the menu item title for
// @return (HTMLString) Title to show in the menu item
// @group i18nMessages
// @visibility external
//<
getGroupByText : function (field) {
    var messageArgs = {
        field:field,
        title: this.getSummaryTitle(field),
        viewer:this
    }
    return this.groupByText.evalDynamicString(this, messageArgs);
},




//> @attr ListGrid.ungroupText (String : "Ungroup" : IRW)
// If we're showing a +link{listGrid.showHeaderContextMenu,headerContextMenu} for this grid, and
// +link{listGrid.isGrouped,this.isGrouped} is true, this
// attribute will be shown as the title for the menu item to ungroup the grid.
// @group i18nMessages
// @visibility external
//<
ungroupText: "Ungroup",


_shouldGroupByField : function (field) {
    var field = this.getField(field);
    return !!(field && this._canGroupByField(field) &&
              this.data.getLength() <= this.groupByMaxRecords);
},
_canGroupByField : function (field) {
    var field = this.getUnderlyingField(field);
    return !!(field &&
              ((this.canGroupBy == true && field.canGroupBy != false) ||
               (this.canGroupBy != false && field.canGroupBy == true) ||
               (this.editingOn && this.editProxy && this.editProxy.canGroupBy)));
},



//> @method listGrid.getHeaderSpanContextMenuItems()
// Return the menus items that should be shown in a menu triggered from a 
// +link{listGrid.headerSpans,headerSpan}.  The default implementation returns the parent 
// element's context menu, unless +link{listGrid.showHeaderSpanContextMenu} is 
// <code>true</code>, in which case it returns standard items for showing / hiding fields and 
// freezing / unfreezing header spans.  Note that no column picker will be shown unless 
// +link{listGrid.showTreeColumnPicker} is <code>true</code>.
//
// @param headerSpan (HeaderSpan) the component representing the headerSpan.  This component will
//                            have all the properties specified via +link{listGrid.headerSpans}.
// @return (Array of MenuItem) return false instead to avoid showing any menu
//
// @group headerSpan
// @visibility external
//<
getHeaderSpanContextMenuItems : function (span) {
    // if (!this.showTreeColumnPicker && !this.showHeaderSpanContextMenu) return false;
    if (!this.showHeaderSpanContextMenu) {
        return span.getParentElement && span.getParentElement().showContextMenu();
    }

    var menuItems = [];
    if (this.canPickFields && this.showTreeColumnPicker) {
        menuItems[0] = {
            title: this.fieldVisibilitySubmenuTitle,
            submenu: this.getColumnPickerItems(),
            icon: this.fieldVisibilitySubmenuIcon
        };
    }

    var grid = this,
        fields = this.getSpannedFields(span),
        frozen
    ;
    if (fields) {
        for (var i = 0; i < fields.length; i++) {
            var fieldName = fields[i],
                field = this.getField(fieldName)
            ;
            if (field && !this._suppressedFrozenFields && field.frozen) {
                frozen = true;
                break;
            }
        }
    }

    if (this._canShowFilterEditor()) {
        menuItems.add({
            title: this.showFilterEditor ? this.hideFilterEditorTitle : this.showFilterEditorTitle,
            //icon: this.canShowFilterEditorIcon,
            grid: this,
            click : function () {
                this.grid.setShowFilterEditor(!this.grid.showFilterEditor);
            }
        });
    }

    // show menu for freezing and unfreezing spans.  Don't allow all fields to be frozen.
    if (this.canFreezeFields && this.fields.length > 1 && !span.parentSpan) {
        // can't freeze the last unfrozen field etc.
        if (frozen || this.frozenFields == null || this.normalFields.length > fields.length) {
            if (menuItems.length > 0) menuItems.add({isSeparator: true});
            menuItems.add({
            // method to get field from completeFields?
                title: this.getToggleFreezeText(
                        this.completeFields.find(this.fieldIdProperty,fields[0]),
                        span),
                grid:this,
                spanFields:fields,
                frozen: frozen,
                icon:(frozen ? "[SKINIMG]actions/unfreeze.png" :
                                    "[SKINIMG]actions/freezeLeft.png"),
                click: function () {
                    var spanFields = this.spanFields;
                    for (var i = 0; i < spanFields.length; i++) {
                        grid.completeFields.find(grid.fieldIdProperty, spanFields[i]).frozen = !this.frozen;
                    }
                    grid.rebuildForFreeze();
                }
            });
        }
    }

    return menuItems;
},

shouldShowColumnPicker : function (fld) {
    // don't allow hiding treeField columns or those marked canHide: false (now includes the checkboxField)
    // - it doesn't make much sense and is not currently supported
    if (fld.treeField || fld.canHide === false) return false;

    var title = this.getSummaryTitle(fld);

    // don't allow hiding columns with no title (because the menu item would then appear
    // blank as well)
    if (title == null || isc.isAn.emptyString(title)) return false;

    return true;
},

getColumnPickerItems : function () {
    var showColumns = [],
        grid = this
    ;

    // create show/hide columns menu items
    for (var i = 0; i < this.completeFields.length ; i++) {
        var fld = this.completeFields[i];
        if (!this.shouldShowColumnPicker(fld)) continue;

        var title = this.getSummaryTitle(fld);

        var spanConfig = this.spanMap ? this.spanMap[fld.name] : null;
        if (this.showTreeColumnPicker && spanConfig) {
            var spanHierarchy = [spanConfig],
                parentSpan = spanConfig.parentSpan;

            while (parentSpan != null) {
                spanHierarchy.add(parentSpan);
                parentSpan = parentSpan.parentSpan;
            }
            var indent = "";
            for (var ii = spanHierarchy.length-1; ii >= 0; ii--) {
                var itemConfig = spanHierarchy[ii];
                // If we're already stuck the span into the menu skip it.
                if (!showColumns.find("spanConfig",itemConfig)) {

                    // Otherwise output span toggle if we haven't already

                    // Interaction with canHide:false fields: If an item spans
                    // canHide:false fields only, omit it from the menu entirely.
                    // If it spans a mixture of canHide:false / canHide:true fields,
                    // show the item and have it toggle just the canHide:true fields.
                    // If all fields are hidden other than canHide:false fields, show
                    // the checkbox (the span *is* visible after all), but have a click
                    // on the item show the other fields.
                    showColumns.add({
                        title: indent + itemConfig.title,
                        // don't auto-dismiss, so that users can show and hide multiple columns at once
                        autoDismiss: false,
                        
                        spanConfig: itemConfig,
                        click : function spanMenu_click (target, item, menu) {
                            var spannedFields = grid.getSpannedFields(item.spanConfig, true);
                            var hide = item.anySpannedFieldsVisible(true);
                            
                            if (hide) grid.hideFields(spannedFields.duplicate())
                            else grid.showFields(spannedFields.duplicate());
                            menu.body.delayCall("markForRedraw");
                        },
                        anySpannedFieldsVisible :function spanMenu_anySpannedFieldsVisible (canHideOnly) {
                            var spannedFields = grid.getSpannedFields(this.spanConfig, canHideOnly);
                            for (var i = 0; i < spannedFields.length; i++) {
                                if (grid.fieldIsVisible(spannedFields[i])) return true;
                            }
                            return false;
                        },
                        enableIf : function spanMenu_enableIf (target, menu, item) {
                            var itemConfig = item.spanConfig;
                            // enabled if any fields *not* in the span are visible
                            var spannedFields = grid.getSpannedFields(itemConfig);
                            for (var i = 0; i < menu.data.length; i++) {
                                var item = menu.data[i];
                                if (item.fieldName && grid.fieldIsVisible(item.fieldName) &&
                                    !spannedFields.contains(item.fieldName)) return true;
                            }
                            return false;
                        },
                        checkIf : function (target, menu, item) {
                            return item.anySpannedFieldsVisible();
                        }
                    });
                }
                
                indent += "&nbsp;&nbsp;&nbsp;&nbsp;"
            }
            title = indent + title;
        }

        showColumns.add({
            title: title,
            fieldName: fld.name,
            prompt: fld.prompt,
            // don't auto-dismiss, so that users can show and hide multiple columns at once
            autoDismiss: false,
            checkIf : function (target, menu, item) {
                return grid.fieldIsVisible(item.fieldName);
            },
            enableIf : function (target, menu, item) {
                var currentlyVisibleFields = 0;

                for (var i = 0; i < grid.fields.length; i++) {
                    var field = grid.fields[i];
                    // If this field is visible and its an actual field object and not
                    // a special field such as the row number, checkbox or delete column,
                    // then lets count it as a visible field.
                    if (grid.fieldIsVisible(field) && field._isFieldObject) {
                        currentlyVisibleFields++;
                    }
                }

                return !(currentlyVisibleFields === 1 && grid.fieldIsVisible(item.fieldName));
            },
            click : function (target,item,menu) {
                // if we're being shown as a submenu of the grouping menu, disable group
                // item if it is the same as the item who will no longer be visible
                var  parentMenu = menu._parentMenu,
                     groupItemIndex = parentMenu ?
                                     parentMenu.data.findIndex("groupItem", true) : null,
                     groupItem = parentMenu ? parentMenu.data[groupItemIndex] : null,
                     togglingCurrentField = (groupItem && groupItem.fieldName == item.fieldName)
                ;

                if (grid.fieldIsVisible(item.fieldName)) {
                    // make sure length of fields doesn't count checkbox field
                    var fieldsLen = grid.fields.length;
                    if (grid.getCurrentCheckboxField() != null) fieldsLen -= 1;
                    // Don't hide the last visible field
                    if (fieldsLen > 1) {
                        grid.hideField(item.fieldName);
                    }
                    // Disable the last checked column, as we don't want it to be able to be
                    // hidden
                    if (fieldsLen == 1) {
                        var visibleItem = menu.data.find("fieldName", grid.fields[0].name);
                        menu.setItemEnabled(visibleItem, false);
                        this._disabledItem = visibleItem;
                    }
                } else {
                    grid.showField(item.fieldName);
                    // if there is a disabled item, enable it, because now we're guaranteed that
                    // its no longer the last item
                    if (this._disabledItem) {
                        menu.setItemEnabled(this._disabledItem, true);
                        this._disabledItem = null;
                    }
                }
                if (togglingCurrentField) {
                    parentMenu.setItemEnabled(groupItemIndex,
                                              grid._shouldGroupByField(groupItem.fieldName));
                }
                menu.body.delayCall("markForRedraw");

            }
        });
    }
    
    return showColumns;
},

getColumnPickerMenu : function (showColumns) {
    var showColumnsMenu = {
        canHover:true,
        showIcons:true,
        showHover:true,
        cellHoverHTML:function (record) {
            return record.prompt;
        },
        items:showColumns
    };

    return {
        title: this.fieldVisibilitySubmenuTitle,
        submenu: showColumnsMenu,
        icon: this.fieldVisibilitySubmenuIcon
    }
},

filterOperatorMenuDefaults: {
    _constructor: "Menu"
},
getFilterOperatorMenuItem : function (field, flatMenu) {
    var item;
    var submenu = flatMenu ? null : this.getFilterOperatorMenuItems(field);
    if (submenu && submenu.length == 1 && submenu[0].title == this.advancedFilteringText) {
        item = submenu[0];
    } else {
        item = {
            title: this.filterUsingText,
            fieldName: field.name,
            targetField: field,
            prompt: field.prompt,
            icon: "[SKINIMG]actions/filter.png",
            canSelectParent: false,
            submenu: flatMenu ? null : this.getFilterOperatorMenuItems(field)
        };
    }
    return item;
},

getFilterOperatorMenuItems : function (field, includeTitleItem) {
    var ds = this.getDataSource(),
        grid = this,
        filterEditor = this.getFilterEditor(),
        form = filterEditor && filterEditor.getEditForm(),
        formItem = form && form.getItem(field.name),
        menuItems = []
    ;

    if (formItem) {
        var addFilterMenuItem = function (operator, field, currentOperator) {
            var title = isc.DS._getFieldOperatorTitle(field, operator);
            menuItems.add({
                title: title,
                grid: grid,
                targetField: field,
                fieldName: field.name,
                operator: operator,
                checked: currentOperator == operator.ID,
                click: function(target, item, menu) {
                    this.grid.setFieldSearchOperator(this.targetField, this.operator)
                }
            });
        }

        if (includeTitleItem) {
            // this call may return the "Filter using" menuItem, with a submenu, or it may
            // return the "Advanced filtering" menuItem, if it would have been the only item 
            // in the "Filter using" submenu - if it returns the "Filter using" menuItem, make 
            // that menuItem a non-interactive "title" item.
            var titleItem = this.getFilterOperatorMenuItem(field, true);
            if (titleItem.submenu) {
                titleItem.showRollOver = false;
                titleItem.canSelect = false;
            }
            menuItems.add(titleItem);
            menuItems.add({ isSeparator: true });
        }

        var editorClass = isc.FormItemFactory.getItemClass(this.getFilterEditorType(field));
        // no support for operators in non-TextItem fields
        if (isc.isA.TextItem(editorClass)) {
            // show the default operator at the top, with an i18n suffix "(default)", and a separator
            var defaultOpId = formItem._defaultOperator || formItem.getDefaultOperator(),
                defaultOp = isc.shallowClone(isc.DS._operators[defaultOpId]),
                title = isc.DS._getFieldOperatorTitle(field, defaultOp)
            ;
            title += " " + this.defaultFilterOperatorSuffix;
            defaultOp.title = title;
            defaultOp.titleProperty = null;
            // add a flag that can automatically hide the operatorIcon when the default is selected
            defaultOp.isFieldDefault = true;


            // get the current operator
            var currentOpId = (formItem.getOperator() || field.filterOperator);
            var currentOp = ds.getSearchOperator(currentOpId);

            // track if the current op is in the menu already - if not, we'll add it after
            // the loop, to deal with case-sensitive expression-ops being introduced as a result 
            // of a case-sensitive defaultOperator having been applied to the field            
            var currentOpVisible = currentOpId == defaultOpId;

            addFilterMenuItem(defaultOp, field, currentOpId);
            menuItems.add({ isSeparator: true });

            var ops = this.getFieldUIOperatorList(field, ds);
            var op;

            for (var opID in ops) {
                if (opID == currentOpId) currentOpVisible = true;
                op = ds.getSearchOperator(opID) || ops[opID];
                if (op.ID != defaultOpId) { // || formItem.getOperator() != defaultOpId) {
                    addFilterMenuItem(op, field, currentOpId);
                }
            }

            // if currentOp is not in the menu, but is allowed for the field (getSearchoperator()),
            // add it now, so we can tick it in the menu
            if (!currentOpVisible && currentOp) {
                addFilterMenuItem(currentOp, field, currentOpId);
            }
        }
    }
	
    return menuItems;
},

//> @method listGrid.getFieldSearchOperator()
// Returns the current search-operator applied to criteria for a given field in this grid's 
// +link{listGrid.filterEditor, filter row}.  Typically, this will be the operator most 
// recently selected by the user, or applied by a call to +link{listGrid.setCriteria} or
// similar..
// <p>
// If no operator has been applied by the user, the result is the default provided 
// +link{listGridField.filterOperator, by the developer}, or null, indicating a default 
// operator according to data-type.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// @param fieldName (String) name of the field to get the search operator for
// @visibility external
//<
getFieldSearchOperator : function (fieldName, defaultOperator) {
    var ds = this.getDataSource();
    if (!ds) return;

    var field = fieldName;
    if (isc.isA.String(field)) field = this.getFieldByName(field);

    var operator;
    if (field.operator || field.filterOperator) {
        operator = ds.getSearchOperator(field.operator || field.filterOperator);
    }
    if (!operator && defaultOperator) {
        operator = ds.getSearchOperator(defaultOperator);
    }
    
    return operator;
},

//> @method listGrid.clearFieldSearchOperator()
// Clears the current search operator from a field in the grid's 
// +link{listGrid.filterEditor, filter row}.  This will reset the field to its 
// +link{listGridField.filterOperator, default operator} and, unless 
// +link{listGrid.alwaysShowOperatorIcon} is true, hide the field's operatorIcon.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// <p>
// If +link{listGrid.filterOnKeypress} is true, a fetch may be issued when the operator
// is cleared - see +link{listGrid.setFieldSearchOperator} for details.  To prevent this fetch,
// pass the <i>suppressFilter</i> parameter.
// <p>
// To retrieve a field's current search operator, use +link{listGrid.getFieldSearchOperator}.  
// To programmatically modify a field's current search operator, use 
// +link{listGrid.setFieldSearchOperator}.
// <p>
// This method has no effect if no specific operator has been set on the field, either by the 
// user or as a result of other criteria applied by +link{listGrid.setCriteria} or similar.
// @param fieldName (String) name of the field to clear the search operator from
// @param suppressFilter (Boolean) prevent this call from causing a filter as a result of 
//              operator change - clearing, eg, "isNull" criteria will cause a refilter
// @visibility external
//<
clearFieldSearchOperator : function (fieldName, suppressFilter) {
    this.setFieldSearchOperator(fieldName, null, null, suppressFilter);
},

//> @method listGrid.setFieldSearchOperator()
// Applies a new +link{type:OperatorId, search operator} to a field in the grid's 
// +link{listGrid.filterEditor, filter row}, and updates it's operatorIcon.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// <p>
// Depending on the field's current filter-value and operator, calls to this method may result 
// in the current filter-value being cleared, and/or a fetch being issued if  
// +link{listGrid.filterByCell, filterByCell} or
// +link{listGrid.filterOnKeypress, filterOnKeypress} are set.
// <p>
// In general, if the field has a current filter-value, it will be cleared if
// <ul>
// <li>the new operator does not require a value (operator-type 
//      +link{type:OperatorValueType, none} - +link{type:OperatorId, isBlank}, 
//      for example)</li>
// <li>the current and new operators have different 
//      +link{type:OperatorValueType, value-types} and +link{listGrid.allowFilterExpressions}
//      is false</li>
// <li>the item has an +link{formItem.optionDataSource, optionDataSource} or valueMap which no
//      longer includes the current value</li>
// </ul>
// <p>
// If <code>filterOnKeypress</code> is true, a fetch will be issued if 
// <ul><li>the value was just cleared, in one of the ways listed above</li>
// <li>the operator changes while there is a current value</li>
// <li>the new operator does not require a value and the old one did</li>
// </ul>
// <p>
// If passed null, the field's operator will be cleared, reverting it to its 
// +link{listGridField.filterOperator, default operator} and, if 
// +link{listGrid.alwaysShowOperatorIcon} is false, the operatorIcon is hidden.  See 
// +link{listGrid.clearFieldSearchOperator} for an alternative way to clear a field's operator. 
// <p>
// To retrieve a field's current search operator, use +link{listGrid.getFieldSearchOperator}.  
// <p>
// @param fieldName (String) name of the field to apply a new search operator to
// @param operator (OperatorId) id of the search operator to apply
// @visibility external
//<
setFieldSearchOperator : function (fieldName, operator, suppressFocus, suppressEditorChanged) {
    var ds = this.getDataSource();
    if (!ds) return;

    // never allow this function to kick off a fetch (via the item's change-handling) if 
    // running as a result of setFilterEditorCriteria(), which is documented to cause no fetch 
    suppressEditorChanged = suppressEditorChanged || this._settingFilterEditorCriteria;

    var field = fieldName;
    if (isc.isA.String(field)) field = this.getFieldByName(field);

    var editor = this.getFilterEditor(),
        form = editor && editor.getEditForm(),
        item = form && form.getItem(field.name),
        oldItemValue = item && item.getValue()
    ;

    // bail if there's no item (there may be no form at this point)
    if (!item) return;

    if (operator != null) {
        if (isc.isA.String(operator)) operator = ds.getSearchOperator(operator);
        if (!isc.isAn.Object(operator)) {
            if (this.shouldAlwaysShowOperatorIcon(field, item)) item.showIcon("operatorIcon");
            return;
        }
    }

    var oldOp = this.getFieldSearchOperator(field, item._defaultOperator),
        operatorChanged = !operator || operator.ID != oldOp.ID,
        sameValueType = (!operatorChanged || 
                            (oldOp != null && operator != null &&
                             oldOp.valueType == operator.valueType)),
        shouldClearValue = false
    ;

    if (item) {
        // clear the value if the valueType changed, if there's a valueMap that no longer 
        // contains the value, or if the new op requires no value, or if the new or old op is
        // valueType "criteria" (a logical operator)
        if (!sameValueType && this.allowFilterExpressions != true) {
            // different types - only clear the value if allowFilterExpressions is false
            shouldClearValue = true;
        } else if (operator && operator.valueType == "none") {
            // if the new operator requires no value, clear the value
            shouldClearValue = true;
        } else if ((operator && operator.valueType == "criteria") || 
                (oldOp && oldOp.valueType == "criteria")) {
            // if either operator is logical, clear the value
            shouldClearValue = true;
        } else if (item.optionDataSource || item.getValueMap() && 
                (item._valueInValueMap && !item._valueInValueMap(item.getValue()))) 
        {
            // value is no longer in ODS or valueMap - check this last, it's the slowest
            shouldClearValue = true;
        }
    }
    
    if (shouldClearValue) item.clearValue();

    var newItemValue = item.getValue(),
        valueChanged = oldItemValue != newItemValue
    ;
    
    var showIcon = this.shouldAlwaysShowOperatorIcon(field, item) ||
                    (operator && !operator.isFieldDefault);
    this.updateOperatorIcon(field, item, showIcon ? operator : null);
    
    if (operator && operator.valueType == "none") {
        // operators with valueType:"none" expect to have no value specified - currently, these
        // operators are "isNull", "notNull", "isBlank" and "notBlank" - disable input in the 
        // formItem 
        if (item.getCanEdit()) {
            if (!item.readOnlyDisplay) item.readOnlyDisplay = "disabled";
            item.setCanEdit(false);
        }

        if (!suppressEditorChanged) {
            // don't cause a refilter if nothing has changed - needed for the case where we're 
            // setting the operator that the field would get by default anyway
            if (operatorChanged || valueChanged) {
                if (this.filterByCell || this.filterOnKeypress) {
                    // if filterByCell is true and the new operator has valueType: "none", kick off 
                    // a filter here - otherwise, the user would have to click the filter-button
                    this.getFilterEditor().editorChanged(item);
                }
            }
        }
    } else {
        if (!item.getCanEdit()) {
            item.setCanEdit(true);
        }
        // don't cause a refilter if nothing has changed - needed for the case where the field
        // had no specified operator before, but we're setting it now to the same operator it
        // was using by default anyway
        if (item && (operatorChanged || valueChanged)) {
            var fireChanged = this.filterByCell || this.filterOnKeypress;
            if (!fireChanged) {
                if (oldOp && (oldOp.valueType == "none" || oldOp.valueType == "criteria")) { 
                    // if filterByCell is true, or the old operator has valueType: "none" or
                    // a "criteria", like "and", kick off a filter here - otherwise, the user 
                    // would have to click the filter-button or press Enter
                    fireChanged = true;
                }
            }
            if (!suppressEditorChanged && fireChanged) {
                this.getFilterEditor().editorChanged(item);
            }
        }
        if (!suppressFocus) this.focusInFilterEditor(field.name);
    }
    
},



setFieldProperty : function(field, property, value) {
    if (property == "operator") {
        var editor = this.getFilterEditor(),
            form = editor.getEditForm(),
            item = form.getItem(field.name);
        if (value) {
            item.setValue(value);
        } else {
            item.resetValue();
            this.updateOperatorIcon(field, item, value);
        }
    }
}, 

updateOperatorIcon : function (field, item, operator) {
    var icon = item.getIcon("operatorIcon"),
        shouldClear = false
    ;

    // no icon - field disallows operatorIcons - just bail
    if (!icon) return;
    
    if (!operator) operator = isc.DS._operators[item._defaultOperator];

    if (operator.ID == item._defaultOperator) {
        // hide the operatorIcon unless field or grid make it always visible
        if (!this.shouldAlwaysShowOperatorIcon(field, item)) shouldClear = true;
    }

    if (shouldClear) {
        item.operator = item._defaultOperator;
        this.getField(field.name).operator = item.operator;
        item.hideIcon("operatorIcon");
        if (!item.getCanEdit()) {
            // re-enable the item (it must have previously had an op of valueType: "none")
            item.setCanEdit(true);
        }
    } else {
        icon.prompt = isc.Operators[operator.titleProperty];
        var usageHint = isc.Operators.getOperatorUsageHint(operator);
        if (usageHint) icon.prompt += "<br>" + usageHint;
        icon.text = operator.symbol;
        item.operator = operator.ID;
        this.getField(field.name).operator = operator.ID;
        item.showIcon("operatorIcon", false);
    }

    item.redraw();
},

operatorIconStyle: "filterOperatorIcon",
operatorIconDefaults: {
    name: "operatorIcon",
    inline: true,
    inlineIconAlign: "left",
    align: "center",
    hspace: 1,
    width: 16,
    disableOnReadOnly: false,
    showOver: true
},
getOperatorIcon : function (field, operator) {
    // if no field was passed, bail
    if (!field) return;
    if (isc.isA.String(operator)) {
        // map an operatorId to an operator
        operator = this.getDataSource().getSearchOperator(operator);
    }
    if (!operator) {
        // get the default operator from the field
        operator = this.getDataSource().getSearchOperator(field.filterOperator);
    }
    var icon = isc.addProperties({}, this.operatorIconDefaults, this.operatorIconProperties,
        { 
            grid: this,
            field: field,
            fieldName: field.name,
            hidden: true,
            showIf: "false",
            text: operator ? operator.symbol : "",
            prompt: operator ? isc.Operators[operator.titleProperty] : "",
            baseStyle: this.operatorIconStyle || this.header.getButton(0).baseStyle,
            click : function (form, item, icon) {
                var grid = icon.grid,
                    items = grid.getFilterOperatorMenuItems(icon.field, true),
                    menu = grid.filterOperatorMenu
                ;
                if (!menu) {
                    menu = grid.filterOperatorMenu = grid.createAutoChild("filterOperatorMenu");
                }
                menu.setItems(items);
                var button = grid.getFieldHeaderButton(grid.getFieldNum(this.field));
                menu.showContextMenu(button);
            }
        }
    );
    return icon;
},

//> @method ListGrid.getHeaderContextMenuItems()
// If +link{attr:listGrid.showHeaderContextMenu} is <code>true</code> this method returns
// the menu items to be displayed in the default header context menu.
// <P>
// This method is called at various times, including during redraws, as the mouse moves over a
// ListGrid header button and each time the menu is actually displayed - this allows for 
// dynamic content depending on the current state of the grid and its fields.
// <P>
// Consequently, this method should not instantiate any classes, because they'll be re-created
// on each call, resulting in a leak - your implementation should return an array of menuItem 
// config-blocks only, so you shouldn't instantiate actual Menu instances to apply as the 
// +link{menuItem.submenu, submenu} of items - instead, set submenu to a simple array of
// menuItems.  If your use-case necessitates that class instances are created, because specific
// submenus have a different Menu class, for example, you should keep a reference to them and 
// either, if their content is dynamic, destroy and recreate them with the new items, or just
// return the existing instances otherwise. 
// <P>
// The default set of menu items includes items for built-in ListGrid features like showing 
// and hiding fields, freezing fields or grouping by them, and other functions.
//
// @param [fieldNum] (Integer) Index of the field the user clicked in the
//    +link{listgrid.fields,fields} array. <b>Note:</b> if the user right-clicked the sorter button
//    this parameter will be <code>null</code>.
//
// @return (Array of MenuItem)
// @group gridHeader
// @visibility external
//<
hasHeaderContextMenuItems : function (fieldNum) {
    // call getHeaderContextMenuItems() passing the second param to have it return 
    // as soon as it finds a first applicable item
    var field = this.getField(fieldNum);
    if (field && field.hasMenuItems != null) return field.hasMenuItems;
    field.hasMenuItems = this.getHeaderContextMenuItems(fieldNum, true).length > 0;
    //this.logWarn("HAS HeaderContextMenuItems for Field " + fieldNum + " returns " + field.hasMenuItems);
    return field.hasMenuItems; 
},
getHeaderContextMenuItems : function (fieldNum, returnFirstItem) {
    var field = this.getField(fieldNum);

    if (!returnFirstItem) {
        //this.logWarn("GET HeaderContextMenuItems for Field " + fieldNum + ".");
    }

    var menuItems = [],
        needSeparator = false
    ;

    var canSort = this._canSort(field);

    if (canSort || !field) {
        if (field) {
            var sortFieldNum = fieldNum != null ? fieldNum : this._getSortFieldNum();
            menuItems[0] = {
                title: this.sortFieldAscendingText,
                icon: "[SKINIMG]actions/sort_ascending.png",
                click: "menu.doSort(" + sortFieldNum + ", 'ascending')"
            };
            menuItems[1] = {
                title: this.sortFieldDescendingText,
                icon: "[SKINIMG]actions/sort_descending.png",
                click: "menu.doSort(" + sortFieldNum + ", 'descending')"
            };
            needSeparator = true;
        }
        if (this._canMultiSort()) {
            menuItems.add({
                title: this.configureSortText,
                icon: "[SKINIMG]actions/configure_sort.png",
                field: field,
                click : function (target, item, menu) {
                    menu.grid.askForSort(this.field == null ? null : this.field[menu.grid.fieldIdProperty]);
                }
            });
            needSeparator = true;
            if (!field || this.isSortField(field[this.fieldIdProperty])) {

                menuItems.add({
                    title: field ? this.clearSortFieldText : this.clearAllSortingText,
                    field: field,
                    icon: "[SKINIMG]actions/clear_sort.png",
                    enableIf : function (target, menu, item) {
                        return (field || (!field && menu.grid.getSortFieldCount() > 0));
                    },
                    click: field ? "menu.doSort(" + sortFieldNum + ", 'unsort')" :
                        "menu.grid.clearSort(true);"
                });
                needSeparator = true;
            }
        }
    }
    
    // returnFirstItem: true is passed by hasHeaderContextMenuItems() and means we
    // just check if *any* manuItems are applicable and return.
    // this code is repeated several times below to catch the first applicable item and return
    if (returnFirstItem && menuItems.length > 0) return menuItems;

    // Note if autoFitWidth is already set on this field we still want to show the
    // option to force a re-run of the autofit logic. This is required to handle the
    // case where we autoFit to the rendered rows but the user scrolls new rows into
    // view which aren't in the draw area and are clipped. In this case we want the user to
    // have the option to re-auto-fit
    
    var showAutoFit = (field && this.canAutoFitField(field));
    if (showAutoFit) {
        if (this.canAutoFitFields) {
            menuItems.add({
                title:this.autoFitAllText,
                icon: "[SKINIMG]actions/auto_fit_all.png",
                click:"menu.grid.autoFitFields()"
            });
        }
        menuItems.add({
            title: this.autoFitFieldText,
            icon: "[SKINIMG]actions/auto_fit.png",
            click: "menu.grid.autoFitField(" + fieldNum + ",true);"
        });
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    if (!field && this.showFilterEditor) {
        if (needSeparator) menuItems.add({ isSeparator: true });
        
        menuItems.add({
            title: this.clearFilterText,
            click: "menu.grid.clearFilterItemClick();"
        });
        needSeparator = true;
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    // add column visibility chooser
    if (this.canPickFields && this.completeFields.length > 1) {
        if (this.useAdvancedFieldPicker &&
            this.completeFields.length >= this.advancedFieldPickerThreshold)
        {
            if (needSeparator) menuItems.add({ isSeparator: true } );
            menuItems.add(this.createFieldPickerWindowMenuItem(
                this.fieldVisibilitySubmenuTitle + "..."));
            needSeparator = true;

        } else {
            var showColumns = this.getColumnPickerItems();
            if (showColumns.length > 0) {
                // Never allow the user to hide the last visible field in the grid.
                // If we can toggle visibility on more than one field, show the picker
                var show = showColumns.length > 1;
                // Otherwise only show the picker if there's at least 1 additional
                // (canHide:false) field visible. 
                // This prevents the user from hiding all fields in the grid.
                if (!show) {
                    var fieldName = showColumns[0].fieldName;
                    for (var i = 0; i < this.fields.length; i++) {
                        if (this.fields[i].name != fieldName) {
                            show = true;
                            break;
                        }
                    }
                }
                if (show) {
                    if (needSeparator) menuItems.add({ isSeparator: true } );
                    menuItems.add(this.getColumnPickerMenu(showColumns));
                    needSeparator = true;
                }
            }
        }
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    // add a "Show/Hide Filter Row" menu-item
    if (this._canShowFilterEditor()) {
        menuItems.add({
            title: this.showFilterEditor ? this.hideFilterEditorTitle : this.showFilterEditorTitle,
            //icon: this.canShowFilterEditorIcon,
            grid: this,
            click : function () {
                this.grid.setShowFilterEditor(!this.grid.showFilterEditor);
            }
        });
    }

    // add group option
    // canGroupBy a field if:
    // - this.canGroupBy is true and field.canGroupBy is not false
    // - this.canGroupBy is unset and field.canGroupBy is true
    var canGroupBy = field && this._canGroupByField(field),
        // only consider grouped if current field is not marked canGroupBy: false.
        // this makes no grouping/ungrouping options show up for the field.
        isGrouped = (this.canGroupBy != false) && field && field.canGroupBy != false
                    && this.isGrouped;
    if (needSeparator && (isGrouped || canGroupBy)) {
        menuItems.add({ isSeparator: true } );
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    var allowFilterWindow = this.shouldAllowFilterWindow();

    // filterOperators menuItem
    if (field && (this.shouldAllowFilterOperators(field) || allowFilterWindow)) {
        var filterEditor = this.getFilterEditor();
        var filterForm = filterEditor && filterEditor.getEditForm();
        // if allowFilterOperators is set, add a "Filter using" menuItem with a submenu 
        // listing all operators that apply to this field, and are valueType: "fieldType"
        // If only the "Advanced filtering" option is available (because the filterEditor is 
        // hidden), just show the Advanced Filtering option at this level, instead of the
        // Filter Using... item
        var item;
        var submenu = (filterForm || allowFilterWindow) ? this.getFilterOperatorMenuItems(field) : []
        ;
        if (submenu.length == 1 && submenu[0].title == this.advancedFilteringText) {
            item = submenu[0];
        } else {
            item = {
                title: this.filterUsingText,
                fieldName: field.name,
                targetField: field,
                prompt: field.prompt,
                icon: "[SKINIMG]actions/filter.png",
                canSelectParent: false,
                submenu: submenu
            };
        }
        menuItems.add(item);
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    if (canGroupBy) {

        // if there is no custom getGroupValue defined, check if there is a custom groupingModes
        // or else fallback to the default simpleType one - if using the simpleType and it has
        // a getGroupingModes() method, run that, otherwise, just assume groupingModes
        var groupingModes = field.groupingModes ? field.groupingModes :
            (!field.getGroupValue ? ( field._simpleType ? (field._simpleType.getGroupingModes ?
                                                           field._simpleType.getGroupingModes() :
                                                           field._simpleType.groupingModes) : false )
             : false);

        var groupBySubmenu = null;
        if (groupingModes) {
            groupBySubmenu = [];
            var addSubmenuItem = function (mode, title) {
                if (!title) title = mode;
                groupBySubmenu.add({
                    title: title,
                    groupType: mode,
                    targetField: field,
                    fieldName: field.name,
                    prompt: field.prompt,
                    checked: field.groupingMode == mode,
                    //TODO> check if this field is actually grouped but with different option
                    click: function(target, item, menu) {
                        menu._parentMenu.groupField(item);
                    }
                });
            }
            // valueMap support: either an array or object of property bindings
            if (isc.isAn.Array(groupingModes)) {
                for (var i = 0; i < groupingModes.length; i++) {
                    addSubmenuItem(groupingModes[i]);
                }
            } else if (isc.isAn.Object(groupingModes)) {
                for (var property in groupingModes) {
                    addSubmenuItem(property, groupingModes[property]);
                }
            }
        }
        
        menuItems.add({
            groupItem: true,
            title: this.getGroupByText(field),
            fieldName: field.name,
            targetField: field,
            prompt: field.prompt,
            icon: "[SKINIMG]actions/groupby.png",
            click: function(target, item, menu) {
                menu.groupField(item);
            },
            enabled: this._shouldGroupByField(field),
            canSelectParent: true,
            submenu: groupBySubmenu
        });
        if (this.canMultiGroup) {
            var grid = this;
            menuItems.add({
                title: this.configureGroupingText,
                icon: "[SKINIMG]actions/groupby.png",
                targetField: field,
                click: function(target, item, menu) {
                    grid.configureGrouping(this.targetField);
                },
                enabled: this._shouldGroupByField(field)
            });
        }
        needSeparator = true;
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    // if grid is grouped, show ungroup option
    if (isGrouped) {
        menuItems.add({
            title: this.ungroupText,
            click: "menu.ungroup()",
            icon: "[SKINIMG]actions/ungroup.png"
        });
        needSeparator = true;
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    if (field) {
        // show menu for freezing and unfreezing fields.  Don't allow all fields to be frozen.
        if (this.canFreezeFields && this.fields.length > 1 &&
            (field.frozen ||
             (this.frozenFields == null || this.normalFields.length > 1)) &&
             // disallow freezing of spanned fields - can only freeze the whole spanned set
             // together
             !(this.spanMap && this.spanMap[field.name]) &&
             // allow listGridField.canFreeze to prevent freeze option from appearing in context menu
             field.canFreeze != false)
        {

            if (needSeparator) menuItems.add({ isSeparator: true });

            menuItems.add({
                title: this.getToggleFreezeText(field),
                grid: this,
                field: field,
                icon: (field.frozen ? "[SKINIMG]actions/unfreeze.png" : "[SKINIMG]actions/freezeLeft.png"),
                click: "item.grid.toggleFrozen(this.field,!this.field.frozen)"
            });
            
            needSeparator = true;
        }
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    var canAddFormulaFields = (this.canAddFormulaFields || (this.editingOn && this.editProxy && this.editProxy.canAddFormulaFields));

    if (canAddFormulaFields) {
        if (needSeparator) menuItems.add({ isSeparator: true });

        if (field && field.userFormula && field.canEditFormula != false) {
            menuItems.add({
                title: this.editFormulaFieldText,
                grid: this,
                field: field,
                click: "item.grid.editFormulaField(item.field)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });

            menuItems.add({
                title: this.removeFormulaFieldText,
                grid: this,
                field: field,
                click: "item.grid.removeField(item.field.name)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });
        }

        menuItems.add({
            title: this.addFormulaFieldText,
            grid: this,
            click: "item.grid.addFormulaField()",
            icon: "[SKINIMG]ListGrid/formula_menuItem.png"
        });
        needSeparator = true;
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    var canAddSummaryFields = (this.canAddSummaryFields || (this.editingOn && this.editProxy && this.editProxy.canAddSummaryFields));

    if (canAddSummaryFields) {
        if (needSeparator) menuItems.add({ isSeparator: true });

        if (field && field.userSummary && field.canEditSummary != false) {
            menuItems.add({
                title: this.editSummaryFieldText,
                grid: this,
                field: field,
                click: "item.grid.editSummaryField(item.field)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });

            menuItems.add({
                title: this.removeSummaryFieldText,
                grid: this,
                field: field,
                click: "item.grid.removeField(item.field.name)",
                icon: "[SKINIMG]ListGrid/formula_menuItem.png"
            });
        }

        menuItems.add({
            title: this.addSummaryFieldText,
            grid: this,
            click: "item.grid.addSummaryField()",
            icon: "[SKINIMG]ListGrid/formula_menuItem.png"
        });
        needSeparator = true;
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    var canEditHilites = (this.canEditHilites || (this.editingOn && this.editProxy && this.editProxy.canEditHilites));
    if (canEditHilites) {
        if (needSeparator) menuItems.add({ isSeparator: true });

        menuItems.add({
            title: this.editHilitesText,
            grid: this,
            click: "item.grid.editHilites()"
        });
    }

    if (returnFirstItem && menuItems.length > 0) return menuItems;

    if (this.canSaveSearches) {
        
        {
            this.logWarn("The canSaveSearches property requires SmartClient Pro or better. " +
                "See https://www.smartclient.com/product/ to find the edition right for you.");
        }
    }

    return menuItems;
},
      
// Helper to determine whether a specific field should show the "autoFit" menu option
// and allow autoFit via the headerAutoFitEvent
canAutoFitField : function (field) {
    if (field.canDragResize == false) return false;
    if (this.canResizeFields == false) return false;
    if (field.canAutoFitWidth != null) return field.canAutoFitWidth;
    return !!this.canAutoFitFields;
},

// clearFilterItemClick - fired when the user clicks the "clear filter" menu item
clearFilterItemClick : function () {
    this.clearAllCriteria();
},

//> @method listGrid.clearAllCriteria()
// This method, the equivalent of the builtin 
// +link{listGrid.clearFilterText, Clear Filter menu-item}, clears all user-visible criteria 
// applied to this grid, including values and filter-operators in the
// +link{listGrid.showFilterEditor, filter-row} and criteria in the 
// +link{listGrid.allowFilterWindow, advanced filter window}, and issues a re-filter.
// @visibility external
//<
clearAllCriteria : function () {
    this.setFilterEditorCriteria(null);
    // also clear filterWindowCriteria if set
    this.clearFilterWindowCriteria(false);
    // re-filter data with empty criteria
    this.filterByEditor();
},

//> @method listGrid.clearFilterWindowCriteria()
// Clears criteria applied to this grid via the 
// +link{listGrid.allowFilterWindow, advanced filter window} and issues a re-filter.
// <p>
// To clear all user-editable criteria, see +link{listGrid.clearAllCriteria}.
// @visibility external
//<
clearFilterWindowCriteria : function (refilter) {
    // clear filterWindowCriteria if set
    if (this.filterWindowCriteria != null) {
        delete this.filterWindowCriteria;
        this._showFilterWindowCriteriaIndicator();
        // re-filter data without filterWindow criteria
        if (refilter != false) {
            this.filterByEditor();
            // return true - a filter happened
            return true;
        }
    }
    // if no criteria to clear, or "refilter" is false, return false - no filter happened
    return false;
},

//> @attr listGrid.allowFilterWindow (Boolean : null : IR)
// Adds the ability for a user to define additional criteria above and beyond those expressed
// in the +link{showFilterEditor,filter editor} via a +link{class:FilterBuilder} which appears
// in a modal Window over the grid and can be accessed by various menus within the grid or
// triggered by external controls.
// <p>
// Causes a menu item titled +link{advancedFilteringText,"Advanced Filtering"} to appear in the
// +link{filterUsingText,"Filter using"} menu show in the +link{showHeaderContextMenu,headerContextMenu}
// that allows the end user to configure an advanced filter on the grid that can supplement the
// +link{showFilterEditor,filter editor}. Note that the menu option will show even
// if +link{allowFilterOperators,filter operators} is disabled.
// <p>
// To use this feature, the grid must be configured with a +link{dataSource}. In fact, this
// feature is enabled by default if the grid has a +link{DataSource} and both
// +link{dataSource.supportsAdvancedCriteria()} and +link{allowFilterOperators} are true.
// This default can be disabled by setting <code>allowFilterWindow</code> to
// <code>false</code>. 
// <p>
// +externalLink{https://www.smartclient.com/smartclient-latest/showcase/?id=filterWindow,This example}
// shows the <code>allowFilterWindow</code> setting in use.
// <p>
// <b>Note:</b> this feature requires
// +externalLink{https://www.smartclient.com/product/,SmartClient Pro} or better.
// 
// @see allowFilterOperators
// @visibility external
//<

shouldAllowFilterWindow : function () {
    

        
        if (this.allowFilterWindow && !isc.ListGrid._unsupportedAllowFilterWindowWarningShown) {
            this.logWarn("The allowFilterWindow property requires SmartClient Pro or better. " +
                "See https://www.smartclient.com/product/ to find the edition right for you.");
            isc.ListGrid._unsupportedAllowFilterWindowWarningShown = true;
        }

        return false;
    

},

// advancedFilteringItemClick - fired when the user clicks the "advanced filtering..." menu item
advancedFilteringItemClick : function (fieldName) {
    this.showFilterWindow(fieldName);
},

//> @attr listGrid.filterWindow (AutoChild Window : null : IR)
// Instance of +link{Window} used to +link{showFilterWindow,show} the
// +link{filterWindowFilter,FilterBuilder}.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use 
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// <p>
// By default the <code>FilterBuilder</code> shows with the top operator selection as a
// radio group and allows switching between simple and advanced modes. These defaults can
// be changed using +link{group:autoChildUsage,autoChild} features such as setting
// +link{filterWindowFilter,filterWindowFilter} properties on a grid instance or globally
// by changing the <code>ListGrid</code> defaults.
// <p>
// <smartclient>
// For example, in JavaScript, to always use advanced mode on a single grid:
// <pre>
// var grid = isc.ListGrid.create({
//     ...
//     filterWindowFilterProperties: {
//         topOperatorAppearance: "bracket",
//         showModeSwitcher: false
//     }
// });
// </pre>
// or to always use advanced mode:
// <pre>
// isc.ListGrid.changeDefaults("filterWindowFilter", {
//     topOperatorAppearance: "bracket",
//     showModeSwitcher: false
// });
// </pre>
// </smartclient>
// <smartgwt>
// For example, to always use advanced mode on a single grid:
// <pre>
// FilterBuilder filterBuilderProperties = new FilterBuilder();          
// filterBuilderProperties.setTopOperatorAppearance(TopOperatorAppearance.BRACKET);
// filterBuilderProperties.setShowModeSwitcher(false);
//
// ListGrid listGrid = new ListGrid();
// listGrid.setAutoChildProperties("filterWindowFilter", filterBuilderProperties);
// </pre>
// or to always use advanced mode: 
// <pre>
// ListGrid.changeAutoChildDefaults("filterWindowFilter", filterBuilderProperties);
// </pre>
// </smartgwt>
// 
// @visibility external
//<
filterWindowDefaults : {
    autoParent: "none",
    _constructor: "Window",

    isModal: true,
    width: "65%",
    minWidth: 800,
    maxWidth: 1150,
    height: 400,
    canDragResize: true,
    canDragReposition: true,
    vertical: true,
    autoCenter: true,
    showMinimizeButton: false,

    title: "Advanced Filtering"
},

//> @attr listGrid.filterWindowFilter (AutoChild FilterBuilder : null : IR)
// Instance of +link{FilterBuilder} shown in +link{filterWindow} by +link{showFilterWindow}.
// See +link{filterWindow} for more information on the filter defaults and changing them.
// @visibility external
//<
filterWindowFilterDefaults: {
    autoParent: "none",
    _constructor: "FilterBuilder",
    overflow: "auto",
    height: "*",
    showModeSwitcher: true
},

//> @attr listGrid.filterWindowInstructions (HTMLString : "Enter criteria below. These criteria are <i>in addition to</i> any criteria entered in the filter immediately above column headers." : IR)
// The instruction text to display at the top of the +link{filterWindow}.
// @group i18nMessages
// @visibility external
//<
filterWindowInstructions: "Enter criteria below. These criteria are <i>in addition to</i> any criteria entered in the filter immediately above column headers.",

editModeFilterWindowInstructions: "When you Run or Deploy your application, this window " +
    "allows users to add additional, advanced criteria to the grid.<P>" +
    "While you are editing your application, instead, criteria defined here are treated as " +
    "<em>Implicit Criteria</em> that your users will not be aware of, and cannot edit or remove.",

//>	@method listGrid.showFilterWindow()
// Shows the dialog for +link{filterWindowCriteria} allowing end-users to edit
// the advanced filter. This method can be called directly but it is also used to show the
// dialog when +link{allowFilterWindow} is enabled and the user chooses the
// +link{advancedFilteringText,"Advanced Filtering"} menu option.
// <p>
// <b>Note:</b> this feature requires
// +externalLink{https://www.smartclient.com/product/,SmartClient Pro} or better.
//
// @visibility external
//<
showFilterWindow : function (field) {
            
    {
        this.logWarn("showFilterWindow() requires SmartClient Pro or better. " +
            "See https://www.smartclient.com/product/ to find the edition right for you.");
    }
},

//>	@attr listGrid.filterWindowCriteria (Criteria : null : IRW)
// Advanced filtering criteria, either +link{type:Criteria,simple} or
// +link{AdvancedCriteria,advanced}, that is combined with the 
// +link{listGrid.getFilterEditorCriteria,filter editor criteria} during filtering.
// <P>
// This criteria is normally configured via +link{showFilterWindow,advanced filtering dialog}
// shown because of the +link{allowFilterWindow} option but can be assigned directly as well.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use 
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// @getter getFilterWindowCriteria()
// @setter setFilterWindowCriteria()
// @visibility external
//<

//>	@method listGrid.setFilterWindowCriteria()
// Setter for +link{listGrid.filterWindowCriteria}.
// @param criteria (Criteria) criteria for advanced filtering
// @visibility external
//<
setFilterWindowCriteria : function (criteria) {
    this.filterWindowCriteria = criteria;

    // Update filter on current data. The filterWindowCriteria will be applied late in the process.
    var filterEditorCriteria = this.getFilterEditorCriteria();
    this.filterData(filterEditorCriteria);

    this._showFilterWindowCriteriaIndicator();
},

//> @method listGrid.getFilterWindowCriteria()
// Returns the current +link{filterWindowCriteria}.
//
// @return (Criteria) a copy of the current filter window criteria
// @visibility external
//<
getFilterWindowCriteria : function () {
    return isc.shallowClone(this.filterWindowCriteria);
},

//> @attr listGrid.showFilterWindowCriteriaIndicator (Boolean : true : IR)
// Should an indicator be shown to indicate that +link{filterWindowCriteria} is configured?
// The indicator is a small triangle shown in the top-right of the grid header or filter.
// 
// @visibility external
//<
showFilterWindowCriteriaIndicator: true,

//> @attr listGrid.filterWindowCriteriaIndicator (AutoChild Canvas : null : IR)
// Instance of +link{Canvas} used to show visual indicator that +link{filterWindowCriteria}
// is configured. +link{showFilterWindowCriteriaIndicator} must be enabled to show indicator.
// @visibility external
//<
filterWindowCriteriaIndicatorDefaults: {
    _constructor: isc.Canvas,
    width: 10,
    height: 10,
    contents: "<div style='width: 0;height: 0;border-top: 10px solid ${this.color};border-left: 10px solid transparent'/>",
    dynamicContents: true,
    overflow: "hidden",
    snapTo: "TR",
    setColor : function (color) {
        this.color = color;
        this.markForRedraw();
    }
},

//> @attr listGrid.criteriaIndicatorColor (String : "#0066cc" : IR)
// The color of the +link{showFilterWindowCriteriaIndicator, filterWindow criteria indicator}.
// 
// @visibility external
//<
criteriaIndicatorColor: "#0066cc",

//> @attr listGrid.criteriaIndicatorHeaderColor (String : null : IR)
// The color of the +link{showFilterWindowCriteriaIndicator, filterWindow criteria indicator}
// when shown on the +link{sorterConstructor, sorter button} or the last
// +link{headerButtonConstructor, header button} in the grid header. The default is to use
// +link{criteriaIndicatorColor}.
// 
// @visibility external
//<
//criteriaIndicatorHeaderColor: null,

_hideFilterWindowCriteriaIndicator : function () {
    if (this.filterWindowCriteriaIndicator) {
        // This is to prevent invalid DOM reference during filter editor removal because the
        // snapTo refers to a removed target. The next _show call will recreate the indicator
        // as needed.
        this.filterWindowCriteriaIndicator.hide();
        this.filterWindowCriteriaIndicator.markForDestroy();
        this.filterWindowCriteriaIndicator = null;
    }
},

_showFilterWindowCriteriaIndicator : function () {
    if (!this.showFilterWindowCriteriaIndicator) return;

    // Criteria produced by FilterBuilder for an empty or cleared critera still has the
    // wrapper but with an empty criteria property. Use simplifyAdvancedCriteria() to
    // return null when the criteria is empty.
    var criteria = isc.DS.simplifyAdvancedCriteria(this.filterWindowCriteria, true);
    if (criteria) {
        if (!this.filterWindowCriteriaIndicator) {
            this.filterWindowCriteriaIndicator = this.createAutoChild("filterWindowCriteriaIndicator");
        }
        var color = this.criteriaIndicatorColor,
            target
        ;

        if (this._shouldLeaveScrollbarGap()) {
            if (this.showFilterEditor && this.filterEditor) {
                target = this.filterEditor.actionButton;
            } else {
                target = this.sorter;
                color = this.criteriaIndicatorHeaderColor || color;
            }
        } else {
            if (this.showFilterEditor && this.filterEditor) {
                target = this.filterEditor.actionButton;
            } else {
                var lastHeaderButton = this.getFieldHeaderButton(this.getFields().length-1);
                target = lastHeaderButton;
                color = this.criteriaIndicatorHeaderColor || color;
            }
        }

        target.addPeer(this.filterWindowCriteriaIndicator);
        this.filterWindowCriteriaIndicator.setColor(color);
        this.filterWindowCriteriaIndicator.moveAbove(target);
        this.filterWindowCriteriaIndicator.show();
        if (target.isDrawn && !this.filterWindowCriteriaIndicator.isDrawn()) this.filterWindowCriteriaIndicator.draw();
    } else {
        if (this.filterWindowCriteriaIndicator) {
            // Since the canvas encapsulates a <div> we need to clear the canvas rather than
            // just hide it
            this.filterWindowCriteriaIndicator.clear();
        }
    }
},

fireCriteriaChanged : function () {
    // ignoreStateChangeHandlers is set in setViewState(), eg, and is used to prevent
    // the various public state-changed notifications from firing during internal work
    if (this.criteriaChanged && !this.ignoreStateChangeHandlers) {
        this.fireCallback(this.criteriaChanged);
    }
    // if saving criteria, call handleViewStateChanged();
    if (this.saveCriteriaInViewState) this.handleViewStateChanged();
},


// ------------------------------------
// SearchForm
// ------------------------------------

//> @attr listGrid.searchForm (DynamicForm | ValuesManager : null : IRW)
// When declared, the specified form is automatically used as a search form for this grid, 
// with criteria that are additive with any criteria shown in the FilterEditor or 
// +link{allowFilterWindow,Filter Window}.
// <p>
// For a discussion of the various filtering and criteria-management APIs and when to use 
// them, see the +link{group:gridFiltering, Grid Filtering overview}.
// <P>
// This is similar to the effect of adding a +link{filterEditorSubmit} override that pulls 
// in criteria from the external form, and having the external form call 
// +link{listGrid.filterByEditor()} instead of +link{fetchData()}, as shown in the 
// +exampleLink{additiveFilter} example.
// <P>
// In particular. the grid will automatically filter when the searchForm.search() or 
// dynamicForm.submit() event fires on the form (happens if a SubmitItem is present and is 
// pressed), and will automatically trigger filtering if enter is pressed in the form, as 
// though searchOnEnter / saveOnEnter had been set.
// <P>
// If the FilterEditor is enabled and listGrid.filterOnKeypress is set, the grid will 
// automatically watch for searchForm.criteriaChanged(), and filter whenever that method 
// fires.  For the purposes of this behavior, the FilterEditor is considered to be enabled 
// even if it is not currently visible but +link{canShowFilterEditor} is true (as 
// otherwise filtering behavior in the form would change when the FilterEditor appears).
// <P>
// The criteria from the specified <code>searchForm</code> will only be shown and edited in
// the external form; they will neither be shown nor editable in the FilterEditor, even if 
// the FilterEditor also allows criteria on the same fields.  That is, they are treated 
// much like +link{listGrid.implicitCriteria}.
// <P>
// Note: when using <code>listGrid.searchForm</code> don't add your own logic to call 
// fetchData() or the criteria you specify will appear in the FilterEditor and be editable 
// there, potentially creating user confusion, especially if some of the criteria in your 
// form cannot be displayed and edited in the FilterEditor.
//
// @group searchCriteria
// @visibility external
//<

// apply a new searchForm
setSearchForm : function (searchForm) {
    if (this._observingSearchForm) this._ignoreSearchForm();
    this.searchForm = searchForm;
    if (this.searchForm) this._observeSearchForm();
},
_observeSearchForm : function () {
    var sf = this.searchForm;

    // always observe submit (DF/VM)
    if (sf.submit) this.observe(sf, "submit", "observer.searchFormChanged(observed, 'submit');");

    // if filterOnKeypress is true, and sf is not an actual SearchForm instance, install 
    // itemChanged() if it isn't already there (SearchForm fires criteriaChanged, see below)
    if (this.filterOnKeypress && !sf.isSearchForm) {
        if (!sf.itemChanged) sf.addMethods({ itemChanged : function () { return; } });
        this.observe(sf, "itemChanged", "observer.searchFormChanged(observed, 'itemChanged');");
    }

    if (isc.isA.ValuesManager(sf)) {
        // simulate saveOnEnter on all forms in the VM
        for (var i=0; i<sf.members.length; i++) {
            //if (!isc.isA.DynamicForm(sf.members[i])) continue;
            sf.members[i].__shouldSaveOnEnter = sf.members[i]._shouldSaveOnEnter;
            sf.members[i]._shouldSaveOnEnter = function () { return true };
        }
    } else if (isc.isA.DynamicForm(sf)) {
        // simulate saveOnEnter and searchOnEnter by having _shouldSaveOnEnter() return true
        sf.__shouldSaveOnEnter = sf._shouldSaveOnEnter;
        sf._shouldSaveOnEnter = function () { return true };

        if (sf.isSearchForm) {
            // observe search()
            if (sf.search) this.observe(sf, "search", "observer.searchFormChanged(observed, 'search');");
            // if filterOnKeypress is installed, hook criteriaChanged()
            if (this.filterOnKeypress) {
                if (!sf.criteriaChanged || sf.criteriaChanged == isc.Class.NO_OP) {
                    sf._origCriteriaChanged = sf.criteriaChanged;
                    sf.criteriaChanged = function () { return; };
                }
                this.observe(sf, "criteriaChanged", "observer.searchFormChanged(observed, 'criteriaChanged');");
            }
        }
    }

    // install valuesChanged if it isn't there, and observe it - VM
    if (!sf.valuesChanged) sf.addMethods({ valuesChanged: function () { return; } });
    this.observe(sf, "valuesChanged", "observer.searchFormChanged(observed, 'valuesChanged');");
    
    this._observingSearchForm = true;
    
    // and store the searchForm's initial values as local criteria
    this.searchFormCriteria = this.searchForm.getValuesAsAdvancedCriteria();
},
_ignoreSearchForm : function () {
    var sf = this.searchForm;
    if (!sf) return;
    if (this.isObserving(sf, "itemChanged")) this.ignore(sf, "itemChanged");
    if (this.isObserving(sf, "submit")) this.ignore(sf, "submit");
    if (this.isObserving(sf, "search")) this.ignore(sf, "search");
    if (this.isObserving(sf, "criteriaChanged")) {
        this.ignore(sf, "criteriaChanged");
        if (sf._origCriteriaChanged) {
            sf.criteriaChanged = sf._origCriteriaChanged;
            delete sf._origCriteriaChanged;
        }
    }
    if (this.isObserving(sf, "valuesChanged")) this.ignore(sf, "valuesChanged");
    if (isc.isA.ValuesManager(sf)) {
        // clear simulated saveOnEnter on all forms in the VM
        for (var i=0; i<sf.members.length; i++) {
            if (sf.members[i].__shouldSaveOnEnter) {
                sf.members[i]._shouldSaveOnEnter = sf.members[i].__shouldSaveOnEnter;
                delete sf.members[i].__shouldSaveOnEnter;
            }
        }
    } else if (sf.__shouldSaveOnEnter) {
        sf._shouldSaveOnEnter = sf.__shouldSaveOnEnter;
        delete sf.__shouldSaveOnEnter;
    }
    delete this.searchFormCriteria;
    delete this._observingSearchForm;
},
searchFormChanged : function (searchForm, sourceMethod) {
    var searchCrit = searchForm.getValuesAsAdvancedCriteria();
    // don't react to multiple events firing with the same criteria
    var ds = this.getDataSource();
    if (ds && ds.compareCriteria(searchCrit, this.searchFormCriteria) == 0) return;
    // apply the new criteria
    this.applySearchFormCriteria(searchCrit);
    // and cause the general update
    this.fireCriteriaChanged();
},
applySearchFormCriteria : function (criteria) {
    //this.logWarn("Applying searchForm criteria: " + isc.echoFull(criteria));
    this.searchFormCriteria = criteria;

    // Update filter on current data. The searchFormCriteria will be applied late in the process.
    var filterEditorCriteria = this.getFilterEditorCriteria();
    this.filterData(filterEditorCriteria);
},
getSearchFormCriteria : function () {
    return isc.shallowClone(this.searchFormCriteria);
},

// helper to lazily assign and observe grid.searchForm 
// - if searchForm is unset or _observingSearchForm is already true, nothing to do 
// - if searchForm it's a widget, observe it 
// - if searchForm is a string, assign the associated widget if it exists, and observe it
// this method is called from body.redraw() to cater for an initial autoFetch returning, and 
// also from filterEditorSubmit() (filterData) and _filter(), as a fallback
checkForSearchForm : function () {
    // check if grid.searchForm can be set up yet - in Reify/ComponentXML, this will be an 
    // unresolved string-ID initially, and the widget with that ID may not yet have been 
    // created
    if (this.searchForm && !this._observingSearchForm) {
        if (isc.isA.String(this.searchForm)) {
            // string ID - if the widget exists, assign and observe it
            var widget = isc.Canvas.getById(this.searchForm);
            if (widget) {
                this.searchForm = widget;
                this._observeSearchForm();
            }
        } else {
            this._observeSearchForm();
        }
    }
},

//> @attr listGrid.showFilterEditorHovers (Boolean : null : IR)
// When set to false, no hover is shown for the filter editor fields. Otherwise, a hover shows
// the current field's criteria description along with the +link{filterWindowCriteria}
// description if configured.
// <p>
// Hovers can also be disabled for individual fields using
// +link{listGridField.showFilterEditorHovers}.
// <p>
// The descriptive text for criteria is formatted by +link{DataSource.getAdvancedCriteriaDescription}.
// 
// @see listGridField.showFilterEditorHovers
// @visibility external
//<

//> @attr listGrid.fieldCriteriaText (HTMLString : "Field criteria:" : IR)
// The field criteria prefix to show in filter editor field hover before the descriptive
// version of the field's criteria, if any. The descriptive text is formatted by
// +link{DataSource.getAdvancedCriteriaDescription}.
// @group i18nMessages
// @visibility external
//<
fieldCriteriaText:"Field criteria:",

//> @attr listGrid.gridAdditionalCriteriaText (HTMLString : "Grid additional criteria:" : IR)
// The additional criteria prefix to show in filter editor field hover, the filter action
// button or the sorter button before the descriptive version of the +{filterWindowCriteria},
// if any. The descriptive text is formatted by +link{DataSource.getAdvancedCriteriaDescription}.
// @group i18nMessages
// @visibility external
//<
gridAdditionalCriteriaText:"Grid additional criteria:",

getFieldCriteriaHover : function (field, filter) {
    var ds = this.getDataSource(),
        hover
    ;
    // Allow user to disable hover for filter editor fields at grid or field-level
    if (field && (this.showFilterEditorHovers == false || field.showFilterEditorHovers == false)) {
        return null;
    }

    if (field) {
        // get the filterEditor item for the field
        var item = this.getFilterEditor().getEditFormItem(field.name);
        // get it's criterion - may be complex, like a greaterThan && lessThan pair
        var criteria = item && item.getCriterion();
        // If the field is part of the criteria provide a hover for it
        if (criteria) {
            hover = isc.DS.getCriterionDescription(criteria, ds);
            
        }
    }
    
    if (!hover && !field && filter) hover = this.filterButtonPrompt;
    return hover;
},

// given a flat advancedCriteria as produced from the filterEditor, extract the criterion
// for a given field. There is only one.
_getFieldCriterion : function (fieldName, criteria) {
    if (!criteria.criteria) return null;
    return criteria.criteria.find("fieldName", fieldName);
},

//> @method ListGrid.getHeaderContextMenu()
// If +link{attr:listGrid.showHeaderContextMenu} is <code>true</code> this method returns
// the menu to display when the user right-clicks on the header or corner sort button of
// this listGrid.<br>
// Default implementation displays the list of available columns, and allows the user to
// change the visibility of each column by selecting the appropriate fieldName.
// @group gridHeader
// @visibility internal
//<
// Leave this internal for now - If a developer wishes to display a custom header context menu
// they can override displayHeaderContextMenu() instead.
// Overriding this method is not as clean - the developer would also need to override
// getHeaderContextMenuItems(), [which will be called each time the menu is actually shown]
headerContextMenuConstructor:"Menu",
headerContextMenuDefaults:{
    // On Hide, if we're showing the headerMenuButton, hide it
    hide : function () {
        this.Super("hide", arguments);
        var grid = this.grid;
        if (grid) {
            // always reset this flag, even in touch browsers, or sort-toggling never works
            grid._showingHeaderContextMenu = false;
            
            var lastEvent = isc.EH.lastEvent;
            if (!isc.Browser.isTouch && (lastEvent.eventType != isc.EH.MOUSE_DOWN ||
                                         lastEvent.target != grid.headerMenuButton))
            {
                grid._hideHeaderMenuButton();
            }
        }
    },
    // sorting
    doSort : function (fieldNum, direction) {
        if (direction == "unsort") this.grid.toggleSort(this.grid.getFieldName(fieldNum), direction);
        else this.grid.sort(fieldNum, direction);
    },
    canHover:true,
    showHover:true,
    cellHoverHTML : function(record,rowNum,colNum) { return record.prompt },
    groupField : function (item) {
        var grid = this.grid,
            gridGroupByFields = grid.getGroupByFields();
        if ((item.targetField && item.groupType) ||
            !(gridGroupByFields && gridGroupByFields.length == 1 && 
              gridGroupByFields.contains(item.fieldName)))
        {
            // make a GroupSpecifier for the menu-item and call setGroupSpecifiers()
            // if groupType is null, makeGroupSpecifier() will use the field/simpleType default
            var spec = grid.makeGroupSpecifier(item.fieldName, item.groupType, 
                    item.groupGranularity, item.groupPrecision);
            
            spec._oldGrouping = item.targetField.groupingMode || "none";
            item.targetField.groupingMode = item.groupType;
            grid.setGroupSpecifiers([spec]);
        }
    },

    ungroup : function () {
        this.grid.ungroup();
    }
},
getHeaderContextMenu : function () {
    return this.createAutoChild("headerContextMenu", {
        ID:this.getID() + "_cornerMenu",
        grid : this
    }, this.getMenuConstructor());
},

//> @method listGrid.getSortArrowImage() (A)
// Return the sort arrow image used in the sorter button and the current sort col header button.
// @group drawing
// @return (ImgProperties | HTMLString) HTML for sorter button
//<
getSortArrowImage : function (fieldNum, returnImg, clipTitle, wrap, rotateTitle) {
    if (fieldNum == null) fieldNum = this._getSortFieldNum();
    var img = null;
    if (this.showSortArrow != false && fieldNum != null) {
        var field = this.getField(fieldNum),
            fieldDirection = field && field.sortDirection;
        if (fieldDirection == null) fieldDirection = this.sortDirection;
        img = Array.shouldSortAscending(fieldDirection)
              ? this.sortAscendingImage
              : this.sortDescendingImage;
    }
    if (returnImg) return img;

    if (img != null) {
        return this.imgHTML(isc.addProperties({
            imgDir: this.widgetImgDir,
            extraCSSText: (clipTitle && this.clipHeaderTitles) || wrap || rotateTitle ? 
                (rotateTitle ? (this.isRTL() ? "float:left;" : "float:right;") :
                 (this.isRTL() ? "float:left;margin-right:4px" : 
                                 "float:right;margin-left:4px")) : null
        }, img));
    } else {
        return isc.Canvas.spacerHTML(1, 1);
    }
},

//> @method listGrid.sorterClick() (A)
// Notification method fired when the user clicks on the corner
// +link{listGrid.sorterConstructor, sort button}.  Return false to suppress the sort.
//
// @return (boolean) return false to suppress the sort
// @group events, sorting
// @visibility external
//<

_sorterClick : function () {
    if (this.sorterClick && !this.sorterClick()) return;

    var sortFieldNum = this._getSortFieldNum();

    // if the list can't sort, return false
    if (!this._canSort(sortFieldNum)) return false;

    if (sortFieldNum != null) {
        var sortField = this.getField(sortFieldNum),
            fieldName = sortField[this.fieldIdProperty],
            globalSortDir = this._baseSortDirection,
            sortDir = this._getFieldSortDirection(sortField)
        ;
        if (this.isSortField(fieldName)) {
            // we're already sorted - decide whether to toggle or unsort
            if (globalSortDir == sortDir || this.canUnsort == false) {
                this.toggleSort(fieldName);
            } else {
                this.toggleSort(fieldName, "unsort");
            }
        } else {
            this.setSort([{ property: fieldName, direction: globalSortDir }]);
        }
    } else {
        this.sort(
            sortFieldNum,
            (sortFieldNum != null ?
                !Array.shouldSortAscending(this.getField(sortFieldNum).sortDirection) :
                null)
        );
    }
},

//> @attribute listGrid.showDropLines (boolean : true : IRW)
// Controls whether to show a drop-indicator during a drag and drop operation.
//
// @visibility external
//<


shouldShowDragLineForRecord : function(recordNum) {
    return this.canReorderRecords && this.showDropLines != false;
},

// Drag Line
// --------------------------------------------------------------------------------------------
// Note that the row and column drag lines are the same Canvas

//> @method listGrid.showDragLineForRecord()    (A)
// Show the drag line relative to a particular record.
// <p>
// If no record number is passed, assumes the one under the mouse.
// <p>
// This is used to show feedback in reordering rows or to insert dragged records at a particular
// row.
//      @group  dragging, drawing
//<
showDragLineForRecord : function (recordNum, position) {
    if (!this.shouldShowDragLineForRecord(recordNum)) return;

    var body = this.body;

    // get the event record
    if (recordNum == null) recordNum = this.getEventRecordNum();

    // If 'recordNum' is -1, we're above the top of the list.
    // This is basically invalid - the user dragged over the header, so just bail.
    // Note: willAcceptDrop() will return false in this case - however
    // this method is called from dropMove() which is tripped by EH without checking
    // for the result of willAcceptDrop
    if (recordNum == -1) {
        if (this._dragLine) this._dragLine.hide();
        return;
    }

    // if 'recordNum' is -2 - we're in the blank area underneath the last record.  Show the
    // drop line underneath the last record.
    var lastVisibleRow = body.getVisibleRows()[1];
    if (recordNum == -2) recordNum = lastVisibleRow;

    // if the record is not enabled, you can't drop on it (unless you're trying to drop at the end
    // of the list, which is special)
    if (this._dragLine && recordNum != lastVisibleRow) {
        var record = this.getCellRecord(recordNum);
        if (!this.recordIsEnabled(record, recordNum)) {
            return this._dragLine.hide();
        }
    }

    // before, after (or over)?
    if (position == null) position = this.getRecordDropPosition(recordNum);
    // now move the dragLine to the proper place and show it
    var leftBody = this.getLeftBody();
    var left = leftBody.getPageLeft()
        + (this.isRTL() && leftBody.vscrollOn ? leftBody.getScrollbarSize() : 0);
    if (position == isc.ListGrid.BEFORE) {
        // drag line above record
        this.showHDragLine(left, body.getRowPageTop(recordNum));
        this._dragLine.afterRow = recordNum -1;
    } else if (position == isc.ListGrid.AFTER) {
        // drag line under record
        this.showHDragLine(left,
                           (body.getRowPageTop(recordNum) + body.getRowSize(recordNum)));
        this._dragLine.afterRow = recordNum;
    } else {
        // if we are not dropping before or after the record, hide the dragLine and bail.
        if (this._dragLine) this._dragLine.hide();
        return;
    }

    if (this.recordDropMove) {
        this.fireCallback("recordDropMove", "viewer,recordNum,record,position",
                          [this, recordNum, this.getRecord(recordNum), position])
    }

},

showHDragLine : function (pageLeft, pageTop) {
    // make sure the drag line is set up
    this.makeDragLine();
    // and resize it to span the viewport.  Note: needs to be based on the overall ListGrid,
    // not the body, since there may be multiple bodies with frozen columns.
    
    this._dragLine.resizeTo(
            this.getViewportWidth() - (this.body.vscrollOn ? this.body.getScrollbarSize() : 0), 2);

    // place it
    var bodyTop = this.body.getPageTop(),
        bodyBottom = bodyTop + this.body.getVisibleHeight();
    if (pageTop < bodyTop) pageTop = bodyTop;
    else if (pageTop > bodyBottom) pageTop = bodyBottom;
    this._dragLine.setPageRect(pageLeft, pageTop);

    // and show it
    this._dragLine.show();
    this._dragLine.moveAbove(this.getTopLevelCanvas());
},


//> @method listGrid.showDragLineForField() (A)
//      Show the drag line relative to a particular field.
//      If no field number is passed, assumes the one under the mouse.
//
//      This is used to show feedback in resizing or moving fields (columns).
//
//      @param  [fieldNum]      (number)    Number of the field to show line for.
//                                          Default is the field under the mouse.
//      @param  [headerOnly]    (boolean)   Show in the header only (true), or over the entire
//                                          list?  Default is over the entire list (false).
//
//      @group  dragging, drawing
//<
showDragLineForField : function (fieldNum, headerOnly) {
    // make sure the drag line is set up
    this.makeDragLine();
    // and resize it to cover the entire height of the listGrid
    if (headerOnly == true || !this.body) {
        this._dragLine.resizeTo(2, this.getHeaderHeight());
    } else {
        
        this._dragLine.resizeTo(2, this.getHeaderHeight() + this.body.getVisibleHeight());
    }

    // get the event record
    if (fieldNum == null) fieldNum = this.getEventFieldNum();

    if (fieldNum < 0) {
        this._dragLine.hide();
        return;
    }

    // now move the dragLine to the proper place and show it

    // dragLine placement:
    // - we shouldn't use body.getColumnLeft() or similar because the body could be displaying
    //   the empty message
    // - resize is from right edge in LTR, left edge in RTL
    // - since the header object may not be doing live redraw, use dragResizeWidth rather than
    //   current header widget width
    // - adjust by 1px to center the 2px-wide drag line
    var resizingField = this.ns.EH.dragTarget,
        left = (!this.isRTL() ?
            // resize is from right edge
            resizingField.getPageLeft() + this.ns.EH.dragResizeWidth :
            // resize if from left edge
            resizingField.getPageRight() - this.ns.EH.dragResizeWidth) - 1;

    this._dragLine.setPageRect(left, this.getPageTop()
                                     + (this.showFilterEditor ? this.filterEditorHeight : 0));
    this._dragLine.bringToFront();
    this._dragLine.show();
},



// Sorting
// --------------------------------------------------------------------------------------------

//> @method listGrid.unsort()
// Turn sorting off, typically because data has changed and is no longer sorted.
// <p>
// Calling <code>unsort()</code> disables visual indication of which columns are sorted,
// and calls <code>unsort()</code> on the underlying dataset if supported.
// <P>
// Note that a grid viewing a paged dataset may not be able to support +link{resultSet.unsort()}
// because the sort order is what establishes the row numbering that allows data to be
// fetched in batches. In this case the dataset will be explicitly sorted to an empty 
// array which may cause the cache to be invalidated and a new fetch performed.
// <P>
// <code>unsort()</code> is automatically called in response to edits or changes to the
// data set that would cause records to be reordered.
//
// @group   sorting
// @visibility external
//<
// Undocumented keepLocalData parameter will be threaded all the way through to data.setSort()
// for data sets that don't support a true unsort. This parameter will be passed to us by
// 'unsortOnChange', for unsort due to user-edit or changes to the sort field of a specific record.
// It allows the expected behavior of edited records not jumping out of view in a partial data set
// so the user gets the experience documented in resultSet.updatePartialCache

unsort : function (keepLocalData) {
    this.setSort(null, keepLocalData);
},

//> @method listGrid.resort()
// If a list has become unsorted due to data modification or a call to
// +link{ListGrid.unsort()}, this method will resort the list by the previous
// +link{listGrid.setSort, sort-specifier} array, if there is one, or by the previous
// sort-field and -direction.
//
// @group sorting
// @visibility external
//<
resort : function () {
    // if already resorting, bail
    if (this._resorting) return;
    this._resorting = true;
    if (this._sortSpecifiers) return this.setSort(isc.shallowClone(this._sortSpecifiers));
    var sortFieldNum = this._getSortFieldNum();
    if (sortFieldNum != null) {
        var field = this.getField(sortFieldNum),
            sortDirection = this._getFieldSortDirection(field)
        ;

        return this.sort(sortFieldNum, sortDirection);
    }
},

//> @method listGrid.sort()   ([])
// Sort this grid's data, with the option to explicitly specify a single field to
// sort by and sort direction.
// <P>
// If sortField is not provided and listGrid.sortField is undefined, the data will be sorted
// by the first sortable column according to +link{ListGridField.sortDirection} if specified,
// or +link{ListGrid.sortDirection}.
// <P>
// ListGrids also support multiple-field sorting. See +link{listGrid.setSort()} for details.
// <P>
// Note that for editable grids, sorting is performed by underlying data values, not
// for unsaved +link{listGrid.getEditValues(),pending edit values}. When the user saves
// edits in a sorted grid, the grid will automatically be +link{unsort(),unsorted}. See
// +link{group:editing} for further details.
//
// @param [sortField] (String | number) the field name or column number to sort by
// @param [sortDirection] (SortDirection) the direction to sort in
// @return (Boolean) sorting worked
//
// @see type:SortDirection
// @group sorting
// @visibility external
//<
_$sort:"sort",
sort : function (sortFieldNum, sortDirection) {
    var sortFieldName,
        sortField
    ;

    if (isc.isA.String(sortFieldNum)) {
        // sortFieldNum is actually a sortFieldName
        sortFieldName = sortFieldNum;
        sortFieldNum = this.getFieldNum(sortFieldName);
        if (sortFieldNum < 0) {
            // the field isn't visible - it might still be in completeFields if specified
            // as hidden in lg.fields, or it might only appear in the DS
            sortField = this.getUnderlyingField(sortFieldName);
        }
    }

    if (!sortField) {
        // remember the current sortField num and direction for redrawing sorter images
        var oldSortFieldNum = this._getSortFieldNum(),
            oldSortDirection =
                (oldSortFieldNum != null ?
                            Array.shouldSortAscending(this.getField(oldSortFieldNum).sortDirection) :
                            null);

        // if no sortField was specified, assume sorting by the current sort field if there is
        // one, or the first sortable field otherwise.
        if (sortFieldNum == null) {
            if (oldSortFieldNum != null) {
                sortFieldNum = oldSortFieldNum;
            } else {
                // if this.sortFieldNum is null, default to the first sortable field
                for (var i = 0; i < this.fields.length; i++) {
                    if (this._canSortData(this.fields[i]) != false) {
                        sortFieldNum = i;
                        break;
                    }
                }
            }
        }
        // if sortFieldNum is still null, no fields are sortable and we should bail
        if (sortFieldNum == null) return false;

        sortField = this.getField(sortFieldNum);
    }

    // if we have no sortField, bail!
    if (sortField == null) {
        return;
    }

    if (sortDirection == null) {
        sortDirection = this._getFieldSortDirection(sortField);
    }

    // If we're already sorted in the specified direction by the specified field, bail!
    if (oldSortFieldNum == sortFieldNum && sortDirection == sortField.sortDirection) return;

    var specifier = {
            property: sortField[this.fieldIdProperty],
            direction: Array.shouldSortAscending(sortDirection) ? "ascending" : "descending"
        }
    ;
    return this.setSort([specifier]);
},

_getSortFieldNum : function () {
    if (this.sortFieldNum != null) return this.sortFieldNum;
    // sortField is doc'd, sortFieldNum is not. If sortField is set, resolve to a number,
    // store, and return the number
    if (this.sortField != null) {
        var fieldNum = this.getFieldNum(this.sortField);
        if (fieldNum == -1) fieldNum = null;
        this.sortFieldNum = fieldNum;
        // normalize the sortField attribute to a fieldName for consistency, in case it
        // was originally specified as a field index.
        var fieldName = this.getFieldName(this.sortFieldNum);
        if (fieldName) this.sortField = fieldName;
        return fieldNum;
    }
    return null;
},

_setSortFieldNum : function (fieldNum) {
    this.sortFieldNum = fieldNum;
    var fieldName = this.getFieldName(fieldNum);
    // update the public 'sortField' attribute in case anyone checks it.
    this.sortField = fieldName;
},

//> @method listGrid.getSortField()
// Returns the current sort field for this grid. Note that if +link{setSort()} has been
// used to sort by multiple fields, you can call +link{getSort()} to retrieve details about
// the complete sort applied to the grid.
//
// @return (String) sort field name
// @group sorting
// @visibility external
//<
getSortField : function () {
    return this.sortField;
},

// Multi-level Sorting
//> @attr listGrid.canMultiSort (Boolean : true : IRW)
// When true, indicates that this ListGrid supports sorting on multiple fields.  Note that even
// when set to true, multi-field sorting may not be available if the grid is databound and the
// +link{DataSource.canMultiSort,DataSource doesn't support multi-sort}, or if sorting for a
// field is +link{listGridField.canSortClientOnly,client-only} but not all data is available.
// @serverDS allowed
// @see sortNumeralMenuButtonSpaceOffset
// @visibility external
//<
canMultiSort: true,

//> @method listGrid.askForSort()
// @include dataBoundComponent.askForSort()
// @visibility external
//<

//> @attr listGrid.multiSortDialogDefaults (MultiSortDialog Properties : null : IR)
// @include dataBoundComponent.multiSortDialogDefaults
// @visibility external
//<

//> @attr listGrid.multiSortDialogProperties (MultiSortDialog Properties : null : IR)
// @include dataBoundComponent.multiSortDialogProperties
// @visibility external
//<

// Multi-level Grouping

//> @attr listGrid.canMultiGroup (boolean : false : IRW)
// When true, indicates that this ListGrid supports grouping on multiple fields.
// @serverDS allowed
// @visibility external
//<
canMultiGroup: false,

//> @attr listGrid.initialSort (Array of SortSpecifier : null : IR)
// An array of +link{SortSpecifier} objects used to set up the initial sort configuration for
// this grid. If specified, this will be used instead of any +link{listGrid.sortField} specified.
// @group sorting
// @visibility external
//<
//initialSort: null,

//> @method listGrid.toggleSort() (A)
//  Toggles the sort-direction of the field with the passed name and resorts the grid.
// @param fieldName (String) The name of a field, visible, hidden or existing only in the
//   dataSource
// @group sorting
// @visibility external
//<
toggleSort : function (fieldName, direction) {
    // get the current list of specifiers and the one for the passed fieldName
    var field = this.getSpecifiedField(fieldName),
        specifiers = this._sortSpecifiers ? isc.shallowClone(this._sortSpecifiers) : [],
        specifier = specifiers.find("property", fieldName)
    ;

    // if no existing sort-field, check by displayField
    if (!specifier && field.displayField) {
        specifier = specifiers.find("property", field.displayField);
        if (!specifier) return;
    }

    // if no direction passed in, work one out
    if (!direction)
        direction = Array.shouldSortAscending(specifier.direction) ?
            "descending" : "ascending";

    // if we're unsorting, remove the field from the specifiers array, otherwise set the direction
    if (direction == "unsort") specifiers.remove(specifier);
    else specifier.direction = direction;

    this.setSort(specifiers);
},

_addSort : function (sortField, sortDirection) {
    if (!isc.isAn.Object(sortField)) {
        sortField = this.getSpecifiedField(sortField);
    }
    var direction = sortDirection || this._getFieldSortDirection(sortField);
    this.addSort(
        {
            property: sortField[this.fieldIdProperty],
            direction: Array.shouldSortAscending(direction) ? "ascending" : "descending"
        }
    );
},

//> @method listGrid.addSort() (A)
//  Adds another +link{SortSpecifier} to this grid's sort configuration and resorts.
// @param sortSpecifier (SortSpecifier) A SortSpecifier object indicating an additional field
//    and direction to sort by
// @visibility external
//<
addSort : function (sortSpecifier) {
    var specifiers = this._sortSpecifiers ? isc.shallowClone(this._sortSpecifiers) : [];
    specifiers.add(sortSpecifier);
    this.setSort(specifiers);
},

//> @method listGrid.getSort()
// Returns the current +link{SortSpecifier,SortSpecifiers} for this ListGrid. Will return null if this grid
// has never been sorted (and has no specified +link{initialSort} or +link{sortField}).
// <P>
// Note that if sorting was applied via +link{sort()} [rather than +link{setSort()}] the
// sortSpecifiers returned will have been created based on the specified sort field / direction
// passed into +link{sort()}.
//
// @return (Array of SortSpecifier) current sort specifiers for this grid (may be null if
//  this grid is unsorted).
// @group sorting
// @visibility external
//<
getSort : function () {
    // once sort(), or setSort() has actually run this._sortSpecifiers will be set.
    // Always treat this as the definitive set of specifiers, if present
    if (this._sortSpecifiers) {
       return this.removeSortSpecifierMarkers(isc.shallowClone(this._sortSpecifiers));
    // we haven't sorted yet
    // Check for initialSort first (more recent, more advanced option, for multi-field sort)
    } else if (this.initialSort) {
        return isc.shallowClone(this.initialSort);
    // It could also be that we need to apply sort before draw, as @ http://forums.smartclient.com/showpost.php?p=131926&postcount=6
    } else if (this.sortState) {
        var sortState = this.evalViewState(this.sortState, "sortState") || {};
        return sortState.sortSpecifiers || sortState;
    // check for sortField / sortDirection being set
    } else {
        // support sortFieldNum and sortField (as a single fieldName or array of sortBy strings)
        var field;
        if (this.sortFieldNum != null) field = this.getField(this.sortFieldNum);
        if (!field && this.sortField != null) {
            // getUnderlyingField() will pick up the field from the
            // completeFields array or the dataSource fields if necessary
            field = this.getUnderlyingField(this.sortField);
        }
        if (field) {
            var direction = this._getFieldSortDirection(field);
            return [{property: field[this.fieldIdProperty], direction: direction }];
        }
    }
},


//> @method listGrid.getSortSpecifier() (A)
//  Returns the +link{SortSpecifier} for the passed fieldName, or null if the field is not
// sorted.
// @param fieldName (String) The name of a field, visible, hidden or existing only in the dataSource
// @return (SortSpecifier) for the passed fieldName, or null if the field is not sorted.
// @visibility external
//<
getSortSpecifier : function (fieldName) {
    var item = null;

    if (this._sortSpecifiers && this._sortSpecifiers.length > 0) {
        item = this._sortSpecifiers.find("property", fieldName);
        if (!item) {
            // see if we're sorted by displayField
            // if field.optionDataSource is specified, the display-field doesn't refer to a field
            // value on this data set.
            var field = this.getSpecifiedField(fieldName);
            if (field && field.displayField && !field.optionDataSource) {
                item = this._sortSpecifiers.find("property", field.displayField);
            }
        }
    }
    return item;
},

//> @method listGrid.getSortFieldCount() (A)
//  Returns the number of fields involved in this grid's current sort configuration.
// @return (Number) the number of fields this grid is currently sorted on.
// @visibility external
//<
getSortFieldCount : function () {
    return this._sortSpecifiers ? this._sortSpecifiers.length : 0;
},

//> @method listGrid.isSortField() (A)
//  Returns true if the passed fieldName is in the current sort-specification.
// @param fieldName (String) The name of a field, visible, hidden or existing only in the dataSource
// @return (Boolean) True if the passed field is sorted, false otherwise
// @visibility external
//<
isSortField : function (fieldName) {
    var result = this.getSortSpecifier(fieldName) ? true : false;
    if (!result) {
        // see if we're sorted by displayField
        var field = this.getSpecifiedField(fieldName);
        
        if (field && field.displayField && !field.optionDataSource) {
            result = this.getSortSpecifier(field.displayField) ? true : false;
        }
    }
    return result;
},

//> @attr listGrid.sortNumeralStyle (CSSStyleName : "sortNumeral" : [IRWA])
// When multiple fields are sorted, the Style to apply to the numeral that appears after the
// sort-arrows in the header-buttons of sorted fields.
// @visibility external
//<
sortNumeralStyle: "sortNumeral",

//> @attr listGrid.showSortNumerals (boolean : null : [IRWA])
// When multiple fields are sorted, set this to false to hide the sort-numeral
// displayed by default after the sort-arrows in the header-buttons of sorted fields.
// @visibility external
//<

//> @method listGrid.getSortNumeralHTML()
// When multiple fields are sorted, this method returns the HTML for the sort-numeral that
// appears after the sort-arrows in the header-buttons of sorted fields.  If you don't want
// sort-numerals in the header-buttons, you can override this
// method to return null or an empty string, or set +link{showSortNumerals} to false.
// <P>
// Note that the sortIndex passed in is zero based. The default implementation of this method
// returns an HTML element with the +link{sortNumeralStyle} applied to it, containing the
// specified sortIndex incremented by 1 (therefore showing the more user-friendly 1-based
// numbering system).
//
// @param fieldName (String) The name of a sort-field to get the
//  +link{listGrid.sortNumeralStyle, sortNumeral} HTML for.
// @param sortIndex (int) The sort index for the field.
// @return (HTMLString) The HTML for this field's sortNumeral
// @visibility external
//<

_$sortNumeralHTMLTemplate: [
    "<span class='",        // [0]
    ,                       // [1] this.sortNumeralStyle
    "' style='",            // [2]
    ,                       // [3] inline CSS text
    "'>",                   // [4]
    ,,,                     // [5-7] (sortIndex + 1)
    "</span>"               // [8]
],
getSortNumeralHTML : function (fieldName, sortIndex, extraCSSText) {
    var template = this._$sortNumeralHTMLTemplate;
    template[1] = this.sortNumeralStyle;
    template[3] = extraCSSText;
    isc._fillNumber(template, (sortIndex + 1), 5, 3);
    return template.join(isc.emptyString);
},


// 
// APIs to get text CSS "writing mode" and CSS rotation transform

_$rotateText180:"transform:rotate(180deg);",

_getTextTransform : function (isVertical, isRTL) {
    if (!isVertical) return null;
    if (isRTL == null) isRTL = this.isRTL();
    var modeCSS = isc.Browser._writingModeCSS;
    return (isRTL ? modeCSS.rotate_rtl : modeCSS.rotate_ltr) ? this._$rotateText180 : null;
},
_getTextWritingMode : function (isVertical, isRTL) {
    var modeCSS = isc.Browser._writingModeCSS;
    if (!isVertical) return modeCSS.horizontal;
    if (isRTL == null) isRTL = this.isRTL();
    return isRTL ? modeCSS.vertical_rtl : modeCSS.vertical_ltr;
},


//> @method listGrid.clearSort()    (A)
//  This method clears any existing sort on this grid by calling +link{listGrid.setSort} with
// a null parameter.  The internal list of +link{SortSpecifier}s is removed and the grid is
// unsorted.
// @visibility external
//<
clearSort : function (fireChangeNotification) {
    // ignoreStateChangeHandlers prevents the various public state-changed notifications 
    var ignoreStateChangeHandlers = this.ignoreStateChangeHandlers;
    if (!fireChangeNotification) this.ignoreStateChangeHandlers = true;
    this.setSort(null);
    if (!fireChangeNotification) this.ignoreStateChangeHandlers = ignoreStateChangeHandlers;
},

// add implicit sort specifiers to the given collection, as necessary and appropriate
_addImplicitSort : function(sortSpecifiers, groupByFields) {

    
    if (!groupByFields) groupByFields = this._groupByFields || this.getGroupByFields() || [];

    var modified = false,
        result = isc.shallowClone(sortSpecifiers);

    if (this.sortByGroupFirst && !groupByFields.isEmpty()) {

        this.logInfo("Evaluating implicit sort for grouping " + isc.echoAll(groupByFields), "sorting");

                
        
        //var defaultSortOrder = sortSpecifiers.isEmpty() ? "ascending" : sortSpecifiers[0].direction;
        //this._groupSortDirection = this.groupSortDirection || this._groupSortDirection || defaultSortOrder;

        var defaultSortOrder = sortSpecifiers.isEmpty() ? "ascending" : null;
        if (!sortSpecifiers.isEmpty() && !this.groupSortDirection) {
            // no groupSortDirection specified - sort the groups according to the direction of the primarySort
            for (var i = 0; i < sortSpecifiers.length; i++) {
                var spec = sortSpecifiers[i];
                if (!spec.sortedImplicitly) {
                    if (spec.direction != null) defaultSortOrder = spec.direction;
                    break;
                }
            }
        }
        this._groupSortDirection = this.groupSortDirection || defaultSortOrder;

        for (var i = 0; i < groupByFields.length; i++) {
            var name = groupByFields[i];

                    
            if (sortSpecifiers.find("property", name)) {
                this.logInfo("Existing sort specifier found for property '" + name +"'.  Skipping.", "sorting");
                continue;
            }
            var field = this.getUnderlyingField(name);

            
            if (field == null) continue;

            var specifier = {
                sortedImplicitly: true,
                context: this,
                // if the field isn't databound and no type was specified, default to "text"
                normalizer: this.groupSortNormalizer || 
                    this._getSortNormalizerForField(field) || "text",
                property: name,
                direction: this._groupSortDirection
            }
            result.addAt(specifier, i);
            modified = true;
        }
    }

    if (modified) {
        this.logInfo("Returning augmented sort specifiers" + isc.echoAll(result), "sorting");
    } else {
        this.logInfo("Returning unmodified sort specifiers" + isc.echoAll(result), "sorting");
    }

    return result;
},

//> @method listGrid.getSortByGroupFirst() (A)
// @see sortByGroupFirst
// @visibility external
//<
getSortByGroupFirst : function() {
    return this.sortByGroupFirst;
},

//> @method listGrid.setSortByGroupFirst() (A)
// @param sortByGroupFirst (Boolean) 
// @visibility external
//<
setSortByGroupFirst : function (sortByGroupFirst) {
    this.sortByGroupFirst = sortByGroupFirst;
},

_getSortNormalizerForField : function (field) {

    if (field.sortNormalizer) {
        // custom normalizer defined
        return field.sortNormalizer;
    }

    // for user fields, install a sort normalizer that tries to 
    // evaluate the formula/summary so we have something to sort
    var grid = this;
    if (field.userFormula) return function (record, field) {
        if (record._isGroup) return record.groupValue;
        return grid.getFormulaFieldValue(field, record);
    };
    if (field.userSummary) return function (record, field) {
        if (record._isGroup) return record.groupValue;
        return grid.getSummaryFieldValue(field, record);
    };

    // summary - value should already be in a record metadata field
    if (field.type == this._$summary) {
        return function (record, field) {
            return record[grid._getRecordSummaryAttributeProperty(field)];
        };
    }

    if (field.valueMap && !isc.isAn.Array(field.valueMap) &&
        (field.sortByMappedValue == null || field.sortByMappedValue == true)) {
        // if there's a valueMap, use it as the normalizer, so that with eg enums
        // we sort by the text name rather than the numeric order.
        
        var normalizerFromMap = isc.addProperties(
                {}, 
                isc.isA.String(field.valueMap) ? this.getGlobalReference(field.valueMap) 
                                                : field.valueMap
        );
        normalizerFromMap._derivedFromValueMap = true;
        return normalizerFromMap;
    }
    
    if ((this._isGrouped || this.isGrouped) && field.groupingMode) {
        var groupSpec = this.getGroupSpecifiers();
        if (groupSpec.find("property", field.name)) {
            return function (record, lField) {
                var fieldName = field.name,
                    value;
                if (record._isGroup) value = record.groupValue;
                else value = record[fieldName];
                //isc.logWarn("groupValue: " + record.groupValue + " :: " +
                //    "recordValue: " + record[fieldName] + " --- returning " + value);
                return value;
            };
        }
    }

    if (field.type != null) {
        // if an explicit field type is declared, pass that in as a normalizer -
        // the sort method understands this.
        return field.type;
    }
},

//> @method listGrid.setSortHandler()  (A)
// Optional notification fired when either user or framework code calls 
// +link{listGrid.setSort(),setSort()}.  This notification fires before the default behavior; 
// <smartclient>return false from the handler</smartclient>
// <smartgwt>use <code>event.cancel()</code></smartgwt> to cancel the default behavior.  Note,
// the notification is fired before the default functionality, but <em>after</em> prechecks 
// have completed; your method will only be called if the default behavior would have been
// called.  For example, if there are pending edits and the user does not confirm that these 
// should be saved, normal sorting would not have gone ahead, so equally your handler will 
// not be called.
// <P>
// The default <code>setSort()</code> method does two things to reflect the set of 
// +link{object:sortSpecifier,sortSpecifier}s passed to it:<ul>
// <li>Change the grid UI (show directional arrows, numerals to indicate sort priority, etc)</li>
// <li>Actually sort the grid data</li>
// </ul>
// If your reason for implementing a custom <code>setSortHandler()</code> is to inhibit or 
// replace one of those behaviors, you should cancel the default behavior and directly invoke
// just that part of it you require.  The following implementation will replicate the default
// behavior:<smartclient><pre>
//   setSortHandler : function(sortSpecifiers) {
//       this.displaySort(sortSpecifiers);
//       this.applySortToData(sortSpecifiers);
//       return false;  // Prevent the framework from running its own default impl
//   }</pre></smartclient>
// <smartgwt><pre>
//   grid.addSetSortHandler(new SetSortHandler() {
//       public void onSetSort(SetSortEvent event) {
//           displaySort(event.getSortSpecifiers());
//           applySortToData(event.getSortSpecifiers());
//           event.cancel();  // Prevent the framework from running its own default impl
//       }
//   });</pre></smartgwt>
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @return (boolean) return false to cancel the default setSort() behavior 
// @visibility external
//<

//> @method listGrid.setSort()  (A)
// Sort the grid on one or more fields.
// <P>
// Pass in an array of +link{SortSpecifier}s to have the grid's data sorted by the fields in
// each +link{sortSpecifier.property,specifier.property} and in the directions specified.  The
// grid can be sorted by any combination of fields, including fields specified in the fields
// array, whether visible or hidden, and +link{DataSource.fields, unused fields from the
// underlying dataSource}, if there is one.
// <P>
// If multiple fields are sorted, those that are visible show a directional icon and a small
// +link{listGrid.sortNumeralStyle, sort-numeral}
// indicating that field's index in the sort configuration.
// <P>
// See +link{listGrid.addSort, addSort()} and +link{listGrid.toggleSort, toggleSort()} APIs
// for information on making changes to the current sort configuration.
// <P>
// Note that for editable grids, sorting is performed by underlying data values, not
// for unsaved +link{listGrid.getEditValues(),pending edit values}.
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @visibility external
//<
// Undocumented 'keepLocalDataOnUnsort' parameter will be passed to resultSet.setSort()
// if we're unsorting. This tells the resultSet to keep its local data for now but
// invalidate the row order so it'll invalidate cache on the next fetch.
_$setSort: "setSort",
setSort : function (sortSpecifiers, keepLocalDataOnUnsort) {
    if (this.logIsInfoEnabled("sorting")) this.logInfo("Entering setSort", "sorting");
    if (!this._resortingFlagStored) this._storeResortingFlag();

    // if we get passed something that isn't an array, wrap it in one
    if (sortSpecifiers && !isc.isAn.Array(sortSpecifiers)) sortSpecifiers = [sortSpecifiers];

    
    var ds = this.getDataSource();
    if (!ds && this.formItem && this.formItem.optionDataSource) {
        this.initialSort = sortSpecifiers;
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("setSort() not performing sort - this is a pickList who's DS is not yet present", "sorting");
        }
        return false;
    }
    
    // if there are no fields arrays bail
    
    if (!this.fields && !this.getDataSource()) {
        
        this.initialSort = sortSpecifiers;
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("setSort() not performing sort - no fields", "sorting");
        }
        return false;
    }

    // If we are databound, and we have pending edits, the sort may cause us to lose edit
    // values (because the rows get lost from the local cache). Catch this case and warn the
    // user if appropriate.
    if (this.confirmDiscardEdits && this.dataSource != null) {
        if (this.hasChanges() &&
            // If we have a complete cache, the sort will not drop any edit values
            // (and they will be re-associated with the appropriate rows via remapEditValues)
            isc.ResultSet && isc.isA.ResultSet(this.data) && !this.data.allMatchingRowsCached())
        {
            
            this.showLostEditsConfirmation({target:this, methodName:"_continueSort"},
                                               {target:this, methodName:"_cancelSort"});
            // this._sortArgs gets cleaned up by the callback methods above
            this._sortArgs = sortSpecifiers
            return;
        }
    }

    // get a list of specifiers that *were* in use but won't be after this setSort() call
    var sortSpecifiers = sortSpecifiers || [],
        removeThese = [],
        firstVisibleField
    ;

    if (this._sortSpecifiers) {
        // get a list of items that *were* in the sort-spec but aren't any more, so we can
        // update their header-states
        for (var i = 0; i < this._sortSpecifiers.length; i++) {
            var oldItem = this._sortSpecifiers[i],
                newItem = sortSpecifiers.find("property", oldItem.property)
            ;
            if (!newItem) {
                removeThese.add(isc.shallowClone(oldItem));
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In setSort - marking field "+oldItem.property+
                        " for removal", "sorting");
                }
            }
        }
    }

    if (!sortSpecifiers || sortSpecifiers.length==0) {
        // no sort-specifiers passed, we'll forcibly unsort
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("null or zero-length sortSpecifiers - unsorting only", "sorting");
        }
    }

    var newSpecifiers = [];

    // handle the normalizer stuff that used to be done in sortData() for each sortSpecifier
    // and store a couple of useful vars on the item, sortIndex (for the numeral) and
    // primarySort, which indicates this is the first Visible field (and, thus, the sortFieldNum)
    sortSpecifiers.removeEmpty();
    for (var i = 0; i < sortSpecifiers.length; i++) {
        if (!sortSpecifiers[i]) continue;

        var item = sortSpecifiers[i],
            field = this.getUnderlyingField(item.property),
            visibleField = this.getField(item.property),
            normalizer=null
        ;

        if (field && field.sortByField) {
            item.sortByProperty = field.sortByField;
            field = this.getUnderlyingField(item.sortByProperty);
        }

        if (!field) {
            // if getUnderlyingField() didn't return a field, check for a field with
            // a displayField equal to item.property
            var fields = this.getAllFields();
            field = !fields ? null : fields.find("displayField", item.sortByProperty ? item.sortByProperty : item.property);
        }

        if (field) {
            if (!this._canSortData(field)) {
                // data in this field can't be sorted because the field specifies client-only
                // sort, but not all data is presently client-side.  Skip this specifier and
                // log a warning.
                this.logWarn("Removing field '" + field[this.fieldIdProperty] + "' from the " +
                    "sortSpecifier array because it specifies canSortClientOnly: true and all " +
                    "data is not yet client-side.", "sorting");
                continue;
            }

            // is this the first visible field? (this will be grid.sortFieldNum)
            if (visibleField) {
                if (!firstVisibleField) firstVisibleField = visibleField;
            }
            // set up a sortNormalizer
            if (!item.normalizer) {
                item.normalizer = this._getSortNormalizerForField(field);
            }
            // set the default sort-direction if none is provided
            if (item.direction == null) {
                item.direction = this._getFieldSortDirection(field);
            }
            if (firstVisibleField && firstVisibleField == visibleField) {
                item.primarySort = true;
            }
            // store the new sortDirection on the grid from the first sort specifier
            if (item.primarySort) {
                // normalize the sort direction to a boolean and store it on the grid
                this.sortDirection = Array.shouldSortAscending(item.direction);
            }
            if (!item.context) item.context = this;
            item.sortIndex = i;

            newSpecifiers.add(item);
        } else {
            this.logDebug("ListGrid sort specifier for property:" + item.property +
                            " has no associated field - ignoring", "sorting");
        }
    } 

    // store the old specifiers so we can decide whether to fire sortChanged() with the new ones
    this._oldSpecifiers = this._sortSpecifiers ? isc.shallowClone(this._sortSpecifiers) : [];

    // store the sortSpecifiers
    // Update initialization property to match new sort specifier state
    this.sortSpecifiers = this._sortSpecifiers = newSpecifiers;
    
    // Save for downstream processing, so we don't have to do it twice (once for UI update, 
    // once for the actual data sort)
    this._allSpecifiers = this._addImplicitSort(this._sortSpecifiers),
    this._sameSpecifiers = (this._allSpecifiers.length == this._oldSpecifiers.length);
    this._removeThese = removeThese;
    
    if (this._sameSpecifiers && this._oldSpecifiers.length > 0) {
     
        // if the new specifiers (including the implicit ones) are the same as the old ones,
        // we'll still (re)sort, but won't fire sortChanged()
        for (var i = 0; i < this._allSpecifiers.length; i++) {
            var item = this._allSpecifiers[i];
            var matchProps = {
                property : item.property,
                direction : item.direction
            };
            
            var defaultNormalizer = this.data.getDefaultNormalizer 
                                    ? this.data.getDefaultNormalizer(item.property) : null;
            
            
            if (item.normalizer != null && item.normalizer != defaultNormalizer) {
                matchProps.normalizer = item.normalizer;
            }
            var itemIndex = this._oldSpecifiers.findIndex(matchProps);
            if (itemIndex == null || itemIndex < 0) {
                this._sameSpecifiers = false;
                break;
            }
        }
    }

    // If there is a user-registered setSortHandler(), call it and allow it to cancel default
    // behavior by returning explicit false
    if (this.setSortHandler && this.setSortHandler(newSpecifiers) === false) {
        this.logInfo("User-written setSortHandler() method returned false", "sorting");
        return false;
    }

    this.displaySort(newSpecifiers);


    this.applySortToData(this._allSpecifiers, keepLocalDataOnUnsort);

    // delete this flag once the sort operation finishes - otherwise, a call to resort() will
    // cause all future calls to setSort() to resort the data instead of applying a new spec
    delete this._resortingFlagStored;
    // also delete the resorting flag - otherwise, further resorts won't do anything, since that
    // method now bails if this attribute is already set to true - prevents an infinite loop
    // causeby by an incorrect (but possible) call to resort() from a dataChanged handler.
    delete this._resorting;

    return true;
},

//> @method listGrid.displaySort()  (A)
// Modify the grid UI to reflect the parameter sortSpecifiers.  For a single sortSpecifier, 
// this consists of marking the field with a directional arrow in its header button (if it 
// visible).
// <P>
// If multiple fields are sorted, those that are visible show a directional icon and a small
// +link{listGrid.sortNumeralStyle, sort-numeral} indicating that field's index in the sort 
// configuration.
// <P>
// See +link{listGrid.addSort, addSort()} and +link{listGrid.toggleSort, toggleSort()} APIs
// for information on making changes to the current sort configuration.
// <p>
// <b>NOTE:</b> This method is primarily used by +link{listGrid.setSort()}; it is not intended 
// to be called by user code, unless you are implementing a custom 
// +link{listGrid.setSortHandler(),setSortHandler}).  For the normal use case, calling this 
// method directly will fail to execute vital pre-steps.  If you are not implementing a custom
// handler as described above, do not call this method directly - call <code>setSort()</code> 
// instead.
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @visibility external
//<
displaySort : function(sortSpecifiers) {
    if (this.logIsInfoEnabled("sorting")) this.logInfo("Entering displaySort", "sorting");

    sortSpecifiers = sortSpecifiers || this._sortSpecifiers;

    var hasSort = sortSpecifiers && sortSpecifiers.length > 0,
        firstSpecifier = hasSort ? sortSpecifiers[0] : null,
        sortFieldName = firstSpecifier ? firstSpecifier.property : null,
        visibleSortFieldNum = sortFieldName ? this.getFieldNum(sortFieldName) : null,
        sortField = sortFieldName ? this.getUnderlyingField(sortFieldName) : null,
        sortDirection = firstSpecifier ? Array.shouldSortAscending(firstSpecifier.direction) : null
    ;

    if (hasSort && !sortField) {
        if (firstSpecifier) {
            this.logWarn("sort: field does not exist: " + firstSpecifier.property);
        }
    }

    if (visibleSortFieldNum >= 0) {
        this._setSortFieldNum(visibleSortFieldNum);
    } else {
        this._setSortFieldNum(null);
    }

    if (this.logIsInfoEnabled("sorting")) {
        this.logInfo("In displaySort - ready to change visible sort state for specifiers:\n"+
            isc.echoAll(sortSpecifiers), "sorting");
    }

    var allSpecifiers = this._allSpecifiers,
        oldSpecifiers = this._oldSpecifiers,
        sameSpecifiers = (allSpecifiers.length == oldSpecifiers.length),
        removeThese = this._removeThese
    ;

    // A note on edit-rows:
    // This sort will change the rowNums for records - if we have unsaved edits for any rows,
    // this means the 'rowNum' will have to be updated for that edit information.
    // We handle this via '_remapEditRows()' called in response to 'dataChanged()', so no need
    // to do any special handling for this here.  Note also that if we have embedded components,
    // these are remapped in the same way via '_remapEmbeddedComponents()'

    var hasHeader = (this.header && isc.isA.Toolbar(this.header));

    // remove the sort indicators from any fields that *were* sorted but now aren't and
    // are still visible
    if (removeThese) {
        if (removeThese.length > 0) {
            if (this.logIsInfoEnabled("sorting")) {
                this.logInfo("In displaySort - Removing sort-media from now unsorted fields:\n"+
                    isc.echoAll(removeThese), "sorting");
            }
        }

        for (var i=0; i<removeThese.length; i++) {
            var specifier = removeThese[i],
                field = this.getSpecifiedField(specifier.property),
                fieldsToSelect = []
            ;

            if (field) {
                fieldsToSelect.add(field);
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In displaySort, removing sort-media for fieldName '" +
                        field.name + "'", "sorting");
                }
            }

            var fields = this.getFields();
            if (fields) {
                var byDisplayField = fields.findAll("displayField", specifier.property);
                if (byDisplayField) {
                    // If displayField is specified with an optionDataSource this should
                    // not impact sort - the display field doesn't refer to field values in
                    // this data-set
                    byDisplayField.removeUnless("optionDataSource", null);
                    if (byDisplayField.length > 0) {
                        fieldsToSelect.addList(byDisplayField);
                        if (this.logIsInfoEnabled("sorting")) {
                            this.logInfo("In displaySort, removing sort-media for fields with displayField " +
                                "'" + field.name + "' - these are: " +
                                isc.echoFull(byDisplayField.getProperty("name").join(", ")), "sorting");
                        }
                    }
                }
            }

            for (var j=0; j<fieldsToSelect.length; j++) {
                var localField = fieldsToSelect[j],
                    fieldNum = this.getFieldNum(localField.name)
                ;

                if (localField) {
                    localField.sortDirection = localField.originalSortDirection;
                }

                if (fieldNum>=0 && hasHeader) {
                    // select the appropriate button
                    var sortButton = this.getFieldHeaderButton(fieldNum);
                    if (sortButton && sortButton.setTitle) sortButton.setTitle(sortButton.getTitle());
                    // height of button must be recalculated
                    delete localField._calculatedMinHeight
                }
            }
        }
    }

    // set sort indicators on the current set of sort fields.
    if (hasSort) {
        this.logInfo("In displaySort - Setting sort-media for sorted fields:\n"+
                isc.echoAll(sortSpecifiers), "sorting");

        var headerSelected = false;
        // set the sort indicators on any fields that are sorted and are visible
        for (var i=0; i<sortSpecifiers.length; i++) {
            var specifier = sortSpecifiers[i],
                field = this.getSpecifiedField(specifier.property),
                fieldsToSelect = []
            ;

            if (field) {
                fieldsToSelect.add(field);
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In displaySort, adding sort-media for fieldName '" +
                        field.name + "'", "sorting");
                }
            }

            var fields = this.getFields();
            if (fields) {
                var byDisplayField = fields.findAll("displayField", specifier.property);
                if (byDisplayField) {
                    fieldsToSelect.addList(byDisplayField);
                    if (this.logIsInfoEnabled("sorting")) {
                        this.logInfo("In displaySort, adding sort-media for fields with displayField " +
                            "'" + field.name + "' - these are: " +
                            isc.echoFull(byDisplayField.getProperty("name").join(", ")), "sorting");
                    }
                }
            }

            for (var j=0; j<fieldsToSelect.length; j++) {
                var localField = fieldsToSelect[j],
                    fieldNum = this.getFieldNum(localField.name)
                ;

                if (localField) {
                    if (localField.sortDirection && !localField.originalSortDirection) {
                        localField.originalSortDirection = localField.sortDirection;
                    }
                    localField.sortDirection = specifier.direction;
                }
                if (hasHeader && fieldNum>=0) {
                    // select the appropriate button
                    var sortHeader = this.getFieldHeader(fieldNum),
                        sortButton = this.getFieldHeaderButton(fieldNum);

                    if (sortButton) {
                        if (!headerSelected && this.selectHeaderOnSort) {
                            sortHeader.selectButton(sortButton);
                            if (isc.Browser.isTouch && this.shouldShowHeaderMenuButton(sortButton, true)) {
                                this._showHeaderMenuButton(sortButton);
                            }
                            headerSelected = true;
                        }
                        if (sortButton.setTitle) sortButton.setTitle(this.getHeaderButtonTitle(sortButton));
                    }
                }
            }
        }
    } else if (hasHeader && this.selectHeaderOnSort) {
        // when unsorting, deselect the selected header-button, if there is one
        var selectedButton;
        if (this.header) {
            selectedButton = this.header.getSelectedButton();
            if (selectedButton) {
                selectedButton.deselect();
                this._hideHeaderMenuButton(selectedButton);
            }
        }
        if (this.frozenHeader) {
            selectedButton = this.frozenHeader.getSelectedButton();
            if (selectedButton) selectedButton.deselect();
        }
    }

    if (visibleSortFieldNum >= 0) {
        if (this.logIsInfoEnabled("sorting")) {
            this.logInfo("In displaySort - _setSortFieldNum called with fieldNum: "+visibleSortFieldNum+
                " - sortField is now: "+this.sortField+"\ngetSortState() now returns: "+
                isc.echoAll(this.getSortState()), "sorting");
        }
    }

    // if there's a sorter button, redraw that
    if (this.sorter && this.sorter.setTitle) {
        this.sorter.setTitle(this.sorter.getTitle());
    }

    if (this.logIsInfoEnabled("sorting")) this.logInfo("Leaving displaySort", "sorting");

    return true;
},


//> @method listGrid.applySortToData()  (A)
// Sort the grid's data to reflect the parameter sortSpecifiers.
// <p>
// <b>NOTE:</b> This method is primarily used by +link{listGrid.setSort()}; it is not intended 
// to be called by user code, unless you are implementing a custom 
// +link{listGrid.setSortHandler(),setSortHandler}).  For the normal use case, calling this 
// method directly will fail to execute vital pre-steps.  If you are not implementing a custom
// handler as described above, do not call this method directly - call <code>setSort()</code> 
// instead.
//
// @param sortSpecifiers (Array of SortSpecifier) Array of +link{SortSpecifier} objects
// @visibility external
//<
// keepLocalDataOnUnsort param will be passed through to resultSet.setSort() if sortSpecifiers are null
applySortToData : function (sortSpecifiers, keepLocalDataOnUnsort) {
    if (this.logIsInfoEnabled("sorting")) this.logInfo("Entering applySortToData", "sorting");

    var allSpecifiers = sortSpecifiers || this._allSpecifiers,
    	hasSort = allSpecifiers && allSpecifiers.length > 0,
        firstSpecifier = hasSort ? allSpecifiers[0] : null,
        data = this.data 
    ;    

    if (hasSort) {
        //var originalData = this.getOriginalData();
        //var needsRegroup = (data != originalData);
        if (this._calledFromResort && data && data.resort && data._sortSpecifiers) {
            // if called from resort() and the data has a resort() method (ResultSet), AND
            // the data has already been sorted, call resort() instead of setSort() (which
            // will no-op for the same specifiers)
            data.resort();
        } else if (data &&
            (data.setSort || data.length > 0
                || isc.isA.ResultTree(data) || isc.isA.Tree(data)))
        {

            for (var i = 0; i < allSpecifiers.length; i++) {
                var spec = allSpecifiers[i],
                    field = this.getUnderlyingField(spec.property);

                // For binary fields, always pick up the file-name field
                // Store as specifier.sortByProperty - this is respsected by data objects
                // such as Array / ResultSet
                if (this.sortBinaryByFileName && field && field.sortByField == null &&
                    isc.SimpleType.inheritsFrom(field.type,"binary", this.getDataSource())) 
                {
                    // duplicate the specified sort so we don't impact what the user sees
                    spec = isc.addProperties({}, spec)
                    // sort by the target field instead...
                    spec.sortByProperty = this.getDataSource().getFilenameField(field);
                    allSpecifiers[i] = spec;
                }
            }
        
            // do the actual sorting
            if (data.setSort) {       
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In applySortToData -  Calling data.setSort with specifiers:\n"
                        +isc.echoAll(allSpecifiers), "sorting");
                }
                data.setSort(allSpecifiers);
                
            
            } else if (data.sortByProperty) {
                if (this.logIsInfoEnabled("sorting")) {
                    this.logInfo("In applySortToData - Calling data.sortByProperty with specifier:\n"+
                        isc.echoAll(firstSpecifier), "sorting");
                }
                data.sortByProperty(
                    firstSpecifier.sortByProperty ? firstSpecifier.sortByProperty : firstSpecifier.property,
                    Array.shouldSortAscending(firstSpecifier.direction),
                    firstSpecifier.normalizer,
                    firstSpecifier.context
                );
            }
        } else {
            if (this.logIsInfoEnabled("sorting")) {
                this.logInfo("In applySortToData - not sorting:\nthis.data is " + this.echoAll(data),
                    "sorting");
            }
        }
    } else {
        
        if (data) {
            var unsorted = data.unsort != null && data.unsort();
            if (!unsorted && data.setSort) data.setSort([], null, keepLocalDataOnUnsort);
        }
        if (this.invalidateCacheOnUnsort) {
            this.invalidateCache();
        }
    }

    if (this.body && this.showRecordComponents) delete this.body._oldDrawArea;

    // and mark the list as dirty so it will be redrawn
    this._markBodyForRedraw(this._$setSort);

    if (!this._sameSpecifiers && !this._initializing && !this._firstDraw) {
        this.handleSortChanged(this._sortSpecifiers);
    }

    if (this.logIsInfoEnabled("sorting")) this.logInfo("Leaving applySortToData", "sorting");
    
    return true;
},

    
// Store the resorting flag - moved out from setSort() when it was split into two methods
_storeResortingFlag : function () {
    // store and clear the flag that gets set in resort()
    this._calledFromResort = this._resorting;
    delete this._resorting;
    this._resortingFlagStored = true;
    return this._calledFromResort;
},

// sort change notification - documented in register string-methods.
handleSortChanged : function (sortSpecifiers) {
    // ignoreStateChangeHandlers prevents the various public state-changed notifications
    if (!this.ignoreStateChangeHandlers) {
        this.sortChanged(this.removeSortSpecifierMarkers(isc.shallowClone(sortSpecifiers)));
    }
    this.handleViewStateChanged(true);
},
sortChanged : function (sortSpecifiers) {
},

// Callback methods fired when the user attempted to sort this grid and was prompted to save
// pending edits.
// _continueSort will finish the sort (fired when the user has discarded or saved edits)
// _cancelSort simply cleans up the temp '_sortArgs' object. Fired if the user chooses to cancel
// the sort to continue editing.
_continueSort : function () {
    var args = this._sortArgs;
    delete this._sortArgs;
    this.displaySort(args);
    this.applySortToData(args);
},

_cancelSort : function () {
    var primarySort;
    var primarySort = this._sortArgs ? this._sortArgs[0] : null;
    delete this._sortArgs;
    // if the user clicked a header button to perform the sort, then abandoned it,
    // deselect that header button now.
    if (primarySort != null) {
        var sortFieldNum = this.getFieldNum(primarySort.property);
        if (sortFieldNum != -1 && this.sortFieldNum != sortFieldNum) {
            this.header.deselectButton(sortFieldNum);
        }
    }
},

//> @method listGrid.sortData() (A)
//      @group  sorting
//          actually sort the data according to the sort characteristics of the list
//<
sortData : function () {
    // if the data or fields arrays haven't been defined, skip the sort
    if (!this.data || !this.fields) return;

    // get the field object
    var field = this.fields[this._getSortFieldNum()],
        normalizer = null;

    if (field == null) {
        // if field is null, we've shrunk the number of columns,
        //  sort re-set sort to column 0
        this._setSortFieldNum(0);
        field = this.fields[0];
    }

    if (field.sortNormalizer) {
        // custom normalizer defined
        normalizer = field.sortNormalizer;
    } else if (field.valueMap) {
        // if there's a valueMap, use it as the normalizer, so that with eg enums we sort by the
        // text name rather than the numeric order.
        normalizer = field.valueMap;
        if (isc.isA.String(field.valueMap)) normalizer = this.getGlobalReference(field.valueMap);

    // if an explicit field type is declared, pass that in as a normalizer - the sort method
    // understands this.
    } else if (field.type != null) {
        normalizer = field.type
    }
    // sort by that field's property
    // pass the grid in as the additional 'context' argument for the sort - this will then
    // be available to the normalizer
    this.data.sortByProperty(field[this.fieldIdProperty], field.sortDirection, normalizer, this);
},

// Embedded Components
// --------------------------------------------------------------------------------------------

// These methods actually implemented in GridRenderer

// helper to get the current count of embeddedComponents
getEmbeddedComponentCount : function (componentType) {
    var components = this.body ? this.body._embeddedComponents : null;
    if (this.frozenBody && this.frozenBody._embeddedComponents != null) {
        components = (components ? components.duplicate() : []).addList(this.frozenBody._embeddedComponents);
    }

    if (!components) return 0;

    if (componentType == "recordComponent") {
        components = components.findAll("isRecordComponent", true);
    } else if (componentType == "backgroundComponent") {
        components = components.findAll("isBackgroundComponent", true);
    }

    return components == null ? 0 : components.length;
},

//> @method listGrid.addEmbeddedComponent() [A]
// Attaches the component to the provided record. If <code>position</code> is specified as
// <code>"within"</code> +link{canvas.snapTo} and +link{canvas.snapOffsetLeft},
// +link{canvas.snapOffsetTop} may be set to specify where the component
// will render within the cell or record. If unset, for components embedded within a record
// we will default to embedding at the top/left coordinate, and for components embedded within
// a cell, we will respect the align / valign properties for the cell in question. Any
// percentage sizing will be interpreted as percentage of row size.
// <P>
// Otherwise it will appear to be embedded within the record, underneath the field values.
// <P>
// Embedded components become children of the grid and will stay attached to a record through
// scrolling, sorting and other operations that cause records to shift position.
// <P>
// If <code>position</code> is set to <code>"expand"</code>, embedded components may offer a
// resize interface, eg, by setting +link{listGridField.canDragResize,canDragResize}:true,
// and the grid will react accordingly, growing or shrinking the record to match the embedded
// component's new extents.
// <P>
// Embedded components can be explicitly removed with +link{removeEmbeddedComponent()}.
// <P>
// If a record is removed from the dataset or is replaced in the dataset, for example, it is
// eliminated through filtering (removes record) or is successfully edited in a databound grid
// (replaces record), the component is cleared but not logically removed from the grid. It is the
// responsibility of code that sets up the embedded component to remove it if the record is removed
// from the dataSet.
// <P>
// When embedding components will result in variable height records,
// you should switch on +link{listGrid.virtualScrolling, virtualScrolling}.
//
// @param component (Canvas) component to embed
// @param record (ListGridRecord) record to attach the component to
// @param [rowNum] (Integer) rowNum of the record to attach the component to
// @param [colNum] (Integer) colNum in which to embed the component
// @param [position] (EmbeddedPosition) positioning with respect to the record or cell (Defaults to "expand").
// @visibility external
//<
// Additional "body" parameter: This allows callers to embed a component in the frozen-body
// without specifying a column to put it in (so it'll span the row in the f-body)
// Used by the rollOverComponent subsystem
addEmbeddedComponent : function (component, record, rowNum, colNum, position, body) {
    
    if (colNum == null && component._currentFieldName != null) {
        colNum = this.getFieldNum(component._currentFieldName);
    }
    // get the local body before localizing the colNum
    if (colNum != null || body == null) {
        body = this.getFieldBody(colNum);
    }
    colNum = this.getLocalFieldNum(colNum);
    position = position || component.embeddedPosition
    if (rowNum == null) rowNum = this.getRecordIndex(record);

    

    body.addEmbeddedComponent(component, record, rowNum, colNum, position);

    // If we have 2 bodies, adding an embedded component to one of them will effect the
    // height of both (the rows "span" both bodies of course and we want them to match up).
    if (this.frozenBody != null) {
        var otherBody = body == this.frozenBody ? this.body : this.frozenBody;
        var isFrozenBody = otherBody == this.frozenBody ? 1 : 0;

        if (rowNum >= 0 && otherBody.isDrawn() && !otherBody.isDirty()) {
            var expectedRowHeight = otherBody.getRowHeight(record,rowNum,isFrozenBody);
            if (expectedRowHeight != body.getRowSize(rowNum)) {
                
                otherBody.markForRedraw();
            }
        }
    }

},

//> @method listGrid.removeEmbeddedComponent() [A]
// Removes an embedded component previously associated with the provided record. If a Canvas
// is passed as the <code>record</code> parameter, it is assumed to be a component and the
// record is detected automatically from it.  If
// <code>destroyOnUnEmbed</code> is <code>true</code> for the component, it will also be
// destroyed.
//
// @param record (ListGridRecord | Canvas) record that the component was previously attached
//     to or the component itself
// @param [component] (Integer | Canvas) component to unembed, or the colNum in which it appears
// @visibility external
//<
removeEmbeddedComponent : function (record, component, suppressRedraw) {
    var body;

    // support component passed as the "record" param - collect the record from the component
    if (isc.isA.Canvas(record)) {
        component = record;
        record = component.embeddedRecord;
    }

    // support a colNum passed as the "component" param
    if (isc.isA.Number(component)) {
        body = this.getFieldBody(component);
        component = this.getLocalFieldNum(component);
    } else {
        if (!component) {
            // no component passed - assume the first one on the record, if there are any
            // or bail otherwise
            if (!record || !this._hasEmbeddedComponents(record)) return;
            component = this._getEmbeddedComponents(record)[0];
        }
        body = isc.Canvas.getById(component._embedBody);
    }
    
    if (body == null) {
        return;
    }
    body.removeEmbeddedComponent(record, component, suppressRedraw);
},

//> @method listGrid.getEmbeddedComponent() [A]
// Gets an embedded component previously associated with the provided record.
//
// @param record (ListGridRecord) record that the component was previously attached to
// @param colNum (Number) column in the grid from which to retrieve the component
// @return (Object) the embeddedComponent
// @visibility embeddedComponents
//<
getEmbeddedComponent : function (record, colNum) {
    var body;
    if (isc.isA.Number(colNum)) {
        body = this.getFieldBody(colNum);
        colNum = this.getLocalFieldNum(colNum);
    } else if (colNum == null) {
        // if no colNum was passed, assume this.body
        body = this.body;
    } else {
        // support "component" passed as an object
        body = isc.Canvas.getById(colNum._embedBody);
    }
    return body.getEmbeddedComponent(record, colNum);
},

//> @method listGrid.getRecordComponent()
// Retrieve the +link{showRecordComponents,recordComponent} currently being shown at the given
// coordinates.
// <p>
// <code>recordComponents</code> are dynamically assigned to row/cell coordinates and, depending
// on the +link{listGrid.recordComponentPoolingMode}, any kind of redraw of the containing
// ListGrid (due to sort change, scrolling, editing etc) may cause a
// <code>recordComponent</code> to be assigned to another row, +link{canvas.clear,clear()ed} or
// permanently +link{canvas.destroy,destroy()ed}.
// <p>
// Hence you should always call <code>getRecordComponent()</code> right before taking action on
// the <code>recordComponent</code> - don't cache the component associated with row/cell
// coordinate.  Similarly, it's invalid to call <code>getRecordComponent()</code> during a redraw
// (for example, from +link{listGridField.formatCellValue,formatting} code).
// <p>
// It's always invalid to try to use a <code>recordComponent</code> outside of a ListGrid (by eg
// adding it to some other layout).
// <p>
// If +link{showRecordComponentsByCell} is true and the colNum parameter is not passed, the call
// will return the first component in the passed rowNum.
// <p>
// Returns null if there is no component at the specified coordinates.
//
// @param rowNum (int) row number to get record component for
// @param [colNum] (Integer) optional column number to get the record component for
// @return (Canvas) record component, or null if none is shown at these coordintes
// @see recordScreen
// @group recordComponents
// @visibility external
//<
getRecordComponent : function (rowNum, colNum) {
    var record = this.getRecord(rowNum);
    return this.getEmbeddedComponent(record, colNum);
},

//> @attr listGrid.recordScreen (String : null : IR)
// Screen to create (via +link{RPCManager.createScreen,createScreen()}) in lieu of calling
// +link{getRecordComponent()}.
// <P>
// If this grid has a +link{listGrid.dataSource,dataSource}, the created screen is
// provided with a +link{canvas.dataContext} that includes the record being shown at the row.
// Be sure the record screen meets these +link{canvas.autoPopulateData,requirements}
// to utilize the <code>dataContext</code>.
// @group recordComponents
// @visibility external
//<


// Embedded Editing
// --------------------------------------------------------------------------------------------
// "embedded editing" means editing with a complete DynamicForm as an embedded component
// appearing underneath the edited row.  This is distinct from "inline editing" where we place
// form items in individual cells, and can only edit the currently visible fields.

// get the DataSource for editing this record
getRecordDataSource : function (record) {
    return this.dataSource;
},

//> @method listGrid.openRecordEditor()           (A)
// Start editing a record, using an editor embedded in the row
//
// @param   record   (Object)            record whose detail records should be shown
// @visibility advancedInlineEdit
//<

openRecordEditor : function (record) {
    // don't allow more than one openRecord embedded component at once
    if (this._openRecord != null) this.closeRecord();

    
    var editValues = isc.addProperties({}, record);

    // create a form to edit the record
    var editor = this.ns.DynamicForm.create(
    this.recordEditorProperties,
    {
        autoDraw:false,
        dataSource : this.getRecordDataSource(record),
        numCols : 4,
        values : editValues,
        _embeddedEditRecord : record
    });
    // place it in a simple stack with a save button
    var component = this.ns.VStack.create({
        autoDraw:false,
        width:this.getAvailableFieldWidth() - this.embeddedComponentIndent,
        left:this.isRTL() ? 0 : this.embeddedComponentIndent,
        destroyOnUnEmbed:true,
        members:[
            editor,
            this.ns.Toolbar.create({
                autoDraw:false,
                width: 200,
                buttons : [
                    { title : this.recordEditorSaveButtonTitle,
                      click : this.getID() + ".embeddedSaveRecord(" + editor.getID() + ")",
                      extraSpace:10
                    },
                    { title : this.recordEditorCancelButtonTitle,
                      record : record,
                      grid : this,
                      click : function () {
                          var stack = this.parentElement.parentElement;
                          this.grid.closeRecord(this.record, stack);
                      }
                    }
                ]
            })
        ]
    });

    component.removeOnHideField = true;

    this.addEmbeddedComponent(component, record, this.data.indexOf(record));

    this._openRecord = record;
    this._openRecordComponent = component;
},

// when the user hits Save during embedded editing, tell the editor to save
embeddedSaveRecord : function (editor) {
    // hold onto the record via the context since we'll need it to get rid of the embedded editor
    editor.saveData({target:this, methodName:"embeddedEditComplete"},
                    {_embeddedEditRecord:editor._embeddedEditRecord,
                     _embeddedEditor:editor});
},

// when the save attempt completes, if there were no errors, remove the embedded editor.
// Otherwise leave it there to show validation errors and allow further editing
embeddedEditComplete : function (response, data, request) {
    if (response.status == 0) {
        this.removeEmbeddedComponent(request._embeddedEditRecord, request._embeddedEditor);
    }
},

//> @method listGrid.closeRecord()
// Close the currently shown embedded component.
//
// @visibility nestedGrid
//<
closeRecord : function (record, component) {
    if (!record) record = this._openRecord;
    if (!component) component = this._openRecordComponent;
    this.removeEmbeddedComponent(record, component);
    this._openRecord = null;
    this._openRecordComponent = null;
},

// Nested Master-Detail
// --------------------------------------------------------------------------------------------

//> @method listGrid.openRecordDetailGrid() (A)
// Show records from another DataSource which are related to this record, in a nested
// ListGrid.
// <P>
// This is often called a "master-detail" view.  The classic example is salesOrder records
// which contain lineItems.
// <P>
// The <code>childDS</code> should be a DataSource that declares a foreignKey relationship to
// the DataSource the current grid is viewing.
//
// @param   record   (Object)            record whose detail records should be shown
// @param   childDS  (DataSource | ID)  dataSource to retrieve detail records from
// @visibility nestedGrid
//<
openRecordDetailGrid : function (record, childDS) {
    // don't allow more than one openRecord embedded component at once
    if (this._openRecord != null) this.closeRecord();

    var subGrid = this.getRecordDetailGrid(record, childDS);
    // and embed it in the target record
    var component = isc.VLayout.create({
        autoDraw:false,
        destroyOnUnEmbed:true,
        height:this.cellHeight, // since the Layout is overflow:visible this is just a minimum
        left:this.isRTL() ? 0 : this.embeddedComponentIndent,
        width:this.getAvailableFieldWidth() - this.embeddedComponentIndent,
        resizeBarSize:4,
        members:[subGrid],
        removeOnHideField: true
    });

    this.addEmbeddedComponent(component, record, this.data.indexOf(record));

    var childDS = isc.DataSource.getDataSource(subGrid.dataSource);
    subGrid.fetchRelatedData(record, this.getRecordDataSource(record));

    this._openRecord = record;
    this._openRecordComponent = component;
},

//> @method listGrid.getRecordDetailGrid()  (A)
// Returns a ListGrid to show the records from another DataSource which are related to this
// record via a child dataSource
//
// @param   record   (Object)            record whose detail records should be shown
// @param   childDS  (DataSource | ID)  dataSource to retrieve detail records from
// @visibility internal
//<
getRecordDetailGrid : function (record, childDS) {

    childDS = isc.DataSource.getDataSource(childDS);

    // create a ListGrid to show them
    var subGrid =
        isc.ListGrid.create(
            this.recordDetailGridProperties,
            {
                autoDraw:false,
                dataSource:childDS,
                showResizeBar:true,
                // XXX the embedded grid needs to inherit a lot of properties from it's parent grid -
                // this particular one is critical because otherwise context menu events will bubble to
                // this grid, and it will show non-sequitur context menus on the embedded grid.
                showCellContextMenus:this.showCellContextMenus
            }, this.nestedGridDefaults
        );

    return subGrid;
},

// Charting
// ---------------------------------------------------------------------------------------

// types of charting:
// - take any single row and plot it as a single series
//   - field names label the values
// - take any single column and plot it as a single series
//   - values from another column label the values
// - take a set of rows and a set of columns and plot it as a multi-series
//   - dataset is 2d: both field names *and* values from another column label the values

//> @method listGrid.chartData()
// Chart the data in this listGrid as a multi-series chart.
// <P>
// Each row provides a series of data.  Each series of data is labeled by a value from one
// column, called the <code>labelField</code>.
// <P>
// For example, cell values are sales figures, and fields are "Product", "August",
// "September", "October".  In this case each row gives a series: sales figures for each of 3
// months.  The <code>labelField</code> in this case is the "Product" field, meaning each row
// represents sales figures for each of 3 months for a particular product.  This dataset
// can be charted via any multi-series chart: stacked or clustered bar or column chart, line
// chart with multiple lines, or area chart (stacked lines).
// <P>
// By default, all visible fields other than the label field are assumed to be labels for
// series values, but an explicit list of fields can be provided as <code>dataFields</code>.
// <P>
// By default, all data is charted if all data is loaded, otherwise, data visible in the
// viewport is charted.  An explicit set of rows can be provided via <code>dataRows</code>.
//
// @param labelField (String) name of the field
// @param [dataFields] (Array of String) optional list of fields to use as labels.  By
//      default, all fields are used.
// @param [dataRows] (Array of ListGridRecord) set of records to chart.  Can be obtained by eg
//      +link{ResultSet.getRange,grid.data.getRange()}.
// @param [chartProperties] (FacetChart Properties) properties to pass to the created chart
// @param [labelFieldFirst] (boolean) if true, use the labelField as the "first" set of labels,
//      for example, as the bar labels in a stacked bar chart, whereas the second set of labels
//      would appear as the legend.
//
// @return (FacetChart) created Chart instance
//
// @visibility external
// @example gridCharting
//<
chartData : function (labelField, dataFields, dataRows, properties, labelFieldFirst) {

    // verify the chartConstructor maps to a valid class (if not typically implies some module is
    // missing).
    this.checkChartConstructor();

    if (labelField) labelField = this.getField(labelField);
    if (dataFields) dataFields = this.map("getField", dataFields);
    else {
        // assume all fields other than a labelField contain values
        dataFields = this.fields.duplicate();
        dataFields.remove(labelField);
    }

    // default for dataRows: all rows, or visible rows if paging
    if (!dataRows) {
        if (!isc.ResultSet || !isc.isA.ResultSet(this.data)) {
            dataRows = this.data;
        } else if (this.data.allMatchingRowsCached()) {
            dataRows = this.data.getAllRows();
        } else {
            var visibleRows = this.getVisibleRows();
            dataRows = this.data.getRange(visibleRows[0], visibleRows[1]);
        }
    }

    // form a facet representing the column headers, aka, the fields.  This is an inlinedFacet,
    // meaning it has multiple values per record under property names indicated by its
    // facet.values
    var rowFacet, columnFacet;
    if (dataFields.length >= 1) {
        // give chart a simplified copy of the fields
        
        for (var i = 0; i < dataFields.length; i++) {
            var field = dataFields[i];
            dataFields[i] = {
                id: field.name,
                title: this.htmlUnescapeExportFieldValue(field.title),
                type: field.type
            }
        }
        columnFacet = {
            id:"columnFacet",
            title:this.valueTitle,
            values: dataFields,
            inlinedValues:true
        };
    }

    // form a facet representing row headers, aka, one column of data intended as labels
    if (dataRows.length >= 1 && labelField) {
        rowFacet = { id: labelField.name };
    }

    // remove unspecified facets to allow just single row or single column charting
    var facets = [columnFacet,rowFacet];
    facets.removeAll([null]);

    // for multi-series charts, allow specifying which facet comes first (eg, for stacked bar
    // charts, appears as a bar label (first) or appears as a legend labeling colors (second)
    if (labelFieldFirst) facets.reverse();

    var props = isc.addProperties({
        data: dataRows,
        facets: facets,
        title: this.chartTitle,
        chartType: this.chartType
    }, properties);

    // single column charting: the (singular) dataField holds the value
    if (rowFacet && !columnFacet) props.valueProperty = dataFields[0].name;
    // otherwise, we have an "inlinedValues" facet: there is no single valueProperty, rather
    // each record contains multiple values stored under the ids of the inlinedFacet's values

    return this.createAutoChild("chart", props, this.chartConstructor);
},

//> @attr listGrid.chartConstructor (Classname : "FacetChart" : IR)
// Name of the SmartClient Class to be used when creating charts.  Must support the
// +link{Chart} interface.
//
// @visibility external
//<
chartConstructor: "FacetChart",

// Helper method to verify that the chartConstructor is set to a valid Chart-based class name.
// Allows us to log a helpful warning when the developer attempts to chartData (or setEnableCharting
// for CubeGrids) if the chartConstructor is set to an unloaded class name.
checkChartConstructor : function () {
    var chartConstructor = this.chartConstructor;
    if (isc.isA.String(chartConstructor)) {
        chartConstructor = window.isc[this.chartConstructor];
    }

    if (chartConstructor == null) {

        this.logWarn('Component chartConstructor attribute set to "' + this.chartConstructor +
            '" - this cannot be resolved to a valid SmartClient class. Verify that all ' +
            'appropriate modules are loaded and that this class exists.');

    // In some cases if all required modules are not loaded,
    // we load a placeholder class to avoid actual JS errors.
    // In this case we mark the class object as "invalid" and provide a custom error message to
    // display
    
    } else if (chartConstructor.invalidClass) {
        var errorMessage = 'Component chartConstructor attribute set to "' + this.chartConstructor
                    + '". ';

        if (chartConstructor.invalidErrorMessage) errorMessage += chartConstructor.invalidErrorMessage;
        else errorMessage += ".This class is invalid - verify all appropriate modules are loaded.";

        this.logWarn(errorMessage);
    }

},


//> @attr listGrid.chartType (ChartType : "Column" : IRW)
// Default type of chart to plot.
//
// @visibility external
//<
chartType: "Column",


//> @method listGrid.chartRow()
// Chart a single row of data, with each cell value labeled by the column header.
//
// @param rowNum (Number) row to chart
// @param [dataFields] (Array of String) optional list of fields to use as labels.  By
//      default, all fields are used.
// @param [chartProperties] (Chart Properties) properties to pass to the created chart
// @return (Chart) created Chart instance
//
// @visibility external
//<
chartRow : function (rowNum, dataFields, chartProperties) {
    return this.chartData(null, dataFields, [this.getRecord(rowNum)], chartProperties);
},

//> @method listGrid.chartColumn()
// Chart a single column of data, with each cell value labeled by a value from another
// column.
//
// @param dataColumn (String) name of the ListGridField to use as a data
// @param labelColumn (String) name of the ListGridField to use as labels for data
// @param [chartProperties] (Chart Properties) properties to pass to the created chart
// @return (Chart) created Chart instance
//
// @visibility external
//<
chartColumn : function (dataColumn, labelColumn, chartProperties) {
    return this.chartData(labelColumn, [dataColumn], null, chartProperties);
},

//> @method listGrid.loadAllRecords()
// Loads all records that match this grid's current filter-criteria, optionally firing a 
// callback when the data arrives.
// <p>
// If the length of the data is +link{resultSet.lengthIsKnown, not known}, or is greater than 
// the passed <i>maxRecords</i>, this call returns false.  No fetch 
// is issued and the <i>callback</i>, if passed, is not fired.
// <p>
// If all data is +link{resultSet.allMatchingRowsCached, already loaded}, no fetch is issued 
// and this call returns true.  The <i>callback</i>, if passed, will be fired, but its 
// parameters will be null, since there was no fetch to provide the values from.
// <p>
// In all other cases, this call returns true and a fetch is issued for all necessary records. 
// When the data arrives, the <i>callback</i> is fired.
//
// @param [maxRecords] (Integer) optional maximum record count - if passed, no fetch takes place 
//                               if maxRecords is below the known length of the data
// @param [callback] (DSCallback) callback to fire if a fetch is issued - if all data was 
//                                already loaded, the callback is fired with no parameters
// @return (Boolean) true if a fetch was made or was not needed - false otherwise
//
// @visibility external
//<
loadAllRecords : function (maxRecords, callback) {
    maxRecords = maxRecords || -1;
    var currData;
    if (this.data.isGroupedOutput && this.originalData) {
        currData = this.originalData;
    } else {
        currData = this.data;
    }
    if (currData != null) {
        // Ensure all rows are read and available.
        var len = currData.getLength();
        var tooManyRows = maxRecords != -1 && len > maxRecords;
        if (isc.ResultSet && isc.isA.ResultSet(currData)) {
            if (tooManyRows) {
                // maxRecords passed and too low - return false
                this.logWarn("Passed 'maxRecords' (" + maxRecords + ") is too low to fetch " +
                    "all records (" + len + ").");
                return false;
            }
            if (!currData.lengthIsKnown()) {
                // !lengthIsKnown() - we don't know the data set size yet - return false
                this.logWarn("ResultSet length is not yet known, can't fetch.");
                return false;
            }

            if (currData.allMatchingRowsCached()) {
                // data already client-side - fire the callback and return true
                if (callback) {
                    this.fireCallback(callback, "response, data, request", [null,null,null]);
                }
                this.logInfo("Data already loaded, firing callback with null parameters");
                return true;
            }

            // getRange() will fetch a full set of data and then fire RS.fetchRemoteDataReply(),
            // which has the params we want for the callback here - hook that method for its 
            // next execution
            var _this = this;
            this.observe(currData, "fetchRemoteDataReply", function (response, data, request) {
                // ignore the observation
                _this.ignore(currData, "fetchRemoteDataReply");
                // fire the custom callback
                _this.fireCallback(callback, "response, data, request", [response,data,request]);
            });

            currData.getRange(0, len);
            this.logInfo("Postponing loadAllRecords() callback until data is loaded");
            return true;
        }
    }
},

// Grouping
// --------------------------------------------------------------------------------------------
// perform the actual operation of grouping the grid. Takes listgrid.data as input,
// and rewrites it (it is also an output); it stores the original object reference in
// listgrid.originalData.


groupIdField: "groupId",
groupParentIdField: "groupParentId",


//> @method listGrid.regroup()
// Programmatically regroup the grid according to the current grouping configuration.
//
// @see listGrid.groupBy()
// @visibility external
//<

regroup : function (fromSetData) {
    
    
    // This function is responsible for knowing if grouping ought to be performed.
    // Check all reasonable things here.
    // don't enforce canGroupBy here, so that programmatic grouping can take place
    // even if canGroupBy is false
    var isGrouped = this._isGrouped || this.isGrouped,
        groupFields = isGrouped && (this._groupByFields || this.getGroupByFields()),
        setOriginalDataToCurrData = false,
        currData
    ;
    if (!isGrouped ||
        groupFields == null || groupFields.length == 0 ||
        this.inhibitRegroup || !(this.originalData || this.data) ||
        // sanity check in case regroup is somehow triggered when data has not been loaded yet
        !this.data)
    {
        currData = null;
    } else {
        // if this.data already contains a grouped grid, use the original source
        // data instead.
        if (this.data.isGroupedOutput && this.originalData) {
            currData = this.originalData;
        } else {
            currData = this.data;

            // this.originalData will be set to currData after the (possibly asynchronous)
            // regroup has finished.
            setOriginalDataToCurrData = true;
        }
    }

    var asyncRegroupInProgress = this._asyncRegroupInProgress;

    if (currData != null) {
        // Ensure all rows are read and available.
        var len = currData.getLength();
        if (isc.ResultSet && isc.isA.ResultSet(currData)
            && (!currData.lengthIsKnown() ||
                (len <= this.groupByMaxRecords && !currData.rangeIsLoaded(0, len - 1))))
        {
            // getRange() will fetch a full set of data, then _markForRegroup ensures we
            // regroup; request groupByMaxRecords if currData's length is not yet known
            currData.getRange(0, currData.lengthIsKnown() ? len : this.groupByMaxRecords);
            this._setMarkForRegroup(true, false, true, false, false, groupFields);
            this.logInfo("postponing grouping until data is loaded", "grouping");
            if (setOriginalDataToCurrData) {
                this.originalData = currData;
            }
            this._suppressRedrawOnDataChanged = true;
            return;
        } else if (len > this.groupByMaxRecords) {
            // If there are too many rows, don't group and display the original data.
            this.logInfo("Results too numerous - disabling grouping.", "grouping");

            
            
            this.clearGroupBy(true);

            if (setOriginalDataToCurrData) {
                this.originalData = currData;
            }
            if (!this.selectionManager || (this.data != this.selectionManager.data)) {
                this.createSelectionModel();
            }
            
            // Fire the groupByComplete notification to let the dev know that
            // a grouping attempt failed (or was undone by extra data)
            var fromGroupBy = this._groupByDataChanged;
            if (fromGroupBy) {
                this.__groupByComplete([]);
            }
            
            // clear the _suppressRedrawOnDataChanged flag, which may have been set above
            delete this._suppressRedrawOnDataChanged;

            this.__groupTreeChanged(fromGroupBy ? isc.ListGrid.GROUP_BY : 
                                                isc.ListGrid.REGROUP, false);
            return;
        }
    } else {
        if (asyncRegroupInProgress) this._completeAsyncRegroup();
        return;
    }
    this._setMarkForRegroup(false, false, true, false, false);
    // If this regroup was caused by a call to groupBy() then the `fields` argument will be
    // saved in the `_groupByCompleteFieldsAfterRegroup` property.
    var fields = this._groupByCompleteFieldsAfterRegroup;

    
    if (fields == null && this.handleRegroup != null) this.handleRegroup();
    
    delete this._suppressRedrawOnDataChanged;

    var async = (currData.getLength() > this.groupByAsyncThreshold);
    if (asyncRegroupInProgress && async) {
        // An asynchronous regroup has already begun but regroup() has now been
        // called before it completed.  Cancel the timer but keep the prompt.
        // The flag this._asyncRegroupInProgress is still true.
        isc.Timer.clear(this._regroupTimerEvent);
        delete this._asyncRegroupBaton;
        delete this._regroupTimerEvent;
    } else if (asyncRegroupInProgress && !async) {
        // An asynchronous regroup has already begun but regroup() has now
        // been called before it completed.  The current regrouping will
        // be performed synchronously so cancel the timer and clear the prompt.
        this._completeAsyncRegroup();

    } else if (!asyncRegroupInProgress && async) {
        // A new asynchronous regrouping will be started - so, unless showAsynchGroupingPrompt
        // is false, set the prompt
        if (this.showAsynchGroupingPrompt != false) isc.showPrompt(this.asynchGroupingPrompt);
        this._asyncRegroupInProgress = true;

        delete this._applyHilitesAfterRegroup;
        delete this._pendingHilitesSuppressRedraw;

        // Save the current settings of two properties that affect whether
        // group summary rows will be shown in the groupTree.  When the
        // _asyncRegroupInProgress flag is cleared then these two properties
        // will be checked again to see if the group summary rows need
        // to be updated.
        this._newShowGroupSummary = this.showGroupSummary;
        this._newGroupByFieldSummaries = this.groupByFieldSummaries;
    }

    // Assemble the list of field names to group by.
    var groupByField = this.groupByField,
        groupByFieldGroupingModes = null;
    if (fields != null) {
        
        groupByField = [];
        groupByFieldGroupingModes = [];
        for (var i = 0; i < fields.length; i++) {
            // Don't allow the checkbox field to be grouped; Shouldn't be possible, but check
            // just in case.
            if (this.isCheckboxField(fields[i])) continue;
            var hasProperty = fields[i].property,
                fieldName = null, 
                field = null
            ;
            if (hasProperty) {
                // If the field has a displayField and no optionDataSource, use the
                // displayField instead of the actual field passed in.
                fieldName = fields[i].property;
                field = this.getUnderlyingField(fieldName);
            } else {
                // If the field has a displayField and no optionDataSource, use the
                // displayField instead of the actual field passed in.
                fieldName = fields[i];
                field = this.getUnderlyingField(fieldName);
            }
            if (field && field.displayField != null && field.optionDataSource == null) {
                var fieldToDisplay = this.getField(field.displayField);
                if (fieldToDisplay) {
                    field = fieldToDisplay;
                    if (field.displayField != null) fieldName = field.displayField;
                    else fieldName = field.name;
                }
            }
            groupByField.add(fieldName);
            var specifier = null;
            if (field && this._groupSpecifiers) {
                specifier = this._groupSpecifiers.find("property", fields[i]);
                if (specifier) {
                    // there's a groupSpecifier for the fieldName - set its properties on the field
                    field.groupingMode = specifier.grouping;
                    field.groupGranularity = specifier.granularity;
                    field.groupPrecision = specifier.precision;
                }
            }
            // Initialize groupingMode if groupingModes is defined.
            var groupingMode = (hasProperty ? fields[i].grouping : null);
            if (field) {
                if (!hasProperty) {
                    groupingMode = field.groupingMode;
                }
                var groupingModes = field.groupingModes ||
                        (field._simpleType ? (field._simpleType.getGroupingModes ?
                                             field._simpleType.getGroupingModes() :
                                             field._simpleType.groupingModes) : null )
                ;
                if (groupingMode == null && groupingModes != null) {
                    var defaultMode = field.defaultGroupingMode || 
                            (field._simpleType && field._simpleType.defaultGroupingMode);
                    if (isc.isAn.Array(groupingModes)) {
                        if (groupingModes.contains(defaultMode)) groupingMode = defaultMode;
                        else if (groupingModes.length > 0)       groupingMode = groupingModes[0];
                    } else if (isc.isAn.Object(groupingModes)) {
                        if (groupingModes[defaultMode] != null)  groupingMode = defaultMode;
                    }
                    // Note that the `groupingMode` is not saved to the field until
                    // _regroupFinish() is called.
                }
            }
            groupByFieldGroupingModes.push(groupingMode);
        }
    }
    var groupByFields = (
            groupByField != null && !isc.isAn.Array(groupByField) ?
                [groupByField] : groupByField),
        groupingMode = null;
    // If groupingModes is present, make sure to clear groupingMode.
    if (groupByFields != null) {
        for (var i = 0; i < groupByFields.length; i++) {
            var field = this.getUnderlyingField(groupByFields[i]),
                fieldGroupingMode = (
                    (groupByFieldGroupingModes != null &&
                        groupByFieldGroupingModes[i] != null) ?
                            groupByFieldGroupingModes[i] : field.groupingMode);
            if (fieldGroupingMode && 
                    (!isc.isAn.Array(groupByField) ? field.name == groupByField :
                    groupByField.contains(field.name))) 
            {
                groupingMode = fieldGroupingMode;
            }
        }
    }

    
    var baton = {
        applyFormulaAfterSummary: this.applyFormulaAfterSummary,
        emptyCellValue: this.emptyCellValue,
        gridSummaryRecordProperty: this.gridSummaryRecordProperty,
        groupByFieldSummaries: (
            isc.isAn.Array(this.groupByFieldSummaries) ?
                this.groupByFieldSummaries.duplicate() : null),
        groupNodeBaseStyle: this.groupNodeBaseStyle,
        groupNodeStyle: this.groupNodeStyle,
        groupStartOpen: (
            isc.isAn.Array(this.groupStartOpen) ?
                this.groupStartOpen.duplicate() : this.groupStartOpen),
        groupSummaryRecordProperty: this.groupSummaryRecordProperty,
        includeInSummaryProperty: this.includeInSummaryProperty,
        nullGroupTitle: this.nullGroupTitle,
        recordBaseStyleProperty: this.recordBaseStyleProperty,
        recordCustomStyleProperty: this.recordCustomStyleProperty,
        recordEditProperty: this.recordEditProperty,
        showCollapsedGroupSummary: this.showCollapsedGroupSummary,
        showGroupSummary: this.showGroupSummary,
        showGroupSummaryInHeader: this.showGroupSummaryInHeader,
        singleCellValueProperty: this.singleCellValueProperty,

        // Use this instead of `this.getGroupByFields()` during regrouping:
        groupByField: groupByField,
        groupByFields: groupByFields,
        groupByFieldGroupingModes: groupByFieldGroupingModes,
        groupingMode: groupingMode,

        currData: currData,
        setOriginalDataToCurrData: setOriginalDataToCurrData,

        
        sortSpecifiers: isc.isAn.Array(this._sortSpecifiers) ? 
                 this._addImplicitSort(this._sortSpecifiers.duplicate(), groupByFields) : null
    };
    this._asyncRegroupBaton = baton;
    
    
    // Also save all mutable state of the ListGridFields that can be referenced during
    // asynchronous regrouping.
    var fieldsHaveUserFormulas = new Array(this.fields.getLength()),
        fieldsHaveUserSummaries = new Array(this.fields.getLength());
        for (var i = fieldsHaveUserFormulas.length; i--; ) {
            var field = this.fields[i];
            fieldsHaveUserFormulas[i] = field && field.userFormula != null;
            fieldsHaveUserSummaries[i] = field && field.userSummary != null;
        }
    baton.fieldsHaveUserFormulas = fieldsHaveUserFormulas;
    baton.fieldsHaveUserSummaries = fieldsHaveUserSummaries;
    var groupByFieldUserFormulas = new Array(groupByFields.length),
        groupByFieldUserSummaries = new Array(groupByFields.length),
        groupByFieldDisplayFields = new Array(groupByFields.length),
        groupByFieldValueMaps = new Array(groupByFields.length);
    for (var i = groupByFields.length; i--; ) {
        var field = this.getUnderlyingField(groupByFields[i]);
        if (field) {
            groupByFieldUserFormulas[i] = isc.clone(field.userFormula);
            groupByFieldUserSummaries[i] = isc.clone(field.userSummary);
            groupByFieldDisplayFields[i] = field.displayField;

            var valueMap = field.valueMap;
            if (isc.isAn.Array(valueMap)) {
                groupByFieldValueMaps[i] = valueMap.duplicate();
            } else {
                groupByFieldValueMaps[i] = isc.shallowClone(valueMap);
            }
        }
    }
    baton.groupByFieldUserFormulas = groupByFieldUserFormulas;
    baton.groupByFieldUserSummaries = groupByFieldUserSummaries;
    baton.groupByFieldDisplayFields = groupByFieldDisplayFields;
    baton.groupByFieldValueMaps = groupByFieldValueMaps;

    // Regrouping is performed with a sequence of function calls:
    // _regroupRestoreOpenFolder(), _regroupAddNodeToOpenState(),
    // _regroupCreateGroupTree(), _regroupAddRecordsToGroup(),
    // _regroupAddSummaryChildren(), _regroupProcessGroupHeaderNode(),
    // _regroupOpenInitialGroups(), _regroupCreateSelectionModel(),
    // _regroupGetGroupTreeLength(), _regroupCacheSelectionModel(),
    // and finally _regroupFinish().
    // If async is true, then the methods may run asynchronously to
    // perform work in batches of size groupByAsyncThreshold.
    // Each method calls itself with delay 0 until its work is completed
    // and then it calls the next method in the sequence.
    // Each function in the sequence passes the baton object
    // through the next asynchronous call (it is storage for variable
    // assignments that will be needed later in the sequence).
    this._regroupRestoreOpenFolders(async, baton, fromSetData);
},

// PickList overrides these internal methods to provide value-reselection when grouped
__groupByComplete : function (fields) {
    if (this.groupByComplete != null) this.groupByComplete(fields);
},

__groupTreeChanged : function (changeType, success) {
    if (this.groupTreeChanged != null) this.groupTreeChanged(changeType, success);
},

_regroupRestoreOpenFolders : function (async, baton, fromSetData) {
    
    var restoreOpenFolders;
    if (this.groupTree) {
        // If we have valid data already, and haven't changed our set of group-by-fields, we'll
        // want to retain our current folder open/closed state
        // Suppress this if canCollapseGroup is false as in that case we always want to open
        // all group members.
        // Also suppress if coming from setData() since we'll have a new data set and should
        // initialize it with standard open state.
        
        var treeGroupField = this.groupTree._groupByField,
            sameGroupByFields = (treeGroupField == baton.groupByField)
        ;
        if (isc.isAn.Array(treeGroupField)) {
            var batonFields = baton.groupByField.duplicate(),
                groupTreeFields = treeGroupField.duplicate()
            ;
            if (batonFields.length != groupTreeFields.length) sameGroupByFields = false;
            else {
                batonFields.removeList(groupTreeFields);
                sameGroupByFields = (batonFields.length == 0)
            }
        }
        if (!fromSetData && this.canCollapseGroup &&
            this.retainOpenStateOnRegroup &&
            (this.groupTree.getLength() > 0) &&
            (sameGroupByFields))
        {
            // if grouping mode had been changed for our groupField we should not persist
            // open/close state for folders
            if (this.groupTree._groupingMode == baton.groupingMode) {
                restoreOpenFolders = [];

                var tree = this.groupTree,
                    node = tree.getRoot();
                if (tree.isOpen(node) && tree.isLoaded(node)) {
                    var stack = [[tree.getFolders(node)], [0]];
                    if (async) {
                        this._regroupTimerEvent = this.delayCall(
                            "_regroupAddNodeToOpenState",
                            [async, baton, stack, tree, restoreOpenFolders], 0);
                    } else {
                        this._regroupAddNodeToOpenState(
                            async, baton, stack, tree, restoreOpenFolders);
                    }

                    // _regroupAddNodeToOpenState() will call _regroupCreateGroupTree().
                    return;
                }
            }
        }
    }

    this._regroupCreateGroupTree(async, baton, baton.currData, restoreOpenFolders);
},

// Similar to ListGrid._addNodeToOpenState(), but rewritten to work asynchronously in batches
// of size groupByAsyncThreshold.
_regroupAddNodeToOpenState : function (async, baton, stack, tree, openState) {
    
    var childrenStack = stack[0],
        indexStack = stack[1],
        stackCount = childrenStack.length,
        recordCount = 0;

    while (stackCount > 0) {
        var children = childrenStack.pop(),
            i = indexStack.pop();
        --stackCount;

        for (var len = children.length; i < len; ++i, ++recordCount) {
            if (async && recordCount > this.groupByAsyncThreshold) {
                childrenStack.push(children);
                indexStack.push(i);
                this._regroupTimerEvent = this.delayCall(
                    "_regroupAddNodeToOpenState",
                    [async, baton, stack, tree, openState], 0);
                return;
            }

            var node = children[i];
            if (tree.isOpen(node) && tree.isLoaded(node)) {
                var folderInfo = {};
                folderInfo[node.groupName] = node.groupValue;
                openState.add(folderInfo);

                var grandChildren = tree.getFolders(node);
                if (grandChildren != null) {
                    childrenStack.push(children);
                    indexStack.push(i + 1);
                    ++stackCount;

                    children = grandChildren;
                    i = -1;
                    len = children.length;
                }
            }
        }
    }

    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupCreateGroupTree",
            [async, baton, baton.currData, openState], 0);
    } else {
        this._regroupCreateGroupTree(async, baton, baton.currData, openState);
    }
},

_regroupCreateGroupTree : function (async, baton, currData, restoreOpenFolders) {
    
    
    
        var groupTree = this.createAutoChild("groupTree", {

        // specify idField and parentIdField explicitly
        // Note these field values are arbitrary as we explicitly add nodes to the tree
        idField:this.groupIdField,
        parentIdField: this.groupParentIdField,
        titleProperty: "groupValue",
        childrenProperty: "groupMembers",
        parentProperty: "_groupTree_" + this.ID,
        showRoot: false,
        isGroupedOutput: true,
        nameProperty:"_name",
        
        // _groupByField is used when sorting - we skip sorting on group headers unless sorting
        // by the group-by-field. Implemented in Tree.js
        // Exception - if showing summaries in headers we want to allow the user to sort the
        // group headers
        
        alwaysSortGroupHeaders: (baton.showGroupSummary && baton.showGroupSummaryInHeader),
        _groupByField: baton.groupByField,
        _groupByFields: baton.groupByFields,
        _groupingMode: baton.groupingMode,
        separateFolders: true,

        // Define a property used to flag the summary records
        _summaryRecordFlag: "_summaryRecordFlag",
        _summaryTargetNode: "_summaryTargetNode",

        // copy sort specifiers across
        
        _sortSpecifiers: baton.sortSpecifiers,

        // Implement 'getCriteria()' so "getCriteria()" on the grid as a whole works.
        // Note that DBC.updateDataModel handles applying criteria directly to the underlying
        // resultSet and regrouping so the "originalData" object always has the
        // most current criteria applied to it.
        getCriteria : function () {
            var originalData = this.creator.originalData;
            if (originalData) {
                
                if (originalData.getCombinedCriteria) return originalData.getCombinedCriteria();
                if (originalData.getCriteria) return originalData.getCriteria();
            }
            return null;
        },

        // Given a group, returns the live records within it. Handles nested groups by reaching
        // into the sub-tree for outer groups.
        getRecordsInGroup : function (node) {
            var groupByFields = this._groupByFields,
                group = node.groupName,
                children = this.getChildren(node),
                records = [];

            if (group == groupByFields[groupByFields.length-1]) {
                if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                    for (var i = 0, length = children.getLength(); i < length; i++) {
                        var child = children.getCachedRow(i);
                        if (child != null && child[this._summaryRecordFlag] !== true) {
                            records.add(child);
                        }
                    }
                }
            } else if (children != null) {
                if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                    for (var i = 0, length = children.getLength(); i < length; i++) {
                        var child = children.getCachedRow(i);
                        if (child != null) {
                            var subRecords = this.getRecordsInGroup(child);
                            if (subRecords != null && subRecords.length > 0) {
                                records.addList(subRecords);
                            }
                        }
                    }
                }
            }
            return records;
        },

        combineWithEditVals : function (children) {
            var grid = this.creator,
                summaryChildren = [];
            summaryChildren.addList(children);

            // if the grid has any edited rows, pass the 'edited' record objects to
            // the summary function so we pick up user edits
            var editRows = grid.getAllEditRows();
            if (editRows.length > 0) {
                var editedInGroup;
                for (var i = 0; i < summaryChildren.length; i++) {
                    var editSession = grid.getEditSession(summaryChildren[i]);
                    if (editSession) {
                        
                        var editedRecord = isc.addProperties({},
                                                            summaryChildren[i],
                                                            editSession._editValues);
                        summaryChildren[i] = editedRecord;
                    }
                }
            }
            return summaryChildren;
        },

        // override indexOf to handle being passed primary keys!
        primaryKeyFields:this.dataSource?this.getDataSource().getPrimaryKeyFieldNames():null,
        indexOf : function (node, pos, endPos) {
            if (node == null) return -1;

            // This can be called in inner for loops (for example during regrouping).
            
            var openList = this._getOpenList(),
                findKeys, hasKeys,
                index = -1;
            
            if (this.primaryKeyFields != null) {
                
                var keyFields = this.primaryKeyFields;
                findKeys = {};
                
                for (var i = 0; i < keyFields.length; i++) {
                    var keyField = keyFields[i];
                    if (node[keyField] == null) {
                        hasKeys = false;
                        break;
                    } else {
                        hasKeys = true;
                        findKeys[keyField] = node[keyField];
                    }
                }
            }
            
            if (hasKeys) {
                // go through the recordSet looking for a record with the same values for 
                // the primary keys
                index = openList.findNextIndex(pos, findKeys, null, endPos);
            } else {
                index = openList.indexOf(node, pos, endPos);
            }
            return index;
        },

        // An asynchronous version of Tree.openAll() which operates in batches of
        // size batchSize.
        _openAllAsync : function (node, callback, batchSize, timerEventPropName) {
            if (!node) node = this.root;

            var getDescendantsAsyncCallback = function (nodeList, i) {
                if (i == null) {
                    i = 0;
                }
                for (var j = 0, length = nodeList.length; j < batchSize && i < length; ++i, ++j) {
                    // if the node is not already set to the newState
                    if (!this.isOpen(nodeList[i])) {
                        // call the dataChanged method to notify anyone who's observing it
                        this.changeDataVisibility(nodeList[i], true);
                    }
                }
                if (i < length) {
                    getDescendantsAsyncCallback.apply(this, [nodeList, i]);
                } else {
                    // make the node itself open
                    this.changeDataVisibility(node, true);
                    callback.apply(this, []);
                }
            };

            this._getDescendantsAsync(node, isc.Tree.FOLDERS_ONLY, null, getDescendantsAsyncCallback, batchSize, timerEventPropName);
        },

        // An asynchronous version of Tree.getDescendants() that works in batches of size batchSize.
        // node, displayNodeType, and condition are the original arguments, and callback, batchSize,
        // timerEventPropName, list, stack are additional arguments.  The callback is called after
        // all work is performed.  The total work performed by this method is split into batches of
        // work proportional to batchSize.  The list argument holds the eventual return value.
        // The stack argument holds iteration state that is passed between asynchronous invocations
        // of this method.  timerEventPropName identifies a property of the list grid in which to
        // store any timer events created.
        _getDescendantsAsync : function (node, displayNodeType, condition, callback, batchSize, timerEventPropName, list, stack) {
            var childrenStack, indexStack;
            if (list == null) {
                if (!node) node = this.root;

                // create an array to hold the descendants
                list = [];

                // if condition wasn't passed in, set it to an always true condition
                // XXX convert this to a function if a string, similar to getChildren()
                if (!condition) condition = function(){return true};

                // if the node is a leaf, return the empty list
                if (this.isLeaf(node)) {
                    callback.apply(this, [list]);
                    return;
                }

                // iterate through all the children of the node
                // Note that this can't depend on getChildren() to subset the nodes,
                //    because a folder may have children that meet the criteria but not meet the criteria itself.
                var children = this.getChildren(node);
                if (!children) {
                    callback.apply(this, [list]);
                    return;
                }

                childrenStack = [children];
                indexStack = [0];
                stack = { childrenStack: childrenStack, indexStack: indexStack };
            } else {
                childrenStack = stack.childrenStack;
                indexStack = stack.indexStack;
            }
            var stackCount = childrenStack.length,
                recordCount = 0;

            while (stackCount > 0) {
                var children = childrenStack.pop(),
                    i = indexStack.pop();
                --stackCount;

                // for each child
                if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                    for (var length = children.getLength(); i < length; ++i, ++recordCount) {

                        if (recordCount > batchSize) {
                            childrenStack.push(children);
                            indexStack.push(i);
                            this.creator[timerEventPropName] = this.delayCall(
                                "_getDescendantsAsync",
                                [node, displayNodeType, condition, callback, batchSize, timerEventPropName, list, stack], 0);
                            return;
                        }

                        // get a pointer to the child
                        var child = children.getCachedRow(i);

                        if (child != null) {
                            // if that child is a folder
                            if (this.isFolder(child)) {
                                // if we're not exluding folders, add the child
                                if (displayNodeType != isc.Tree.LEAVES_ONLY && condition(child))
                                    list[list.length] = child;

                                // now concatenate the list with the descendants of the child
                                var grandChildren = this.getChildren(child);
                                if (grandChildren) {
                                    childrenStack.push(children);
                                    indexStack.push(i + 1);
                                    ++stackCount;
                                    children = grandChildren;
                                    i = -1;
                                    length = children.getLength();
                                }
                            } else {
                                // if we're not excluding leaves, add the leaf to the list
                                if (displayNodeType != isc.Tree.FOLDERS_ONLY && condition(child)) {
                                    list[list.length] = child;
                                }
                            }
                        }
                    }
                }
            }

            // finally, return the entire list
            callback.apply(this, [list]);
        },

        addBeforeSummaries : function (record, currRoot) {
            var children = this.getChildren(currRoot);

            var targetIndex = children ? children.length : null;
            while (targetIndex > 0 &&
                   children && children[targetIndex-1][this._summaryRecordFlag])
            {
                targetIndex --;
            }
            this.add(record, currRoot, targetIndex);
        },

        
        _markForUpdateSummaryRows : function (groupNodes, fastChildren, nodeList) {
            if (!isc.isAn.Array(groupNodes)) groupNodes = [groupNodes];

            for (var i = 0; i < groupNodes.length; i++) {
                var originalNode = groupNodes[i];
                
                if (originalNode != null && !originalNode._isGroup) {
                    originalNode = this.getParent(originalNode);
                }
                if (!originalNode || !originalNode._isGroup) continue;

                var parents = this.getParents(originalNode);
                parents.unshift(originalNode);
                for (var j = parents.length - 2; j >= 0; j--) {
                    var node   = parents[j];
                    if (node._refreshGroup == null) {
                        node._refreshGroup = true;
                        if (fastChildren) {
                            var parent = parents[j+1];
                            if (!parent._dirtyChildren) parent._dirtyChildren = [];
                            parent._dirtyChildren.add(node);
                        } else if (nodeList) {
                            nodeList.add(node);
                        }
                    }
                }
            }
            if (nodeList) return nodeList;
        },

        _getDirtyGroups : function (node) {
            var dirtyChildren = node._dirtyChildren;
            if (!dirtyChildren) return [];
            delete node._dirtyChildren;
            return dirtyChildren;
        }
    }, isc.Tree);

    this.logInfo("Adding " + currData.getLength() + " records to groups", "grouping");

    // Create grouped tree from flat data, set group titles (traversing the tree in level order),
    // then finish the grouping and redraw.
    if (async) {
        this._regroupTimerEvent = this.delayCall(
                "_regroupAddRecordsToGroup",
                [async, baton, groupTree, currData, 0, currData.getLength(), restoreOpenFolders], 0);
    } else {
        this._regroupAddRecordsToGroup(
            async, baton, groupTree, currData, 0, currData.getLength(), restoreOpenFolders);
    }
},

_regroupAddRecordsToGroup : function (async, baton, groupTree, currData, startIndex, endIndex, restoreOpenFolders) {
    
    
    var finalIndex = endIndex;
    if (async) {
        endIndex = Math.min(startIndex + this.groupByAsyncThreshold, finalIndex);
    }

    // create grouped tree from flat data
    var loadingMarker = (
            isc.ResultSet && isc.isA.ResultSet(currData) ?
                isc.ResultSet.getLoadingMarker() : null);
    
    var dataOpenList;
    if (this.groupTree == this.data) {
        dataOpenList = this.data._getOpenList();
    }    
    for (var i = startIndex; i < endIndex; ++i) {
        var record = currData.get(i);
        if (record != null && record != loadingMarker) {
            this.__addRecordToGroup(
                baton.groupByFields, this.data, baton.emptyCellValue,
                baton.groupSummaryRecordProperty, baton.gridSummaryRecordProperty,
                baton.fieldsHaveUserFormulas, baton.fieldsHaveUserSummaries,
                baton.applyFormulaAfterSummary, baton.groupByFieldUserFormulas,
                baton.groupByFieldUserSummaries, baton.groupByFieldDisplayFields,
                baton.groupByFieldValueMaps, baton.nullGroupTitle, baton.showGroupSummary,
                baton.showGroupSummaryInHeader, baton.recordBaseStyleProperty,
                baton.groupNodeBaseStyle, baton.recordCustomStyleProperty,
                baton.groupNodeStyle, baton.recordEditProperty, baton.singleCellValueProperty,
                groupTree, record, false, restoreOpenFolders, dataOpenList);
        }
    }

    if (async && endIndex < finalIndex) {
        this._regroupTimerEvent = this.delayCall(
                "_regroupAddRecordsToGroup",
                [async, baton, groupTree, currData, endIndex, finalIndex, restoreOpenFolders], 0);

    } else if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupAddSummaryChildren", [async, baton, groupTree], 0);
    } else {
        this._regroupAddSummaryChildren(async, baton, groupTree);
    }
},

// Adds the initial group summary rows, if any, to the groupTree.
_regroupAddSummaryChildren : function (async, baton, groupTree) {
    
    this.__updateSummaryRows(
        baton.showGroupSummaryInHeader, baton.groupByFields, baton.showCollapsedGroupSummary,
        baton.includeInSummaryProperty, baton.applyFormulaAfterSummary,
        baton.groupSummaryRecordProperty, baton.fieldsHaveUserFormulas, groupTree, null,
        baton.showGroupSummary, [], baton.groupByFieldSummaries);
    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupProcessGroupHeaderNode", [async, baton, groupTree], 0);
    } else {
        this._regroupProcessGroupHeaderNode(async, baton, groupTree);
    }
},

//> @method listGrid.getGroupMembers()
// For a +link{groupByField,grouped} grid, returns all the direct children of the supplied node
// in the +link{groupTree} if <code>recordsOnly</code> false.  Otherwise, if
// <code>recordsOnly</code> is true, returns instead a list of all descendants under the
// supplied node that are actual records from the grid's original data - i.e. that are not other
// group nodes (for multi-grouping) or summary records.
// <P>
// Note that null may be returned if the grid is not currently grouped or the supplied node is
// not a valid +link{GroupNode}.
//
// @param  node        (GroupNode)  node from +link{groupTree}
// @param  recordsOnly (boolean)    <code>true</code> to return all descendants that are actual
//                                  records from the grid's original data, or <code>false</code>
//                                  to return all immediate children of the supplied group node
// @return (Array of ListGridRecord) records under the supplied node, as specified above, or
//                                   null if we're not grouping or the node isn't a group node
// @group grouping
// @visibility external
//<
getGroupMembers : function (node, recordsOnly) {
    // pull the tree from the group node if the node refers to a valid tree
    
    var groupTreeID = node._isc_tree,
        groupTree = window[groupTreeID]
    ;
    

    // no valid groupTree - bail
    if (!groupTree) return null;

        

    var nodes = recordsOnly ? groupTree.getRecordsInGroup(node) :
                              groupTree.getChildren(node);
    

    return nodes;
},

// Helper method to add/update/remove group summary rows from the groupTree in response to
// changes to the showGroupSummary or groupByFieldSummaries properties of the ListGrid.
// Also handles refreshing summaries to react to data change (see refreshGroupSummary)
_updateSummaryRows : function (
    tree, prevShowGroupSummary, showGroupSummary,
    prevGroupByFieldSummaries, groupByFieldSummaries,
    refreshExisting, records, fields)
{
    return this.__updateSummaryRows(
        this.showGroupSummaryInHeader, this.getGroupByFields(), this.showCollapsedGroupSummary,
        this.includeInSummaryProperty, this.applyFormulaAfterSummary,
        this.groupSummaryRecordProperty, null, tree, prevShowGroupSummary, showGroupSummary,
        prevGroupByFieldSummaries, groupByFieldSummaries, refreshExisting, records, fields);
},
__updateSummaryRows : function (
    showGroupSummaryInHeader, groupByFields, showCollapsedGroupSummary,
    includeInSummaryProperty, applyFormulaAfterSummary, groupSummaryRecordProperty,
    fieldsHaveUserFormulas, tree, prevShowGroupSummary, showGroupSummary,
    prevGroupByFieldSummaries, groupByFieldSummaries, refreshExisting, records, fields)
{
    if (showGroupSummaryInHeader) {
        // In this case the group summaries are not displayed as extra leaves in the tree
        // and so there are no summary rows that need to be added/updated.
        return;
    }

    // A null setting of groupByFieldSummaries means that summaries for all of the groupBy
    // fields should be calculated.
    if (!isc.isAn.Array(prevGroupByFieldSummaries)) {
        prevGroupByFieldSummaries = groupByFields;
    }
    if (!isc.isAn.Array(groupByFieldSummaries)) {
        groupByFieldSummaries = groupByFields;
    }

    // Determine if there is a change in the showGroupSummary property that
    // would require the groupTree to be traversed to add/remove summary rows.
    var addedSummaries,
        removedSummaries,
        refreshSummaries;
    if (!(prevShowGroupSummary || showGroupSummary)) {
        // No group summary rows are currently showing or need to be shown, so
        // there is nothing to do.
        return;
    // Were showing, no longer are...
    } else if (prevShowGroupSummary && !showGroupSummary) {
        removedSummaries = prevGroupByFieldSummaries;
    // Were not showing, but are now
    } else if (!prevShowGroupSummary && showGroupSummary) {
        addedSummaries = groupByFieldSummaries;
    // Were showing, and still are (but may be different fields)
    } else {
        removedSummaries = [];
        if (groupByFieldSummaries) {
            for (var i = prevGroupByFieldSummaries.length; i--; ) {
                var summary = prevGroupByFieldSummaries[i];
                if (!groupByFieldSummaries.contains(summary)) {
                    removedSummaries.push(summary);
                }
            }
        }

        addedSummaries = [];
        refreshSummaries = [];
        for (var i = groupByFieldSummaries.length; i--; ) {
            var summary = groupByFieldSummaries[i];
            if (!prevGroupByFieldSummaries.contains(summary)) {
                addedSummaries.push(summary);
            } else if (refreshExisting) {
                refreshSummaries.push(summary);
            }
        }
    }
    if (!(addedSummaries && addedSummaries.length > 0) &&
        !(removedSummaries && removedSummaries.length > 0) &&
        !(refreshSummaries && refreshSummaries.length > 0)
       )
    {
        // There is nothing to do.
        return;
    }

    // If showCollapsedGroupSummary is true, add summary rows as
    // siblings of the group header rather than children. This ensures
    // they show up after the group members if the group is expanded, and
    // after the group header if the group is collapsed.
    
    var summariesAreSiblings = showCollapsedGroupSummary,
        fastChildren = records != null && !summariesAreSiblings;

    if (records != null) tree._markForUpdateSummaryRows(records, fastChildren);

    var root = tree.getRoot(),
        rootChildren = null;
    if (root && tree.isFolder(root)) {
        rootChildren = fastChildren ? tree._getDirtyGroups(root) : tree.getChildren(root);
    }
    if (!(root && rootChildren && !rootChildren.isEmpty())) {
        return;
    }

    
    
    var flag = tree._summaryRecordFlag,
        targetNodeFlag = tree._summaryTargetNode,
        skipSortFlag = Array.excludeFromSortProperty,
        parentStack = [root],
        siblingsStack = [rootChildren],
        indexStack = [0];

    
    var dataChanged = false;
    tree._deferDataChanged = true;

    while (indexStack.length > 0) {
        var parent = parentStack.pop(),
            siblings = siblingsStack.pop(),
            i = indexStack.pop();

        // we need to know the length, so skip a result set with in-progress operation
        if (isc.isA.ResultSet(siblings) && !siblings.lengthIsKnown()) continue;

        var len = siblings.getLength();
        for (; i < len; ++i) {
            var node = siblings.getCachedRow(i);
            if (!node) {
                continue;
            }
            if (records != null) {
                if (node._refreshGroup) delete node._refreshGroup;
                else                  continue;
            }

            var group = node.groupName,
                add = addedSummaries && addedSummaries.contains(group),
                remove = removedSummaries && removedSummaries.contains(group),
                children = tree.getChildren(node);

            // Handle "refresh" as remove then re-add.
            if (refreshSummaries && !add && !remove) {
                add = refreshSummaries.contains(group);
                remove = refreshSummaries.contains(group);
            }
            // assert !(add && remove)

            if (remove) {
                // Remove the summary rows, which are the last children.
                if (!summariesAreSiblings) {
                    if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                        var summaryChildren = [];
                        for (var j = children.getLength(); j-- > 0; ) {
                            var child = children.getCachedRow(j);
                            if (child[flag] === true) {
                                summaryChildren.push(child);
                            } else {
                                break;
                            }
                        }
                        dataChanged |= tree.removeList(summaryChildren);
                    }
                } else {
                    var summaries = [],
                        j = 0;
                    for (;;) {
                        var s = siblings.getCachedRow(i + j + 1);
                        if (s && s[flag] == true) {
                            summaries.add(s);
                            ++j;
                        } else {
                            break;
                        }
                    }
                    dataChanged |= tree.removeList(summaries);
                    len -= summaries.length;
                }
            }
            if (add) {
                // We want to call 'getGroupSummaryData' and pass in live records to pick up
                // the summary row(s) based on the actual data.
                // If there are multiple layers of nesting this means we'll have to reach into
                // the sub-tree to get the ultimate descendants (the live records), rather than
                // just looking at the children of the current node (which would be a set of
                // header-nodes unless this is the innermost group).
                var summaryChildren = tree.getRecordsInGroup(node);

                summaryChildren = tree.combineWithEditVals(summaryChildren);

                var summaryRecords = this._getGroupSummaryData(
                        includeInSummaryProperty, applyFormulaAfterSummary,
                        groupSummaryRecordProperty, fieldsHaveUserFormulas,
                        summaryChildren, node, fields);
                if (summaryRecords != null) {
                    if (!isc.isAn.Array(summaryRecords)) {
                        summaryRecords[flag]         = true;
                        summaryRecords[skipSortFlag] = true;
                        if (!summariesAreSiblings) {
                            dataChanged |= tree.add(summaryRecords, node)      != null;
                        } else {
                            dataChanged |= tree.add(summaryRecords, parent, i) != null;
                            i+=1;
                            len+=1;
                        }
                    } else {
                        for (var k = summaryRecords.length; k--; ) {
                            summaryRecords[k][flag]         = true;
                            summaryRecords[k][skipSortFlag] = true;
                            
                            if (summariesAreSiblings) {
                                summaryRecords[k][targetNodeFlag] = node;
                            }
                        }
                        if (!summariesAreSiblings) {
                            dataChanged |= tree.addList(summaryRecords, node)        != null;
                        } else {
                            dataChanged |= tree.addList(summaryRecords, parent, i+1) != null;
                            i+=summaryRecords.length;
                            len+=summaryRecords.length;
                        }
                    }
                }
            }

            if (fastChildren) children = tree._getDirtyGroups(node);

            // Siblings in the groupTree should have the same type (folder or leaf).
            // Check the type of the first child.  This method calculates summaries
            // over folders so skip over the leaves.
            var childrenAreFolders = (children && !children.isEmpty() &&
                                      tree.isFolder(children.first()));
            if (childrenAreFolders) {
                // Recurse
                parentStack.push(parent);
                siblingsStack.push(siblings);
                indexStack.push(i + 1);
                parent = node;
                siblings = children;
                len = siblings.getLength();
                i = -1;
            }
        }
    }

    
    delete tree._deferDataChanged;
    if (dataChanged) {
        tree._clearNodeCache(true);
        tree.dataChanged();
    }
},

// Iterate through the tree recursively from root, for as many layers of nesting as
// required by the specified groupFields, applying group title and group summary info
// to the header nodes.
_regroupProcessGroupHeaderNode : function (async, baton, tree, state) {
    
    if (state == null) {
        state = {
            i: 0,
            children: tree.getChildren(tree.getRoot()),
            groupsVisited: 0,
            indexStack: [],
            childrenStack: []
        };
    }

    var groupFields = baton.groupByFields || [],
        i = state.i,
        children = state.children || [],
        groupsVisited = state.groupsVisited == null ? 0 : state.groupsVisited,
        indexStack = state.indexStack || [],
        childrenStack = state.childrenStack || [],
        recordCount = 0;
    if (groupFields.length > 0) {
        for (;;) {
            if (!isc.isA.ResultSet(children) || children.lengthIsKnown()) {
                // We know there's a layer of grouping below us, so process each child as a header
                // node as well.
                for ( ; i < children.getLength(); ++i, ++recordCount) {

                    if (async && recordCount > this.groupByAsyncThreshold) {
                        state.i = i;
                        state.children = children;
                        state.groupsVisited = groupsVisited;
                        this._regroupTimerEvent = this.delayCall(
                            "_regroupProcessGroupHeaderNode", [async, baton, tree, state], 0);
                        return;
                    }
                    // process each child that's a group node (and not a summary record)
                    var currNode = children.getCachedRow(i);
                    if (currNode != null && !currNode[this.groupSummaryRecordProperty]) {
                        var fld = this.getUnderlyingField(groupFields[groupsVisited]);
                        
                        if (baton.showGroupSummary && baton.showGroupSummaryInHeader) {
                            recordCount += this._applyGroupSummaryToHeader(
                                baton.groupByFieldSummaries, baton.includeInSummaryProperty,
                                baton.applyFormulaAfterSummary,
                                baton.groupSummaryRecordProperty, baton.fieldsHaveUserFormulas,
                                tree, currNode);
                        }

                        // call _getGroupTitle() after applying groupSummaries to headers, so
                        // an override of getGroupTitle() (or a GroupTitleRenderer) can get at 
                        // summary data for the node via getGroupSummaryData()
                        var groupTitle = this._getGroupTitle(
                                tree, baton.groupByFields, baton.groupByFieldValueMaps,
                                baton.singleCellValueProperty, currNode, fld);

                        // don't set singleCellValue if groupTitleField is set, in which case we want
                        // the groupTitle to be contained within a specific cell
                        if (!this._singleCellGroupHeaders(
                                baton.showGroupSummary, baton.showGroupSummaryInHeader))
                        {
                            currNode.groupTitle = groupTitle;
                        } else currNode[baton.singleCellValueProperty] = groupTitle;

                        if (groupsVisited + 1 < groupFields.length) {
                            ++groupsVisited;
                            indexStack.push(i + 1);
                            childrenStack.push(children);
                            i = -1; // i will be incremented to zero before the start of the loop
                            children = tree.getChildren(currNode) || [];
                        }
                    }
                }
            }
            if (indexStack.length > 0) {
                --groupsVisited;
                i = indexStack.pop();
                children = childrenStack.pop();
            } else {
                break;
            }
        }
    }

    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupOpenInitialGroups", [async, baton, tree, baton.restoreOpenFolders], 0);
    } else {
        this._regroupOpenInitialGroups(async, baton, tree, baton.restoreOpenFolders);
    }
},

_regroupOpenInitialGroups : function (async, baton, tree, restoreOpenFolders) {
    
    // If restoreOpenFolders is non null we will have passed it to 'addRecordToGroup'
    // and lazily instantiated the folders with the appropriate open property
    // Otherwise group fields have changed and we need to reset to initial open state
    if (!restoreOpenFolders) {
        var groupStartOpen = baton.groupStartOpen;

        if (!async) {
            this._openInitialGroups(groupStartOpen, tree);
        } else {
            var callback = function () {
                    // 'this' refers to the groupTree AutoChild, so this.creator is the ListGrid.
                    this.creator._regroupCreateSelectionModel(
                        async, baton, baton.currData, baton.setOriginalDataToCurrData, tree);
                };

            // group open options
            
            var batchSize = 250;
            if (isc.isAn.Array(groupStartOpen)) {
                // specific field values
                var children = tree.getChildren(tree.getRoot());
                for (var i = 0; i < groupStartOpen.length; i++) {
                    var value = groupStartOpen[i];
                    var folder = children.find("groupValue", value);
                    if (folder) tree.openFolder(folder);
                }
            } else if (groupStartOpen == "all") {
                tree._openAllAsync(null, callback, batchSize, "_regroupTimerEvent");
                return;
            } else if (groupStartOpen == "first") {
                
                var children = tree.getChildren(tree.getRoot(), null, null, null, null, null,
                                   null, null, this.sortByGroupFirst ? false : null);
                tree._openAllAsync(children.first(), callback, batchSize, "_regroupTimerEvent");
                return;
            }
        }
    }

    if (async) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupCreateSelectionModel",
            [async, baton, baton.currData, baton.setOriginalDataToCurrData, tree],
            0
        );
    } else {
        this._regroupCreateSelectionModel(
            async, baton, baton.currData, baton.setOriginalDataToCurrData, tree);
    }
},

_regroupCreateSelectionModel : function (async, baton, currData, setOriginalDataToCurrData, tree) {
    
    if (setOriginalDataToCurrData) {
        this.originalData = currData;
    }

    // Clean up the previous groupTree, then switch to the current working groupTree.
    if (this.groupTree) {
        this.ignore(this.groupTree, "changeDataVisibility");
        this.groupTree.destroy();
    }
    this.groupTree = tree;

    // Set .data directly, because this may be called from setData() anyway.
    // Note that this also avoids us worrying about 'preserveEditsOnSetData'
    this.data = tree;
    this._observeGroupData(this.data);
    // reset the selection model so the user can select items in the tree
    this.createSelectionModel();

    if (async) {
        // In an asynchronous regroup, pre-calculate the cache length of the
        // groupTree then have this.selectionManager create its internal cache
        // now instead of lazily because it can be expensive to compute.
        // _regroupGetGroupTreeLength() will call _regroupCacheSelectionModel()
        // which will then call _regroupFinish().
        this._regroupTimerEvent = this.delayCall(
            "_regroupGetGroupTreeLength", [async, baton], 0);
    } else {
        this._regroupFinish(async, baton);
    }
},

_regroupGetGroupTreeLength : function (async, baton) {
    // assert async
    // assert this.data == this.groupTree
    var batchSize = 4000;
    this.data._getLengthAsync(this, "_regroupTimerEvent", batchSize, function (length) {
        this._regroupTimerEvent = this.delayCall(
            "_regroupCacheSelectionModel", [async, baton], 0);
    });
},

_regroupCacheSelectionModel : function (async, baton) {
    // assert async
    // assert this.data.getNewSelection == null
    // assert isc.isA.Selection(this.selectionManager) || 
    //        isc.isA.CellSelection(this.selectionManager)
    var callback = function () {
        this._regroupTimerEvent = this.delayCall("_regroupFinish", [async, baton], 0);
    };

    if (isc.isA.Selection(this.selectionManager)) {
        var batchSize = 4000;
        this.selectionManager._cacheSelectionAsync(this, "_regroupTimerEvent", batchSize, 
                                                   callback);
    } else if (isc.isA.CellSelection(this.selectionManager)) {
        this.selectionManager.getSelectedCells();
        this._regroupTimerEvent = this.delayCall("_regroupFinish", [async, baton], 0);
    }
},

// common code associated with clearing _asyncRegroupInProgress flag
_completeAsyncRegroup : function (skipClearTimer, skipFinalConfig) {
    // Cancel the timer and clear the prompt.
    delete this._asyncRegroupInProgress;
    delete this._asyncRegroupBaton;

    if (!skipClearTimer) isc.Timer.clear(this._regroupTimerEvent);
    delete this._regroupTimerEvent;
    isc.clearPrompt();

    if (!skipFinalConfig) {
        // Setting of two properties were postponed until the
        // asynchronous regroup finished and now they need to be set.
        this.setGroupByFieldSummaries(this._newGroupByFieldSummaries);
        this.setShowGroupSummary(this._newShowGroupSummary);

        // apply hilites now if it was deferred during the regroup
        if (this._applyHilitesAfterRegroup) {
            this.applyHilites(this._pendingHilitesSuppressRedraw);
        }
    }

    delete this._applyHilitesAfterRegroup;
    delete this._pendingHilitesSuppressRedraw;
},

// override to handle deferring if an asynchronous regroup is in progress
applyHilites : function (suppressRedraw) {
    if (this._asyncRegroupInProgress) {
        this._applyHilitesAfterRegroup = true;
        // remember whether any call was made with suppressRedraw: false
        var oldSuppressRedraw = this._pendingHilitesSuppressRedraw;
        this._pendingHilitesSuppressRedraw = oldSuppressRedraw != null ?
            oldSuppressRedraw && !!suppressRedraw : !!suppressRedraw;
        return;
    }
    this.invokeSuper(isc.ListGrid, "applyHilites", suppressRedraw);
},

_regroupFinish : function (async, baton) {
    
    delete this._asyncRegroupBaton;
    
    // Store grouped fields for future reference.
    var groupByFields = baton.groupByFields;
    this.groupByField = groupByFields;
    if (baton.groupByFieldGroupingModes != null) {
        for (var i = groupByFields.length; i--; ) {
            var groupingMode = baton.groupByFieldGroupingModes[i];
            if (groupingMode != null) {
                var field = this.fields.find(this.fieldIdProperty, groupByFields[i]);
                if (field) field.groupingMode = groupingMode;
            }
        }
    }
    this.isGrouped = true;
    // Fire the group/viewStateChanged notification here.
    this.handleGroupStateChanged();
    
    // restore the selected state after a grouping operation
    if (this._lastStoredSelectedState) {
        this.setSelectedState(this._lastStoredSelectedState, true);
        delete this._lastStoredSelectedState;
    }
    // If we're showing the special 'groupTitleColumn', force it to refresh its width now
    
    if (this.fields.find("_isGroupTitleColumn", true) != null) {
        this.updateFieldWidthsForAutoFitValue("regroup with group title column showing");
    }

    this.markForRedraw("regroup");

    // Clear the asynchGroupingPrompt message that was set in regroup().
    if (async) this._completeAsyncRegroup(true);

    var fields = this._groupByCompleteFieldsAfterRegroup,
        undef;
    delete this._groupByCompleteFieldsAfterRegroup;    

    // notification methods that the (re)grouping process has successfully completed
    var fromGroupBy = fields !== undef;
    if (fromGroupBy) {
        this.__groupByComplete(fields);
    }
    this.__groupTreeChanged(fromGroupBy ? isc.ListGrid.GROUP_BY :
                                        isc.ListGrid.REGROUP, true);
},


retainOpenStateOnRegroup: true,

// Update grouping of the grid for a single changed record. Originally in
// _fireCellChanged.
// NOTE: originalRecord must be a TreeNode from this.data.
_incrementalRegroup : function (record, originalRecord, newValues) {

    // If changes are made locally, this code is responsible for updating
    // groups and records. If this grid is databound, the server update will
    // reset this.data to the new values, and regroup() (called from dataChanged())
    // will update the groups.

    var wasSuppressed = this._suppressFolderToggleRedraw;
    this._suppressFolderToggleRedraw = true;
    
    var storedSelectedState = false;
    if (this._lastStoredSelectedState == null) {
        storedSelectedState = true; 
        this._lastStoredSelectedState = this.getSelectedState(true);
    }
    
    // cache the current group chain associated with the original record
    var groups = originalRecord ? this.data.getParents(originalRecord) : [];

    
    if (this.groupTree == this.data && record == originalRecord) {
        originalRecord = null;
    }

    // if an original record is still present, remove it now before ListGrid._addRecordToGroup()
    var removeSucceeded = originalRecord ? this.data.remove(originalRecord) : false;

    // re-add record to group.
    // record may be null if eg adding a new record to unbound data. If it is,
    // add the new values instead - they represent what was added.
    // if original remove failed and we had data to begin with, don't add -
    // it's already been added elsewhere
    var recordOrNewValues = record || newValues;
    if (!(originalRecord && !removeSucceeded) && (recordOrNewValues)) {
        this._addRecordToGroup(this.groupTree, recordOrNewValues, true, true);
    }

    // next recalc group titles and remove empty groups
    var originalGroupNode = null;
    for (var i = 0; i < groups.length - 1; i++) {
        var currGroup = groups[i],
            members = currGroup.groupMembers,
            checkForSummaryChildren = this.showGroupSummary && !this.showCollapsedGroupSummary;
        if (checkForSummaryChildren ? !members.find("isGroupSummary", null) : 
                                       members.getLength() == 0) 
        {
            this.data.remove(currGroup);
        } else {
            var fld = (this.completeFields||this.fields).find(this.fieldIdProperty, currGroup);
            
            if (this.singleCellGroupHeaders()) {
                currGroup[this.singleCellValueProperty] = this.getGroupTitle(currGroup, fld);
            } else {
                currGroup.groupTitle = this.getGroupTitle(currGroup,fld);
            }
            if (!originalGroupNode) originalGroupNode = currGroup;
        }
    }

    // reset this flag so that future calls to toggleFolder() don't bail 
    this._suppressFolderToggleRedraw = wasSuppressed;
    
    
    if (this.showGroupSummary) {
        var recordsToRefresh = [recordOrNewValues];
        if (originalGroupNode) recordsToRefresh.add(originalGroupNode);
        this.refreshGroupSummary(recordsToRefresh);
    }
    // restore the selected state if we removed anything from the tree.
    // This will handle re-selecting a node updated to sit in a new group.
    if (storedSelectedState) {
        if (removeSucceeded) {
            this.setSelectedState(this._lastStoredSelectedState);
        }
        delete this._lastStoredSelectedState;
    }

    // notification method that the incremental grouping process has successfully completed
    var newGroups = recordOrNewValues && this.data.getParents ? 
            this.data.getParents(recordOrNewValues) : [];
    if (!newGroups.equals(groups)) this.__groupTreeChanged(isc.ListGrid.INCREMENTAL, true);
},

_openInitialGroups : function (groupStartOpen, tree) {
    // group open options
    
    if (isc.isAn.Array(groupStartOpen)) {
        // specific field values
        var children = tree.getChildren(tree.getRoot());
        for (var i = 0; i < groupStartOpen.length; i++) {
            var value = groupStartOpen[i];
            var folder = children.find("groupValue", value);
            if (folder) tree.openFolder(folder);
        }
    } else if (groupStartOpen == "all") {
        tree.openAll();
    } else if (groupStartOpen == "first") {
        
        var children = tree.getChildren(tree.getRoot(), null, null, null, null, null, null,
                                        null, this.sortByGroupFirst ? false : null);
        tree.openAll(children.first());
    }
},

getGroupSpecifiers : function () {
    if (this._groupSpecifiers) return isc.shallowClone(this._groupSpecifiers);
},

setGroupSpecifiers : function (groupSpecifiers) {
    if (groupSpecifiers) {
        if (!isc.isAn.Array(groupSpecifiers)) groupSpecifiers = [groupSpecifiers];
        if (isc.isA.String(groupSpecifiers[0])) {
            var newSpec = [];
            for (var i=0; i<groupSpecifiers.length; i++) {
                // get a GroupSpecifier for the passed fieldName - returns null if no field
                var spec = this.makeGroupSpecifier(groupSpecifiers[i]);
                if (spec) newSpec.add(spec);
            }
            groupSpecifiers = newSpec;
        }
        
        
        // groupBy() will now call this method if it gets passed strings - call it back now
        // with proper specifiers
        this.groupBy(groupSpecifiers);
    } else {
        delete this._groupSpecifiers;
        this._lastStoredSelectedState = this.getSelectedState(true);
        this.groupBy([]);
    }
},
makeGroupSpecifier : function (fieldName, mode, granularity, precision) {
    // make a GroupSpecifier object from the passed values - for missing values, check the
    // associated field for defaults
    var field = this.getFieldByName(fieldName);
    var spec = { property: fieldName };
    if (field) {
        var mode = mode || field.groupingMode || field.defaultGroupingMode || 
                  (field._simpleType && field._simpleType.defaultGroupingMode);
        if (mode != null) spec.grouping = mode;
        granularity = granularity || field.groupGranularity;
        if (granularity != null) spec.granularity = granularity;
        precision = precision || field.groupPrecision;
        if (precision != null) spec.precision = precision;
    }
    return spec;
},
clearGroupSpecifiers : function () {
    this.setGroupSpecifiers(null);
},
 
//> @method listGrid.groupBy()
// Display the current set of records grouped by their values for the given field or
// fields. With no arguments, disables all grouping.
// <P>
// Grouping transforms the current dataset into a Tree on the fly, then provides a familiar tree
// interface for exploring the grouped data. Note that for performance reasons grouping
// is only available for dataSets with less than +link{listGrid.groupByMaxRecords} entries.
// <P>
// Grouping works automatically with any dataset, providing simple default grouping based on
// each field's declared type - see +link{simpleType.groupingModes} for more information.  
// Additionally, you can use +link{listGridField.getGroupValue,field.getGroupValue()} 
// to control how records are grouped, and 
// <smartclient>+link{listGridField.getGroupTitle,field.getGroupTitle()}</smartclient>
// <smartgwt>{@link com.smartgwt.client.widgets.grid.ListGridField#setGroupTitleRenderer()}</smartgwt>
// to control how groups are titled.  You can affect multiple fields of the same data-type via the 
// same-named APIs on an appropriate custom +link{simpleType.getGroupValue, SimpleType}.
// <P>
// Grouping can be performed programmatically via this API, or you can set
// +link{canGroupBy,grid.canGroupBy:true} to enable menus that allow the user to perform
// grouping. To group a grid automatically, instantiate the grid with a
//  +link{listGrid.groupByField} setting.  To take action when an end use requests grouping,
// see +link{handleGroupBy()}.
// <P>
// While grouped, the automatically created Tree is available as
// +link{groupTree,grid.groupTree} and the original dataset is available as
// +link{originalData,grid.originalData}.
// <p>
// <h3>Data Requirements</h3>
// <p>
// Before grouping can be performed, all records that match current
// +link{listGrid.fetchData,criteria} must be loaded.  If +link{dataFetchMode,data paging} is
// in use, not all matching records are cached, and the 
// +link{resultSet.getLength,total rows available from the server} is less than
// +link{groupByMaxRecords}, the grid will automatically request all unloaded records from the
// server, then perform grouping once they arrive.
// <p>
// If the total number of rows available from the server exceeds +link{groupByMaxRecords},
// calling <code>groupBy</code> will have no effect, and menu items for grouping will appear
// disabled.
// <p>
// <h3>Grouping Notification</h3>
// <p>
// Grouping is often an asynchronous operation, both because of automatic loading of remaining
// rows, and because asynchronous processing is required to work around bugs in some browsers
// related to misdetection of "hung" scripts (see +link{groupByAsyncThreshold}).  Define a
// +link{handleGroupBy()} method to be called when grouping is about to start (potentially
// canceling it), and define a +link{groupByComplete()} method to be notified when it's done.
//
// @param   [arguments 0-N] (Array of String) name of fields to group by
// @visibility external
// @group grouping
// @example dynamicGrouping
//<

groupBy : function (passedArray) {
    // support passing an Array instead of passing as a series of arguments
    var fields = [];

    if (isc.isAn.Array(passedArray)) {
        fields = isc.shallowClone(passedArray);
    } else {
        for (var i = 0; i < arguments.length; i++) {
            fields[i] = arguments[i];
        }
    }

    // the GroupSpecifier objects to pass to handleGroupBy()
    var specifiers = [];

    if (fields.length > 0) {
        if (isc.isA.String(fields[0])) {
            
            this.setGroupSpecifiers(fields);
            return;
        } else if (isc.isAn.Object(fields[0])) {
            
            specifiers = fields.duplicate();
            fields = fields.getProperty("property");
        }
    }

    // If we are currently unbound / have no fields, we'll actually group lazily when fields and
    // data are available
    if (!this.fields) {
        this.groupState = fields.join(",");
        
        this._markForRegroup = true;
        return;
    }

    for (var i = 0; i < fields.length; i++) {
        if (fields[i] != null && !this.getUnderlyingField(fields[i])) {
            this.logWarn("groupBy() passed field:" + fields[i] + " - this is not a valid field" +
                " within this grid - ignoring", "grouping");
            return;
        }
    }
    if (fields.length > 0 && fields[0] == null) {
        
        fields = [];
    }

    // fire handleGroupBy notification, if installed, and allow grouping to be cancelled
    if (this.handleGroupBy != null && this.handleGroupBy(fields, specifiers) == false) {
        
        for (var i=0; i<specifiers.length; i++) {
            var spec = specifiers[i];
            if (spec._oldGrouping) {
                var specField = this.getFieldByName(spec.property);
                if (spec._oldGrouping == "none") delete specField.groupingMode;
                else specField.groupingMode = spec._oldGrouping;
                delete spec._oldGrouping;
            }
        }
        return;
    }

    
    this._groupSpecifiers = isc.shallowClone(specifiers);

    // if arguments are null, return to original grouping
    if (fields.length == 0) {
        this.clearGroupBy();
        // fire the groupStateChanged / viewStateChanged notification here
        this.handleGroupStateChanged();
        // notification methods that the (un)grouping process has successfully completed
        this.__groupByComplete(fields);
        this.__groupTreeChanged(isc.ListGrid.GROUP_BY, true);
        return;
    }

    
    var groupByFields = [];
    for (var i = 0; i < fields.length; i++) {
        if (this.isCheckboxField(fields[i])) continue;
        var fieldName = (fields[i].property || fields[i]),
            field = this.getUnderlyingField(fieldName);
        if (field && field.displayField != null && field.optionDataSource == null &&
            this.getField(field.displayField))
        {
            fieldName = field.displayField;
        }
        groupByFields.add(fieldName);
    }
    this.logInfo("groupBy: " + groupByFields, "grouping");

    var origIsGrouped = this.isGrouped;
    this.isGrouped = true;
    // add the special groupTitleColumn if necessary - note that we have to do this after setting
    // isGrouped so getGroupTitleColumnPositon gives us back the position we want
    if (this.showGroupSummary && this.showGroupSummaryInHeader && this.showGroupTitleColumn &&
            this.getGroupTitleField() == null)
    {
        if (this.groupTitleColumn == null) {
            this.groupTitleColumn = this.getGroupTitleColumn();
        }
        if (this.fields.indexOf(this.groupTitleColumn) == -1) {
            this.addField(this.groupTitleColumn, this.getGroupTitleColumnPosition());
        }
    }
    // `isGrouped` will eventually be set to true in _regroupFinish().
    this.isGrouped = origIsGrouped;

    this._setMarkForRegroup(true, true, false, false, false, fields, groupByFields);

    
    this._groupByDataChanged = true;
    this.dataChanged();
    delete this._groupByDataChanged;
},

// Actually clears groupByFields / this.isGrouped and resets to original (ungrouped) data.
clearGroupBy : function (setAsyncFinalConfig) {
    this._setMarkForRegroup(false, false, false, true, false);

    this.logInfo("ungrouping", "grouping");

    if (this._asyncRegroupInProgress) {
        this._completeAsyncRegroup(false, setAsyncFinalConfig);
    }

    // if groupingModes is present, make sure to clear groupingMode
    var groupByFields = this.getGroupByFields();
    if (groupByFields != null) for (var i = 0; i < groupByFields.length; i++) {
        var field = this.getUnderlyingField(groupByFields[i]);
        if (field) field.groupingMode = null;
    }

    this.isGrouped = false;
    // Should we Fire the group/viewStateChanged notification here.?
    this._provideIsGroupedToRuleContext();

    if (this.originalData) {

        
        if (this.groupByField) this.groupByField = null;

        var pose = this.preserveEditsOnSetData;
        this.preserveEditsOnSetData = true;
        this.setData(this.originalData, true);
        this.preserveEditsOnSetData = pose;
        delete this.originalData;

        // If we have a groupTree, destroy it
        
        if (this.groupTree) {
            
            isc.Tree.removeNodeMetaData(isc.isA.ResultSet(this.data) ? this.data.allRows : this.data, false, false, this.groupTree);

            this.ignore(this.groupTree, "changeDataVisibility");
            this.groupTree.destroy();
            delete this.groupTree;
        }
            
    }

    // in the case where showGroupSummaryInHeader is true we may have created a
    // default summary title column - clear this from our fields array now.
    if (this.groupTitleColumn != null) {
        var completeFields = this.completeFields || this.fields,
            index = completeFields.indexOf(this.groupTitleColumn);
        if (index != -1) {
            // duplicate the array, dropping the auto generated title column
            var newFields = [];
            for (var i = 0; i < completeFields.length; i++) {
                if (i == index) continue;
                newFields[newFields.length] = completeFields[i];
            }
            this.setFields(newFields);
        }
    }
},

groupIconPadding: 5,
// Returns group title for node. If field.getGroupTitle() exists, use that. Otherwise determines
// the groupTitle from the computed group value.
getGroupTitle : function (node, field) {
    return this._getGroupTitle(
        this.data, this.getGroupByFields(), null, this.singleCellValueProperty, node, field);
},
_getGroupTitle : function (data, groupFields, groupFieldValueMaps, singleCellValueProperty, node, field) {
    
    if (!field && groupFields) {
        // If no field specified, use indentation level of node to index into groupByField
        var groupLevel = data.getLevel(node) - 1,
            field = this.getUnderlyingField(groupFields[groupLevel]);
    }
    if (field == null) {
        
        return;
    }

    var value;

    if (field.getGroupTitle) {
        return field.getGroupTitle(node.groupValue, node, field, field.name, this);
    }
    else if (!field.getGroupValue && field._simpleType && field._simpleType.getGroupTitle) {
        // Only pick up default groupingModes / groupTitle if getGroupValue has not been
        // overridden. Standard groupingModes will have no meaning to a custom getGroupValue()
        // method. Note that the inverse is not true: groupingModes or getGroupTitle() may be
        // modified for EG localization, but rely on the standard getGroupValue behavior
        return field._simpleType.getGroupTitle(node.groupValue, node, field, field.name, this);
    } else {
        value = node.groupValue;
    }

    // if there's a valueMap, pick up the display value.
    // Note that this handles optionDataSource + displayField / valueField as these
    // automatically build and apply a field valueMap
    var k = (groupFieldValueMaps == null ? -1 : groupFieldValueMaps.indexOf(field)),
        fieldValueMap = (k == -1 ? field.valueMap : groupFieldValueMaps[k]);
    if (fieldValueMap) {
        value = this.resolveValueMap(value, fieldValueMap);
    // In this case there's a display field but no option dataSource.
    } else if (field.displayField && node[field.displayField] != null) {
        value = node[field.displayField];
    }

    if (field.escapeHTML && isc.isA.String(value) && value != this._$nbsp) {
        value = value.asHTML(null, this.shouldSkipLineBreaks(field));
    }

    return value;
},

//> @attr listgrid.showGroupTitleInFrozenBody (boolean : true : IRWA)
// If this is +link{listGrid.groupBy(),grouped} and has 
// +link{group:frozenFields,frozen fields}, should the group title show in the
// frozen or unfrozen body?
// <P>
// Setting this property to false will cause the group title to show in the 
// unfrozen body in this case, meaning it will appear to the right of the frozen fields,
// and scroll horizontally as the user scrolls the unfrozen fields. 
// This can be useful for grids where there isn't
// enough available space to show the group title text in the frozen body.
// <P>
// Note that if +link{listGrid.groupTitleField} is explicitly set, or 
// +link{listGrid.showGroupSummaryInHeader} is true, this property has no
// effect. In this case rather than the group title showing in a single cell spanning
// multiple other fields, it will be rendered into a specific column.
// @visibility external
//<
showGroupTitleInFrozenBody:true,

//> @method listGrid.getGroupNodeHTML
// Returns the HTML code necessary to render a group node, including icon, title, and padding.
// The amount of the padding is at least +link{listGrid.groupLeadingIndent} pixels, and
// an additional +link{listGrid.groupIndentSize} pixels for each increasing level of the
// node.
// <P>
// The result of this method will be displayed to the user for the 
// appropriate row, either in a single cell which spans multiple columns, or in 
// the +link{listGrid.groupTitleField}. For the case where group titles are displayed 
// in a cell spanning multiple columns, if this grid has frozen fields, this method 
// may be run for both the frozen and unfrozen body. This method will return the html
// described above for the frozen body, and an empty string for the unfrozen body 
// (or vice versa depending on +link{listGrid.showGroupTitleInFrozenBody}). This ensures
// the groupNodeHTML is not displayed twice.
//
// @param node (Object) Specified group node
// @param [gridBody] (GridRenderer) The body in which the returned value will be displayed.
//  This parameter allows the default implementation to return an empty string if appropriate
//  for the case where there is both a frozen and unfrozen body. Note that if this parameter
//  may be empty. If not passed, the full group node HTML will be returned.
// @return (HTMLString) The HTML to be displayed in the appropriate row.
// @visibility external
//<
// A developer could override this method for custom behavior (EG.:checking which 'body' was
// wider, writing something other than the empty string into the unfrozen body along
// with the group title in the frozen body, etc).
getGroupNodeHTML : function (node, gridBody) {
    
    var isFrozenBody = this.frozenBody === gridBody;
    
    var hasFrozenBody = this.frozenFields && this.frozenFields.length > 0;
    // If we're rendering one single cell value across the row only render it
    // in the frozen body.
    if (hasFrozenBody && this.singleCellGroupHeaders()) {
    
        // If this is the frozen body and we shouldn't put the group title there
        // or vice versa, just return an empty string.
        if (this.showGroupTitleInFrozenBody != isFrozenBody) {
            return this.emptyCellValue;
        }
    }
    
    
    if (!isc.isA.Tree(this.data)) return this.emptyCellValue;
    
    var isOpen = this.data.isOpen(node),
        state = isOpen ? "opened" : "closed",
        url = isc.Img.urlForState(this.groupIcon, null, null, state),
        iconIndent = isc.Canvas.spacerHTML(this.groupIconPadding, 1),
        groupIndent =
            isc.Canvas.spacerHTML((this.data.getLevel(node) - 1) * this.groupIndentSize +
                                  this.groupLeadingIndent, 1),
        groupTitle = this.getGroupTitle(node);
    
    var imgConfig = {
            src:url,
            width:this.groupIconSize,
            height:this.groupIconSize,
            align:"middle"
        },
        img = this.imgHTML(imgConfig, null, null, null, null, null, null,
                  isc.Canvas._generateSpanForBlankImgHTML, "eventPart='opener'");
    var retStr = (this.canCollapseGroup ? groupIndent + img
                                        : groupIndent) +
                 iconIndent + groupTitle;
    return retStr;
},

_shouldUseGroupNodeHTML : function (gridBody, fieldNum, isGroupTitleField) {
    var checkboxFieldPos = this.getCheckboxFieldPosition();
    return (!this.canSelectGroups || fieldNum > checkboxFieldPos) &&
        (this.singleCellGroupHeaders() && !gridBody._gettingAutoSizeHTML || isGroupTitleField);
},

// Override shouldCascadeSelection - if we're grouped we want cascading selection
// If "canSelectGroups" is true, this is required to allow users to select group data by
// selecting the headers.
// If false, it's useful for getGroupTreeSelection to be able to tell devs which groups are
// selected (either fully or in part).
_shouldCascadeSelection : function () {
    
    if (this.canSelectGroups && this.groupTree != null && (this.groupTree == this.data)) return true;
    return this.Super("_shouldCascadeSelection", arguments);
},

//> @method listGrid.getGroupTreeSelection()
// If this grid +link{listGrid.isGrouped,is grouped}, this method will return the
// current selection. Unlike the standard +link{listGrid.getSelection(),getSelection method},
// this method will return +link{listGrid.isGroupNode(),group nodes} in addition to standard
// +link{ListGridRecord}s within the grid's data.
// @param [excludePartialSelection] (boolean) By default a group header node is considered
//   selected if any members of the group are selected. If this flag is passed in, only
//   header nodes where <b>all</b> members of the group are selected will be included
//   in the returned results.
// @param [groupNodesOnly] (boolean) If this parameter is passed as <code>true</code>, 
//   this method will return just the group header nodes from the group tree. If omitted
//   or false, both header nodes and data records will be returned.
// @return (Array of ListGridRecord) Selected group header nodes and record data objects.
//   If this grid is not grouped, standard +link{listGrid.getSelection(),listGrid selection}
//   will be returned.
// @visibility external
//<
getGroupTreeSelection : function (excludePartialSelection, groupNodesOnly) {
    var selection = this.getSelection(excludePartialSelection, true);
    if (groupNodesOnly && this.isGrouped) {
        var finalArray = [];
        for (var i = 0; i < selection.length; i++) {
            if (selection[i]._isGroup) finalArray.add(selection[i]);
        }
        selection = finalArray;
    }
    return selection;
},

//> @method listGrid.getSelection()
// Returns all selected records in this grid. If this grid is
// +link{listGrid.isGrouped,grouped}, group header nodes will not be included in the 
// returned array. Developers can make use of +link{getGroupTreeSelection()} to 
// get the selection including the selected group header nodes.
// <p>
// <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not
// modified.
// @param [excludePartialSelections] (Boolean) When true, partially selected records will not be returned.
//                                   Otherwise, both fully and partially selected records are
//                                   returned.
// @return (Array of ListGridRecord) array of selected records, which will be empty if no record
// is selected.
// @group  selection
// @visibility external
// @example databoundRemove
//<

// Override getSelection() to avoid returning group tree nodes if we can select groups
// since the dev calling this API only really wants real records.
getSelection : function (excludePartialSelection, includeGroupNodes, dontSort) {
    var selection = this.Super("getSelection", arguments);
    // don't return group nodes as part of the selection
    // Undocumented "includeGroupNodes" param negates this, used by getGroupTreeSelection()
    if (!includeGroupNodes && selection && selection.length > 0 && this.isGrouped) {
        var trimmedSelection = [];
        for (var i = 0; i < selection.length; i++) {
            if (selection[i]._isGroup) continue;
            trimmedSelection.add(selection[i]);
        }
        selection = trimmedSelection;
    }
    return selection;
},

// As with getSelection() - overridden to omit group-header-nodes for grouped grids
getSelectedRecord : function () {
    var selection = this.getSelection();
    return (selection.length > 0 ? selection[0] : null);
},

// internal method to determine the group value for the supplied record
_getGroupValue : function (fieldValue, record, field, fieldName, 
    userFormula, userSummary, displayField, valueMap, nullGroupTitle)
{
    var currentUserFormula = field.userFormula,
        currentUserSummary = field.userSummary;

    // typically set if called by __addRecordToGroup() - null otherwise
    if (userFormula  == null) userFormula  = currentUserFormula;
    if (userSummary  == null) userSummary  = currentUserSummary;
    if (displayField == null) displayField = field.displayField;
    if (valueMap     == null) valueMap     = field.valueMap;

    
    var undef;
    if (fieldValue === undef) fieldValue = null;

    if (field.getGroupValue) {
        fieldValue = field.getGroupValue(fieldValue, record, field, fieldName, this);
    } else if (userFormula) {
        field.userFormula = userFormula;
        fieldValue = this.getFormulaFieldValue(field, record);
        field.userFormula = currentUserFormula;
    } else if (userSummary) {
        field.userSummary = userSummary;
        fieldValue = this.getSummaryFieldValue(field, record);
        field.userSummary = currentUserSummary;
    } else {
        if (displayField) {
            var displayValue = this._getDisplayValue(
                field, valueMap, displayField, fieldValue, record);
            if (displayValue) {
                fieldValue = displayValue;
            }
        } else if (field._simpleType && field._simpleType.getGroupValue) {
            fieldValue = field._simpleType.getGroupValue(
                fieldValue, record, field, fieldName, this);
        }
    }
    if (valueMap && valueMap[fieldValue]) {
        fieldValue = valueMap[fieldValue];
    }
    if (fieldValue == null || isc.isAn.emptyString(fieldValue)) {
        fieldValue = nullGroupTitle || this.nullGroupTitle;
    }
    return fieldValue;
},

// helper function for adding a record to an existing group, or creating a new group

_addRecordToGroup : function (groupTree, record, setGroupTitles, openFolders) {
    return this.__addRecordToGroup(
        this.getGroupByFields(), this.data, this.emptyCellValue,
        this.groupSummaryRecordProperty, this.gridSummaryRecordProperty, null, null,
        this.applyFormulaAfterSummary, null, null, null, null, this.nullGroupTitle,
        this.showGroupSummary, this.showGroupSummaryInHeader, this.recordBaseStyleProperty,
        this.groupNodeBaseStyle, this.recordCustomStyleProperty, this.groupNodeStyle,
        this.recordEditProperty, this.singleCellValueProperty, groupTree, record,
        setGroupTitles, openFolders);
},
__addRecordToGroup : function (
    groupFields, data, emptyCellValue, groupSummaryRecordProperty, gridSummaryRecordProperty,
    fieldsHaveUserFormulas, fieldsHaveUserSummaries, applyFormulaAfterSummary,
    groupByFieldUserFormulas, groupByFieldUserSummaries, groupByFieldDisplayFields,
    groupByFieldValueMaps, nullGroupTitle, showGroupSummary, showGroupSummaryInHeader,
    recordBaseStyleProperty, groupNodeBaseStyle, recordCustomStyleProperty, groupNodeStyle,
    recordEditProperty, singleCellValueProperty, groupTree, record, setGroupTitles,
    openFolders, dataOpenList)
{
    var singleCellGroupHeaders = this._singleCellGroupHeaders(
            showGroupSummary, showGroupSummaryInHeader),
        currRoot = groupTree.getRoot(),
        node;
    


    // recordNum passed to 'getRawCellValue' should be position of data in this.data
    // in order for things like edit-values to behave as expected.
    // Note that this may not reflect the position in the 'currData' [this.originalData]
    // and indeed can legitimately be -1 at this point if we're reacing to
    // a record being added to our dataSet.
    
    var recordNum = dataOpenList != null ? dataOpenList.indexOf(record) : data.indexOf(record);

    
    var editedRecord = this.rowEditNotComplete(recordNum) ? 
                       this.getEditedRecord(recordNum) : record;
        
    for (var i = 0; i < groupFields.length; i++) {
        // find index of field w/ fieldName
        var fieldName = groupFields[i],
            field = this.getUnderlyingField(fieldName)
        ;
        var userFormula = groupByFieldUserFormulas == null ?
                field.userFormula : groupByFieldUserFormulas[i],
            userSummary = groupByFieldUserSummaries == null ?
                field.userSummary : groupByFieldUserSummaries[i],
            displayField = groupByFieldDisplayFields == null ? 
                field.displayField : groupByFieldDisplayFields[i],
            valueMap = groupByFieldValueMaps == null ? 
                field.valueMap : groupByFieldValueMaps[i],

            fieldValue = this._getRawCellValue(
                emptyCellValue, groupSummaryRecordProperty, gridSummaryRecordProperty,
                fieldsHaveUserFormulas, fieldsHaveUserSummaries, data,
                applyFormulaAfterSummary, (userFormula != null), userFormula,
                (userSummary != null), userSummary, record, recordNum, fieldName, true)
        ;

        // compute the group value from the raw cell value and record
        var originalValue = fieldValue;
        fieldValue = this._getGroupValue(fieldValue, editedRecord, field, fieldName,
            userFormula, userSummary, displayField, valueMap, nullGroupTitle);

        // find the group, if it exists
        var nodeChildren = groupTree.getChildren(currRoot);
        if (nodeChildren == null) node = null;
        else node = nodeChildren.find('groupValue', fieldValue,
                                    field.type == "datetime" ? Array.DATETIME_VALUES : null);
        if (!node) { // add new group
            node = {
                groupName: fieldName,
                groupValue: fieldValue, _isGroup: true, canDrag: false
                // Note: We disable user-selection unless canSelectGroups is true
                // in canSelectRecord()
                
            };
            
            // If a displayField is set, copy the displayField value from the record to
            // the node. The assumption here is that it will match for each record in the
            // group.
            if (field.optionDataSource == null && field.displayField != null) {
                node[field.displayField] = record[field.displayField];
            }

            
            if (field.groupingMode) {
                node[fieldName] = originalValue;
            } else {
                node[fieldName] = fieldValue;
            }
            
            // set group style
            node[recordBaseStyleProperty] = groupNodeBaseStyle;
            node[recordCustomStyleProperty] = groupNodeStyle;
            // set non-editable
            node[recordEditProperty] = false
            // if openFolders property is passed respect it now.
            // this allows us to lazily recreate the open/closed state of folders when rebuilding
            // a groupTree with the same set of groupByFields
            if (openFolders != null) {
                node[groupTree.openProperty] = isc.isA.List(openFolders) ? 
                    openFolders.find(fieldName, fieldValue) : !!openFolders;
            }

            // add to the current group
            if (showGroupSummary) groupTree.addBeforeSummaries(node, currRoot);
            else                  groupTree.add               (node, currRoot);
        }
        // move to next group
        currRoot = node;
    }

    
    if (groupTree == data) data.remove(record);

    // add record to group
    if (showGroupSummary) groupTree.addBeforeSummaries(record, currRoot);
    else                  groupTree.add               (record, currRoot);

    // set the group titles if need be, mainly for dragging records in
    // start with the topmost group
    if (setGroupTitles) {
        var groups = groupTree.getParents(record);
        for (var i = groups.length - 2, j = 0; i >= 0; i--, j++) {
            var groupTitle = this._getGroupTitle(
                    groupTree, groupFields, groupByFieldValueMaps, singleCellValueProperty,
                    groups[i], null);

            if (!singleCellGroupHeaders) groups[i].groupTitle = groupTitle;
            else groups[i][singleCellValueProperty] = groupTitle;
        }
    }
},

//> @method listGrid.isGroupNode()
// If this listGrid is +link{listGrid.groupBy(),grouped}, is the record
// passed in a group header node.
// @param record (ListGridRecord) record to test
// @return (boolean) returns true if the record passed in is a group header node
// @visibility external
//<
isGroupNode : function (record) {
    if (record == null) return false;
    return !!record._isGroup;
},

applyGroupSummaryToHeader : function (tree, headerNode, fields) {
    return this._applyGroupSummaryToHeader(
        this.groupByFieldSummaries, this.includeInSummaryProperty,
        this.applyFormulaAfterSummary, this.groupSummaryRecordProperty, null,
        tree, headerNode, fields);
},
_applyGroupSummaryToHeader : function (
    groupByFieldSummaries, includeInSummaryProperty, applyFormulaAfterSummary,
    groupSummaryRecordProperty, fieldsHaveUserFormulas, tree, headerNode, fields)
{
    // Skip this if groupByFieldSummaries explicitly excludes this group
    var group = headerNode.groupName;
    if (groupByFieldSummaries != null && !groupByFieldSummaries.contains(group)) {
        return;
    }

    // If we're showing the group summary in the header node, call the
    // method to get group summary data, and copy the relevant properties across
    // [from the first record only - we don't currently support multiple summary lines
    // in the group header...]
    var summaryRecords = tree.combineWithEditVals(tree.getRecordsInGroup(headerNode)),
        summaryData = this._getGroupSummaryData(
            includeInSummaryProperty, applyFormulaAfterSummary, groupSummaryRecordProperty,
            fieldsHaveUserFormulas, summaryRecords, headerNode, fields);

    if (isc.isAn.Array(summaryData)) summaryData = summaryData[0];

    // bail if there's no summary data to process (no auto-summaries based on SimpleType or
    // fields with summary functions)
    if (!summaryData) return 0;

    // We want to apply all our fields (complete, not just visible, and the
    // includeInSummary and isGroupSummary values.
    // We don't want to do a blind 'addProperties' - this picks up additional meta data
    // enabled:false which we shouldn't apply to the header node.
    var fields = this.completeFields || this.fields;
    for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        var summaryFunc = this.getGridSummaryFunction(field);
        if (summaryFunc && isc.isAn.Array(summaryFunc)) summaryFunc = summaryFunc[0];
        if (summaryFunc == "count") {
            var array = headerNode[this.recordApplyPluralTitleProperty] || [];
            array.add(field.name);
            headerNode[this.recordApplyPluralTitleProperty] = array;
        }
        // don't clobber the groupTitle node value - we need that to display our title value
        var attribName = field.type != this._$summary ? field.name :
                this._getRecordSummaryAttributeProperty(field);
        if (attribName == "groupTitle") continue;

        headerNode[attribName] = summaryData[attribName];
    }
    headerNode[groupSummaryRecordProperty] = true;

    // Return the number of records in the summary to help determine how
    // to break up the computation of a regroup into asynchronously-run
    // batches.
    return summaryRecords.length;
},

//> @method listGrid.setShowGroupSummaryInHeader()
// Setter for +link{listGrid.showGroupSummaryInHeader}
// @param showGroupSummaryInHeader (boolean) new showGroupSummaryInHeader state
// @visibility external
//<
setShowGroupSummaryInHeader : function (showGroupSummaryInHeader) {
    if (this.showGroupSummaryInHeader == showGroupSummaryInHeader) return;
    this.showGroupSummaryInHeader = showGroupSummaryInHeader;
    var fields = this.getGroupByFields();
    this.ungroup();
    if (fields != null && fields.length > 0) {
        this.groupBy(fields);
    }
},

//> @method listGrid.setShowCollapsedGroupSummary()
// Setter for +link{listGrid.showCollapsedGroupSummary}
// @param showCollapsedGroupSummary (boolean) new showCollapsedGroupSummary value
// @visibility external
//<
setShowCollapsedGroupSummary : function (showCollapsed) {
    if (this.showCollapsedGroupSummary == showCollapsed) return;
    this.showCollapsedGroupSummary = showCollapsed;
    var fields = this.getGroupByFields();
    this.ungroup();
    if (fields != null && fields.length > 0) {
        this.groupBy(fields);
    }
},

//> @method listGrid.ungroup()
// Removes the grouping from the listGrid, restoring its original data
//
// @visibility external
//<
ungroup : function () {
    this._lastStoredSelectedState = this.getSelectedState(true);
    this.groupBy(null);
},

//> @method listGrid.setHeaderSpans()
// Update the headerSpans configuration on the grid dynamically.
//
// @param headerSpans (Array of HeaderSpan) same configuration block as that passed to
//                                          +link{listGrid.headerSpans}.
//
// @group headerSpan
// @visibility external
//<
setHeaderSpans : function (headerSpans, skipSetFields) {
    this.headerSpans = headerSpans;
    // when headerSpans changes, updateHeader() will orphan the span objects in
    // the old header._spans - this flag tells updateHeader() that headerSpans 
    // have changed, causing it to destroy spans as it deparent()s them
    this._autoDestroySpans = true;
    // if the second parameter is set, bail - TimelineView uses this
    if (skipSetFields) return;
    // re-run setFields. This will reorder the fields to match the order
    // specified by the spans if necessary!
    if (this.completeFields) this.setFields(this.completeFields);
    this.layoutChildren("headerSpans changed");
},


//> @method listGrid.setHeaderSpanTitle()
// Update the title of a +link{listGrid.headerSpans,headerSpan} dynamically.
//
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newTitle (String) new title for the headerSpan
//
// @group headerSpan
// @visibility external
//<
setHeaderSpanTitle : function (name, newTitle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanTitle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.title = newTitle;
    if (spanConfig.liveObject && spanConfig.headerTitle == null) {
        spanConfig.liveObject.setTitle(newTitle);
    }
},

//> @method listGrid.setHeaderSpanHeaderTitle()
// Update the headerTitle of a +link{listGrid.headerSpans,headerSpan} dynamically.
//
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newTitle (String) new headerTitle for the headerSpan
//
// @group headerSpan
// @visibility external
//<
setHeaderSpanHeaderTitle : function (name, newTitle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanHeaderTitle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.headerTitle = newTitle;
    if (spanConfig.liveObject) spanConfig.liveObject.setTitle(newTitle);
},

//> @method listGrid.setHeaderSpanBaseStyle()
// Update the +link{headerSpan.headerBaseStyle} for a span within the grid at runtime.
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newStyle (CSSStyleName) new baseStyle for the headerSpan
// @visibility external
//<
setHeaderSpanBaseStyle : function (name, baseStyle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanBaseStyle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.headerBaseStyle = baseStyle;

    if (spanConfig.liveObject == null) return;

    // Treat being passed null as an attempt to revert to default base style.
    if (baseStyle == null) {
        var spannedFields = this.getSpannedFields(spanConfig),
            field = spannedFields[0];

        var buttonProperties = this.getHeaderButtonProperties();
        if (field.frozen && buttonProperties.frozenBaseStyle) {
            baseStyle = buttonProperties.frozenBaseStyle;
        } else if (buttonProperties.baseStyle) {
            baseStyle = buttonProperties.baseStyle;
        }

        if (baseStyle == null) {
            baseStyle = spanConfig.liveObject.getClass().getPrototype().baseStyle;
        }

    }
    spanConfig.liveObject.setBaseStyle(baseStyle);
},

//> @method listGrid.setHeaderSpanTitleStyle()
// Update the +link{headerSpan.headerTitleStyle} for a span within the grid at runtime.
// @param name (String) name of the headerSpan, as specified via +link{headerSpan.name}.
// @param newTitle (CSSStyleName) new titleStyle for the headerSpan
// @visibility external
//<
setHeaderSpanTitleStyle : function (name, titleStyle) {
    var spanConfig = this.getHeaderSpanConfig(name);
    if (!spanConfig) {
        this.logWarn("setHeaderSpanTitleStyle() - unable to locate span named: " + name
                     + this.getStackTrace());
        return;
    }
    spanConfig.headerTitleStyle = titleStyle;

    if (spanConfig.liveObject == null) return;

    if (titleStyle == null) {
        var spannedFields = this.getSpannedFields(spanConfig),
            field = spannedFields[0];

        var buttonProperties = this.getHeaderButtonProperties();
        if (field.frozen && buttonProperties.frozenTitleStyle) {
            titleStyle = buttonProperties.frozenTitleStyle;
        } else if (buttonProperties.titleStyle) {
            titleStyle = buttonProperties.titleStyle;
        }
        if (titleStyle == null) {
            titleStyle = spanConfig.liveObject.getClass().getPrototype().titleStyle;
        }
    }
    spanConfig.liveObject.setTitleStyle(titleStyle);
},

// group summaries

//> @attr listGrid.showGroupSummary (Boolean : false : IRW)
// If this listGrid supports +link{listGrid.canGroupBy,grouping}, setting this property will cause
// the grid to render an extra row at the end of each group when grouped, containing summary
// information for the fields.
// Summary information will be calculated by the +link{listGridField.getGroupSummary()} method
// if specified, otherwise via the specified +link{listGridField.summaryFunction}.
// @see listGrid.groupByFieldSummaries
// @visibility external
//<
showGroupSummary:false,

//> @attr listGrid.groupByFieldSummaries (Array of String : null : IRWA)
// If this grid is +link{listGrid.groupByField,grouped}, and
// +link{listGrid.showGroupSummary} is true, this attribute may be set to an array of
// groupBy field names for which group summaries should appear.
// <P>
// This is particularly useful for listGrids grouped by more than one field as it allows developers
// to display the group summary for a particular nested group without showing a summary for every
// level of the tree.
// @see listGrid.showGroupSummary
// @visibility external
//<


//> @attr listGrid.groupSummaryStyle (CSSStyleName : "gridSummaryCell" : IR)
// +link{listGridRecord.customStyle} for the group-level summary row displayed when
// +link{listGrid.showGroupSummary} is true.
// @visibility external
//<

groupSummaryStyle: "gridSummaryCell",


//> @method listGrid.setShowGroupSummary()
// Setter for the +link{listGrid.showGroupSummary} attribute
// @param showGroupSummary (boolean) new value for this.showGroupSummary
// @visibility external
//<
setShowGroupSummary : function (showGroupSummary) {
    if (this._asyncRegroupInProgress) {
        // Postpone the change in showGroupSummary until after the
        // asynchronous regroup.
        this._newShowGroupSummary = showGroupSummary;
        return;
    }

    var changed = (this.showGroupSummary != showGroupSummary);
    if (changed && this.groupTree) {
        var sums = this.groupByFieldSummaries;
        this._updateSummaryRows(
            this.groupTree,
            this.showGroupSummary, showGroupSummary,
            sums, sums);
    }
    this.showGroupSummary = showGroupSummary;
},

//> @method listGrid.setGroupByFieldSummaries()
// Setter for the +link{listGrid.groupByFieldSummaries} attribute
// @param groupByFieldSummaries (Array of String) new value for this.groupByFieldSummaries
// @visibility external
//<
setGroupByFieldSummaries : function (groupByFieldSummaries) {

    if (this._asynchRegroupInProgress) {
        // Postpone the change in groupByFieldSummaries until after the
        // asynchronous regroup.
        this._newGroupByFieldSummaries = groupByFieldSummaries;
        return;
    }

    // Determine if the new value of groupByFieldSummaries is different from the
    // old value.
    var changed = (this.groupByFieldSummaries != groupByFieldSummaries);
    if (!changed) {
        var isArray = isc.isAn.Array(groupByFieldSummaries);
        changed = (isArray != isc.isAn.Array(this.groupByFieldSummaries));
        if (!changed && isArray) {
            var length = groupByFieldSummaries.length;
            changed = (length == this.groupByFieldSummaries.length);
            if (!changed) {
                for (var i = length; !changed && i--; ) {
                    changed = !this.groupByFieldSummaries.contains(groupByFieldSummaries[i]);
                }
            }
        }
    }

    if (changed && this.groupTree) {
        var show = this.showGroupSummary;
        this._updateSummaryRows(
            this.groupTree,
            show, show,
            this.groupByFieldSummaries, groupByFieldSummaries);
    }
    this.groupByFieldSummaries = groupByFieldSummaries;
},

// Method to refresh the group summary row for some record
refreshGroupSummary : function (records, fields) {

    if (!this.isGrouped || !this.showGroupSummary || !this.groupTree) return;

    // allow a row number to be provided, which we map into node
    if (isc.isA.Number(records)) records = this.groupTree.get(records);

    // If we're showing the summary in the header we have to refresh the header node
    // with the new summary field values (and refresh the row).
    if (this.showGroupSummaryInHeader) {
        if (records != null) {
            var headerNodes = this.groupTree._markForUpdateSummaryRows(records, false, []);
            for (var i = headerNodes.length - 1; i >= 0; i--) {
                var headerNode = headerNodes[i];
                this.applyGroupSummaryToHeader(this.groupTree, headerNode, fields);
                this.refreshRow(this.groupTree.indexOf(headerNode));
                delete headerNode._refreshGroup;
            }
        } else {
            var headerNodes = this.groupTree.findAll("_isGroup", true);
            if (headerNodes != null) {
                for (var i = 0; i < headerNodes.length; i++) {
                    this.applyGroupSummaryToHeader(this.groupTree, headerNodes[i], fields);
                }
            }
            this.markForRedraw("refresh group summaries");
        }

    // Otherwise we have to rerun 'getChildren()' and refresh the relevant group's set of drawn
    // rows.
    } else {

        
        this._updateSummaryRows(this.groupTree,
            this.showGroupSummary, this.showGroupSummary,
            this.groupByFieldSummaries, this.groupByFieldSummaries,
            true, records, fields);
    }
},

//> @method listGrid.configureGrouping()
// Open a MultiGroupDialog to configure the fields used for grouping.
//
// @visibility external
//<
configureGrouping : function (targetField) {
    var grid = this,
        groupFields = this.getGroupByFields()
    ;
    if (targetField && (!groupFields || groupFields.length == 0)) {
        groupFields = [targetField[this.fieldIdProperty]];
    }
    var props = isc.addProperties({}, this.multiGroupDialogDefaults, this.multiGroupDialogProperties);
    isc.MultiGroupDialog.askForGrouping(
        this, groupFields,
        function (groupLevels) {
            if (groupLevels) grid.setGroupSpecifiers(groupLevels);
        },
        props
    );
},

//> @attr listGrid.multiGroupDialogDefaults (MultiGroupDialog Properties : null : IR)
// Class-level defaults to apply to the +link{MultiGroupDialog} which gets automatically 
// generated when +link{listGrid.configureGrouping()} is called.
// @visibility external
//<

//> @attr listGrid.multiGroupDialogProperties (MultiGroupDialog Properties : null : IR)
// Properties to apply to the +link{MultiGroupDialog} which gets automatically 
// generated when +link{listGrid.configureGrouping()} is called.
// @visibility external
//<

// GridRenderer / ListGrid API routing
// --------------------------------------------------------------------------------------------

// if this LV defines any of the GridRenderer's APIs, route those methods through to the LV.  See
// LV.classInit()
addBodyPassthroughMethods : function (body) {
    // if the body hasn't been created yet, bail - we always add the passthrough methods when we
    // create the body
    if (this.body) this._addBodyPassthroughMethods(this.body);
    if (this.frozenBody) this._addBodyPassthroughMethods(this.frozenBody);
},

_addBodyPassthroughMethods : function (body) {

    var body2LGMethods = {},
        methodNames = isc.getKeys(isc.ListGrid._passthroughMethods);

    for (var i = 0; i < methodNames.length; i++) {
        var methodName = methodNames[i],
            methodOnListGrid = this[methodName];

        // the cellContextClick stringMethod is specially overridden
        // - The GR.cellContextClick method is overridden to fire LG._cellContextClick()
        //   That will handle creating the context menu, as well as firing any developer-defined
        //   'cellContextClick' stringMethod.
        if (methodName == "cellContextClick") continue;

        // If the method is being cleared out, ensure we clear out any passthrough method
        // we may have previously set up
        if (methodOnListGrid == null) {
            
            body2LGMethods[methodName] = body.getClass().getPrototype()[methodName];

        // If the method on the listGrid is something other than a passBack method,
        // ensure the method on the GridBody actually calls it unless:
        // - the gridBody method is allready a passthrough (no need to do anything)
        // - the method on the gridBody has been overridden to be something other than
        //   the instance default
        } else if (methodOnListGrid != isc.ListGrid._passBackMethods[methodName] &&
                  !((body[methodName] != null) && 
                    (body[methodName]._isPassthroughMethod ||
                    (body[methodName] != body.getClass().getPrototype()[methodName]))) 
                  ) 
        {
            // install a passthrough method on the body to call the LG
            body2LGMethods[methodName] = isc.ListGrid._passthroughMethods[methodName];
        }
        
    }
    body.addMethods(body2LGMethods);
},

// anytime methods are added on the fly to a ListGrid instance, install passthrough functions
// on the body.  This makes sure that if you eg add a cellHover function on the fly, we notice
// and set up a passthrough from the body.

addProperties : function (methods) {
    this.Super("addProperties", arguments);
    this.addBodyPassthroughMethods();
},

addMethods : function (methods) {
    this.Super("addMethods", arguments);
    this.addBodyPassthroughMethods();
},

// React to 'setProperties()' modifying drag related properties by updating
// 'canDrag' / 'canAcceptDrop' / etc
_$dragProperties : {
    canDragSelect:true,
    canDragSelectText:true,
    canDragRecordsOut:true,
    canReorderRecords:true,
    canAcceptDroppedRecords:true
},
// React to changes to 'alternateRecordStyles', 'fixedRecordHeights', et al by
// changing the related property ('alternateRowStyles', etc) on the body.
_$gridPropertyRenames : {

        // We have an explicit setBodyOverflow so no need to catch this case
        // overflow:this.bodyOverflow,
        bodyBackgroundColor:"backgroundColor",
        bodyStyleName:"styleName",

        // Note updating fixedRowHeights on the body is required in addition to the fact
        // we pass our "shouldFixRowHeight()" method through to the body.
        // That method has no effect if fixedRowHeights is false on the GridRenderer.
        fixedRecordHeights:"fixedRowHeights",

        fixedFieldWidths:"fixedColumnWidths",
        alternateRecordStyles:"alternateRowStyles",
        alternateRecordSuffix:"alternateRowSuffix",
        alternateRecordFrequency:"alternateRowFrequency",
        alternateFieldStyles:"alternateColumnStyles",
        alternateFieldSuffix:"alternateColumnSuffix",
        alternateFieldFrequency:"alternateColumnFrequency",
        showAllRecords:"showAllRows",

        canSelectText:"canDragSelectText"
},
// propertyChanged - fired by setProperties for each modified property.
propertyChanged : function (propName, value) {
    this.invokeSuper(isc.ListGrid, "propertyChanged", propName, value);
    if (this._$dragProperties[propName]) this._dragPropertyChanged = true;
    if (this.body == null) return;
    if (isc.ListGrid._gridPassthroughProperties.contains(propName)) {
        this.body[propName] = value;
        if (this.frozenBody) this.frozenBody[propName] = value;
    }
    if (this._$gridPropertyRenames[propName] != null) {
        this.body.setProperty(this._$gridPropertyRenames[propName], value);
        if (this.frozenBody) this.frozenBody.setProperty(this._$gridPropertyRenames[propName], value);
        
        // markForRedraw to display the changes
        
        this.markForRedraw();
    }
    //>EditMode
    if (this.editingOn && this.editProxy && propName == "initialCriteria") {
        this.setCriteria(this.initialCriteria);
    } else if (this.editingOn && this.editProxy && propName == "sortField") {
        this.sort(value);
    }
    //<EditMode
},

// doneSettingProperties - fired after all the properties have been updated.
doneSettingProperties : function () {
    if (this._dragPropertyChanged) this._setUpDragProperties();
},

//>EditMode

// EditMode
// ---------------------------------------------------------------------------------------
setChildEditableProperties : function (liveObject, properties, editNode, editContext) {
    var schema = isc.DS.get(editNode.type);
    if (!schema || !schema.inheritsSchema("ListGridField")) {
        return this.Super("setChildEditableProperties", arguments);
    }

    // Special case to handle VB editing of LGF with change to hidden property.
    if (!properties.hidden && liveObject.showIf == "false") liveObject.showIf = null;

    // the fields will need to be refreshed via setFields(); grab them here
    var fields = this.completeFields || this.fields;
    isc.addProperties(liveObject, properties);
        
    // fields list now final
    this.setFields(fields);
},

//<EditMode

// ---------------------------------------------------------------------------------------
getExportFieldValue : function (record, fieldName, fieldIndex, exportValueFields) {
    // Checkbox icons (and generally all other icons) are a no-no for exported data.
    // If the display value would return a checkbox icon, use the raw cell value instead.
    var field = this.getSpecifiedField(fieldName);
    if (this.isCheckboxField(field)
        || field.valueIcons
        || this._formatBooleanFieldAsImages(field))
    {
        var recordNum = this.getRecordIndex(record),
            value;

        
        var useDisplayFieldValue = field.displayField != null && !field.valueMap &&
                                  !field.getCellValue && this._useDisplayFieldValue(field);
        if (useDisplayFieldValue) {
            value = this.getRawCellValue(record, recordNum, field.displayField, true);
        } else {
            value = this.getRawCellValue(record, recordNum, fieldIndex);

            // if value display is configured, apply the value map if one is present
            var valueMap = !this.showValueIconOnly(field) && field.valueMap;
            if (valueMap) value = this.resolveValueMap(value, valueMap);
        }
        
        var hiliteAfterFormat = field.hiliteHTMLAfterFormat;
        if (hiliteAfterFormat == null) hiliteAfterFormat = this.hiliteHTMLAfterFormat;
        if (hiliteAfterFormat == null) hiliteAfterFormat = true;
        var hilites = this.getFieldHilites(record, field);

        if (!hiliteAfterFormat) {
            
            // Note that hilites can == 0, so if (hilites) doesn't work
            if (hilites != null) value = this.applyHiliteHTML(hilites, value);
            value = this._formatCellValue(value, record, field, recordNum, fieldIndex);
        } else {
            value = this._formatCellValue(value, record, field, recordNum, fieldIndex);
            if (hilites != null) value = this.applyHiliteHTML(hilites, value);
        }
        return this.htmlUnescapeExportFieldTitle(value.toString());
    }

    return this.Super("getExportFieldValue", arguments);
},

//> @method listGrid.getOriginalData()
// Returns the original, ungrouped data in the grid. If the grid is ungrouped,
// returns +link{listGrid.data}.
// @group grouping
//
// @return (Object) The ungrouped data that is being displayed and observed
// @visibility external
//<
getOriginalData : function () {
    return (this.isGrouped && this.originalData) ? this.originalData : this.getData();
},

//> @groupDef excelPasting
// +link{DataSource.recordsAsText()} can export a set of DataSource records in
// tab-separated-values format so that it can be copied and pasted into a Microsoft Excel
// spreadsheet.
// <P>
// However, be aware that Excel does a bunch of type guessing on pasted data:
// <ul>
// <li> values that look like dates (eg 1-2-2011 and even just 1-2) will become true date-valued
//      cells (as indicated by Excel rendering them as eg 2-Jan).  Note that the month-day-year
//      interpretation is <b>locale-dependent</b> so be sure text is exported
// <li> values that look numeric, eg "5.0" become true number values (as indicated by Excel
//      showing just "5")
// <li> values that look like times, eg "5:30", will be converted to times (as indicated by
//      Excel showing 5:30:00 AM when editing the value)
// <li> values with a leading "=" will be treated as formulas
// </ul>
// Unfortunately, when these behaviors are undesirable, there is no means of turning them off
// that doesn't have any drawbacks.  You can:
// <ul>
// <li> adding a leading space or other char (but this changes the cell value).
// <li> turning the cell into a trivial formula, eg ="literal value".  But this means that when
//     the cell is edited, it's value is a formula.
// <li> format the cells as text in Excel before pasting data onto them
// </ul>
// The first or second approach can be enabled when exporting text - see
// +link{DataSource.recordsAsText()} and +link{DataSourceField.exportForceText}.
//
// @title Copy and Paste with Excel
//<


//> @method listGrid.getSelectedCellData()
// Returns the selected cells as a series of Records where each field value is stored under
// it's offset from the top-left of the selection.  For example, a 2x2 cell selection starting
// from the first column would return two Records, each with two values stored under the names
// "0" and "1".
// <P>
// If +link{canSelectCells} is not enabled, this API always returns null.
//
// @return (RecordList) list of Records as described above
// @visibility external
//<
getSelectedCellData : function (copyDownFromTopRow, copyRightFromLeftColumn) {
    if (this.canSelectCells) {
        var records = [],
            values = {},
            undef;

        var selection = this.selectionManager.getSelectedCells();
        if (selection.length == 0) return [];

        var value, index = 0,
            origCol = selection[index][1];

        while (index < selection.length) {

            var record = {},
                addRecord = false,
                firstRow = selection[index][0],
                firstCol = selection[index][1];

            while (index < selection.length) {
                var row = selection[index][0];
                var col = selection[index][1];
                if (row != firstRow) break;

                if (col == firstCol || !copyRightFromLeftColumn) {
                    var gridRecord = this.getCellRecord(row, col);
                    if (this.shouldShowRecordComponent(gridRecord, col)) {
                        value = this.getRawCellValue(gridRecord, row, col);
                        // to assign to record, we must first map undef to null
                        if (value === undef && this.copyEmptyCells) value = null;
                        // cell is shown; row matters
                        addRecord = true;
                    } else value = undef;
                }
                var targetCol = col - origCol;
                if (copyDownFromTopRow) {
                    var binding = values[targetCol];
                    if (binding !== undef) value = binding;
                    else values[targetCol] = value;
                }
                if (value !== undef) record[targetCol] = value;
                index++;
            }
            if (addRecord) records.add(record);
        }
        return records;
    }
    return null;
},

//> @method listGrid.applyCellData()
// Applies a set of Records containing coordinate-based data as returned by
// +link{getSelectedCellData()} and applies the data at the current selection.
// <P>
// For consistency with Excel, given a record in the cellData, after the data value with the
// most negative column index is found, the rest of the values in the record are applied
// contiguously to the right of it, using the positional data for ordering only.
// <P>
// Will only modify cells in the grid which are editable, and changes will be applied
// as editValues, exactly as though the user had typed the values in (see
// +link{group:editing,Grid Editing Overview}).
// <P>
// See also +link{applyRecordData()}.
//
// @param cellData (RecordList) list of Records as described above
// @visibility external
//<

applyCellData : function (cellData, preserveOffsets, targetCells) {
    if (!this.canSelectCells || !cellData) return;

    if (!targetCells) targetCells = this.selectionManager.getSelectedCells().slice(0,1);
    if (targetCells.length == 0) return;

    var origCol = targetCells[0][1],
        nTotalRows = this.getTotalRows();

    var rowIterator = isc.CellListIterator.create({cells: targetCells});
    for (var i = 0, row = rowIterator.getNextRow(); i < cellData.length && row < nTotalRows;
             i++,   row = rowIterator.getNextRow()) {

        while (!this._isValidRowForApplyGridData(row)) { row = rowIterator.getNextRow(); }
        if (row >= nTotalRows) break;

        var col,
            record = cellData[i];

        var indices = isc.ListGrid._getCoordinateList(record, !preserveOffsets);
        for (var j = 0; j < indices.length; j++) {
            if (j == 0 || preserveOffsets) col = origCol + indices[j];
            else                           col++;

            for (var field = null; col >= 0 && col < this.getTotalCols(); col++) {
                field = this._getFieldIfNonGenerated(col);
                if (field || preserveOffsets) break;
            }
            if (field && this.canEditCell(row, col)) {
                this.setEditValue(row, col, record[indices[j]]);
            }
        }
    }
},

//> @method listGrid.applyRecordData()
// Applies a list of Records as changes to the current selection.
// <P>
// Values found in each of the passed records will be applied to the same-named fields in the
// Records starting from the top-left of the current selection, in order.
// <P>
// Will only modify cells in the grid which are editable, and changes will be applied
// as editValues, exactly as though the user had typed the values in (see
// +link{group:editing,Grid Editing Overview}).
// <P>
// See also +link{applyCellData()}.
//
// @param recordData (RecordList) list of Records as described above
// @visibility external
//<
applyRecordData : function (recordData) {
    if (!this.canSelectCells || !recordData) return;

    var targetCells = this.selectionManager.getSelectedCells();
    if (targetCells.length == 0) return;

    var undef,
        baseRow = targetCells[0][0],
        nTotalRows = this.getTotalRows();

    for (var i = 0, row = baseRow; i < recordData.length && row < nTotalRows; i++, row++) {

        while (!this._isValidRowForApplyGridData(row)) { row++; }
        if (row >= nTotalRows) break;

        var record = recordData[i];
        for (var name in record) {
            if (record.hasOwnProperty(name)) {
                var value = record[name];
                if (value !== undef) {
                    var column = this.getFieldNum(name);
                    var field  = this.getField(column);
                    if (field && this.canEditCell(row, column)) {
                        this.setEditValue(row, column, value);
                    }
                }
            }
        }
    }
},

_getFieldIfNonGenerated : function (fieldIndex) {
    var field = this.getField(fieldIndex);
    if (!field || field.userFormula || field.userSummary ||
         field.type == this._$summary) return null;
    return field;
},

_isValidRowForApplyGridData : function (row) {
    var record = this.getCellRecord(row);
    if (record == null) return true;
    return !record._isGroup && !record[this.isSeparatorProperty] &&
           !record[this.groupSummaryRecordProperty];
},

_invokeKeyboardCopyPasteShortcut : function (keyName) {
    if (!this._shouldUseCopyPasteShortcuts()) return true;
    switch (keyName) {
        case "D":
            this.applyCellData(this.getSelectedCellData(true, null), true,
                               this.selectionManager.getSelectedCells());
            break;
        case "R":
            this.applyCellData(this.getSelectedCellData(null, true), true,
                               this.selectionManager.getSelectedCells());
            break;
        case "C":
            isc.ListGrid._cellClipboard = this.getSelectedCellData();
            break;
        case "V":
            this.applyCellData(isc.ListGrid._cellClipboard);
           break;
    }
    return false;
},

// Advanced Field Picker
// ---------------------------------------------------------------------------------------

//> @attr listGrid.useAdvancedFieldPicker (Boolean : false : IR)
// If set to true, an advanced field picker based on the +link{FieldPicker} will be shown instead
// of the column picker submenu if there are more fields in the grid than
// +link{advancedFieldPickerThreshold}.
// <P>
// When there are large numbers of available fields, the FieldPicker-based interface is more
// usable for both defining visible fields and defining field order.
// @visibility external
//<
useAdvancedFieldPicker: false,

//> @attr listGrid.canEditTitles (boolean : false : IRW)
// If set to true, the +link{listGrid.useAdvancedFieldPicker,advanced field picker} provides
// an interface allowing users to modify fields' titles.
// <P>
// Note that when enabled, the +link{getFieldState(),field state} for this component
// will include field titles by default (see +link{dataBoundComponent.shouldIncludeTitleInFieldState()}).
//
// @visibility external
//<
canEditTitles:false,

//> @attr listGrid.fieldPickerWindow (AutoChild FieldPickerWindow : null : IR)
// Instance of +link{FieldPickerWindow} used if +link{useAdvancedFieldPicker} is set.
// @visibility external
//<

fieldPickerWindowDefaults : {
    autoParent: "none",
    _constructor: "FieldPickerWindow"
},

//> @attr listGrid.fieldPickerFieldProperties (Array of String : null : IR)
// Names of properties on +link{ListGridField} for which the +link{fieldPicker} should
// show an editing interface, for convenience.
// <P>
// For example, specify ["frozen", "decimalPrecision"] to allow end users to modify
// +link{listGridField.frozen} and +link{listGridField.decimalPrecision} respectively.
// @visibility external
//<
fieldPickerFieldProperties: null,

//> @attr listGrid.advancedFieldPickerThreshold (int : 25 : IR)
// When +link{useAdvancedFieldPicker} is set, total number of available fields that must be
// present in the grid before the advanced field picker interface is used instead of the normal
// columns submenu.
// <P>
// Set to 0 to have the advanced picker always used (when useAdvancedFieldPicker is true).
// @visibility external
//<
advancedFieldPickerThreshold: 25,

//> @attr listGrid.fieldPickerShowSampleValues (Boolean : true : IR)
// When set to false, sample values of the FieldPicker are never shown. This property applies to the entire FieldPicker.
// @visibility external
//<
fieldPickerShowSampleValues: true,

// ruleScope
// ---------------------------------------------------------------------------------------

_provideEditRecordToRuleContext : function (newValues) {
    if (this.ruleScope || this.isRuleScope) {
        var rowNum = (this.getEditSession(this.getEditRow()) ? this.getEditRow() : null),
            values = (rowNum != null ? this.getEditedRecord(rowNum, null, true) : null),
            hasChanges = (rowNum != null ? this.rowHasChanges(rowNum, false) : null),
            ds = this.getDataSource(),
            hasStableID = this.hasStableLocalID() || (this.editNode != null)
        ;

        if (newValues) {
            for (var key in newValues) {
                if (ds) {
                    this.provideRuleContext(ds.getID() + "." + key,
                        newValues[key], this, null, hasStableID);
                }
                if (hasStableID) {
                    this.provideRuleContext(this.getLocalId() + ".values." + key,
                        newValues[key], this, null, true);
                }
            }
        } else {
            if (values) {
                if (this.selectionManager) {
                    delete values[this.selectionManager.selectionProperty];
                }
                delete values.__ref;
            }
            if (ds) {
                this.provideRuleContext(ds.getID() , values, this, null, hasStableID);
            }
            if (hasStableID) {
                this.provideRuleContext(this.getLocalId() + ".values", 
                    values, this, null, true);
            }
        }
        if (hasStableID) {
            this.provideRuleContext(this.getLocalId() + ".hasChanges", hasChanges, this);
        }
    }
},

_provideEditFocusToRuleContext : function (item) {
    if (!this.hasStableLocalID() && this.editNode == null) return;
    var path = this.getLocalId() + ".focusField",
        value = (item ? item.name : null),
        currentValue = this._getFromRuleContext(path)
    ;
    if (value != currentValue) this.provideRuleContext(path, value, this);
},

_provideIsGroupedToRuleContext : function () {
    if (!this.hasStableLocalID() && this.editNode == null) return;
    var path = this.getLocalId() + ".isGrouped",
        value = this.isGrouped,
        currentValue = this._getFromRuleContext(path)
    ;
    if (value != currentValue) this.provideRuleContext(path, value, this);
},

_provideCriteriaToRuleContext : function () {
    if (!this.hasStableLocalID() && this.editNode == null) return;
    var path = this.getLocalId() + ".criteria",
        value = this.getCriteria(),
        implicitCriteria = this.getImplicitCriteria(true),
        ds = (this.dataSource ? isc.DS.get(this.dataSource) : null),
        currentValue = this._getFromRuleContext(path)
    ;
    if (implicitCriteria) {
        value = (ds || isc.DS).combineCriteria(value || {}, implicitCriteria);
    }
    if (ds && ds.implicitCriteria) {
        value = ds.combineCriteria(
            value || {}, 
            isc.DataSource.copyCriteria(ds.implicitCriteria)
        );
    }

    if (value && isc.isAn.emptyObject(value)) value = null;
    if (currentValue != null && this.data.compareCriteria) {
        if (this.data.compareCriteria(value, currentValue)) {
            this.provideRuleContext(path, value, this);
        }
    } else if (value != currentValue) {
        this.provideRuleContext(path, value, this);
    }
},

_provideDataLoadingToRuleContext : function () {
    if (!this.hasStableLocalID() && this.editNode == null) return;
    var path = this.getLocalId() + ".dataLoading",
        currentValue = this._getFromRuleContext(path)
    ;
    var value = null;
    if (isc.isA.ResultSet(this.data)) { 
        value = !this.data.lengthIsKnown();
    } else if (isc.isA.ResultTree(this.data)) {
        var children = this.data.getChildren(this.data.getRoot());
        if (isc.isA.ResultSet(children)) {
            value = !children.lengthIsKnown();
        } else {
            value = this.data.isLoading(this.data.getRoot());
        }
    }
    
    if (!value) value = null;
    if (value != currentValue) this.provideRuleContext(path, value, this);
},

_observeRuleContextChanged : function () {
    var grid = this,
        ruleScopeComponent = this.getRuleScopeComponent();

    if (ruleScopeComponent && !this.isObserving(ruleScopeComponent, "ruleContextChanged")) {
        this.observe(ruleScopeComponent, "ruleContextChanged", function (newContext) {
            var needsFetch = false,
                needsRefreshData = false,
                ds = this.getDataSource()
            ;

            if (grid.destroying || grid.destroyed) {
                this.logInfo("Attempt to respond to RuleContext changes during destruction...");
                return;
            }

            // if implicitCriteria has changed since the last run through this method, that 
            // requires at least a refreshData() - if normal crit has also changed, fetchData()
            // will run instead below
            if (grid.implicitCriteria && isc.DS._criteriaHasValuePath(grid.implicitCriteria)) {
                // get the current implicitCrit, with dynamicCriteria already resolved (param:true)
                var iCrit = grid.getImplicitCriteria(true);

                // if criteria were 'incomplete' (no value at the valuePath), might be empty now
                if (!iCrit || !iCrit.criteria || iCrit.criteria.length == 0) return;
                if (ds && ds.compareCriteria(this.oldImplicitCriteria, iCrit) != 0) {
                    this.oldImplicitCriteria = isc.DS.copyCriteria(iCrit);
                    needsRefreshData = true;
                    //isc.logWarn("implicitCriteria causes refreshData");
                }
            }
            // if normal criteria (from initialCriteria, eg) has changed since the last run 
            // through this method, that requires a fetchData()
            var currentCriteria = grid.getCriteria() || grid.getInitialCriteria();
            if (currentCriteria && isc.DS._criteriaHasValuePath(currentCriteria)) {
                var resolvedCrit = grid.resolveDynamicCriteria(currentCriteria, null);
                if (ds && ds.compareCriteria(this.oldResolvedCriteria, resolvedCrit) != 0) {
                    this.oldResolvedCriteria = isc.DS.copyCriteria(resolvedCrit);
                    needsFetch = true;
                    //isc.logWarn("normal criteria causes fetch");
                }
            }
            if (needsFetch) {
                // normal crit has changed since last run - call fetchData() - deals with 
                // implicitCrit as well
                grid.fetchData(currentCriteria);
            } else if (needsRefreshData) {
                if (!grid.dataObjectSupportsFilter(grid.getData())) 
                    // no previous fetch, so no ResultSet - fetch now
                    grid.fetchData(currentCriteria);
                else 
                    // implicitCrit has changed since last run - call refreshData()
                    grid.markForRrefreshData();
            }
        });
    }
},

markForRefreshDataDelay: 300,
markForRrefreshData : function () {
    if (this.refreshDataTimer) isc.Timer.clear(this.refreshDataTimer);
    var grid = this;
    this.refreshDataTimer = isc.Timer.setTimeout(function() {
        isc.Timer.clear(grid.refreshDataTimer);
        grid.refreshData();
    }, this.markForRefreshDataDelay);
},

_removeFromRuleScope : function () {
    if (this.ruleScope) {
     // remove any ruleContext values for this grid 
        var ds = isc.DS.get(this.getDataSource()),
            hasStableID = this.hasStableLocalID() || (this.editNode != null)
        ;
        if (ds) this.provideRuleContext(ds.getID(), null, this, null, hasStableID);
        if (hasStableID) this.provideRuleContext(this.getLocalId(), null, this);
    }

    var ruleScopeComponent = this.getRuleScopeComponent();
    if (ruleScopeComponent && this.isObserving(ruleScopeComponent, "ruleContextChanged")) {
        this.ignore(ruleScopeComponent, "ruleContextChanged");
    }
    this.Super("_removeFromRuleScope", arguments);
}


});

//
// Register 'stringMethods' for ListGrid instances
// NOTE: all GridRenderer StringMethods are available on the LV too; see classInit()

isc.ListGrid.registerStringMethods(isc.GridRenderer._gridAPIs);
isc.ListGrid.registerStringMethods({
    // XXX the list of variables available for an expression is good here, but as method signatures
    // these look wacky.  Should probably be:
    // recordClick:"record,field,value,rawValue,rowNum,colNum"
    recordClick : "viewer,record,recordNum,field,fieldNum,value,rawValue,editedRecord",
    recordDoubleClick : "viewer,record,recordNum,field,fieldNum,value,rawValue,editedRecord",

    
    recordsDropped : "records,rowNum,viewer,sourceWidget",
    recordDropMove : "viewer,recordNum,record,position",

    //>!BackCompat 2004.12.10
    //> @method listGrid.editValueChanged
    // Callback fired when an edit modifies the value of a cell (before attempting to save that
    // value permanently)
    //
    // @param   rowNum     (number) row number for the cell
    // @param   fieldName   (String)    name of the edited field
    // @param   newValue   (Any)    new value for the cell
    // @param   oldValue   (Any)    old value for the cell
    // @visibility internal
    // @deprecated  As of SmartClient 5.5, use +link{listGrid.editorChange}.
    //  @group  editing
    //<
    editValueChanged : "rowNum,fieldName,newValue,oldValue",
    //<!BackCompat

    //> @method listGrid.editorChange
    // Callback fired when an edit modifies the value of a cell (before attempting to save that
    // value permanently)
    //
    // @param   record      (ListGridRecord)    record being edited (null if this is a new row)
    // @param   newValue   (Any)    new value for the cell
    // @param   oldValue   (Any)    old value for the cell
    // @param   rowNum     (number) row number for the cell
    // @param   colNum      (number) column number of the cell
    // @visibility advancedInlineEdit
    //  @group  editing
    // @example calculatedCellValue
    //<
    editorChange : "record,newValue,oldValue,rowNum,colNum",

    //> @method listGrid.cellChanged
    // Fires after user edits have been successfully saved to the server, only for cells where the
    // value was actually modified.
    // <p>
    // If you want immediate notification of a changes <b>before</b> changes has been saved to the
    // server, implement +link{listGridField.change,field.change()} or
    // +link{listGridField.changed(),field.changed()} instead.
    // <P>
    // You can alternatively use +link{listGridField.cellChanged} to get notification only of
    // saved changes for a specific field.  If both a listGridField and the containing listGrid
    // have a handler for this event, only the handler defined on the field is called.
    //
    // @param   record     (ListGridRecord) record for the cell being changed
    // @param   newValue   (Any)    new value for the cell
    // @param   oldValue   (Any)    old value for the cell
    // @param   rowNum     (number) row number for the cell
    // @param   colNum     (number) column number of the cell
    // @param   grid       (ListGrid)   grid where cell was changed.  Also available as "this"
    // @group  editing
    //
    // @see listGridField.cellChanged()
    // @visibility external
    //<
    // NOTE: extra recordNum/fieldNum parameters allow limited backward compatibility, since any
    // time a string expression is provided, parameter order doesn't matter.
    // old signature: recordNum,fieldNum,newValue,oldValue
    
    cellChanged : "record,newValue,oldValue,rowNum,colNum,grid,recordNum,fieldNum",


    

    //> @method listGrid.editComplete()
    // Callback fired when inline edits have been successfully saved.
    // <P>
    // No default implementation.
    //
    //  @group  editing
    //
    // @param rowNum (number) current index of the row that was saved
    // @param colNum (number) index of the column that was saved, if applicable
    // @param newValues (Object | Record) new values that were saved
    // @param oldValues (Record) the complete original values from before the save occurred
    // @param editCompletionEvent (EditCompletionEvent) Event that led to the save
    // @param [dsResponse] (DSResponse) for DataSource saves, DSResponse object returned
    // @visibility external
    //<
    editComplete : "rowNum,colNum,newValues,oldValues,editCompletionEvent,dsResponse",

    //> @method listGrid.editFailed()
    // Called when an attempt to save inline edits fails, due to a validation error or other
    // server error.
    // <P>
    // The default implementation of editFailed does nothing for normal validation errors,
    // which are displayed before editFailed() is called.  For any other errors, the default
    // implementation will call +link{classMethod:RPCManager.handleError()}, which by default
    // will result in a warning dialog.
    //
    //  @group  editing
    //
    // @param rowNum (number) current index of the row we attempted to save
    // @param colNum (number) index of the column where the edit failed, if applicable
    // @param newValues (Object | Record) new values that we attempted to save
    // @param oldValues (Record) the complete original values from before the save occurred
    // @param editCompletionEvent (EditCompletionEvent) Edit completion event that led to the save
    //                                                  attempt
    // @param [dsResponse]   (DSResponse)    DSResponse, for saves through a DataSource
    //
    // @visibility external
    //<
    editFailed : "rowNum,colNum,newValues,oldValues,editCompletionEvent,dsResponse,dsRequest",

    //> @method listGrid.editorEnter()
    // Callback fired when the user starts editing a new cell.
    // <P>
    // This callback is typically used to establish dynamic default values via
    // +link{setEditValue()} or +link{setEditValues()}.
    // <P>
    // Can also be overridden on a per-field basis via
    // +link{listGridField.editorEnter,field.editorEnter}.
    //
    // @param record (ListGridRecord) record for the cell being edited.  <b>Will be null</b>
    //                                for a new, unsaved record.
    // @param value (Any) value for the cell being edited
    // @param rowNum (int)  row number for the cell
    // @param colNum (int)  column number of the cell
    // @group editing
    // @see listGridField.editorEnter()
    // @visibility external
    //<
    editorEnter : "record,value,rowNum,colNum",

    //> @method listGrid.rowEditorEnter()
    // Callback fired when the user starts editing a new row.
    //
    // @param   record     (ListGridField)  record for the cell being edited
    // @param   editValues  (Object)    edit values for the current row
    // @param   rowNum     (number) row number for the cell
    //  @group  editing
    //  @see listGrid.editorEnter()
    // @visibility external
    //<
    rowEditorEnter : "record,editValues,rowNum",

    //> @method listGrid.editorExit()
    // Callback fired when the user attempts to navigate away from the current edit cell,
    // or complete the current edit.
    // <P>
    // Return false from this method to cancel the default behavior (Saving / cancelling the
    // current edit / moving to the next edit cell).
    // <P>
    // This callback is typically used to dynamically update values or value maps for related
    // fields (via +link{setEditValue()} and +link{setEditorValueMap()} respectively, or to
    // implement custom navigation (via +link{startEditing(), startEditing(rowNum,colNum)}.
    // <P>
    // Can be overridden at the field level as field.editorExit.
    //
    // @param editCompletionEvent   (EditCompletionEvent) How was the edit completion fired?
    // @param   record     (ListGridRecord) record for the cell being edited
    // @param   newValue   (Any)    new edit value for the cell being edited. Note that if the
    //    user has not made any changes this will be undefined
    // @param   rowNum     (number) row number for the cell
    // @param   colNum     (number) column number of the cell
    //  @group  editing
    // @return  (boolean)   Returning false from this method will cancel the default behavior
    //                      (for example saving the row) and leave the editor visible and focus
    //                      in this edit cell.
    //  @see listGridField.editorExit()
    // @visibility external
    //<
    
    editorExit : "editCompletionEvent,record,newValue,rowNum,colNum",

    //> @method listGrid.rowEditorExit()
    // Callback fired when the user attempts to navigate away from the current edit row,
    // or complete the current edit.
    // <P>
    // Return false from this method to cancel the default behavior (Saving / cancelling the
    // current edit / moving to the next edit cell).
    //
    // @param editCompletionEvent   (EditCompletionEvent) How was the edit completion fired?
    // @param   record     (ListGridRecord) record for the cell being edited
    // @param   newValues  (Object)    new values for the record [Note that fields that have
    //                                 not been edited will not be included in this object]
    // @param   rowNum     (number) row number for the row being left
    //  @group  editing
    // @return  (boolean)   Returning false from this method will cancel the default behavior
    //                      (for example saving the row) and leave the editor visible and focus
    //                      in this edit cell.
    //  @see listGridField.editorExit()
    // @visibility external
    //<
    rowEditorExit : "editCompletionEvent,record,newValues,rowNum",

    // JS doc comments by default implementation of validateCellValue and validateFieldValue
    validateCellValue : "rowNum,colNum,newValue,oldValue",
    validateFieldValue : "newValue,oldValue,record,field,rowNum,colNum",

    //> @method listGrid.formatCellValue()
    // Formatter to apply to values displayed within cells.
    // <P>
    // The value passed to this method is either the field value found in the cell record
    // or, if there are unsaved edits, the current user-entered value for the cell.
    // <b>NOTE:</b> unsaved user edits may contain nulls, bad values or values of the wrong
    // type, so formatters used for editable data should be bulletproof.  For example, if you
    // have a function "myNumberFormatter" that should only be passed actual Numbers, you might
    // define formatCellValue like so:
    // <pre>
    //     isc.isA.Number(parseInt(value)) ?
    //            myNumberFormatter(parseInt(value)) : value
    // </pre>
    // Note that this formatter will not be applied to the value displayed within editors for
    // cells - use <code>formatEditorValue</code> to achieve this.
    // <P>
    // If <code>formatCellValue</code> is defined at the field level for some cell being edited,
    // the field level method will be used to format the edit value and this method will not
    // be called for that cell.<br>
    //
    // @group display_values
    //
    // @param   value    (Any)   raw value for the cell being
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter.
    // @param   rowNum   (number)    row number for the cell
    // @param   colNum   (number)    column number for the cell.
    // @return  (HTMLString) formatted value to display in the cell.
    // @see listGridField.formatCellValue()
    // @see listGrid.formatEditorValue()
    // @visibility external
    //<
    formatCellValue : "value,record,rowNum,colNum",
    
    //> @method listGrid.formatInactiveCellValue()
    // Formatter for inactive content.
    // <P>
    // If present, this method will be invoked instead of +link{listGrid.formatCellValue()} in cases 
    // where the grid is rendering non-interactive content outside. Examples of cases
    // where this can happen include:<ul>
    // <li>dragTracker HTML for a row when +link{listGrid.dragTrackerMode} is set to
    //    "record"</li>
    // <li>measurement HTML used for sizing columns during autoFit</li>
    // <li>measurement HTML used for sizing rows when +link{listGrid.fixedRecordHeights}
    //     is false and the grid has both frozen and unfrozen fields</li>
    // </ul>
    // May also be overridden at the +link{listGridField.formatInactiveCellValue,field level}.
    // <P>
    // This is useful for cases where it would not be appropriate to render the 
    // standard formatted cell value outside of the body of the grid. An example might be
    // if the formatted value contains a DOM element with a specified ID - an approach
    // sometimes used for integrating third party components into SmartClient listGrid
    // cells. In this case developers will wish to avoid having the framework render an
    // element with the same ID outside of the grid, and should instead return HTML that
    // would render at the same size, with an appropriate appearance.
    //
    // @param   value    (Any)   raw value for the cell being
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved, in an
    //   editable grid, it has no associated record object. In this case the edit values will
    //   be passed in as this parameter.
    // @param   rowNum   (number)    row number for the cell
    // @param   colNum   (number)    column number for the cell.
    // @return  (HTMLString) formatted value to display in the cell.
    // @see listGrid.formatCellValue()
    // @see listGridField.formatInactiveCellValue()
    // @visibility external
    //<
    formatInactiveCellValue : "value,record,rowNum,colNum",
    
    //> @method listGrid.formatEditorValue()
    // Formatter to apply to values displayed within editors while a cell is being edited.
    // The value passed to this method is the raw value for the cell.<br>
    // If <code>formatEditorValue</code> is defined at the field level for some cell being edited,
    // the field level method will be used to format the edit value and this method will not
    // be called for that cell.<br>
    // To convert the formatted value displayed within an editor back to a raw value, the
    // <code>parseEditorValue</code> method is used.
    //
    // @group editing
    //
    // @param   value (Any)   raw value for the cell being edited
    // @param   record   (ListGridRecord)
    //   Record object for the cell. Note: If this is a new row that has not been saved,
    //   it has no associated record object. In this case the edit values will
    //   be passed in as this parameter.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @return  (Any)   formatted value to display in the editor
    // @see listGridField.formatEditorValue()
    // @see listGrid.parseEditorValue()
    // @visibility external
    //<
    
    formatEditorValue : "value,record,rowNum,colNum",

    //> @method listGrid.parseEditorValue
    // Method used to convert the value displayed in an editor for some cell being edited into
    // a raw value for saving.<br>
    // If <code>parseEditorValue</code> is defined at the field level for some cell being edited,
    // the field level method will be used to parse the edit value and this method will not
    // be called for that cell.<br>
    //
    // @group editing
    //
    // @param   value (Any)   value displayed in the editor for the cell
    // @param   record (ListGridRecord) record object for the row being edited. May be null if this
    //                          is a new row being added to the end of the list.
    // @param   rowNum  (number)    row number for the cell
    // @param   colNum  (number)    column number for the cell.
    // @return  (Any)   value in raw format
    // @see listGridField.parseEditorValue()
    // @see listGrid.formatEditorValue()
    // @visibility external
    //<
    parseEditorValue : "value,record,rowNum,colNum",

    //> @method listGrid.sortChanged
    // Notification method executed when the +link{listGrid.setSort(),sort specifiers} change
    // for this grid.
    // @param sortSpecifiers (Array of SortSpecifier) new sort specifiers - may be empty indicating
    //   the grid was unsorted
    // @visibility external
    //<
    sortChanged:"sortSpecifiers",

    //> @method listGrid.fieldStateChanged
    // Notification method executed when columns are resized or reordered, or fields are
    // shown or hidden, frozen or unfrozen.  Has no default implementation.
    //
    // @see viewStateChanged()
    // @visibility external
    // @group fieldState
    //<
    fieldStateChanged : "",

    //> @method listGrid.groupStateChanged
    // Notification method executed whenever the groupState of this grid changes.
    // Group state is accessible via +link{listGrid.getGroupState()}, and contains group state
    // information.
    //
    // @visibility external
    //<
    groupStateChanged : "",

    //> @method listGrid.viewStateChanged
    // Notification method executed whenever the viewState of this grid changes.
    // View state is accessible via +link{listGrid.getViewState()}, and contains field state
    // information, sort information, selection information, hiliting information and
    // grouping information.
    //
    // @see fieldStateChanged()
    // @visibility external
    //<
    viewStateChanged : "",

    //> @method listGrid.dataArrived() (A)
    // Notification method fired when new data arrives from the server to be displayed in this
    // ListGrid, (for example in response to the user scrolling a new set of rows into view).
    // Only applies to databound listGrids where the +link{listGrid.data,data} attribute is a
    // +link{ResultSet}. This ResultSet may have been created manually and applied to the grid via
    // a call to +link{listGrid.setData()} or may have been created and automatically assigned if
    // +link{listGrid.fetchData()} was used to populate the grid.  This method is fired directly in
    // response to +link{ResultSet.dataArrived(),dataArrived()} firing on the data object.
    // <P>
    // Note that <code>dataArrived()</code>, unlike +link{dataChanged()}, only fires in limited
    // circumstances - when data for a +link{resultSet} arrives from the server due to a fetch
    // or cache invalidation, or as a result of filtering.  If you want to catch all data
    // changes, you should instead react to +link{dataChanged()}.
    //
    // @param startRow (int) starting index of the newly loaded set of rows
    // @param endRow (int) ending index of the newly loaded set of rows (non inclusive).
    // @see dataChanged
    // @visibility external
    //<
    dataArrived:"startRow,endRow",

    //> @method listGrid.dataChanged() (A)
    // Notification method fired when the ListGrid's data changes, for any reason.<smartclient>
    // If overridden (rather than +link{observe(), observed}), you must +link{Super(),call the
    // superclass implementation} to ensure proper Framework behavior.</smartclient>
    // <P>
    //  Examples of why data changed might be:<ul>
    // <li> a call to +link{addData()}, +link{updateData()}, or +link{removeData()}
    // <li> +link{DataSource} updates from the server for +link{ResultSet} data
    // (triggered by record editing, etc.)
    // <li> fetches arriving back from the server for +link{ResultSet} data
    // <li> changes to array data if made through APIs such as +link{Array.set()},
    // +link{Array.add()}, etc.
    // <li> cache invalidation
    // <li> filtering
    // </ul>
    // Calling +link{setData()} doesn't call this notification directly, but it may
    // fire if one of the above listed events is triggered (e.g. a server fetch for 
    // +link{ResultSet} data).
    // <P>
    // Note that the <code>operationType</code> parameter is optional and will be passed and
    // contain the operation (e.g. "update") if this notification was triggered by a fetch,
    // an +link{addData()}, +link{updateData()}, or +link{removeData()}, or a +link{DataSource}
    // update for +link{ResultSet} data (the first three reasons listed above) but otherwise
    // will be <smartclient>undefined</smartclient><smartgwt>null</smartgwt>.
    //
    // @param [operationType] (String) optionally passed operation causing the change
    // @see dataArrived()
    // @visibility external
    //<
    dataChanged:"operationType",

    //> @method listGrid.headerHover() (A)
    // Handle a hover over a button in the header.
    //
    // @param fieldNum (number) field number for the header that was hovered
    // @see ListGrid.headerHoverHTML()
    // @group events, gridHeader, hovers
    // @visibility external
    //<
    headerHover:"fieldNum",

    // doc'd above
    headerClick:"fieldNum",

    //> @method listGrid.onHeaderClick()
    // Handler fired when the user clicks a header in this listGrid before any other processing
    // occurs.
    // Return false to suppress the default header click handling
    // @param fieldNum (int) index of the field on which the click occurred.
    // @return (boolean) return false to cancel the default header click behavior
    // @visibility sgwt
    //<
    
    onHeaderClick:"fieldNum",

    //> @method listGrid.onRecordDrop()
    // @param dropRecords (Array of ListGridRecord[]) records being dropped
    // @param targetRecord (ListGridRecord) record being dropped on.  May be null
    // @param index (int) index of record being dropped on
    // @param dropPosition (RecordDropPosition) position with respect to the target record
    // @param sourceWidget (Canvas) widget where dragging began
    // @return (boolean) return false to cancel the default record drop handling
    // @include ListGrid.recordDrop
    // @visibility sgwt
    //<
    
    onRecordDrop:"dropRecords,targetRecord,index,dropPosition,sourceWidget",

    //> @method listGrid.onExpandRecord()
    // Handler fired when a record is expanded in a grid with <code>canExpandRecords</code> set to
    // true. Allows the expansion to be cancelled.
    // @param record (ListGridRecord) record being expanded
    // @return (boolean) return false to cancel record expansion
    // @visibility sgwt
    //<
    
    onExpandRecord:"record",

    //> @method listGrid.onCollapseRecord()
    // Handler fired when a record is collapsed in a grid with <code>canExpandRecords</code> set to
    // true. Allows the collapse to be cancelled.
    // @param record (ListGridRecord) record being collapsed
    // @return (boolean) return false to cancel record collapse
    // @visibility sgwt
    //<
    
    onCollapseRecord:"record",

    //> @method listGrid.drawAreaChanged()  (A)
    //  Notification method that fires when the drawArea changes due to scrolling.  Receives
    // the previous drawArea co-ordinates as parameters.  Call +link{listGrid.getDrawArea()} to
    // get the new drawArea co-ordinates.
    // <P>
    // Note that if this grid is showing any +link{listGridField.frozen,frozen fields}, they
    // will not be included in the <code>oldStartCol</code>, <code>oldEndCol</code> range
    // reported by this method. Frozen fields are assumed never to be scrolled out of view.
    //
    // @param oldStartRow (number) the startRow from before the drawArea changed
    // @param oldEndRow (number) the endRow from before the drawArea changed
    // @param oldStartCol (number) the startCol from before the drawArea changed
    // @param oldEndCol (number) the endCol from before the drawArea changed
    // @visibility external
    //<
    drawAreaChanged:"oldStartRow,oldEndRow,oldStartCol,oldEndCol",

    //> @method listGrid.showRecordComponent()
    // When +link{listGrid.showRecordComponents} is true, return false from this method
    // to prevent the recordComponent system from processing the passed record or cell.
    // <P>
    // <b>If +link{listGrid.showRecordComponentsByCell, showRecordComponentsByCell} is true, 
    // it is important to implement this method</b> - especially if the grid has many fields - 
    // otherwise, the internal automatic detection will process every visible cell, checking,
    // for example, whether a component already exists for that cell, before eventually running 
    // +link{ListGrid.createRecordComponent} to check if one is required.  Implementing this
    // method avoids all that processing for cells that aren't expected to have components.
    // <P>
    // The second parameter is only applicable if +link{showRecordComponentsByCell} is true.
    //
    // @param record (ListGridRecord) record being processed
    // @param [colNum] (Integer) column index of the cell in which the record component
    //   may be shown. Will be null unless showRecordComponentsByCell is true.
    // @return (boolean) return false to cancel showRecordComponent behavior
    // @group recordComponents
    // @visibility external
    //<
    showRecordComponent:"record,colNum",
    

    //> @method listGrid.createRecordComponent()
    // When +link{showRecordComponents} is true, this method is called to create
    // per-row or per-cell embedded components to display in the grid.
    // <p>
    // The colNum parameter is applicable only when
    // +link{listGrid.showRecordComponentsByCell} is true.
    // <p>
    // If this row should not have a <code>recordComponent</code>, return null.
    // <p>
    // This method should create and return a new component for the record passed in every
    // time it is called and never return the same Canvas instance twice.  To re-use components
    // with different rows, set +link{recordComponentPoolingMode} to "recycle".  In this mode,
    // in addition to implementing this method, developers should also implement
    // +link{listGrid.updateRecordComponent()} which allows already created components to be
    // altered for re-use in new records. See the +link{listGrid.showRecordComponents} overview
    // for more information.
    //
    // @param record (ListGridRecord) record to create a component for
    // @param colNum (Integer) cell to which the component applies
    // @return (Canvas) return the component to embed in the passed record
    // @group recordComponents
    // @visibility external
    //<
    createRecordComponent:"record,colNum",

    //> @method listGrid.updateRecordComponent()
    // When +link{listGrid.showRecordComponents} is true, this method is called to update
    // components created by +link{listGrid.createRecordComponent()} when they are to be
    // applied to a different record in the grid. See the
    // +link{listGrid.showRecordComponents, record components overview}
    // for more information on recordComponents.
    // <P>
    // The colNum parameter is applicable only when
    // +link{listGrid.showRecordComponentsByCell} is true. Note that if
    // +link{listGrid.poolComponentsPerColumn} is set to false, the component may have been generated
    // by a +link{listGrid.createRecordComponent()} call applied to a different field.
    // <P>
    // Return null to avoid re-adding the component to the row or cell.
    //
    // @param record (ListGridRecord) record to which the passed component applies
    // @param colNum (Integer) cell to which the passed component applies
    // @param component (Canvas) the component to update
    // @param recordChanged (boolean) was the passed component previously embedded in a
    //     different record?
    // @return (Canvas) return the component to embed in the passed record
    // @group recordComponents
    // @visibility external
    //<
    updateRecordComponent:"record,colNum,component,recordChanged",


    //> @method updateFilterEditorValues () [A]
    // If specified, and +link{ListGrid.showFilterEditor} is true, this stringMethod
    // will be called whenever fetchData() or filterData (or clearCriteria())
    // is called on this grid and should return a set of values to display in the
    // filterEditor.
    // @param currentCriteria (Criteria) Criteria being applied to the grid. May be null if
    //   the filter is being cleared
    // @return (Object) Values to display in the filter editor.
    // @visibility internal
    //<
    
    updateFilterEditorValues:"criteria",

    //> @method listGrid.filterEditorSubmit()
    // Optional notification fired when the user performs a filter using the
    // +link{showFilterEditor,Filter Editor}.  Useful for applying additional criteria not 
    // available in the filterEditor.  Note that it is often easiest to do this with the 
    // +link{searchForm} attribute, which requires no code.
    // <P>
    // May fire as criteria values are being edited if 
    // +link{filterByCell} or +link{filterOnKeypress} is true, otherwise will fire when the
    // user clicks the filter button or presses the Enter key while focus is in the Filter Editor.
    // <p>
    // <smartgwt>Use event.cancel()</smartgwt>
    // <smartclient>Return false</smartclient>
    // to cancel the default behavior - you <b>must</b> cancel the default behavior if your
    // code is going to call +link{filterData()}, +link{setCriteria()} or any other API that
    // affects the criteria applied to the grid.
    // <P>
    // The <code>criteria</code> parameter contains the current criteria applied to the
    // grid including edits the user has just made using the Filter Editor and those applied
    // with the +link{showFilterWindow,advanced filtering dialog}. A call to
    // +link{getFilterEditorCriteria()} does not include the +link{getFilterWindowCriteria,
    // advanced filtering criteria}.
    // <P>
    // If you wish to access the <code>criteria</code> applied to the grid without picking
    // up any edits to the Filter Editor, use +link{getCriteria()} instead.
    // <P>
    // Developers may wish to perform a filter using the Filter Editor values from code
    // running outside the standard filterEditorSubmit flow.  For example, if you wanted a
    // confirmation dialog to be shown before filtering was performed, you would cancel the
    // default behavior as described above, but then need to replicate the default behavior
    // once the user confirms that they want to proceed.  To replicate the default behavior, 
    // just call:
    // <pre>
    //  grid.filterData(grid.getFilterEditorCriteria());
    // </pre>
    // or, to ensure the specified +link{listGrid.autoFetchTextMatchStyle} is picked up
    // <smartclient>
    // <pre>
    //  grid.filterData(grid.getFilterEditorCriteria(), 
    //          null, {textMatchStyle:grid.autoFetchTextMatchStyle});
    // </pre>
    // </smartclient>
    // <smartgwt>
    // <pre>
    //  DSRequest request = new DSRequest();
    //  request.setTextMatchStyle(grid.getAutoFetchTextMatchStyle());
    //  grid.filterData(grid.getFilterEditorCriteria(), null,
    //       request);
    // </pre>
    // </smartgwt>
    //
    // @param criteria (Criteria) criteria derived from the filter editor values
    // @return (boolean) returning false will suppress the filter from occurring
    // @see criteriaChanged
    // @visibility external
    //<
    filterEditorSubmit:"criteria",

    //> @method listGrid.handleGroupBy()
    // Callback fired when the user attempts to group or ungroup the listGrid, or when
    // +link{listGrid.groupBy()} is called programmatically.
    // <smartclient>Return false to cancel grouping.</smartclient>
    // <smartgwt>This event may be cancelled.</smartgwt>
    // <P>
    // This notification is fired before the +link{listGrid.groupTree,data} is updated to
    // reflect the grouping. See also +link{listGrid.groupByComplete()}.
    // <P>
    // Note that this method is not called when the data is regrouped, either
    // +link{regroup(),programmatically}, or in response to new data arriving from the server,
    // and such regrouping can't be canceled - instead use callback +link{handleRegroup()}.
    //
    // @param fields (Array of String) the list of ListGrid field-names by which the grid is 
    //                 about to be grouped.  If the grid is being ungrouped, this param will be
    //                 an empty array
    // @param specifiers (Array of GroupSpecifier) list of GroupSpecifier objects detailing
    //                 grouping specifics for each grouped field
    // @return (boolean) return false to cancel grouping on the passed specification
    // @group grouping
    // @see handleRegroup()
    // @see groupByComplete()
    // @visibility external
    //<
    handleGroupBy:"fields,specifiers",

    //> @method listGrid.groupByComplete()
    // Callback fired when the listGrid is grouped or ungrouped.
    // <P>
    // Unlike +link{listGrid.handleGroupBy()}, this notification will fire when grouping
    // is complete, and the +link{listGrid.data} object has been updated.
    // On successful grouping the <code>fields</code> argument will list the new 
    // grouping and the +link{listGrid.groupTree} will have been updated to reflect the
    // grouped data.
    // <P>
    // Note that the <code>fields</code> argument may be an empty array if the data
    // is not grouped. This implies that a user or developer explicitly ungrouped the
    // grid, or that a groupBy attempt failed due to the data length exceeding 
    // +link{listGrid.groupByMaxRecords}.
    // <P>
    // By design, this method is not called when the data is regrouped, either 
    // +link{regroup(),programmatically}, or in response to new data arriving from the server.
    // You can use the callback +link{groupTreeChanged()} to be notified in that situation.
    // <P>
    // If you monitor only this method and call +link{groupBy()} before data is fetched, the
    // notification that you'll receive will be for grouping the initial (perhaps empty) data
    // set only.  To have this method actually trigger when grouping of the fetched data is
    // done, you should avoid calling +link{groupBy()} before the initial fetch, and instead do
    // it in the the +link{listGrid.fetchData(),fetch callback}.
    //
    // @param fields (Array of String) ListGrid field names by which the grid is now
    //  grouped. If the grid is currently not grouped, this parameter will be an
    //  empty array.
    // @group grouping
    // @see handleGroupBy
    // @see groupTreeChanged()
    // @visibility external
    //<
    
    
    groupByComplete:"fields",

    //> @type GroupTreeChangeType
    // Type of change to the +link{listGrid.groupTree}.
    // @value ListGrid.GROUP_BY +link{listGrid.groupBy()} responsible (grouping fields changed)
    // @value ListGrid.REGROUP +link{listGrid.regroup()} responsible (grid already grouped)
    // @value ListGrid.INCREMENTAL incremental regroup of a single record
    // @see listGrid.groupTreeChanged()
    // @visibility external
    //<

    //> @method listGrid.handleRegroup()
    // Callback fired when a regroup operation is begun, either from a direct call to
    // +link{regroup()}, or because of +link{dataChanged(),data arriving from the server} when
    // the grid is already +link{groupBy(),grouped}.
    // <P>
    // After this call, the Framework should eventually call +link{groupTreeChanged()}.
    // @see handleGroupBy()
    // @see groupTreeChanged()
    // @group grouping
    // @visibility external
    //<
    handleRegroup:"",

    //> @method listGrid.groupTreeChanged()
    // Callback fired when a +link{groupByField,grouping} operation completes, whether it
    // started as a direct call to +link{groupBy()} or +link{regroup()} or data changing,
    // including incremental changes.
    // <P>
    // If <code>changeType</code> is "groupBy", +link{handleGroupBy()} should have been
    // called at the beginning of the operation, and +link{groupByComplete()} will be called
    // immediately before this method.  If <code>changeType</code> is "regroup", then 
    // +link{handleRegroup()} should have been called at the beginning of the operation.
    //
    // @param changeType (GroupTreeChangeType) did the change originate from +link{groupBy()},
    //                                         +link{regroup()}. or an incremental data change?
    // @param success (boolean) did the operation complete successfully?
    // @group grouping
    // @see handleRegroup()
    // @see groupByComplete()
    // @visibility external
    //<
    groupTreeChanged:"changeType,success",

    //> @method listGrid.hilitesChanged()
    // Notification method executed whenever the end user uses the HiliteEditor to change
    // the set of hilites applied to this grid.  This method will not be called after
    // a purely programmatic change to the hilites made with a call to
    // +link{databoundComponent.setHilites(),setHilites()}.  The array of currently applied hilite objects is
    // accessible via +link{databoundComponent.getHilites(),getHilites()}.
    // @group hiliting
    // @visibility external
    //<
    hilitesChanged : "",

    //> @method listGrid.cellErrorIconHover() ([A])
    // Optional stringMethod to fire when the user hovers over the error icon of a cell with 
    // validation errors.  The default behavior is to show a hover canvas containing the
    // validation error message text. Return false to suppress this default behavior.
    //
    // @group events
    // @param record (ListGridRecord) cell record as returned by getCellRecord()
    // @param rowNum (number) row number for the cell
    // @param colNum (number) column number of the cell
    // @return (boolean) false to suppress the standard error message hover
    // @see showErrorIcons
    // @visibility external
    //<
    cellErrorIconHover : "record,rowNum,colNum",

    //> @method listGrid.cellErrorIconOver() ([A])
    // Optional stringMethod to fire when the mouse moves over the error icon of a cell with 
    // validation errors.
    //
    // @group events
    // @param record (ListGridRecord) cell record as returned by getCellRecord()
    // @param rowNum (number) row number for the cell
    // @param colNum (number) column number of the cell
    // @return (boolean) false to suppress the default behavior (show a standard error message
    //                   hover)
    // @see showErrorIcons
    // @visibility external
    //<
    cellErrorIconOver : "record,rowNum,colNum",

    //> @method listGrid.cellErrorIconOut() ([A])
    // Optional stringMethod to fire when the mouse moves off the error icon of a cell with 
    // validation errors.
    //
    // @group events
    // @param record (ListGridRecord) cell record as returned by getCellRecord()
    // @param rowNum (number) row number for the cell
    // @param colNum (number) column number of the cell
    // @return (boolean) false to suppress the standard behavior (clear the standard error 
    //                   message hover if it is showing)
    // @see showErrorIcons
    // @visibility external
    //<
    cellErrorIconOut : "record,rowNum,colNum",

    //> @method listGrid.criteriaChanged
    // Callback fired when the end-user changes criteria. This occurs via the +{FilterEditor}
    // or +{showFilterWindow,advanced filtering} interface. It does not fire when a change is
    // made via +link{setCriteria}, +link{fetchData}, +link{setFilterWindowCriteria} or
    // other APIs are called to change the criteria.
    //
    // @visibility external
    //<
    criteriaChanged : ""
});


isc.ListGrid._unskinnedHeaderDefaults =
    isc.addProperties({}, isc.ListGrid.getInstanceProperty("headerDefaults"));
isc.ListGrid._unskinnedHeaderButtonDefaults =
    isc.addProperties({}, isc.ListGrid.getInstanceProperty("headerButtonDefaults"));

isc.ListGrid.classInit();


// AutoTest subsystem supports some configuration of ListGrids
//> @attr ListGrid.locateRowsBy (String : null : IRW)
// When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
// +link{isc.AutoTest.getLocator()} for a cell in this grid, how should the row be identified?
// <br>
// Note that getLocator() will actually store all available information about the row in
// the generated string -- this attribute effects how a stored string will be parsed only.
// <P>
// Valid options area:
// <ul>
// <li><code>"primaryKey"</code> Only applies to databound grids: If the cell in question has
//  a primary key cell value, use it to identify cells in autoTest locator strings.</li>
// <li><code>"titleField"</code> If the cell in question has a value for the
//  +link{listGrid.getTitleField(),titleField}, use it to identify cells in autoTest
//  locator strings</li>
// <li><code>"targetCellValue"</code> Identify rows by storing the cell value for the target
//  row / field in autoTest locator strings</li>
// <li><code>"index"</code>The rowNum will be used to identify the row.</li>
// </ul>
// If unset, default behavior is to identify by primary key (if available), otherwise by
// titleField (if available), otherwise by cell value (if available), and lastly by index.
// @see locatorStrategy
// @visibility external
// @group autoTest
//<

//> @attr ListGrid.locateColumnsBy (String : null : IRW)
// When +link{isc.AutoTest.getElement()} is used to parse locator strings generated by
// +link{isc.AutoTest.getLocator()} for a cell in this grid, how should the column be identified?
// <br>
// Note that getLocator() will actually store all available information about the column in
// the generated string -- this attribute effects how a stored string will be parsed only.
// <P>
// Valid options area:
// <ul>
// <li><code>"fieldName"</code> Attempt to identify by fieldName.</li>
// <li><code>"index"</code> Attempt to identify by colNum (index in the fields array).</li>
// </ul>
// If unset, default behavior is to identify by fieldName (if available), otherwise by index.
// @see locatorStrategy
// @visibility external
// @group autoTest
//<


//

// LineEditor
// ---------------------------------------------------------------------------------------
// A minimum-height editor that expands as you add more rows
isc.defineClass("LineEditor", isc.ListGrid).addProperties({
    canEdit:true,
    editEvent: "click",
    editOnFocus: true,
    modalEditing:true,
    // allow new record entry
    enterKeyEditAction: "nextRowStart",
    listEndEditAction: "next",
    // be one row tall initially
    height:50,
    emptyMessage:"Click to add data",
    emptyMessageStyle: "normal", // just gets rid of padding
    // expand as data is added
    autoFitData:"vertical",
    leaveScrollbarGap:false,

    // start editing on a click with an initially empty grid
    click : function () {
        var record = this.getRecord(this.getEventRow());
        //this.logWarn("click call with record: " + this.echo(record));
        this.Super("click", arguments);
        if (record == null && isc.EH.lastEvent.target == this.body) this.startEditingNew();
    }
})


// UserFormula
// ---------------------------------------------------------------------------------------
// Definition of UserFormula object and related events.
// formulaUpdated() is triggered in DataBoundComponent.js
//

//> @object UserFormula
// An object representing a user-created and user-modifiable formula, which can be created and
// edited with a +link{FormulaBuilder} either directly or via the
// +link{ListGrid.canAddFormulaFields} behavior.
// <p>
// Note that the current implementation of UserFormula simply executes +link{userFormula.text}
// as a JavaScript string after making special variables and methods available to the formula.
// It is safe to allow users to define formulas for themselves (since an end user can always
// execute whatever JavaScript they want via the browser's built-in developer tools), and is
// safe to allow formulas to be shared between trusted users.  However it would not be safe to
// allow an untrusted user to create formulas that are shared to other users.
// <p>
// Also, while the current implementation would allow creation of a formula that calls
// JavaScript functions that are not part of the standard or custom
// +link{MathFunction,MathFunctions}, this should not be relied upon, as future versions of the
// formula engine may prohibit such calls.
//
// @treeLocation Client Reference/Grids/ListGrid
// @visibility external
//<

//> @attr userFormula.text (String : null : IRW)
// Formula to be evaluated.
// <P>
// There are two contexts where a UserFormula is used: +link{listGridField.userFormula} and
// +link{formItem.formula} or +link{listGridField.editorFormula}. For the grid field formula
// all variables used by the formula must be single-letter capital characters (eg A). These
// are derived from field values for the record in question - see +link{formulaVars}.
// <P>
// In addition to these variables, the keyword <code>record</code> may be used to
// refer directly to the record for which the formula is being displayed.
// <P>
// In the second usage context variables are dot-separated (.) names representing the nested
// hierarchy path to the desired value within the +link{canvas.ruleScope,rule context}. No
// mapping with +link{formulaVars} is needed.
// <P>
// The formula text must be valid JavaScript code and may only call either the built-in
// +link{MathFunction,MathFunctions} or a +link{MathFunction.registerFunction(),custom
// function}.
//
// @visibility external
//<

//> @attr userFormula.formulaVars (Map : null : IR)
// Object mapping from variable names to fieldNames.  All variable names must be single-letter
// capital characters (eg A).  For example, for a formula that should divide the field
// "population" over the field "area", the formula might be "E/L" and formula vars would be:
// <smartclient>
// <pre>
//   {
//       E: "population",
//       L: "area"
//   }
// </pre>
// </smartclient>
// <smartgwt>
// <pre>
//   Map vars = new HashMap();
//   vars.put("E", "population");
//   vars.put("L", "area");
// </pre>
// </smartgwt>
// <p>
// When used in +link{listGridField.userFormula} context, field names are evaluated against the
// grid record.
// <p>
// When used in +link{formItem.formula} or +link{listGridField.editorFormula} this property is
// not used for formula mapping. Instead, field names are evaluated directly against the
// current +link{canvas.ruleScope,rule context}.
//
// @visibility external
//<

//> @attr listGridField.userFormula (UserFormula : null : IRW)
// Formula definition for this field.
// <P>
// Advanced applications that wish to save formulas separately from a grid's
// +link{listGrid.getViewState(),viewState} can provide a +link{UserFormula} as part of the field
// definition, and may subsequently access the formula is updated via the
// +link{listGrid.formulaUpdated()} notification.
// <p>
// Note that the current implementation of UserFormula simply executes +link{userFormula.text}
// as a JavaScript string after making special variables and methods available to the formula.
// It is safe to allow users to define formulas for themselves (since an end user can always
// execute whatever JavaScript they want via the browser's built-in developer tools), and is
// safe to allow formulas to be shared between trusted users.  However it would not be safe to
// allow an untrusted user to create formulas that are shared to other users.
// <p>
// Also, while the current implementation would allow creation of a formula that calls
// JavaScript functions that are not part of the standard or custom
// +link{MathFunction,MathFunctions}, this should not be relied upon, as future versions of the
// formula engine may prohibit such calls.
//
// @visibility external
//<

//> @attr listGridField.canEditFormula (Boolean : null : IR)
// Can formula be edited from header context menu? Setting attribute to
// <code>false</code> prevents editing. A <code>null</code> or <code>true</code>
// value allows editing.
// <P>
// Has no effect when +link{listGrid.canAddFormulaFields} is <code>false</code>.
// 
// @visibility external
//<

//> @method listGrid.formulaUpdated()
// Notification fired when a user either creates a new formula field or edits an existing formula field.
// @param field (ListGridField) the formula field
// @param formula (UserFormula) the new or updated formula definition
//
// @visibility external
//<

//> @attr listGridField.editorFormula (UserFormula : null : IR)
// Shortcut to configure a +link{FormItem.formula} for the +link{editorType,editor} used when this
// field is +link{listGrid.canEdit,edited}.
//
// @visibility external
//<

//> @attr listGridField.editorTextFormula (UserSummary : null : IR)
// Shortcut to configure a +link{FormItem.textFormula} for the +link{editorType,editor} used when this
// field is +link{listGrid.canEdit,edited}.
//
// @visibility external
//<

// UserSummary
// ---------------------------------------------------------------------------------------
// Definition of UserSummary object and related events.
// summaryUpdated() is triggered in DataBoundComponent.js
//

//> @object UserSummary
// An object representing a user-created and user-modifiable summary, which can be created and
// edited with a +link{SummaryBuilder} either directly or via the
// +link{ListGrid.canAddSummaryFields} behavior.
//
// @treeLocation Client Reference/Grids/ListGrid
// @visibility external
//<

//> @attr userSummary.text (String : null : IRW)
// Summary to be evaluated.
// <P>
// There are two contexts where a UserSummary is used: +link{listGridField.userSummary} and
// +link{formItem.textFormula} or +link{listGridField.editorTextFormula}. For the grid field
// summary all variables used by the summary
// must be all-capital letter names surrounded by braces and escaped with a # sign (eg #{A}).
// These are derived from field values for the record in question - see +link{summaryVars}.
// <P>
// In the second usage context variables are dot-separated (.) names representing the nested
// hierarchy path to the desired value within the +link{canvas.ruleScope,rule context}. No
// mapping with +link{summaryVars} is needed.
//
// @visibility external
//<

//> @attr userSummary.summaryVars (Map : null : IR)
// Map from the all-capital letter names used as summary variables in the +link{UserSummary}
// String to the fieldNames these variables should represent in the context where the
// summary is evaluated.
// <p>
// When used in +link{listGridField.userSummary} context, field names are evaluated against the
// grid record.
// <p>
// When used in +link{formItem.textFormula} or +link{listGridField.editorTextFormula} this property
// is not used for summary mapping. Instead, field names are evaluated directly against the
// current +link{canvas.ruleScope,rule context}.
//
// @visibility external
//<

//> @attr listGridField.userSummary (UserSummary : null : IRW)
// Summary definition for this field.
// <P>
// Advanced applications that wish to save summaries separately from a grid's
// +link{listGrid.getViewState(),viewState} can provide a +link{UserSummary} as part of the
// field definition, and may subsequently access the summary is updated via the
// +link{listGrid.summaryUpdated()} notification.
//
// @visibility external
//<

//> @attr listGridField.canEditSummary (Boolean : null : IR)
// Can summary be edited from header context menu? Setting attribute to
// <code>false</code> prevents editing. A <code>null</code> or <code>true</code>
// value allows editing.
// <P>
// Has no effect when +link{listGrid.canAddSummaryFields} is <code>false</code>.
// 
// @visibility external
//<

//> @method listGrid.summaryUpdated()
// Notification fired when a user either creates a new summary field or edits an existing
// summary field.
// @param field (ListGridField) the summary field
// @param summary (UserSummary) the new or updated summary definition
//
// @visibility external
//<


//> @groupDef gridFiltering
// This overview discusses various ways that +link{type:Criteria, search criteria} can be 
// applied to a +link{class:ListGrid, grid} to filter the data being displayed.  
// <p>
// Typically, there are two types of criteria that affect how a grid matches data:
// <ul>
// <li>Implicit criteria - hidden criteria, applied by the developer, to the 
//     +link{listGrid.implicitCriteria, grid} or its
//     +link{dataSource.implicitCriteria, dataSource}, and never made available to 
//     users</li>
// <li>Explicit criteria - public criteria, which may be applied by the developer or 
//     entered by the user - this
//     criteria may be displayed to and modified by the user at runtime in various ways</li>
// </ul>
// A grid may have both implicit criteria, and explicit criteria that may come from multiple 
// sources.  When data is fetched, the implicit-criteria and any sources of 
// +link{listGrid.getCriteria, explicit criteria} are  
// +link{dataSource.combinCriteria, combined} and used to match records.
// <p>
// Note, however, that attempts to fetch with more restrictive criteria may not result in a 
// server-trip, because +link{class:ResultSet}s implement local filtering adaptively and may 
// not require a server-trip if a filter can be achieved from local caches.
//
// <h4>Initial Filter Criteria</h4>
// You can provide an initial filter for a grid by setting 
// +link{listGrid.implicitCriteria, implicit criteria}, which is never shown to the user, or
// +link{listGrid.initialCriteria, initial criteria}, which may be shown for editing in the 
// grid's builtin +link{listGrid.showFilterEditor, filter-row}.  You can also provide both 
// types, if only some parts of the criteria should be public. 
// 
// <h4>Filter Row Criteria</h4>
// Grids provide a +link{listGrid.filterEditor, filter-row} that allows users
// to apply search-values on a per-field basis.  When +link{listGrid.allowFilterOperators} is
// true, the default, users can modify the +link{type:Operator, search operator} assigned to a
// given field via the grid's +link{listGrid.headerContextMenu, header context-menu}, allowing 
// for more complex matching.  If the selected operator is not the field's
// +link{listGridField.filterOperator, default operator}, or if 
// +link{listGrid.alwaysShowOperatorIcon} is true, the current operator is indicated in a small
// icon in each filter-field. 
// <p>
// Developers can interact with a field's search operator with 
// +link{listGrid.getFieldSearchOperator}, +link{listGrid.setFieldSearchOperator} and
// +link{listGrid.clearFieldSearchOperator}.
// <p>
// Criteria in the filter-row reflects current public criteria that 
// +link{FormItem.canEditCriterion, can be edited}.  Developers can retrieve this criteria with
// +link{listGrid.getFilterEditorCriteria} and set it with 
// +link{listGrid.setFilterEditorCriteria}.  When the filter-row is showing, Calls to APIs such 
// as +link{listGrid.setCriteria} or +link{listGrid.fetchData} will apply criteria to the 
// filter-row, if the editors there allow it.  Any criteria
// applied by these methods, that cannot be edited by the associated field's filter-editor, are 
// still applied to fetches and will be 
// returned by calls to +link{listGrid.getCriteria()} or 
// +link{listGrid.getFilterEditorCriteria()}, but are not shown to the user for editing. 
// <p>
// Developers may specify a field's +link{listGridField.filterEditorType, filterEditor-type},
// and this can be a custom +link{class:FormItem} class that uses 
// +link{FormItem.getCriterion, getCriterion()}, 
// +link{FormItem.setCriterion, setCriterion()} and 
// +link{FormItem.canEditCriterion, canEditCriterion()} to manage the criteria it works with.
// <p>
// For more complicated cases or more control, developers can implement 
// +link{listGrid.filterEditorSubmit}.
// <p>
// Criteria from the filter-row is combined with other sources of criteria when data is fetched.
// 
// <h4>External Criteria</h4>
// If you have external logic, or a +link{class:SearchForm, form} outside of the grid, that 
// produces criteria, you can apply the criteria by passing it to 
// +link{ListGrid.fetchData, fetchData} or  +link{ListGrid.filterData, filterData}.  The 
// primary difference between these two APIs is that <code>filterData</code> applies a 
// +link{DSRequest.textMatchStyle} of <i>substring</i>, so that records are matched by 
// case-insensitive substring comparison.
// <p>
// If you have the <code>FilterEditor</code> showing, these external criteria will be appear
// in the filterEditor, where supported.  Developers can apply additional external criteria 
// without that effect by passing them to
// +link{DataBoundComponent.setImplicitCriteria}, or by setting +link{listGrid.searchForm} to 
// the external criteria form. 
// <p>
// If you need more power or variance than the filter-row provides, you can set 
// +link{listGrid.allowFilterWindow} to show a full-blown +link{class:FilterBuilder}, to 
// construct more complex criteria that can also include logical operators like <i>or</i>.
// <p>
// All sources of criteria are combined to match records when data is fetched.  
// <h4>Saving Criteria</h4>
// Grid criteria can be saved and restored with +link{listGrid.getViewState, view-state} and 
// via the +link{class:SavedSearches} feature, which is turned on by default.
// 
// @title Grid Filtering Overview
// @treeLocation Client Reference/Grids/ListGrid
// @visibility external
//<

//> @class RowRangeDisplay
// Specialized +link{class:Label} for showing the currently visible row range and
// row count for a source listGrid.
// <P>
// A rowRangeDisplay may be requested directly from the source grid
// via +link{listGrid.getRowRangeDisplay()}.
// 
//  @inheritsFrom Label
//  @visibility rowCountDisplay
//<
 
isc.defineClass("RowRangeDisplay", "Label").addProperties({

    //> @attr rowRangeDisplay.wrap (boolean : false : IRW)
    // rowRangeDisplay will not allow its content to wrap by default
    // @visibility rowCountDisplay
    //<
    wrap:false,
    //> @attr rowRangeDisplay.align (Alignment : "center" : IRW)
    // rowRangeDisplay will center its content by default.
    // @visibility rowCountDisplay
    //<
    align:"center",

    //> @attr rowRangeDisplay.vlign (Alignment : "center" : IRW)
    // rowRangeDisplay will vertically center its content by default.
    // @visibility rowCountDisplay
    //<
    valign:"center",
    
    //> @attr rowRangeDisplay.sourceGrid (ListGrid : null : IRW)
    // The +link{class:ListGrid} for which this label displays
    // the current row range and row count.
    // @visibility rowCountDisplay
    //<

    initWidget : function () {
        if (this.sourceGrid != null && isc.isA.ListGrid(this.sourceGrid)) {
            this.observeSourceGrid();
        }
        return this.Super("initWidget", arguments);
    },

    //> @method rowRangeDisplay.setSourceGrid()
    // Setter for the +link{sourceGrid}.
    // @param sourceGrid (ListGrid) ListGrid to display row information about
    // @visibility rowCountDisplay
    //<
    setSourceGrid : function (sourceGrid) {
        if (this.sourceGrid == sourceGrid) return;
        if (isc.isA.ListGrid(this.sourceGrid)) this.ignoreSourceGrid();
        this.sourceGrid = sourceGrid;
        if (isc.isA.ListGrid(sourceGrid)) {
            this.observeSourceGrid();
        }
    },

    observeSourceGrid : function () {
        this.observe(this.sourceGrid, "rowRangeDisplayValueChanged", "observer._rowRangeDisplayValueChanged(reason)");
    },
    ignoreSourceGrid : function () {
        this.ignore(this.sourceGrid, "rowRangeDisplayValueChanged");
    },

    _rowRangeDisplayValueChanged : function (reason) {   
        if (this.isDrawn()) this.markForRedraw("rowRangeDisplayValueChanged");
    },

    // Override getContents to actually pick up the rowRange display value
    getContents : function () {
        var grid = this.sourceGrid;
        if (isc.isA.ListGrid(grid)) {
            return grid.getRowRangeDisplayValue();
        }
    },

    //> @attr rowRangeDisplay.canRequestRowCount (boolean : false : IRW)
    // When an exact row count is currently unavailable on the source listGrid's 
    // +link{resultSet.getRowCountStatus(),data object}, can the user issue
    // a +link{resultSet.fetchRowCount(),row count fetch} by clicking?
    // <P>
    // For a rowRangeDisplay created via +link{listGrid.getRowRangeDisplay()}
    // this value will be set to +link{listGrid.canRequestRowCount}
    // <P>
    // See also +link{interactiveStyleName} and +link{requestRowCountPrompt}.
    // 
    // @visibility rowCountDisplay
    //<
    canRequestRowCount:false,

    getRowCountStatus : function () {
        return this.sourceGrid.getRowCountStatus();
    },

    click : function () {
        if (this._canRequestRowCount()) {
            this.sourceGrid.fetchRowCount();
            this.redraw();
        }
    },

    _canRequestRowCount : function () {
        return this.canRequestRowCount && 
               this.getRowCountStatus() != "exact" && 
               this.getRowCountStatus() != "loading";
    },

    fetchRowCountReply : function (data, response, criteriaChanged) {
        if (criteriaChanged) return;
        this.markForRedraw("row count fetch complete");
    },

    //> @attr rowRangeDisplay.interactiveStyleName (CSSStyleName : null : IRW)
    // If +link{canRequestRowCount} is true, this style name will be applied to the
    // rowRangeDisplay as long as an accurate row count is not known, indicating
    // to the user that they may click the label to retrieve an accurate status value.
    // @visibility rowCountDisplay
    //<


    getStateName : function () {
        if (this.interactiveStyleName && this._canRequestRowCount()) {
            return this.interactiveStyleName;
        }
        return this.Super("getStateName", arguments);
    },

    interactiveCursor:isc.Canvas.HAND,
    getCurrentCursor : function () {
        if (this.interactiveCursor && this._canRequestRowCount()) {
            return this.interactiveCursor;
        }
        return this.Super("getCurrentCursor", arguments);
    },

    //> @attr rowRangeDisplay.requestRowCountPrompt (String : "Click to calculate row count" : IRW)
    // This prompt will be displayed in a hover when +link{canRequestRowCount} is true and 
    // an accurate row count is not currently known. This indicates to the user that they
    // can click to issue a +link{listGrid.fetchRowCount(),row count fetch} request.
    // <P>
    // If set to null, no hover prompt will be displayed by default
    //
    // @visibility rowCountDisplay
    // @group i18nMessages
    //<
    requestRowCountPrompt : "Click to calculate row count",

    canHover:true,
    showHover:true,
    
    getHoverHTML : function () {
        if (this.requestRowCountPrompt && this._canRequestRowCount()) {
            return this.requestRowCountPrompt;
        }
    }


});